!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! ==============================================================================
! hipfort: FORTRAN Interfaces for GPU kernels
! ==============================================================================
! Copyright (c) 2021 Advanced Micro Devices, Inc. All rights reserved.
! [MITx11 License]
! 
! Permission is hereby granted, free of charge, to any person obtaining a copy
! of this software and associated documentation files (the "Software"), to deal
! in the Software without restriction, including without limitation the rights
! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
! copies of the Software, and to permit persons to whom the Software is
! furnished to do so, subject to the following conditions:
! 
! The above copyright notice and this permission notice shall be included in
! all copies or substantial portions of the Software.
! 
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
! THE SOFTWARE.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
          
           
module hipfort_rocsolver
  use hipfort_rocsolver_enums
  implicit none

 
  
  interface rocsolver_create_handle
    function rocsolver_create_handle_(handle) bind(c, name="rocsolver_create_handle")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_create_handle_
      type(c_ptr) :: handle
    end function


  end interface
  
  interface rocsolver_destroy_handle
    function rocsolver_destroy_handle_(handle) bind(c, name="rocsolver_destroy_handle")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_destroy_handle_
      type(c_ptr),value :: handle
    end function


  end interface
  
  interface rocsolver_set_stream
    function rocsolver_set_stream_(handle,stream) bind(c, name="rocsolver_set_stream")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_set_stream_
      type(c_ptr),value :: handle
      type(c_ptr),value :: stream
    end function


  end interface
  
  interface rocsolver_get_stream
    function rocsolver_get_stream_(handle,stream) bind(c, name="rocsolver_get_stream")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_get_stream_
      type(c_ptr),value :: handle
      type(c_ptr) :: stream
    end function


  end interface
  
  interface rocsolver_set_matrix
    function rocsolver_set_matrix_(rows,cols,elem_size,a,lda,b,ldb) bind(c, name="rocsolver_set_matrix")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_set_matrix_
      integer(c_int),value :: rows
      integer(c_int),value :: cols
      integer(c_int),value :: elem_size
      type(c_ptr),value :: a
      integer(c_int),value :: lda
      type(c_ptr),value :: b
      integer(c_int),value :: ldb
    end function


  end interface
  
  interface rocsolver_get_matrix
    function rocsolver_get_matrix_(rows,cols,elem_size,a,lda,b,ldb) bind(c, name="rocsolver_get_matrix")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_get_matrix_
      integer(c_int),value :: rows
      integer(c_int),value :: cols
      integer(c_int),value :: elem_size
      type(c_ptr),value :: a
      integer(c_int),value :: lda
      type(c_ptr),value :: b
      integer(c_int),value :: ldb
    end function


  end interface
  !> ! \brief GET_VERSION_STRING Queries the library version.
  !> 
  !>     \details
  !>     @param[out]
  !>     buf         A buffer that the version string will be written into.
  !>     @param[in]
  !>     len         The size of the given buffer in bytes.
  !>  
  interface rocsolver_get_version_string
    function rocsolver_get_version_string_(buf,len) bind(c, name="rocsolver_get_version_string")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_get_version_string_
      type(c_ptr),value :: buf
      integer(c_size_t),value :: len
    end function


  end interface
  !> ! \brief GET_VERSION_STRING_SIZE Queries the minimum buffer size for a
  !>     successful call to \ref rocsolver_get_version_string.
  !> 
  !>     \details
  !>     @param[out]
  !>     len         pointer to size_t.
  !>                 The minimum length of buffer to pass to
  !>                 \ref rocsolver_get_version_string.
  !>  
  interface rocsolver_get_version_string_size
    function rocsolver_get_version_string_size_(len) bind(c, name="rocsolver_get_version_string_size")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_get_version_string_size_
      type(c_ptr),value :: len
    end function


  end interface
  !> ! \brief LOG_BEGIN begins a rocSOLVER multi-level logging session.
  !> 
  !>     \details
  !>     Initializes the rocSOLVER logging environment with default values (no
  !>     logging and one level depth). Default mode can be overridden by using the
  !>     environment variables ROCSOLVER_LAYER and ROCSOLVER_LEVELS.
  !> 
  !>     This function also sets the streams where the log results will be outputted.
  !>     The default is STDERR for all the modes. This default can also be overridden
  !>     using the environment variable ROCSOLVER_LOG_PATH, or specifically
  !>     ROCSOLVER_LOG_TRACE_PATH, ROCSOLVER_LOG_BENCH_PATH, andor ROCSOLVER_LOG_PROFILE_PATH.
  !>  
  interface rocsolver_log_begin
    function rocsolver_log_begin_() bind(c, name="rocsolver_log_begin")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_log_begin_
    end function


  end interface
  !> ! \brief LOG_END ends the multi-level rocSOLVER logging session.
  !> 
  !>     \details
  !>     If applicable, this function also prints the profile logging results
  !>     before cleaning the logging environment.
  !>  
  interface rocsolver_log_end
    function rocsolver_log_end_() bind(c, name="rocsolver_log_end")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_log_end_
    end function


  end interface
  !> ! \brief LOG_SET_LAYER_MODE sets the logging mode for the rocSOLVER multi-level
  !>     logging environment.
  !> 
  !>     \details
  !>     @param[in]
  !>     layer_mode  rocblas_layer_mode_flags.
  !>                 Specifies the logging mode.
  !>  
  interface rocsolver_log_set_layer_mode
    function rocsolver_log_set_layer_mode_(layer_mode) bind(c, name="rocsolver_log_set_layer_mode")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_log_set_layer_mode_
      integer(4),value :: layer_mode
    end function


  end interface
  !> ! \brief LOG_SET_MAX_LEVELS sets the maximum trace log depth for the rocSOLVER
  !>     multi-level logging environment.
  !> 
  !>     \details
  !>     @param[in]
  !>     max_levels  rocblas_int. max_levels >= 1.
  !>                 Specifies the maximum depth at which nested function calls
  !>                 will appear in the trace and profile logs.
  !>  
  interface rocsolver_log_set_max_levels
    function rocsolver_log_set_max_levels_(max_levels) bind(c, name="rocsolver_log_set_max_levels")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_log_set_max_levels_
      integer(c_int),value :: max_levels
    end function


  end interface
  !> ! \brief LOG_RESTORE_DEFAULTS restores the default values of the rocSOLVER
  !>     multi-level logging environment.
  !> 
  !>     \details
  !>     This function sets the logging mode and maximum trace log depth to their
  !>     default values (no logging and one level depth).
  !>  
  interface rocsolver_log_restore_defaults
    function rocsolver_log_restore_defaults_() bind(c, name="rocsolver_log_restore_defaults")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_log_restore_defaults_
    end function


  end interface
  !> ! \brief LOG_WRITE_PROFILE prints the profile logging results.
  !>  
  interface rocsolver_log_write_profile
    function rocsolver_log_write_profile_() bind(c, name="rocsolver_log_write_profile")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_log_write_profile_
    end function


  end interface
  !> ! \brief LOG_FLUSH_PROFILE prints the profile logging results and clears the
  !>     profile record.
  !>  
  interface rocsolver_log_flush_profile
    function rocsolver_log_flush_profile_() bind(c, name="rocsolver_log_flush_profile")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_log_flush_profile_
    end function


  end interface
  !> ! @{
  !>     \brief LACGV conjugates the complex vector x.
  !> 
  !>     \details
  !>     It conjugates the n entries of a complex vector x with increment incx.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The dimension of vector x.
  !>     @param[inout]
  !>     x           pointer to type. Array on the GPU of size at least n (size depends on the value of incx).
  !>                 On entry, the vector x.
  !>                 On exit, each entry is overwritten with its conjugate value.
  !>     @param[in]
  !>     incx        rocblas_int. incx != 0.
  !>                 The distance between two consecutive elements of x.
  !>                 If incx is negative, the elements of x are indexed in
  !>                 reverse order.
  !>     
  interface rocsolver_clacgv
    function rocsolver_clacgv_(handle,n,x,incx) bind(c, name="rocsolver_clacgv")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clacgv_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_clacgv_rank_0,&
      
rocsolver_clacgv_rank_1
#endif

  end interface
  
  interface rocsolver_zlacgv
    function rocsolver_zlacgv_(handle,n,x,incx) bind(c, name="rocsolver_zlacgv")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlacgv_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zlacgv_rank_0,&
      
rocsolver_zlacgv_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief LASWP performs a series of row interchanges on the matrix A.
  !> 
  !>     \details
  !>     Row interchanges are done one by one. If \f$\text{ipiv}[k_1 + (j - k_1) \cdot \text{abs}(\text{incx})] = r\f$, then the j-th row of A
  !>     will be interchanged with the r-th row of A, for \f$j = k_1,k_1+1,\dots,k_2\f$. Indices \f$k_1\f$ and \f$k_2\f$ are 1-based indices.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of the matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix to which the row
  !>                 interchanges will be applied. On exit, the resulting permuted matrix.
  !>     @param[in]
  !>     lda         rocblas_int. lda > 0.
  !>                 The leading dimension of the array A.
  !>     @param[in]
  !>     k1          rocblas_int. k1 > 0.
  !>                 The k_1 index. It is the first element of ipiv for which a row interchange will
  !>                 be done. This is a 1-based index.
  !>     @param[in]
  !>     k2          rocblas_int. k2 > k1 > 0.
  !>                 The k_2 index. k_2 - k_1 + 1 is the number of elements of ipiv for which a row
  !>                 interchange will be done. This is a 1-based index.
  !>     @param[in]
  !>     ipiv        pointer to rocblas_int. Array on the GPU of dimension at least \f$k_1 + (k_2 - k_1)\cdot \text{abs}(\text{incx})\f$.
  !>                 The vector of pivot indices. Only the elements in positions
  !>                 \f$k_1\f$ through \f$k_1 + (k_2 - k_1)\cdot \text{abs}(\text{incx})\f$ of this vector are accessed.
  !>                 Elements of ipiv are considered 1-based.
  !>     @param[in]
  !>     incx        rocblas_int. incx != 0.
  !>                 The distance between successive values of ipiv.  If incx
  !>                 is negative, the pivots are applied in reverse order.
  !>     
  interface rocsolver_slaswp
    function rocsolver_slaswp_(handle,n,A,lda,k1,k2,ipiv,incx) bind(c, name="rocsolver_slaswp")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slaswp_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int),value :: k1
      integer(c_int),value :: k2
      type(c_ptr),value :: ipiv
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_slaswp_full_rank,&
      
rocsolver_slaswp_rank_0,&
      
rocsolver_slaswp_rank_1
#endif

  end interface
  
  interface rocsolver_dlaswp
    function rocsolver_dlaswp_(handle,n,A,lda,k1,k2,ipiv,incx) bind(c, name="rocsolver_dlaswp")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlaswp_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int),value :: k1
      integer(c_int),value :: k2
      type(c_ptr),value :: ipiv
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dlaswp_full_rank,&
      
rocsolver_dlaswp_rank_0,&
      
rocsolver_dlaswp_rank_1
#endif

  end interface
  
  interface rocsolver_claswp
    function rocsolver_claswp_(handle,n,A,lda,k1,k2,ipiv,incx) bind(c, name="rocsolver_claswp")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_claswp_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int),value :: k1
      integer(c_int),value :: k2
      type(c_ptr),value :: ipiv
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_claswp_full_rank,&
      
rocsolver_claswp_rank_0,&
      
rocsolver_claswp_rank_1
#endif

  end interface
  
  interface rocsolver_zlaswp
    function rocsolver_zlaswp_(handle,n,A,lda,k1,k2,ipiv,incx) bind(c, name="rocsolver_zlaswp")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlaswp_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int),value :: k1
      integer(c_int),value :: k2
      type(c_ptr),value :: ipiv
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zlaswp_full_rank,&
      
rocsolver_zlaswp_rank_0,&
      
rocsolver_zlaswp_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief LARFG generates a Householder reflector H of order n.
  !> 
  !>     \details
  !>     The reflector H is such that
  !> 
  !>     \f[
  !>         H'\left[\begin{array}{c}
  !>         \text{alpha}\\
  !>         x
  !>         \end{array}\right]=\left[\begin{array}{c}
  !>         \text{beta}\\
  !>         0
  !>         \end{array}\right]
  !>     \f]
  !> 
  !>     where x is an n-1 vector, and alpha and beta are scalars. Matrix H can be
  !>     generated as
  !> 
  !>     \f[
  !>         H = I - \text{tau}\left[\begin{array}{c}
  !>         1\\
  !>         v
  !>         \end{array}\right]\left[\begin{array}{cc}
  !>         1 & v'
  !>         \end{array}\right]
  !>     \f]
  !> 
  !>     where v is an n-1 vector, and tau is a scalar known as the Householder scalar. The vector
  !> 
  !>     \f[
  !>         \bar{v}=\left[\begin{array}{c}
  !>         1\\
  !>         v
  !>         \end{array}\right]
  !>     \f]
  !> 
  !>     is the Householder vector associated with the reflection.
  !> 
  !>     \note
  !>     The matrix H is orthogonalunitary (i.e. \f$H'H=HH'=I\f$). It is symmetric when real (i.e. \f$H^T=H\f$), but not Hermitian when complex
  !>     (i.e. \f$H^H\neq H\f$ in general).
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The order (size) of reflector H.
  !>     @param[inout]
  !>     alpha       pointer to type. A scalar on the GPU.
  !>                 On entry, the scalar alpha.
  !>                 On exit, it is overwritten with beta.
  !>     @param[inout]
  !>     x           pointer to type. Array on the GPU of size at least n-1 (size depends on the value of incx).
  !>                 On entry, the vector x,
  !>                 On exit, it is overwritten with vector v.
  !>     @param[in]
  !>     incx        rocblas_int. incx > 0.
  !>                 The distance between two consecutive elements of x.
  !>     @param[out]
  !>     tau         pointer to type. A scalar on the GPU.
  !>                 The Householder scalar tau.
  !>     
  interface rocsolver_slarfg
    function rocsolver_slarfg_(handle,n,alpha,x,incx,tau) bind(c, name="rocsolver_slarfg")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slarfg_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_float) :: tau
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_slarfg_rank_0,&
      
rocsolver_slarfg_rank_1
#endif

  end interface
  
  interface rocsolver_dlarfg
    function rocsolver_dlarfg_(handle,n,alpha,x,incx,tau) bind(c, name="rocsolver_dlarfg")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlarfg_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_double) :: tau
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dlarfg_rank_0,&
      
rocsolver_dlarfg_rank_1
#endif

  end interface
  
  interface rocsolver_clarfg
    function rocsolver_clarfg_(handle,n,alpha,x,incx,tau) bind(c, name="rocsolver_clarfg")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clarfg_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: tau
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_clarfg_rank_0,&
      
rocsolver_clarfg_rank_1
#endif

  end interface
  
  interface rocsolver_zlarfg
    function rocsolver_zlarfg_(handle,n,alpha,x,incx,tau) bind(c, name="rocsolver_zlarfg")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlarfg_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: tau
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zlarfg_rank_0,&
      
rocsolver_zlarfg_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief LARFT generates the triangular factor T of a block reflector H of
  !>     order n.
  !> 
  !>     \details
  !>     The block reflector H is defined as the product of k Householder matrices
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         H = H(1)H(2)\cdots H(k) & \: \text{if direct indicates forward direction, or} \\
  !>         H = H(k)\cdots H(2)H(1) & \: \text{if direct indicates backward direction}
  !>         \end{array}
  !>     \f]
  !> 
  !>     The triangular factor T is upper triangular in the forward direction and lower triangular in the backward direction.
  !>     If storev is column-wise, then
  !> 
  !>     \f[
  !>         H = I - VTV'
  !>     \f]
  !> 
  !>     where the \f$j\f$th column of matrix V contains the Householder vector associated with \f$H(j)\f$. If storev is row-wise, then
  !> 
  !>     \f[
  !>         H = I - V'TV
  !>     \f]
  !> 
  !>     where the \f$i\f$th row of matrix V contains the Householder vector associated with \f$H(i)\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     direct      #rocblas_direct.
  !>                 Specifies the direction in which the Householder matrices are applied.
  !>     @param[in]
  !>     storev      #rocblas_storev.
  !>                 Specifies how the Householder vectors are stored in matrix V.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The order (size) of the block reflector.
  !>     @param[in]
  !>     k           rocblas_int. k >= 1.
  !>                 The number of Householder matrices forming H.
  !>     @param[in]
  !>     V           pointer to type. Array on the GPU of size ldvk if column-wise, or ldvn if row-wise.
  !>                 The matrix of Householder vectors.
  !>     @param[in]
  !>     ldv         rocblas_int. ldv >= n if column-wise, or ldv >= k if row-wise.
  !>                 Leading dimension of V.
  !>     @param[in]
  !>     tau         pointer to type. Array of k scalars on the GPU.
  !>                 The vector of all the Householder scalars.
  !>     @param[out]
  !>     T           pointer to type. Array on the GPU of dimension ldtk.
  !>                 The triangular factor. T is upper triangular if direct indicates forward direction, otherwise it is
  !>                 lower triangular. The rest of the array is not used.
  !>     @param[in]
  !>     ldt         rocblas_int. ldt >= k.
  !>                 The leading dimension of T.
  !>     
  interface rocsolver_slarft
    function rocsolver_slarft_(handle,myDirect,storev,n,k,V,ldv,tau,T,ldt) bind(c, name="rocsolver_slarft")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slarft_
      type(c_ptr),value :: handle
      integer(kind(rocblas_forward_direction)),value :: myDirect
      integer(kind(rocblas_column_wise)),value :: storev
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      real(c_float) :: tau
      type(c_ptr),value :: T
      integer(c_int),value :: ldt
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_slarft_full_rank,&
      
rocsolver_slarft_rank_0,&
      
rocsolver_slarft_rank_1
#endif

  end interface
  
  interface rocsolver_dlarft
    function rocsolver_dlarft_(handle,myDirect,storev,n,k,V,ldv,tau,T,ldt) bind(c, name="rocsolver_dlarft")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlarft_
      type(c_ptr),value :: handle
      integer(kind(rocblas_forward_direction)),value :: myDirect
      integer(kind(rocblas_column_wise)),value :: storev
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      real(c_double) :: tau
      type(c_ptr),value :: T
      integer(c_int),value :: ldt
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dlarft_full_rank,&
      
rocsolver_dlarft_rank_0,&
      
rocsolver_dlarft_rank_1
#endif

  end interface
  
  interface rocsolver_clarft
    function rocsolver_clarft_(handle,myDirect,storev,n,k,V,ldv,tau,T,ldt) bind(c, name="rocsolver_clarft")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clarft_
      type(c_ptr),value :: handle
      integer(kind(rocblas_forward_direction)),value :: myDirect
      integer(kind(rocblas_column_wise)),value :: storev
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      complex(c_float_complex) :: tau
      type(c_ptr),value :: T
      integer(c_int),value :: ldt
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_clarft_full_rank,&
      
rocsolver_clarft_rank_0,&
      
rocsolver_clarft_rank_1
#endif

  end interface
  
  interface rocsolver_zlarft
    function rocsolver_zlarft_(handle,myDirect,storev,n,k,V,ldv,tau,T,ldt) bind(c, name="rocsolver_zlarft")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlarft_
      type(c_ptr),value :: handle
      integer(kind(rocblas_forward_direction)),value :: myDirect
      integer(kind(rocblas_column_wise)),value :: storev
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      complex(c_double_complex) :: tau
      type(c_ptr),value :: T
      integer(c_int),value :: ldt
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zlarft_full_rank,&
      
rocsolver_zlarft_rank_0,&
      
rocsolver_zlarft_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief LARF applies a Householder reflector H to a general matrix A.
  !> 
  !>     \details
  !>     The Householder reflector H, of order m or n, is to be applied to an m-by-n matrix A
  !>     from the left or the right, depending on the value of side. H is given by
  !> 
  !>     \f[
  !>         H = I - \text{alpha}\cdot xx'
  !>     \f]
  !> 
  !>     where alpha is the Householder scalar and x is a Householder vector. H is never actually computed.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     side        rocblas_side.
  !>                 Determines whether H is applied from the left or the right.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 Number of rows of A.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of columns of A.
  !>     @param[in]
  !>     x           pointer to type. Array on the GPU of size at least 1 + (m-1)abs(incx) if left side, or
  !>                 at least 1 + (n-1)abs(incx) if right side.
  !>                 The Householder vector x.
  !>     @param[in]
  !>     incx        rocblas_int. incx != 0.
  !>                 Distance between two consecutive elements of x.
  !>                 If incx < 0, the elements of x are indexed in reverse order.
  !>     @param[in]
  !>     alpha       pointer to type. A scalar on the GPU.
  !>                 The Householder scalar. If alpha = 0, then H = I (A will remain the same; x is never used)
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of size ldan.
  !>                 On entry, the matrix A. On exit, it is overwritten with
  !>                 HA (or AH).
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Leading dimension of A.
  !>     
  interface rocsolver_slarf
    function rocsolver_slarf_(handle,side,m,n,x,incx,alpha,A,lda) bind(c, name="rocsolver_slarf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slarf_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_slarf_full_rank,&
      
rocsolver_slarf_rank_0,&
      
rocsolver_slarf_rank_1
#endif

  end interface
  
  interface rocsolver_dlarf
    function rocsolver_dlarf_(handle,side,m,n,x,incx,alpha,A,lda) bind(c, name="rocsolver_dlarf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlarf_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dlarf_full_rank,&
      
rocsolver_dlarf_rank_0,&
      
rocsolver_dlarf_rank_1
#endif

  end interface
  
  interface rocsolver_clarf
    function rocsolver_clarf_(handle,side,m,n,x,incx,alpha,A,lda) bind(c, name="rocsolver_clarf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clarf_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_clarf_full_rank,&
      
rocsolver_clarf_rank_0,&
      
rocsolver_clarf_rank_1
#endif

  end interface
  
  interface rocsolver_zlarf
    function rocsolver_zlarf_(handle,side,m,n,x,incx,alpha,A,lda) bind(c, name="rocsolver_zlarf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlarf_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zlarf_full_rank,&
      
rocsolver_zlarf_rank_0,&
      
rocsolver_zlarf_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief LARFB applies a block reflector H to a general m-by-n matrix A.
  !> 
  !>     \details
  !>     The block reflector H is applied in one of the following forms, depending on
  !>     the values of side and trans:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         HA & \: \text{(No transpose from the left),}\\
  !>         H'A & \:  \text{(Transpose or conjugate transpose from the left),}\\
  !>         AH & \: \text{(No transpose from the right), or}\\
  !>         AH' & \: \text{(Transpose or conjugate transpose from the right).}
  !>         \end{array}
  !>     \f]
  !> 
  !>     The block reflector H is defined as the product of k Householder matrices as
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         H = H(1)H(2)\cdots H(k) & \: \text{if direct indicates forward direction, or} \\
  !>         H = H(k)\cdots H(2)H(1) & \: \text{if direct indicates backward direction}
  !>         \end{array}
  !>     \f]
  !> 
  !>     H is never stored. It is calculated as
  !> 
  !>     \f[
  !>         H = I - VTV'
  !>     \f]
  !> 
  !>     where the \f$j\f$th column of matrix V contains the Householder vector associated with \f$H(j)\f$, if storev is column-wise; or
  !> 
  !>     \f[
  !>         H = I - V'TV
  !>     \f]
  !> 
  !>     where the \f$i\f$th row of matrix V contains the Householder vector associated with \f$H(i)\f$, if storev is row-wise.
  !>     T is the associated triangular factor as computed by \ref rocsolver_slarft "LARFT".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     side        rocblas_side.
  !>                 Specifies from which side to apply H.
  !>     @param[in]
  !>     trans       rocblas_operation.
  !>                 Specifies whether the block reflector or its transposeconjugate transpose is to be applied.
  !>     @param[in]
  !>     direct      #rocblas_direct.
  !>                 Specifies the direction in which the Householder matrices are to be applied to generate H.
  !>     @param[in]
  !>     storev      #rocblas_storev.
  !>                 Specifies how the Householder vectors are stored in matrix V.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 Number of rows of matrix A.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of columns of matrix A.
  !>     @param[in]
  !>     k           rocblas_int. k >= 1.
  !>                 The number of Householder matrices.
  !>     @param[in]
  !>     V           pointer to type. Array on the GPU of size ldvk if column-wise, ldvn if row-wise and applying from the right,
  !>                 or ldvm if row-wise and applying from the left.
  !>                 The matrix of Householder vectors.
  !>     @param[in]
  !>     ldv         rocblas_int. ldv >= k if row-wise, ldv >= m if column-wise and applying from the left, or ldv >= n if
  !>                 column-wise and applying from the right.
  !>                 Leading dimension of V.
  !>     @param[in]
  !>     T           pointer to type. Array on the GPU of dimension ldtk.
  !>                 The triangular factor of the block reflector.
  !>     @param[in]
  !>     ldt         rocblas_int. ldt >= k.
  !>                 The leading dimension of T.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of size ldan.
  !>                 On entry, the matrix A. On exit, it is overwritten with
  !>                 HA, AH, H'A, or AH'.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Leading dimension of A.
  !>     
  interface rocsolver_slarfb
    function rocsolver_slarfb_(handle,side,trans,myDirect,storev,m,n,k,V,ldv,T,ldt,A,lda) bind(c, name="rocsolver_slarfb")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slarfb_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_forward_direction)),value :: myDirect
      integer(kind(rocblas_column_wise)),value :: storev
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      type(c_ptr),value :: T
      integer(c_int),value :: ldt
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_slarfb_full_rank,&
      
rocsolver_slarfb_rank_0,&
      
rocsolver_slarfb_rank_1
#endif

  end interface
  
  interface rocsolver_dlarfb
    function rocsolver_dlarfb_(handle,side,trans,myDirect,storev,m,n,k,V,ldv,T,ldt,A,lda) bind(c, name="rocsolver_dlarfb")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlarfb_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_forward_direction)),value :: myDirect
      integer(kind(rocblas_column_wise)),value :: storev
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      type(c_ptr),value :: T
      integer(c_int),value :: ldt
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dlarfb_full_rank,&
      
rocsolver_dlarfb_rank_0,&
      
rocsolver_dlarfb_rank_1
#endif

  end interface
  
  interface rocsolver_clarfb
    function rocsolver_clarfb_(handle,side,trans,myDirect,storev,m,n,k,V,ldv,T,ldt,A,lda) bind(c, name="rocsolver_clarfb")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clarfb_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_forward_direction)),value :: myDirect
      integer(kind(rocblas_column_wise)),value :: storev
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      type(c_ptr),value :: T
      integer(c_int),value :: ldt
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_clarfb_full_rank,&
      
rocsolver_clarfb_rank_0,&
      
rocsolver_clarfb_rank_1
#endif

  end interface
  
  interface rocsolver_zlarfb
    function rocsolver_zlarfb_(handle,side,trans,myDirect,storev,m,n,k,V,ldv,T,ldt,A,lda) bind(c, name="rocsolver_zlarfb")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlarfb_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(kind(rocblas_forward_direction)),value :: myDirect
      integer(kind(rocblas_column_wise)),value :: storev
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      type(c_ptr),value :: T
      integer(c_int),value :: ldt
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zlarfb_full_rank,&
      
rocsolver_zlarfb_rank_0,&
      
rocsolver_zlarfb_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief LABRD computes the bidiagonal form of the first k rows and columns of
  !>     a general m-by-n matrix A, as well as the matrices X and Y needed to reduce
  !>     the remaining part of A.
  !> 
  !>     \details
  !>     The reduced form is given by:
  !> 
  !>     \f[
  !>         B = Q'AP
  !>     \f]
  !> 
  !>     where the leading k-by-k block of B is upper bidiagonal if m >= n, or lower bidiagonal if m < n. Q and
  !>     P are orthogonalunitary matrices represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Q = H(1)H(2)\cdots H(k), & \text{and} \\
  !>         P = G(1)G(2)\cdots G(k).
  !>         \end{array}
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H(i)\f$ and \f$G(i)\f$ is given by
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         H(i) = I - \text{tauq}[i]\cdot v_i^{}v_i', & \text{and} \\
  !>         G(i) = I - \text{taup}[i]\cdot u_i^{}u_i'.
  !>         \end{array}
  !>     \f]
  !> 
  !>     If m >= n, the first \f$i-1\f$ elements of the Householder vector \f$v_i\f$ are zero, and \f$v_i[i]=1\f$;
  !>     while the first \f$i\f$ elements of the Householder vector \f$u_i\f$ are zero, and  \f$u_i[i+1]=1\f$.
  !>     If m < n, the first \f$i\f$ elements of the Householder vector  \f$v_i\f$ are zero, and  \f$v_i[i+1]=1\f$;
  !>     while the first \f$i-1\f$ elements of the Householder vector \f$u_i\f$ are zero, and \f$u_i[i]=1\f$.
  !> 
  !>     The unreduced part of the matrix A can be updated using the block update
  !> 
  !>     \f[
  !>         A = A - VY' - XU'
  !>     \f]
  !> 
  !>     where V and U are the m-by-k and n-by-k matrices formed with the vectors \f$v_i\f$ and \f$u_i\f$, respectively.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of the matrix A.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of the matrix A.
  !>     @param[in]
  !>     k           rocblas_int. min(m,n) >= k >= 0.
  !>                 The number of leading rows and columns of matrix A that will be reduced.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrix to be reduced.
  !>                 On exit, the first k elements on the diagonal and superdiagonal (if m >= n), or
  !>                 subdiagonal (if m < n), contain the bidiagonal form B.
  !>                 If m >= n, the elements below the diagonal of the first k columns are the possibly non-zero elements
  !>                 of the Householder vectors associated with Q, while the elements above the
  !>                 superdiagonal of the first k rows are the n - i - 1 possibly non-zero elements of the Householder vectors related to P.
  !>                 If m < n, the elements below the subdiagonal of the first k columns are the m - i - 1 possibly non-zero
  !>                 elements of the Householder vectors related to Q, while the elements above the
  !>                 diagonal of the first k rows are the n - i possibly non-zero elements of the vectors associated with P.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     D           pointer to real type. Array on the GPU of dimension k.
  !>                 The diagonal elements of B.
  !>     @param[out]
  !>     E           pointer to real type. Array on the GPU of dimension k.
  !>                 The off-diagonal elements of B.
  !>     @param[out]
  !>     tauq        pointer to type. Array on the GPU of dimension k.
  !>                 The Householder scalars associated with matrix Q.
  !>     @param[out]
  !>     taup        pointer to type. Array on the GPU of dimension k.
  !>                 The Householder scalars associated with matrix P.
  !>     @param[out]
  !>     X           pointer to type. Array on the GPU of dimension ldxk.
  !>                 The m-by-k matrix needed to update the unreduced part of A.
  !>     @param[in]
  !>     ldx         rocblas_int. ldx >= m.
  !>                 The leading dimension of X.
  !>     @param[out]
  !>     Y           pointer to type. Array on the GPU of dimension ldyk.
  !>                 The n-by-k matrix needed to update the unreduced part of A.
  !>     @param[in]
  !>     ldy         rocblas_int. ldy >= n.
  !>                 The leading dimension of Y.
  !>     
  interface rocsolver_slabrd
    function rocsolver_slabrd_(handle,m,n,k,A,lda,D,E,tauq,taup,X,ldx,Y,ldy) bind(c, name="rocsolver_slabrd")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slabrd_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: tauq
      type(c_ptr),value :: taup
      type(c_ptr),value :: X
      integer(c_int),value :: ldx
      type(c_ptr),value :: Y
      integer(c_int),value :: ldy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_slabrd_full_rank,&
      
rocsolver_slabrd_rank_0,&
      
rocsolver_slabrd_rank_1
#endif

  end interface
  
  interface rocsolver_dlabrd
    function rocsolver_dlabrd_(handle,m,n,k,A,lda,D,E,tauq,taup,X,ldx,Y,ldy) bind(c, name="rocsolver_dlabrd")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlabrd_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: tauq
      type(c_ptr),value :: taup
      type(c_ptr),value :: X
      integer(c_int),value :: ldx
      type(c_ptr),value :: Y
      integer(c_int),value :: ldy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dlabrd_full_rank,&
      
rocsolver_dlabrd_rank_0,&
      
rocsolver_dlabrd_rank_1
#endif

  end interface
  
  interface rocsolver_clabrd
    function rocsolver_clabrd_(handle,m,n,k,A,lda,D,E,tauq,taup,X,ldx,Y,ldy) bind(c, name="rocsolver_clabrd")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clabrd_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: tauq
      type(c_ptr),value :: taup
      type(c_ptr),value :: X
      integer(c_int),value :: ldx
      type(c_ptr),value :: Y
      integer(c_int),value :: ldy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_clabrd_full_rank,&
      
rocsolver_clabrd_rank_0,&
      
rocsolver_clabrd_rank_1
#endif

  end interface
  
  interface rocsolver_zlabrd
    function rocsolver_zlabrd_(handle,m,n,k,A,lda,D,E,tauq,taup,X,ldx,Y,ldy) bind(c, name="rocsolver_zlabrd")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlabrd_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: tauq
      type(c_ptr),value :: taup
      type(c_ptr),value :: X
      integer(c_int),value :: ldx
      type(c_ptr),value :: Y
      integer(c_int),value :: ldy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zlabrd_full_rank,&
      
rocsolver_zlabrd_rank_0,&
      
rocsolver_zlabrd_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief LATRD computes the tridiagonal form of k rows and columns of
  !>     a symmetrichermitian matrix A, as well as the matrix W needed to update
  !>     the remaining part of A.
  !> 
  !>     \details
  !>     The reduced form is given by:
  !> 
  !>     \f[
  !>         T = Q'AQ
  !>     \f]
  !> 
  !>     If uplo is lower, the first k rows and columns of T form the tridiagonal block. If uplo is upper, then the last
  !>     k rows and columns of T form the tridiagonal block. Q is an orthogonalunitary matrix represented as the
  !>     product of Householder matrices
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Q = H(1)H(2)\cdots H(k) & \text{if uplo indicates lower, or}\\
  !>         Q = H(n)H(n-1)\cdots H(n-k+1) & \text{if uplo is upper}.
  !>         \end{array}
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H(i)\f$ is given by
  !> 
  !>     \f[
  !>         H(i) = I - \text{tau}[i]\cdot v_i^{}v_i'
  !>     \f]
  !> 
  !>     where tau[\f$i\f$] is the corresponding Householder scalar. When uplo indicates lower, the first \f$i\f$
  !>     elements of the Householder vector \f$v_i\f$ are zero, and \f$v_i[i+1] = 1\f$. If uplo is upper,
  !>     the last n-\f$i\f$ elements of the Householder vector \f$v_i\f$ are zero, and \f$v_i[i] = 1\f$.
  !> 
  !>     The unreduced part of the matrix A can be updated using a rank update of the form:
  !> 
  !>     \f[
  !>         A = A - VW' - WV'
  !>     \f]
  !> 
  !>     where V is the n-by-k matrix formed by the vectors \f$v_i\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the matrix A is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower)
  !>                 part of A is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of the matrix A.
  !>     @param[in]
  !>     k           rocblas_int. 0 <= k <= n.
  !>                 The number of rows and columns of the matrix A to be reduced.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the n-by-n matrix to be reduced.
  !>                 On exit, if uplo is lower, the first k columns have been reduced to tridiagonal form
  !>                 (given in the diagonal elements of A and the array E), the elements below the diagonal
  !>                 contain the possibly non-zero entries of the Householder vectors associated with Q, stored as columns.
  !>                 If uplo is upper, the last k columns have been reduced to tridiagonal form
  !>                 (given in the diagonal elements of A and the array E), the elements above the diagonal
  !>                 contain the possibly non-zero entries of the Householder vectors associated with Q, stored as columns.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 The leading dimension of A.
  !>     @param[out]
  !>     E           pointer to real type. Array on the GPU of dimension n-1.
  !>                 If upper (lower), the last (first) k elements of E are the off-diagonal elements of the
  !>                 computed tridiagonal block.
  !>     @param[out]
  !>     tau         pointer to type. Array on the GPU of dimension n-1.
  !>                 If upper (lower), the last (first) k elements of tau are the Householder scalars related to Q.
  !>     @param[out]
  !>     W           pointer to type. Array on the GPU of dimension ldwk.
  !>                 The n-by-k matrix needed to update the unreduced part of A.
  !>     @param[in]
  !>     ldw         rocblas_int. ldw >= n.
  !>                 The leading dimension of W.
  !>     
  interface rocsolver_slatrd
    function rocsolver_slatrd_(handle,uplo,n,k,A,lda,E,tau,W,ldw) bind(c, name="rocsolver_slatrd")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slatrd_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: E
      real(c_float) :: tau
      type(c_ptr),value :: W
      integer(c_int),value :: ldw
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_slatrd_full_rank,&
      
rocsolver_slatrd_rank_0,&
      
rocsolver_slatrd_rank_1
#endif

  end interface
  
  interface rocsolver_dlatrd
    function rocsolver_dlatrd_(handle,uplo,n,k,A,lda,E,tau,W,ldw) bind(c, name="rocsolver_dlatrd")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlatrd_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: E
      real(c_double) :: tau
      type(c_ptr),value :: W
      integer(c_int),value :: ldw
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dlatrd_full_rank,&
      
rocsolver_dlatrd_rank_0,&
      
rocsolver_dlatrd_rank_1
#endif

  end interface
  
  interface rocsolver_clatrd
    function rocsolver_clatrd_(handle,uplo,n,k,A,lda,E,tau,W,ldw) bind(c, name="rocsolver_clatrd")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clatrd_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: E
      complex(c_float_complex) :: tau
      type(c_ptr),value :: W
      integer(c_int),value :: ldw
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_clatrd_full_rank,&
      
rocsolver_clatrd_rank_0,&
      
rocsolver_clatrd_rank_1
#endif

  end interface
  
  interface rocsolver_zlatrd
    function rocsolver_zlatrd_(handle,uplo,n,k,A,lda,E,tau,W,ldw) bind(c, name="rocsolver_zlatrd")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlatrd_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: E
      complex(c_double_complex) :: tau
      type(c_ptr),value :: W
      integer(c_int),value :: ldw
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zlatrd_full_rank,&
      
rocsolver_zlatrd_rank_0,&
      
rocsolver_zlatrd_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief LASYF computes a partial factorization of a symmetric matrix \f$A\f$
  !>     using Bunch-Kaufman diagonal pivoting.
  !> 
  !>     \details
  !>     The partial factorization has the form
  !> 
  !>     \f[
  !>         A = \left[ \begin{array}{cc}
  !>         I & U_{12} \\
  !>         0 & U_{22}
  !>         \end{array} \right] \left[ \begin{array}{cc}
  !>         A_{11} & 0 \\
  !>         0 & D
  !>         \end{array} \right] \left[ \begin{array}{cc}
  !>         I & 0 \\
  !>         U_{12}^T & U_{22}^T
  !>         \end{array} \right]
  !>     \f]
  !> 
  !>     or
  !> 
  !>     \f[
  !>         A = \left[ \begin{array}{cc}
  !>         L_{11} & 0 \\
  !>         L_{21} & I
  !>         \end{array} \right] \left[ \begin{array}{cc}
  !>         D & 0 \\
  !>         0 & A_{22}
  !>         \end{array} \right] \left[ \begin{array}{cc}
  !>         L_{11}^T & L_{21}^T \\
  !>         0 & I
  !>         \end{array} \right]
  !>     \f]
  !> 
  !>     depending on the value of uplo. The order of the block diagonal matrix \f$D\f$
  !>     is either \f$nb\f$ or \f$nb-1\f$, and is returned in the argument \f$kb\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the matrix A is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower)
  !>                 part of A is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of the matrix A.
  !>     @param[in]
  !>     nb          rocblas_int. 2 <= nb <= n.
  !>                 The number of columns of A to be factored.
  !>     @param[out]
  !>     kb          pointer to a rocblas_int on the GPU.
  !>                 The number of columns of A that were actually factored (either nb or
  !>                 nb-1).
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the symmetric matrix A to be factored.
  !>                 On exit, the partially factored matrix.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     ipiv        pointer to rocblas_int. Array on the GPU of dimension n.
  !>                 The vector of pivot indices. Elements of ipiv are 1-based indices.
  !>                 If uplo is upper, then only the last kb elements of ipiv will be
  !>                 set. For n - kb < k <= n, if ipiv[k] > 0 then rows and columns k
  !>                 and ipiv[k] were interchanged and D[k,k] is a 1-by-1 diagonal block.
  !>                 If, instead, ipiv[k] = ipiv[k-1] < 0, then rows and columns k-1
  !>                 and -ipiv[k] were interchanged and D[k-1,k-1] to D[k,k] is a 2-by-2
  !>                 diagonal block.
  !>                 If uplo is lower, then only the first kb elements of ipiv will be
  !>                 set. For 1 <= k <= kb, if ipiv[k] > 0 then rows and columns k
  !>                 and ipiv[k] were interchanged and D[k,k] is a 1-by-1 diagonal block.
  !>                 If, instead, ipiv[k] = ipiv[k+1] < 0, then rows and columns k+1
  !>                 and -ipiv[k] were interchanged and D[k,k] to D[k+1,k+1] is a 2-by-2
  !>                 diagonal block.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0, D is singular. D[i,i] is the first diagonal zero.
  !>     
  interface rocsolver_slasyf
    function rocsolver_slasyf_(handle,uplo,n,nb,kb,A,lda,ipiv,myInfo) bind(c, name="rocsolver_slasyf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slasyf_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nb
      type(c_ptr),value :: kb
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_slasyf_full_rank,&
      
rocsolver_slasyf_rank_0,&
      
rocsolver_slasyf_rank_1
#endif

  end interface
  
  interface rocsolver_dlasyf
    function rocsolver_dlasyf_(handle,uplo,n,nb,kb,A,lda,ipiv,myInfo) bind(c, name="rocsolver_dlasyf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlasyf_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nb
      type(c_ptr),value :: kb
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dlasyf_full_rank,&
      
rocsolver_dlasyf_rank_0,&
      
rocsolver_dlasyf_rank_1
#endif

  end interface
  
  interface rocsolver_clasyf
    function rocsolver_clasyf_(handle,uplo,n,nb,kb,A,lda,ipiv,myInfo) bind(c, name="rocsolver_clasyf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clasyf_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nb
      type(c_ptr),value :: kb
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_clasyf_full_rank,&
      
rocsolver_clasyf_rank_0,&
      
rocsolver_clasyf_rank_1
#endif

  end interface
  
  interface rocsolver_zlasyf
    function rocsolver_zlasyf_(handle,uplo,n,nb,kb,A,lda,ipiv,myInfo) bind(c, name="rocsolver_zlasyf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlasyf_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nb
      type(c_ptr),value :: kb
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zlasyf_full_rank,&
      
rocsolver_zlasyf_rank_0,&
      
rocsolver_zlasyf_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief LAUUM computes the product of the upper (or lower) triangular part U (or L) of a
  !>     symmetricHemitian matrix A with its transpose.
  !> 
  !>     \details
  !>     If uplo indicates upper, then \f$UU'\f$ is computed. If uplo indicates lower, then \f$L'L\f$ is computed instead.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower triangular part of A will be used.
  !>                 If uplo indicates lower (or upper), then the upper (or lower)
  !>                 part of A is not referenced.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns and rows of the matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, it contains the upper (or lower) part of the symmetricHermitian matrix.
  !>                 On exit, the upper (or lower) part is overwritten with the result of UU' (or L'L).
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 The leading dimension of the array A.
  !>     
  interface rocsolver_slauum
    function rocsolver_slauum_(handle,uplo,n,A,lda) bind(c, name="rocsolver_slauum")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slauum_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_slauum_full_rank,&
      
rocsolver_slauum_rank_0,&
      
rocsolver_slauum_rank_1
#endif

  end interface
  
  interface rocsolver_dlauum
    function rocsolver_dlauum_(handle,uplo,n,A,lda) bind(c, name="rocsolver_dlauum")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlauum_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dlauum_full_rank,&
      
rocsolver_dlauum_rank_0,&
      
rocsolver_dlauum_rank_1
#endif

  end interface
  
  interface rocsolver_clauum
    function rocsolver_clauum_(handle,uplo,n,A,lda) bind(c, name="rocsolver_clauum")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clauum_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_clauum_full_rank,&
      
rocsolver_clauum_rank_0,&
      
rocsolver_clauum_rank_1
#endif

  end interface
  
  interface rocsolver_zlauum
    function rocsolver_zlauum_(handle,uplo,n,A,lda) bind(c, name="rocsolver_zlauum")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlauum_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zlauum_full_rank,&
      
rocsolver_zlauum_rank_0,&
      
rocsolver_zlauum_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief ORG2R generates an m-by-n Matrix Q with orthonormal columns.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The matrix Q is defined as the first n columns of the product of k Householder
  !>     reflectors of order m
  !> 
  !>     \f[
  !>         Q = H(1)H(2)\cdots H(k).
  !>     \f]
  !> 
  !>     The Householder matrices \f$H(i)\f$ are never stored, they are computed from its corresponding
  !>     Householder vectors \f$v_i\f$ and scalars \f$\text{ipiv}[i]\f$, as returned by \ref rocsolver_sgeqrf "GEQRF".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of the matrix Q.
  !>     @param[in]
  !>     n           rocblas_int. 0 <= n <= m.
  !>                 The number of columns of the matrix Q.
  !>     @param[in]
  !>     k           rocblas_int. 0 <= k <= n.
  !>                 The number of Householder reflectors.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A as returned by \ref rocsolver_sgeqrf "GEQRF", with the Householder vectors in the first k columns.
  !>                 On exit, the computed matrix Q.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension at least k.
  !>                 The Householder scalars as returned by \ref rocsolver_sgeqrf "GEQRF".
  !>     
  interface rocsolver_sorg2r
    function rocsolver_sorg2r_(handle,m,n,k,A,lda,ipiv) bind(c, name="rocsolver_sorg2r")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorg2r_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sorg2r_full_rank,&
      
rocsolver_sorg2r_rank_0,&
      
rocsolver_sorg2r_rank_1
#endif

  end interface
  
  interface rocsolver_dorg2r
    function rocsolver_dorg2r_(handle,m,n,k,A,lda,ipiv) bind(c, name="rocsolver_dorg2r")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorg2r_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dorg2r_full_rank,&
      
rocsolver_dorg2r_rank_0,&
      
rocsolver_dorg2r_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief UNG2R generates an m-by-n complex Matrix Q with orthonormal columns.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The matrix Q is defined as the first n columns of the product of k Householder
  !>     reflectors of order m
  !> 
  !>     \f[
  !>         Q = H(1)H(2)\cdots H(k)
  !>     \f]
  !> 
  !>     The Householder matrices \f$H(i)\f$ are never stored, they are computed from its corresponding
  !>     Householder vectors \f$v_i\f$ and scalars \f$\text{ipiv}[i]\f$, as returned by \ref rocsolver_sgeqrf "GEQRF".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of the matrix Q.
  !>     @param[in]
  !>     n           rocblas_int. 0 <= n <= m.
  !>                 The number of columns of the matrix Q.
  !>     @param[in]
  !>     k           rocblas_int. 0 <= k <= n.
  !>                 The number of Householder reflectors.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A as returned by \ref rocsolver_sgeqrf "GEQRF", with the Householder vectors in the first k columns.
  !>                 On exit, the computed matrix Q.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension at least k.
  !>                 The Householder scalars as returned by \ref rocsolver_sgeqrf "GEQRF".
  !>     
  interface rocsolver_cung2r
    function rocsolver_cung2r_(handle,m,n,k,A,lda,ipiv) bind(c, name="rocsolver_cung2r")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cung2r_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cung2r_full_rank,&
      
rocsolver_cung2r_rank_0,&
      
rocsolver_cung2r_rank_1
#endif

  end interface
  
  interface rocsolver_zung2r
    function rocsolver_zung2r_(handle,m,n,k,A,lda,ipiv) bind(c, name="rocsolver_zung2r")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zung2r_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zung2r_full_rank,&
      
rocsolver_zung2r_rank_0,&
      
rocsolver_zung2r_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief ORGQR generates an m-by-n Matrix Q with orthonormal columns.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The matrix Q is defined as the first n columns of the product of k Householder
  !>     reflectors of order m
  !> 
  !>     \f[
  !>         Q = H(1)H(2)\cdots H(k)
  !>     \f]
  !> 
  !>     The Householder matrices \f$H(i)\f$ are never stored, they are computed from its corresponding
  !>     Householder vectors \f$v_i\f$ and scalars \f$\text{ipiv}[i]\f$, as returned by \ref rocsolver_sgeqrf "GEQRF".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of the matrix Q.
  !>     @param[in]
  !>     n           rocblas_int. 0 <= n <= m.
  !>                 The number of columns of the matrix Q.
  !>     @param[in]
  !>     k           rocblas_int. 0 <= k <= n.
  !>                 The number of Householder reflectors.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A as returned by \ref rocsolver_sgeqrf "GEQRF", with the Householder vectors in the first k columns.
  !>                 On exit, the computed matrix Q.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension at least k.
  !>                 The Householder scalars as returned by \ref rocsolver_sgeqrf "GEQRF".
  !>     
  interface rocsolver_sorgqr
    function rocsolver_sorgqr_(handle,m,n,k,A,lda,ipiv) bind(c, name="rocsolver_sorgqr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorgqr_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sorgqr_full_rank,&
      
rocsolver_sorgqr_rank_0,&
      
rocsolver_sorgqr_rank_1
#endif

  end interface
  
  interface rocsolver_dorgqr
    function rocsolver_dorgqr_(handle,m,n,k,A,lda,ipiv) bind(c, name="rocsolver_dorgqr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorgqr_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dorgqr_full_rank,&
      
rocsolver_dorgqr_rank_0,&
      
rocsolver_dorgqr_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief UNGQR generates an m-by-n complex Matrix Q with orthonormal columns.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The matrix Q is defined as the first n columns of the product of k Householder
  !>     reflectors of order m
  !> 
  !>     \f[
  !>         Q = H(1)H(2)\cdots H(k)
  !>     \f]
  !> 
  !>     Householder matrices \f$H(i)\f$ are never stored, they are computed from its corresponding
  !>     Householder vectors \f$v_i\f$ and scalars \f$\text{ipiv}[i]\f$, as returned by \ref rocsolver_sgeqrf "GEQRF".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of the matrix Q.
  !>     @param[in]
  !>     n           rocblas_int. 0 <= n <= m.
  !>                 The number of columns of the matrix Q.
  !>     @param[in]
  !>     k           rocblas_int. 0 <= k <= n.
  !>                 The number of Householder reflectors.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A as returned by \ref rocsolver_sgeqrf "GEQRF", with the Householder vectors in the first k columns.
  !>                 On exit, the computed matrix Q.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension at least k.
  !>                 The Householder scalars as returned by \ref rocsolver_sgeqrf "GEQRF".
  !>     
  interface rocsolver_cungqr
    function rocsolver_cungqr_(handle,m,n,k,A,lda,ipiv) bind(c, name="rocsolver_cungqr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cungqr_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cungqr_full_rank,&
      
rocsolver_cungqr_rank_0,&
      
rocsolver_cungqr_rank_1
#endif

  end interface
  
  interface rocsolver_zungqr
    function rocsolver_zungqr_(handle,m,n,k,A,lda,ipiv) bind(c, name="rocsolver_zungqr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zungqr_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zungqr_full_rank,&
      
rocsolver_zungqr_rank_0,&
      
rocsolver_zungqr_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief ORGL2 generates an m-by-n Matrix Q with orthonormal rows.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The matrix Q is defined as the first m rows of the product of k Householder
  !>     reflectors of order n
  !> 
  !>     \f[
  !>         Q = H(k)H(k-1)\cdots H(1)
  !>     \f]
  !> 
  !>     The Householder matrices \f$H(i)\f$ are never stored, they are computed from its corresponding
  !>     Householder vectors \f$v_i\f$ and scalars \f$\text{ipiv}[i]\f$, as returned by \ref rocsolver_sgelqf "GELQF".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. 0 <= m <= n.
  !>                 The number of rows of the matrix Q.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of the matrix Q.
  !>     @param[in]
  !>     k           rocblas_int. 0 <= k <= m.
  !>                 The number of Householder reflectors.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A as returned by \ref rocsolver_sgeqrf "GELQF", with the Householder vectors in the first k rows.
  !>                 On exit, the computed matrix Q.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension at least k.
  !>                 The Householder scalars as returned by \ref rocsolver_sgelqf "GELQF".
  !>     
  interface rocsolver_sorgl2
    function rocsolver_sorgl2_(handle,m,n,k,A,lda,ipiv) bind(c, name="rocsolver_sorgl2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorgl2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sorgl2_full_rank,&
      
rocsolver_sorgl2_rank_0,&
      
rocsolver_sorgl2_rank_1
#endif

  end interface
  
  interface rocsolver_dorgl2
    function rocsolver_dorgl2_(handle,m,n,k,A,lda,ipiv) bind(c, name="rocsolver_dorgl2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorgl2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dorgl2_full_rank,&
      
rocsolver_dorgl2_rank_0,&
      
rocsolver_dorgl2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief UNGL2 generates an m-by-n complex Matrix Q with orthonormal rows.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The matrix Q is defined as the first m rows of the product of k Householder
  !>     reflectors of order n
  !> 
  !>     \f[
  !>         Q = H(k)^HH(k-1)^H\cdots H(1)^H
  !>     \f]
  !> 
  !>     The Householder matrices \f$H(i)\f$ are never stored, they are computed from its corresponding
  !>     Householder vectors \f$v_i\f$ and scalars \f$\text{ipiv}[i]\f$, as returned by \ref rocsolver_sgelqf "GELQF".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. 0 <= m <= n.
  !>                 The number of rows of the matrix Q.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of the matrix Q.
  !>     @param[in]
  !>     k           rocblas_int. 0 <= k <= m.
  !>                 The number of Householder reflectors.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A as returned by \ref rocsolver_sgeqrf "GELQF", with the Householder vectors in the first k rows.
  !>                 On exit, the computed matrix Q.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension at least k.
  !>                 The Householder scalars as returned by \ref rocsolver_sgelqf "GELQF".
  !>     
  interface rocsolver_cungl2
    function rocsolver_cungl2_(handle,m,n,k,A,lda,ipiv) bind(c, name="rocsolver_cungl2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cungl2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cungl2_full_rank,&
      
rocsolver_cungl2_rank_0,&
      
rocsolver_cungl2_rank_1
#endif

  end interface
  
  interface rocsolver_zungl2
    function rocsolver_zungl2_(handle,m,n,k,A,lda,ipiv) bind(c, name="rocsolver_zungl2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zungl2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zungl2_full_rank,&
      
rocsolver_zungl2_rank_0,&
      
rocsolver_zungl2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief ORGLQ generates an m-by-n Matrix Q with orthonormal rows.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The matrix Q is defined as the first m rows of the product of k Householder
  !>     reflectors of order n
  !> 
  !>     \f[
  !>         Q = H(k)H(k-1)\cdots H(1)
  !>     \f]
  !> 
  !>     The Householder matrices \f$H(i)\f$ are never stored, they are computed from its corresponding
  !>     Householder vectors \f$v_i\f$ and scalars \f$\text{ipiv}[i]\f$, as returned by \ref rocsolver_sgelqf "GELQF".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. 0 <= m <= n.
  !>                 The number of rows of the matrix Q.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of the matrix Q.
  !>     @param[in]
  !>     k           rocblas_int. 0 <= k <= m.
  !>                 The number of Householder reflectors.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A as returned by \ref rocsolver_sgeqrf "GELQF", with the Householder vectors in the first k rows.
  !>                 On exit, the computed matrix Q.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension at least k.
  !>                 The Householder scalars as returned by \ref rocsolver_sgelqf "GELQF".
  !>     
  interface rocsolver_sorglq
    function rocsolver_sorglq_(handle,m,n,k,A,lda,ipiv) bind(c, name="rocsolver_sorglq")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorglq_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sorglq_full_rank,&
      
rocsolver_sorglq_rank_0,&
      
rocsolver_sorglq_rank_1
#endif

  end interface
  
  interface rocsolver_dorglq
    function rocsolver_dorglq_(handle,m,n,k,A,lda,ipiv) bind(c, name="rocsolver_dorglq")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorglq_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dorglq_full_rank,&
      
rocsolver_dorglq_rank_0,&
      
rocsolver_dorglq_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief UNGLQ generates an m-by-n complex Matrix Q with orthonormal rows.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The matrix Q is defined as the first m rows of the product of k Householder
  !>     reflectors of order n
  !> 
  !>     \f[
  !>         Q = H(k)^HH(k-1)^H\cdots H(1)^H
  !>     \f]
  !> 
  !>     The Householder matrices \f$H(i)\f$ are never stored, they are computed from its corresponding
  !>     Householder vectors \f$v_i\f$ and scalars \f$\text{ipiv}[i]\f$, as returned by \ref rocsolver_sgelqf "GELQF".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. 0 <= m <= n.
  !>                 The number of rows of the matrix Q.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of the matrix Q.
  !>     @param[in]
  !>     k           rocblas_int. 0 <= k <= m.
  !>                 The number of Householder reflectors.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A as returned by \ref rocsolver_sgeqrf "GELQF", with the Householder vectors in the first k rows.
  !>                 On exit, the computed matrix Q.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension at least k.
  !>                 The Householder scalars as returned by \ref rocsolver_sgelqf "GELQF".
  !>     
  interface rocsolver_cunglq
    function rocsolver_cunglq_(handle,m,n,k,A,lda,ipiv) bind(c, name="rocsolver_cunglq")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunglq_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cunglq_full_rank,&
      
rocsolver_cunglq_rank_0,&
      
rocsolver_cunglq_rank_1
#endif

  end interface
  
  interface rocsolver_zunglq
    function rocsolver_zunglq_(handle,m,n,k,A,lda,ipiv) bind(c, name="rocsolver_zunglq")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunglq_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zunglq_full_rank,&
      
rocsolver_zunglq_rank_0,&
      
rocsolver_zunglq_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief ORG2L generates an m-by-n Matrix Q with orthonormal columns.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The matrix Q is defined as the last n columns of the product of k
  !>     Householder reflectors of order m
  !> 
  !>     \f[
  !>         Q = H(k)H(k-1)\cdots H(1)
  !>     \f]
  !> 
  !>     The Householder matrices \f$H(i)\f$ are never stored, they are computed from its
  !>     corresponding Householder vectors \f$v_i\f$ and scalars \f$\text{ipiv}[i]\f$, as returned by \ref rocsolver_sgeqlf "GEQLF".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of the matrix Q.
  !>     @param[in]
  !>     n           rocblas_int. 0 <= n <= m.
  !>                 The number of columns of the matrix Q.
  !>     @param[in]
  !>     k           rocblas_int. 0 <= k <= n.
  !>                 The number of Householder reflectors.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A as returned by \ref rocsolver_sgeqrf "GEQLF", with the Householder vectors in the last k columns.
  !>                 On exit, the computed matrix Q.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension at least k.
  !>                 The Householder scalars as returned by \ref rocsolver_sgeqlf "GEQLF".
  !>     
  interface rocsolver_sorg2l
    function rocsolver_sorg2l_(handle,m,n,k,A,lda,ipiv) bind(c, name="rocsolver_sorg2l")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorg2l_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sorg2l_full_rank,&
      
rocsolver_sorg2l_rank_0,&
      
rocsolver_sorg2l_rank_1
#endif

  end interface
  
  interface rocsolver_dorg2l
    function rocsolver_dorg2l_(handle,m,n,k,A,lda,ipiv) bind(c, name="rocsolver_dorg2l")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorg2l_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dorg2l_full_rank,&
      
rocsolver_dorg2l_rank_0,&
      
rocsolver_dorg2l_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief UNG2L generates an m-by-n complex Matrix Q with orthonormal columns.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The matrix Q is defined as the last n columns of the product of k
  !>     Householder reflectors of order m
  !> 
  !>     \f[
  !>         Q = H(k)H(k-1)\cdots H(1)
  !>     \f]
  !> 
  !>     The Householder matrices \f$H(i)\f$ are never stored, they are computed from its
  !>     corresponding Householder vectors \f$v_i\f$ and scalars \f$\text{ipiv}[i]\f$, as returned by \ref rocsolver_sgeqlf "GEQLF".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of the matrix Q.
  !>     @param[in]
  !>     n           rocblas_int. 0 <= n <= m.
  !>                 The number of columns of the matrix Q.
  !>     @param[in]
  !>     k           rocblas_int. 0 <= k <= n.
  !>                 The number of Householder reflectors.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A as returned by \ref rocsolver_sgeqrf "GEQLF", with the Householder vectors in the last k columns.
  !>                 On exit, the computed matrix Q.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension at least k.
  !>                 The Householder scalars as returned by \ref rocsolver_sgeqlf "GEQLF".
  !>     
  interface rocsolver_cung2l
    function rocsolver_cung2l_(handle,m,n,k,A,lda,ipiv) bind(c, name="rocsolver_cung2l")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cung2l_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cung2l_full_rank,&
      
rocsolver_cung2l_rank_0,&
      
rocsolver_cung2l_rank_1
#endif

  end interface
  
  interface rocsolver_zung2l
    function rocsolver_zung2l_(handle,m,n,k,A,lda,ipiv) bind(c, name="rocsolver_zung2l")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zung2l_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zung2l_full_rank,&
      
rocsolver_zung2l_rank_0,&
      
rocsolver_zung2l_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief ORGQL generates an m-by-n Matrix Q with orthonormal columns.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The matrix Q is defined as the last n column of the product of k Householder
  !>     reflectors of order m
  !> 
  !>     \f[
  !>         Q = H(k)H(k-1)\cdots H(1)
  !>     \f]
  !> 
  !>     The Householder matrices \f$H(i)\f$ are never stored, they are computed from its
  !>     corresponding Householder vectors \f$v_i\f$ and scalars \f$\text{ipiv}[i]\f$, as returned by \ref rocsolver_sgeqlf "GEQLF".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of the matrix Q.
  !>     @param[in]
  !>     n           rocblas_int. 0 <= n <= m.
  !>                 The number of columns of the matrix Q.
  !>     @param[in]
  !>     k           rocblas_int. 0 <= k <= n.
  !>                 The number of Householder reflectors.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A as returned by \ref rocsolver_sgeqrf "GEQLF", with the Householder vectors in the last k columns.
  !>                 On exit, the computed matrix Q.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension at least k.
  !>                 The Householder scalars as returned by \ref rocsolver_sgeqlf "GEQLF".
  !>     
  interface rocsolver_sorgql
    function rocsolver_sorgql_(handle,m,n,k,A,lda,ipiv) bind(c, name="rocsolver_sorgql")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorgql_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sorgql_full_rank,&
      
rocsolver_sorgql_rank_0,&
      
rocsolver_sorgql_rank_1
#endif

  end interface
  
  interface rocsolver_dorgql
    function rocsolver_dorgql_(handle,m,n,k,A,lda,ipiv) bind(c, name="rocsolver_dorgql")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorgql_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dorgql_full_rank,&
      
rocsolver_dorgql_rank_0,&
      
rocsolver_dorgql_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief UNGQL generates an m-by-n complex Matrix Q with orthonormal columns.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The matrix Q is defined as the last n columns of the product of k
  !>     Householder reflectors of order m
  !> 
  !>     \f[
  !>         Q = H(k)H(k-1)\cdots H(1)
  !>     \f]
  !> 
  !>     The Householder matrices \f$H(i)\f$ are never stored, they are computed from its
  !>     corresponding Householder vectors \f$v_i\f$ and scalars \f$\text{ipiv}[i]\f$, as returned by \ref rocsolver_sgeqlf "GEQLF".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of the matrix Q.
  !>     @param[in]
  !>     n           rocblas_int. 0 <= n <= m.
  !>                 The number of columns of the matrix Q.
  !>     @param[in]
  !>     k           rocblas_int. 0 <= k <= n.
  !>                 The number of Householder reflectors.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A as returned by \ref rocsolver_sgeqrf "GEQLF", with the Householder vectors in the last k columns.
  !>                 On exit, the computed matrix Q.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension at least k.
  !>                 The Householder scalars as returned by \ref rocsolver_sgeqlf "GEQLF".
  !>     
  interface rocsolver_cungql
    function rocsolver_cungql_(handle,m,n,k,A,lda,ipiv) bind(c, name="rocsolver_cungql")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cungql_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cungql_full_rank,&
      
rocsolver_cungql_rank_0,&
      
rocsolver_cungql_rank_1
#endif

  end interface
  
  interface rocsolver_zungql
    function rocsolver_zungql_(handle,m,n,k,A,lda,ipiv) bind(c, name="rocsolver_zungql")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zungql_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zungql_full_rank,&
      
rocsolver_zungql_rank_0,&
      
rocsolver_zungql_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief ORGBR generates an m-by-n Matrix Q with orthonormal rows or columns.
  !> 
  !>     \details
  !>     If storev is column-wise, then the matrix Q has orthonormal columns. If m >= k, Q is defined as the first
  !>     n columns of the product of k Householder reflectors of order m
  !> 
  !>     \f[
  !>         Q = H(1)H(2)\cdots H(k)
  !>     \f]
  !> 
  !>     If m < k, Q is defined as the product of Householder reflectors of order m
  !> 
  !>     \f[
  !>         Q = H(1)H(2)\cdots H(m-1)
  !>     \f]
  !> 
  !>     On the other hand, if storev is row-wise, then the matrix Q has orthonormal rows. If n > k, Q is defined as the
  !>     first m rows of the product of k Householder reflectors of order n
  !> 
  !>     \f[
  !>         Q = H(k)H(k-1)\cdots H(1)
  !>     \f]
  !> 
  !>     If n <= k, Q is defined as the product of Householder reflectors of order n
  !> 
  !>     \f[
  !>         Q = H(n-1)H(n-2)\cdots H(1)
  !>     \f]
  !> 
  !>     The Householder matrices \f$H(i)\f$ are never stored, they are computed from its corresponding
  !>     Householder vectors \f$v_i\f$ and scalars \f$\text{ipiv}[i]\f$, as returned by \ref rocsolver_sgebrd "GEBRD" in its arguments A and tauq or taup.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     storev      #rocblas_storev.
  !>                 Specifies whether to work column-wise or row-wise.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of the matrix Q.
  !>                 If row-wise, then min(n,k) <= m <= n.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of the matrix Q.
  !>                 If column-wise, then min(m,k) <= n <= m.
  !>     @param[in]
  !>     k           rocblas_int. k >= 0.
  !>                 The number of columns (if storev is column-wise) or rows (if row-wise) of the
  !>                 original matrix reduced by \ref rocsolver_sgebrd "GEBRD".
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the Householder vectors as returned by \ref rocsolver_sgebrd "GEBRD".
  !>                 On exit, the computed matrix Q.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension min(m,k) if column-wise, or min(n,k) if row-wise.
  !>                 The Householder scalars as returned by \ref rocsolver_sgebrd "GEBRD".
  !>     
  interface rocsolver_sorgbr
    function rocsolver_sorgbr_(handle,storev,m,n,k,A,lda,ipiv) bind(c, name="rocsolver_sorgbr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorgbr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_column_wise)),value :: storev
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sorgbr_full_rank,&
      
rocsolver_sorgbr_rank_0,&
      
rocsolver_sorgbr_rank_1
#endif

  end interface
  
  interface rocsolver_dorgbr
    function rocsolver_dorgbr_(handle,storev,m,n,k,A,lda,ipiv) bind(c, name="rocsolver_dorgbr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorgbr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_column_wise)),value :: storev
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dorgbr_full_rank,&
      
rocsolver_dorgbr_rank_0,&
      
rocsolver_dorgbr_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief UNGBR generates an m-by-n complex Matrix Q with orthonormal rows or
  !>     columns.
  !> 
  !>     \details
  !>     If storev is column-wise, then the matrix Q has orthonormal columns. If m >= k, Q is defined as the first
  !>     n columns of the product of k Householder reflectors of order m
  !> 
  !>     \f[
  !>         Q = H(1)H(2)\cdots H(k)
  !>     \f]
  !> 
  !>     If m < k, Q is defined as the product of Householder reflectors of order m
  !> 
  !>     \f[
  !>         Q = H(1)H(2)\cdots H(m-1)
  !>     \f]
  !> 
  !>     On the other hand, if storev is row-wise, then the matrix Q has orthonormal rows. If n > k, Q is defined as the
  !>     first m rows of the product of k Householder reflectors of order n
  !> 
  !>     \f[
  !>         Q = H(k)H(k-1)\cdots H(1)
  !>     \f]
  !> 
  !>     If n <= k, Q is defined as the product of Householder reflectors of order n
  !> 
  !>     \f[
  !>         Q = H(n-1)H(n-2)\cdots H(1)
  !>     \f]
  !> 
  !>     The Householder matrices \f$H(i)\f$ are never stored, they are computed from its corresponding
  !>     Householder vectors \f$v_i\f$ and scalars \f$\text{ipiv}[i]\f$, as returned by \ref rocsolver_sgebrd "GEBRD" in its arguments A and tauq or taup.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     storev      #rocblas_storev.
  !>                 Specifies whether to work column-wise or row-wise.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of the matrix Q.
  !>                 If row-wise, then min(n,k) <= m <= n.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of the matrix Q.
  !>                 If column-wise, then min(m,k) <= n <= m.
  !>     @param[in]
  !>     k           rocblas_int. k >= 0.
  !>                 The number of columns (if storev is column-wise) or rows (if row-wise) of the
  !>                 original matrix reduced by \ref rocsolver_sgebrd "GEBRD".
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the Householder vectors as returned by \ref rocsolver_sgebrd "GEBRD".
  !>                 On exit, the computed matrix Q.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension min(m,k) if column-wise, or min(n,k) if row-wise.
  !>                 The Householder scalars as returned by \ref rocsolver_sgebrd "GEBRD".
  !>     
  interface rocsolver_cungbr
    function rocsolver_cungbr_(handle,storev,m,n,k,A,lda,ipiv) bind(c, name="rocsolver_cungbr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cungbr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_column_wise)),value :: storev
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cungbr_full_rank,&
      
rocsolver_cungbr_rank_0,&
      
rocsolver_cungbr_rank_1
#endif

  end interface
  
  interface rocsolver_zungbr
    function rocsolver_zungbr_(handle,storev,m,n,k,A,lda,ipiv) bind(c, name="rocsolver_zungbr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zungbr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_column_wise)),value :: storev
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zungbr_full_rank,&
      
rocsolver_zungbr_rank_0,&
      
rocsolver_zungbr_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief ORGTR generates an n-by-n orthogonal Matrix Q.
  !> 
  !>     \details
  !>     Q is defined as the product of n-1 Householder reflectors of order n. If
  !>     uplo indicates upper, then Q has the form
  !> 
  !>     \f[
  !>         Q = H(n-1)H(n-2)\cdots H(1)
  !>     \f]
  !> 
  !>     On the other hand, if uplo indicates lower, then Q has the form
  !> 
  !>     \f[
  !>         Q = H(1)H(2)\cdots H(n-1)
  !>     \f]
  !> 
  !>     The Householder matrices \f$H(i)\f$ are never stored, they are computed from its
  !>     corresponding Householder vectors \f$v_i\f$ and scalars \f$\text{ipiv}[i]\f$, as returned by
  !>     \ref rocsolver_ssytrd "SYTRD" in its arguments A and tau.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the \ref rocsolver_ssytrd "SYTRD" factorization was upper or lower
  !>                 triangular. If uplo indicates lower (or upper), then the upper (or lower)
  !>                 part of A is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of the matrix Q.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the Householder vectors as returned
  !>                 by \ref rocsolver_ssytrd "SYTRD". On exit, the computed matrix Q.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension n-1.
  !>                 The Householder scalars as returned by \ref rocsolver_ssytrd "SYTRD".
  !>     
  interface rocsolver_sorgtr
    function rocsolver_sorgtr_(handle,uplo,n,A,lda,ipiv) bind(c, name="rocsolver_sorgtr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorgtr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sorgtr_full_rank,&
      
rocsolver_sorgtr_rank_0,&
      
rocsolver_sorgtr_rank_1
#endif

  end interface
  
  interface rocsolver_dorgtr
    function rocsolver_dorgtr_(handle,uplo,n,A,lda,ipiv) bind(c, name="rocsolver_dorgtr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorgtr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dorgtr_full_rank,&
      
rocsolver_dorgtr_rank_0,&
      
rocsolver_dorgtr_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief UNGTR generates an n-by-n unitary Matrix Q.
  !> 
  !>     \details
  !>     Q is defined as the product of n-1 Householder reflectors of order n. If
  !>     uplo indicates upper, then Q has the form
  !> 
  !>     \f[
  !>         Q = H(n-1)H(n-2)\cdots H(1)
  !>     \f]
  !> 
  !>     On the other hand, if uplo indicates lower, then Q has the form
  !> 
  !>     \f[
  !>         Q = H(1)H(2)\cdots H(n-1)
  !>     \f]
  !> 
  !>     The Householder matrices \f$H(i)\f$ are never stored, they are computed from its
  !>     corresponding Householder vectors \f$v_i\f$ and scalars \f$\text{ipiv}[i]\f$, as returned by
  !>     \ref rocsolver_chetrd "HETRD" in its arguments A and tau.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the \ref rocsolver_chetrd "HETRD" factorization was upper or lower
  !>                 triangular. If uplo indicates lower (or upper), then the upper (or lower)
  !>                 part of A is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of the matrix Q.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the Householder vectors as returned
  !>                 by \ref rocsolver_chetrd "HETRD". On exit, the computed matrix Q.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension n-1.
  !>                 The Householder scalars as returned by \ref rocsolver_chetrd "HETRD".
  !>     
  interface rocsolver_cungtr
    function rocsolver_cungtr_(handle,uplo,n,A,lda,ipiv) bind(c, name="rocsolver_cungtr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cungtr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cungtr_full_rank,&
      
rocsolver_cungtr_rank_0,&
      
rocsolver_cungtr_rank_1
#endif

  end interface
  
  interface rocsolver_zungtr
    function rocsolver_zungtr_(handle,uplo,n,A,lda,ipiv) bind(c, name="rocsolver_zungtr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zungtr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zungtr_full_rank,&
      
rocsolver_zungtr_rank_0,&
      
rocsolver_zungtr_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief ORM2R multiplies a matrix Q with orthonormal columns by a general m-by-n
  !>     matrix C.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The matrix Q is applied in one of the following forms, depending on
  !>     the values of side and trans:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         QC & \: \text{No transpose from the left,}\\
  !>         Q^TC & \: \text{Transpose from the left,}\\
  !>         CQ & \: \text{No transpose from the right, and}\\
  !>         CQ^T & \: \text{Transpose from the right.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Q is defined as the product of k Householder reflectors
  !> 
  !>     \f[
  !>         Q = H(1)H(2) \cdots H(k)
  !>     \f]
  !> 
  !>     of order m if applying from the left, or n if applying from the right. Q is never stored, it is
  !>     calculated from the Householder vectors and scalars returned by the QR factorization \ref rocsolver_sgeqrf "GEQRF".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     side        rocblas_side.
  !>                 Specifies from which side to apply Q.
  !>     @param[in]
  !>     trans       rocblas_operation.
  !>                 Specifies whether the matrix Q or its transpose is to be applied.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 Number of rows of matrix C.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of columns of matrix C.
  !>     @param[in]
  !>     k           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.
  !>                 The number of Householder reflectors that form Q.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU of size ldak.
  !>                 The Householder vectors as returned by \ref rocsolver_sgeqrf "GEQRF"
  !>                 in the first k columns of its argument A.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m if side is left, or lda >= n if side is right.
  !>                 Leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension at least k.
  !>                 The Householder scalars as returned by \ref rocsolver_sgeqrf "GEQRF".
  !>     @param[inout]
  !>     C           pointer to type. Array on the GPU of size ldcn.
  !>                 On entry, the matrix C. On exit, it is overwritten with
  !>                 QC, CQ, Q'C, or CQ'.
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= m.
  !>                 Leading dimension of C.
  !>     
  interface rocsolver_sorm2r
    function rocsolver_sorm2r_(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_sorm2r")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorm2r_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sorm2r_full_rank,&
      
rocsolver_sorm2r_rank_0,&
      
rocsolver_sorm2r_rank_1
#endif

  end interface
  
  interface rocsolver_dorm2r
    function rocsolver_dorm2r_(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_dorm2r")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorm2r_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dorm2r_full_rank,&
      
rocsolver_dorm2r_rank_0,&
      
rocsolver_dorm2r_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief UNM2R multiplies a complex matrix Q with orthonormal columns by a
  !>     general m-by-n matrix C.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The matrix Q is applied in one of the following forms, depending on
  !>     the values of side and trans:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         QC & \: \text{No transpose from the left,}\\
  !>         Q^HC & \: \text{Conjugate transpose from the left,}\\
  !>         CQ & \: \text{No transpose from the right, and}\\
  !>         CQ^H & \: \text{Conjugate transpose from the right.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Q is defined as the product of k Householder reflectors
  !> 
  !>     \f[
  !>         Q = H(1)H(2)\cdots H(k)
  !>     \f]
  !> 
  !>     of order m if applying from the left, or n if applying from the right. Q is never stored, it is
  !>     calculated from the Householder vectors and scalars returned by the QR factorization \ref rocsolver_sgeqrf "GEQRF".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     side        rocblas_side.
  !>                 Specifies from which side to apply Q.
  !>     @param[in]
  !>     trans       rocblas_operation.
  !>                 Specifies whether the matrix Q or its conjugate transpose is to be applied.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 Number of rows of matrix C.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of columns of matrix C.
  !>     @param[in]
  !>     k           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.
  !>                 The number of Householder reflectors that form Q.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU of size ldak.
  !>                 The Householder vectors as returned by \ref rocsolver_sgeqrf "GEQRF"
  !>                 in the first k columns of its argument A.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m if side is left, or lda >= n if side is right.
  !>                 Leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension at least k.
  !>                 The Householder scalars as returned by \ref rocsolver_sgeqrf "GEQRF".
  !>     @param[inout]
  !>     C           pointer to type. Array on the GPU of size ldcn.
  !>                 On entry, the matrix C. On exit, it is overwritten with
  !>                 QC, CQ, Q'C, or CQ'.
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= m.
  !>                 Leading dimension of C.
  !> 
  !>     
  interface rocsolver_cunm2r
    function rocsolver_cunm2r_(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_cunm2r")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunm2r_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cunm2r_full_rank,&
      
rocsolver_cunm2r_rank_0,&
      
rocsolver_cunm2r_rank_1
#endif

  end interface
  
  interface rocsolver_zunm2r
    function rocsolver_zunm2r_(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_zunm2r")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunm2r_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zunm2r_full_rank,&
      
rocsolver_zunm2r_rank_0,&
      
rocsolver_zunm2r_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief ORMQR multiplies a matrix Q with orthonormal columns by a general m-by-n
  !>     matrix C.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The matrix Q is applied in one of the following forms, depending on
  !>     the values of side and trans:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         QC & \: \text{No transpose from the left,}\\
  !>         Q^TC & \: \text{Transpose from the left,}\\
  !>         CQ & \: \text{No transpose from the right, and}\\
  !>         CQ^T & \: \text{Transpose from the right.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Q is defined as the product of k Householder reflectors
  !> 
  !>     \f[
  !>         Q = H(1)H(2)\cdots H(k)
  !>     \f]
  !> 
  !>     of order m if applying from the left, or n if applying from the right. Q is never stored, it is
  !>     calculated from the Householder vectors and scalars returned by the QR factorization \ref rocsolver_sgeqrf "GEQRF".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     side        rocblas_side.
  !>                 Specifies from which side to apply Q.
  !>     @param[in]
  !>     trans       rocblas_operation.
  !>                 Specifies whether the matrix Q or its transpose is to be applied.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 Number of rows of matrix C.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of columns of matrix C.
  !>     @param[in]
  !>     k           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.
  !>                 The number of Householder reflectors that form Q.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU of size ldak.
  !>                 The Householder vectors as returned by \ref rocsolver_sgeqrf "GEQRF"
  !>                 in the first k columns of its argument A.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m if side is left, or lda >= n if side is right.
  !>                 Leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension at least k.
  !>                 The Householder scalars as returned by \ref rocsolver_sgeqrf "GEQRF".
  !>     @param[inout]
  !>     C           pointer to type. Array on the GPU of size ldcn.
  !>                 On entry, the matrix C. On exit, it is overwritten with
  !>                 QC, CQ, Q'C, or CQ'.
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= m.
  !>                 Leading dimension of C.
  !>     
  interface rocsolver_sormqr
    function rocsolver_sormqr_(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_sormqr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sormqr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sormqr_full_rank,&
      
rocsolver_sormqr_rank_0,&
      
rocsolver_sormqr_rank_1
#endif

  end interface
  
  interface rocsolver_dormqr
    function rocsolver_dormqr_(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_dormqr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dormqr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dormqr_full_rank,&
      
rocsolver_dormqr_rank_0,&
      
rocsolver_dormqr_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief UNMQR multiplies a complex matrix Q with orthonormal columns by a
  !>     general m-by-n matrix C.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The matrix Q is applied in one of the following forms, depending on
  !>     the values of side and trans:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         QC & \: \text{No transpose from the left,}\\
  !>         Q^HC & \: \text{Conjugate transpose from the left,}\\
  !>         CQ & \: \text{No transpose from the right, and}\\
  !>         CQ^H & \: \text{Conjugate transpose from the right.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Q is defined as the product of k Householder reflectors
  !> 
  !>     \f[
  !>         Q = H(1)H(2)\cdots H(k)
  !>     \f]
  !> 
  !>     of order m if applying from the left, or n if applying from the right. Q is never stored, it is
  !>     calculated from the Householder vectors and scalars returned by the QR factorization \ref rocsolver_sgeqrf "GEQRF".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     side        rocblas_side.
  !>                 Specifies from which side to apply Q.
  !>     @param[in]
  !>     trans       rocblas_operation.
  !>                 Specifies whether the matrix Q or its conjugate transpose is to be applied.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 Number of rows of matrix C.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of columns of matrix C.
  !>     @param[in]
  !>     k           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.
  !>                 The number of Householder reflectors that form Q.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU of size ldak.
  !>                 The Householder vectors as returned by \ref rocsolver_sgeqrf "GEQRF"
  !>                 in the first k columns of its argument A.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m if side is left, or lda >= n if side is right.
  !>                 Leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension at least k.
  !>                 The Householder scalars as returned by \ref rocsolver_sgeqrf "GEQRF".
  !>     @param[inout]
  !>     C           pointer to type. Array on the GPU of size ldcn.
  !>                 On entry, the matrix C. On exit, it is overwritten with
  !>                 QC, CQ, Q'C, or CQ'.
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= m.
  !>                 Leading dimension of C.
  !>     
  interface rocsolver_cunmqr
    function rocsolver_cunmqr_(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_cunmqr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunmqr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cunmqr_full_rank,&
      
rocsolver_cunmqr_rank_0,&
      
rocsolver_cunmqr_rank_1
#endif

  end interface
  
  interface rocsolver_zunmqr
    function rocsolver_zunmqr_(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_zunmqr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunmqr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zunmqr_full_rank,&
      
rocsolver_zunmqr_rank_0,&
      
rocsolver_zunmqr_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief ORML2 multiplies a matrix Q with orthonormal rows by a general m-by-n
  !>     matrix C.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The matrix Q is applied in one of the following forms, depending on
  !>     the values of side and trans:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         QC & \: \text{No transpose from the left,}\\
  !>         Q^TC & \: \text{Transpose from the left,}\\
  !>         CQ & \: \text{No transpose from the right, and}\\
  !>         CQ^T & \: \text{Transpose from the right.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Q is defined as the product of k Householder reflectors
  !> 
  !>     \f[
  !>         Q = H(k)H(k-1)\cdots H(1)
  !>     \f]
  !> 
  !>     of order m if applying from the left, or n if applying from the right. Q is never stored, it is
  !>     calculated from the Householder vectors and scalars returned by the LQ factorization \ref rocsolver_sgelqf "GELQF".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     side        rocblas_side.
  !>                 Specifies from which side to apply Q.
  !>     @param[in]
  !>     trans       rocblas_operation.
  !>                 Specifies whether the matrix Q or its transpose is to be applied.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 Number of rows of matrix C.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of columns of matrix C.
  !>     @param[in]
  !>     k           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.
  !>                 The number of Householder reflectors that form Q.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU of size ldam if side is left, or ldan if side is right.
  !>                 The Householder vectors as returned by \ref rocsolver_sgelqf "GELQF"
  !>                 in the first k rows of its argument A.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= k.
  !>                 Leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension at least k.
  !>                 The Householder scalars as returned by \ref rocsolver_sgelqf "GELQF".
  !>     @param[inout]
  !>     C           pointer to type. Array on the GPU of size ldcn.
  !>                 On entry, the matrix C. On exit, it is overwritten with
  !>                 QC, CQ, Q'C, or CQ'.
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= m.
  !>                 Leading dimension of C.
  !> 
  !>     
  interface rocsolver_sorml2
    function rocsolver_sorml2_(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_sorml2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorml2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sorml2_full_rank,&
      
rocsolver_sorml2_rank_0,&
      
rocsolver_sorml2_rank_1
#endif

  end interface
  
  interface rocsolver_dorml2
    function rocsolver_dorml2_(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_dorml2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorml2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dorml2_full_rank,&
      
rocsolver_dorml2_rank_0,&
      
rocsolver_dorml2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief UNML2 multiplies a complex matrix Q with orthonormal rows by a general
  !>     m-by-n matrix C.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The matrix Q is applied in one of the following forms, depending on
  !>     the values of side and trans:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         QC & \: \text{No transpose from the left,}\\
  !>         Q^HC & \: \text{Conjugate transpose from the left,}\\
  !>         CQ & \: \text{No transpose from the right, and}\\
  !>         CQ^H & \: \text{Conjugate transpose from the right.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Q is defined as the product of k Householder reflectors
  !> 
  !>     \f[
  !>         Q = H(k)^HH(k-1)^H\cdots H(1)^H
  !>     \f]
  !> 
  !>     of order m if applying from the left, or n if applying from the right. Q is never stored, it is
  !>     calculated from the Householder vectors and scalars returned by the LQ factorization \ref rocsolver_sgelqf "GELQF".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     side        rocblas_side.
  !>                 Specifies from which side to apply Q.
  !>     @param[in]
  !>     trans       rocblas_operation.
  !>                 Specifies whether the matrix Q or its conjugate transpose is to be applied.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 Number of rows of matrix C.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of columns of matrix C.
  !>     @param[in]
  !>     k           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.
  !>                 The number of Householder reflectors that form Q.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU of size ldam if side is left, or ldan if side is right.
  !>                 The Householder vectors as returned by \ref rocsolver_sgelqf "GELQF"
  !>                 in the first k rows of its argument A.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= k.
  !>                 Leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension at least k.
  !>                 The Householder scalars as returned by \ref rocsolver_sgelqf "GELQF".
  !>     @param[inout]
  !>     C           pointer to type. Array on the GPU of size ldcn.
  !>                 On entry, the matrix C. On exit, it is overwritten with
  !>                 QC, CQ, Q'C, or CQ'.
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= m.
  !>                 Leading dimension of C.
  !>     
  interface rocsolver_cunml2
    function rocsolver_cunml2_(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_cunml2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunml2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cunml2_full_rank,&
      
rocsolver_cunml2_rank_0,&
      
rocsolver_cunml2_rank_1
#endif

  end interface
  
  interface rocsolver_zunml2
    function rocsolver_zunml2_(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_zunml2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunml2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zunml2_full_rank,&
      
rocsolver_zunml2_rank_0,&
      
rocsolver_zunml2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief ORMLQ multiplies a matrix Q with orthonormal rows by a general m-by-n
  !>     matrix C.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The matrix Q is applied in one of the following forms, depending on
  !>     the values of side and trans:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         QC & \: \text{No transpose from the left,}\\
  !>         Q^TC & \: \text{Transpose from the left,}\\
  !>         CQ & \: \text{No transpose from the right, and}\\
  !>         CQ^T & \: \text{Transpose from the right.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Q is defined as the product of k Householder reflectors
  !> 
  !>     \f[
  !>         Q = H(k)H(k-1)\cdots H(1)
  !>     \f]
  !> 
  !>     of order m if applying from the left, or n if applying from the right. Q is never stored, it is
  !>     calculated from the Householder vectors and scalars returned by the LQ factorization \ref rocsolver_sgelqf "GELQF".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     side        rocblas_side.
  !>                 Specifies from which side to apply Q.
  !>     @param[in]
  !>     trans       rocblas_operation.
  !>                 Specifies whether the matrix Q or its transpose is to be applied.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 Number of rows of matrix C.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of columns of matrix C.
  !>     @param[in]
  !>     k           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.
  !>                 The number of Householder reflectors that form Q.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU of size ldam if side is left, or ldan if side is right.
  !>                 The Householder vectors as returned by \ref rocsolver_sgelqf "GELQF"
  !>                 in the first k rows of its argument A.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= k.
  !>                 Leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension at least k.
  !>                 The Householder scalars as returned by \ref rocsolver_sgelqf "GELQF".
  !>     @param[inout]
  !>     C           pointer to type. Array on the GPU of size ldcn.
  !>                 On entry, the matrix C. On exit, it is overwritten with
  !>                 QC, CQ, Q'C, or CQ'.
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= m.
  !>                 Leading dimension of C.
  !>     
  interface rocsolver_sormlq
    function rocsolver_sormlq_(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_sormlq")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sormlq_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sormlq_full_rank,&
      
rocsolver_sormlq_rank_0,&
      
rocsolver_sormlq_rank_1
#endif

  end interface
  
  interface rocsolver_dormlq
    function rocsolver_dormlq_(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_dormlq")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dormlq_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dormlq_full_rank,&
      
rocsolver_dormlq_rank_0,&
      
rocsolver_dormlq_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief UNMLQ multiplies a complex matrix Q with orthonormal rows by a general
  !>     m-by-n matrix C.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The matrix Q is applied in one of the following forms, depending on
  !>     the values of side and trans:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         QC & \: \text{No transpose from the left,}\\
  !>         Q^HC & \: \text{Conjugate transpose from the left,}\\
  !>         CQ & \: \text{No transpose from the right, and}\\
  !>         CQ^H & \: \text{Conjugate transpose from the right.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Q is defined as the product of k Householder reflectors
  !> 
  !>     \f[
  !>         Q = H(k)^HH(k-1)^H\cdots H(1)^H
  !>     \f]
  !> 
  !>     of order m if applying from the left, or n if applying from the right. Q is never stored, it is
  !>     calculated from the Householder vectors and scalars returned by the LQ factorization \ref rocsolver_sgelqf "GELQF".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     side        rocblas_side.
  !>                 Specifies from which side to apply Q.
  !>     @param[in]
  !>     trans       rocblas_operation.
  !>                 Specifies whether the matrix Q or its conjugate transpose is to be applied.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 Number of rows of matrix C.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of columns of matrix C.
  !>     @param[in]
  !>     k           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.
  !>                 The number of Householder reflectors that form Q.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU of size ldam if side is left, or ldan if side is right.
  !>                 The Householder vectors as returned by \ref rocsolver_sgelqf "GELQF"
  !>                 in the first k rows of its argument A.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= k.
  !>                 Leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension at least k.
  !>                 The Householder scalars as returned by \ref rocsolver_sgelqf "GELQF".
  !>     @param[inout]
  !>     C           pointer to type. Array on the GPU of size ldcn.
  !>                 On entry, the matrix C. On exit, it is overwritten with
  !>                 QC, CQ, Q'C, or CQ'.
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= m.
  !>                 Leading dimension of C.
  !>     
  interface rocsolver_cunmlq
    function rocsolver_cunmlq_(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_cunmlq")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunmlq_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cunmlq_full_rank,&
      
rocsolver_cunmlq_rank_0,&
      
rocsolver_cunmlq_rank_1
#endif

  end interface
  
  interface rocsolver_zunmlq
    function rocsolver_zunmlq_(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_zunmlq")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunmlq_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zunmlq_full_rank,&
      
rocsolver_zunmlq_rank_0,&
      
rocsolver_zunmlq_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief ORM2L multiplies a matrix Q with orthonormal columns by a general m-by-n
  !>     matrix C.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The matrix Q is applied in one of the following forms, depending on
  !>     the values of side and trans:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         QC & \: \text{No transpose from the left,}\\
  !>         Q^TC & \: \text{Transpose from the left,}\\
  !>         CQ & \: \text{No transpose from the right, and}\\
  !>         CQ^T & \: \text{Transpose from the right.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Q is defined as the product of k Householder reflectors
  !> 
  !>     \f[
  !>         Q = H(k)H(k-1)\cdots H(1)
  !>     \f]
  !> 
  !>     of order m if applying from the left, or n if applying from the right. Q is
  !>     never stored, it is calculated from the Householder vectors and scalars
  !>     returned by the QL factorization \ref rocsolver_sgeqlf "GEQLF".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     side        rocblas_side.
  !>                 Specifies from which side to apply Q.
  !>     @param[in]
  !>     trans       rocblas_operation.
  !>                 Specifies whether the matrix Q or its transpose is to be
  !>                 applied.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 Number of rows of matrix C.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of columns of matrix C.
  !>     @param[in]
  !>     k           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.
  !>                 The number of Householder reflectors that form Q.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU of size ldak.
  !>                 The Householder vectors as returned by \ref rocsolver_sgeqlf "GEQLF" in the last k columns of its
  !>                 argument A.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m if side is left, lda >= n if side is right.
  !>                 Leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension at least k.
  !>                 The Householder scalars as returned by
  !>                 \ref rocsolver_sgeqlf "GEQLF".
  !>     @param[inout]
  !>     C           pointer to type. Array on the GPU of size ldcn.
  !>                 On entry, the matrix C. On exit, it is overwritten with
  !>                 QC, CQ, Q'C, or CQ'.
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= m.
  !>                 Leading dimension of C.
  !>     
  interface rocsolver_sorm2l
    function rocsolver_sorm2l_(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_sorm2l")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorm2l_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sorm2l_full_rank,&
      
rocsolver_sorm2l_rank_0,&
      
rocsolver_sorm2l_rank_1
#endif

  end interface
  
  interface rocsolver_dorm2l
    function rocsolver_dorm2l_(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_dorm2l")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorm2l_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dorm2l_full_rank,&
      
rocsolver_dorm2l_rank_0,&
      
rocsolver_dorm2l_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief UNM2L multiplies a complex matrix Q with orthonormal columns by a
  !>     general m-by-n matrix C.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The matrix Q is applied in one of the following forms, depending on
  !>     the values of side and trans:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         QC & \: \text{No transpose from the left,}\\
  !>         Q^HC & \: \text{Conjugate transpose from the left,}\\
  !>         CQ & \: \text{No transpose from the right, and}\\
  !>         CQ^H & \: \text{Conjugate transpose from the right.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Q is defined as the product of k Householder reflectors
  !> 
  !>     \f[
  !>         Q = H(k)H(k-1)\cdots H(1)
  !>     \f]
  !> 
  !>     of order m if applying from the left, or n if applying from the right. Q is
  !>     never stored, it is calculated from the Householder vectors and scalars
  !>     returned by the QL factorization \ref rocsolver_sgeqlf "GEQLF".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     side        rocblas_side.
  !>                 Specifies from which side to apply Q.
  !>     @param[in]
  !>     trans       rocblas_operation.
  !>                 Specifies whether the matrix Q or its conjugate
  !>                 transpose is to be applied.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 Number of rows of matrix C.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of columns of matrix C.
  !>     @param[in]
  !>     k           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.
  !>                 The number of Householder reflectors that form Q.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU of size ldak.
  !>                 The Householder vectors as returned by \ref rocsolver_sgeqlf "GEQLF" in the last k columns of its
  !>                 argument A.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m if side is left, lda >= n if side is right.
  !>                 Leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension at least k.
  !>                 The Householder scalars as returned by
  !>                 \ref rocsolver_sgeqlf "GEQLF".
  !>     @param[inout]
  !>     C           pointer to type. Array on the GPU of size ldcn.
  !>                 On entry, the matrix C. On exit, it is overwritten with
  !>                 QC, CQ, Q'C, or CQ'.
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= m.
  !>                 Leading dimension of C.
  !>     
  interface rocsolver_cunm2l
    function rocsolver_cunm2l_(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_cunm2l")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunm2l_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cunm2l_full_rank,&
      
rocsolver_cunm2l_rank_0,&
      
rocsolver_cunm2l_rank_1
#endif

  end interface
  
  interface rocsolver_zunm2l
    function rocsolver_zunm2l_(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_zunm2l")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunm2l_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zunm2l_full_rank,&
      
rocsolver_zunm2l_rank_0,&
      
rocsolver_zunm2l_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief ORMQL multiplies a matrix Q with orthonormal columns by a general m-by-n
  !>     matrix C.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The matrix Q is applied in one of the following forms, depending on
  !>     the values of side and trans:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         QC & \: \text{No transpose from the left,}\\
  !>         Q^TC & \: \text{Transpose from the left,}\\
  !>         CQ & \: \text{No transpose from the right, and}\\
  !>         CQ^T & \: \text{Transpose from the right.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Q is defined as the product of k Householder reflectors
  !> 
  !>     \f[
  !>         Q = H(k)H(k-1)\cdots H(1)
  !>     \f]
  !> 
  !>     of order m if applying from the left, or n if applying from the right. Q is
  !>     never stored, it is calculated from the Householder vectors and scalars
  !>     returned by the QL factorization \ref rocsolver_sgeqlf "GEQLF".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     side        rocblas_side.
  !>                 Specifies from which side to apply Q.
  !>     @param[in]
  !>     trans       rocblas_operation.
  !>                 Specifies whether the matrix Q or its transpose is to be
  !>                 applied.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 Number of rows of matrix C.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of columns of matrix C.
  !>     @param[in]
  !>     k           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.
  !>                 The number of Householder reflectors that form Q.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU of size ldak.
  !>                 The Householder vectors as returned by \ref rocsolver_sgeqlf "GEQLF" in the last k columns of its
  !>                 argument A.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m if side is left, lda >= n if side is right.
  !>                 Leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension at least k.
  !>                 The Householder scalars as returned by
  !>                 \ref rocsolver_sgeqlf "GEQLF".
  !>     @param[inout]
  !>     C           pointer to type. Array on the GPU of size ldcn.
  !>                 On entry, the matrix C. On exit, it is overwritten with
  !>                 QC, CQ, Q'C, or CQ'.
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= m.
  !>                 Leading dimension of C.
  !>     
  interface rocsolver_sormql
    function rocsolver_sormql_(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_sormql")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sormql_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sormql_full_rank,&
      
rocsolver_sormql_rank_0,&
      
rocsolver_sormql_rank_1
#endif

  end interface
  
  interface rocsolver_dormql
    function rocsolver_dormql_(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_dormql")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dormql_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dormql_full_rank,&
      
rocsolver_dormql_rank_0,&
      
rocsolver_dormql_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief UNMQL multiplies a complex matrix Q with orthonormal columns by a
  !>     general m-by-n matrix C.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The matrix Q is applied in one of the following forms, depending on
  !>     the values of side and trans:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         QC & \: \text{No transpose from the left,}\\
  !>         Q^HC & \: \text{Conjugate transpose from the left,}\\
  !>         CQ & \: \text{No transpose from the right, and}\\
  !>         CQ^H & \: \text{Conjugate transpose from the right.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Q is defined as the product of k Householder reflectors
  !> 
  !>     \f[
  !>         Q = H(k)H(k-1)\cdots H(1)
  !>     \f]
  !> 
  !>     of order m if applying from the left, or n if applying from the right. Q is
  !>     never stored, it is calculated from the Householder vectors and scalars
  !>     returned by the QL factorization \ref rocsolver_sgeqlf "GEQLF".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     side        rocblas_side.
  !>                 Specifies from which side to apply Q.
  !>     @param[in]
  !>     trans       rocblas_operation.
  !>                 Specifies whether the matrix Q or its conjugate
  !>                 transpose is to be applied.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 Number of rows of matrix C.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of columns of matrix C.
  !>     @param[in]
  !>     k           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.
  !>                 The number of Householder reflectors that form Q.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU of size ldak.
  !>                 The Householder vectors as returned by \ref rocsolver_sgeqlf "GEQLF" in the last k columns of its
  !>                 argument A.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m if side is left, lda >= n if side is right.
  !>                 Leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension at least k.
  !>                 The Householder scalars as returned by
  !>                 \ref rocsolver_sgeqlf "GEQLF".
  !>     @param[inout]
  !>     C           pointer to type. Array on the GPU of size ldcn.
  !>                 On entry, the matrix C. On exit, it is overwritten with
  !>                 QC, CQ, Q'C, or CQ'.
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= m.
  !>                 Leading dimension of C.
  !>     
  interface rocsolver_cunmql
    function rocsolver_cunmql_(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_cunmql")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunmql_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cunmql_full_rank,&
      
rocsolver_cunmql_rank_0,&
      
rocsolver_cunmql_rank_1
#endif

  end interface
  
  interface rocsolver_zunmql
    function rocsolver_zunmql_(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_zunmql")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunmql_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zunmql_full_rank,&
      
rocsolver_zunmql_rank_0,&
      
rocsolver_zunmql_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief ORMBR multiplies a matrix Q with orthonormal rows or columns by a
  !>     general m-by-n matrix C.
  !> 
  !>     \details
  !>     If storev is column-wise, then the matrix Q has orthonormal columns.
  !>     If storev is row-wise, then the matrix Q has orthonormal rows.
  !>     The matrix Q is applied in one of the following forms, depending on
  !>     the values of side and trans:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         QC & \: \text{No transpose from the left,}\\
  !>         Q^TC & \: \text{Transpose from the left,}\\
  !>         CQ & \: \text{No transpose from the right, and}\\
  !>         CQ^T & \: \text{Transpose from the right.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     The order q of the orthogonal matrix Q is q = m if applying from the left, or q = n if applying from the right.
  !> 
  !>     When storev is column-wise, if q >= k, then Q is defined as the product of k Householder reflectors
  !> 
  !>     \f[
  !>         Q = H(1)H(2)\cdots H(k),
  !>     \f]
  !> 
  !>     and if q < k, then Q is defined as the product
  !> 
  !>     \f[
  !>         Q = H(1)H(2)\cdots H(q-1).
  !>     \f]
  !> 
  !>     When storev is row-wise, if q > k, then Q is defined as the product of k Householder reflectors
  !> 
  !>     \f[
  !>         Q = H(1)H(2)\cdots H(k),
  !>     \f]
  !> 
  !>     and if q <= k, Q is defined as the product
  !> 
  !>     \f[
  !>         Q = H(1)H(2)\cdots H(q-1).
  !>     \f]
  !> 
  !>     The Householder matrices \f$H(i)\f$ are never stored, they are computed from its corresponding
  !>     Householder vectors and scalars as returned by \ref rocsolver_sgebrd "GEBRD" in its arguments A and tauq or taup.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     storev      #rocblas_storev.
  !>                 Specifies whether to work column-wise or row-wise.
  !>     @param[in]
  !>     side        rocblas_side.
  !>                 Specifies from which side to apply Q.
  !>     @param[in]
  !>     trans       rocblas_operation.
  !>                 Specifies whether the matrix Q or its transpose is to be applied.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 Number of rows of matrix C.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of columns of matrix C.
  !>     @param[in]
  !>     k           rocblas_int. k >= 0.
  !>                 The number of columns (if storev is column-wise) or rows (if row-wise) of the
  !>                 original matrix reduced by \ref rocsolver_sgebrd "GEBRD".
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU of size ldamin(q,k) if column-wise, or ldaq if row-wise.
  !>                 The Householder vectors as returned by \ref rocsolver_sgebrd "GEBRD".
  !>     @param[in]
  !>     lda         rocblas_int. lda >= q if column-wise, or lda >= min(q,k) if row-wise.
  !>                 Leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension at least min(q,k).
  !>                 The Householder scalars as returned by \ref rocsolver_sgebrd "GEBRD".
  !>     @param[inout]
  !>     C           pointer to type. Array on the GPU of size ldcn.
  !>                 On entry, the matrix C. On exit, it is overwritten with
  !>                 QC, CQ, Q'C, or CQ'.
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= m.
  !>                 Leading dimension of C.
  !>     
  interface rocsolver_sormbr
    function rocsolver_sormbr_(handle,storev,side,trans,m,n,k,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_sormbr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sormbr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_column_wise)),value :: storev
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sormbr_full_rank,&
      
rocsolver_sormbr_rank_0,&
      
rocsolver_sormbr_rank_1
#endif

  end interface
  
  interface rocsolver_dormbr
    function rocsolver_dormbr_(handle,storev,side,trans,m,n,k,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_dormbr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dormbr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_column_wise)),value :: storev
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dormbr_full_rank,&
      
rocsolver_dormbr_rank_0,&
      
rocsolver_dormbr_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief UNMBR multiplies a complex matrix Q with orthonormal rows or columns by
  !>     a general m-by-n matrix C.
  !> 
  !>     \details
  !>     If storev is column-wise, then the matrix Q has orthonormal columns.
  !>     If storev is row-wise, then the matrix Q has orthonormal rows.
  !>     The matrix Q is applied in one of the following forms, depending on
  !>     the values of side and trans:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         QC & \: \text{No transpose from the left,}\\
  !>         Q^HC & \: \text{Conjugate transpose from the left,}\\
  !>         CQ & \: \text{No transpose from the right, and}\\
  !>         CQ^H & \: \text{Conjugate transpose from the right.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     The order q of the unitary matrix Q is q = m if applying from the left, or q = n if applying from the right.
  !> 
  !>     When storev is column-wise, if q >= k, then Q is defined as the product of k Householder reflectors
  !> 
  !>     \f[
  !>         Q = H(1)H(2)\cdots H(k),
  !>     \f]
  !> 
  !>     and if q < k, then Q is defined as the product
  !> 
  !>     \f[
  !>         Q = H(1)H(2)\cdots H(q-1).
  !>     \f]
  !> 
  !>     When storev is row-wise, if q > k, then Q is defined as the product of k Householder reflectors
  !> 
  !>     \f[
  !>         Q = H(1)H(2)\cdots H(k),
  !>     \f]
  !> 
  !>     and if q <= k, Q is defined as the product
  !> 
  !>     \f[
  !>         Q = H(1)H(2)\cdots H(q-1).
  !>     \f]
  !> 
  !>     The Householder matrices \f$H(i)\f$ are never stored, they are computed from its corresponding
  !>     Householder vectors and scalars as returned by \ref rocsolver_sgebrd "GEBRD" in its arguments A and tauq or taup.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     storev      #rocblas_storev.
  !>                 Specifies whether to work column-wise or row-wise.
  !>     @param[in]
  !>     side        rocblas_side.
  !>                 Specifies from which side to apply Q.
  !>     @param[in]
  !>     trans       rocblas_operation.
  !>                 Specifies whether the matrix Q or its conjugate transpose is to be applied.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 Number of rows of matrix C.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of columns of matrix C.
  !>     @param[in]
  !>     k           rocblas_int. k >= 0.
  !>                 The number of columns (if storev is column-wise) or rows (if row-wise) of the
  !>                 original matrix reduced by \ref rocsolver_sgebrd "GEBRD".
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU of size ldamin(q,k) if column-wise, or ldaq if row-wise.
  !>                 The Householder vectors as returned by \ref rocsolver_sgebrd "GEBRD".
  !>     @param[in]
  !>     lda         rocblas_int. lda >= q if column-wise, or lda >= min(q,k) if row-wise.
  !>                 Leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension at least min(q,k).
  !>                 The Householder scalars as returned by \ref rocsolver_sgebrd "GEBRD".
  !>     @param[inout]
  !>     C           pointer to type. Array on the GPU of size ldcn.
  !>                 On entry, the matrix C. On exit, it is overwritten with
  !>                 QC, CQ, Q'C, or CQ'.
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= m.
  !>                 Leading dimension of C.
  !>     
  interface rocsolver_cunmbr
    function rocsolver_cunmbr_(handle,storev,side,trans,m,n,k,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_cunmbr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunmbr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_column_wise)),value :: storev
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cunmbr_full_rank,&
      
rocsolver_cunmbr_rank_0,&
      
rocsolver_cunmbr_rank_1
#endif

  end interface
  
  interface rocsolver_zunmbr
    function rocsolver_zunmbr_(handle,storev,side,trans,m,n,k,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_zunmbr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunmbr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_column_wise)),value :: storev
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zunmbr_full_rank,&
      
rocsolver_zunmbr_rank_0,&
      
rocsolver_zunmbr_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief ORMTR multiplies an orthogonal matrix Q by a general m-by-n matrix C.
  !> 
  !>     \details
  !>     The matrix Q is applied in one of the following forms, depending on
  !>     the values of side and trans:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         QC & \: \text{No transpose from the left,}\\
  !>         Q^TC & \: \text{Transpose from the left,}\\
  !>         CQ & \: \text{No transpose from the right, and}\\
  !>         CQ^T & \: \text{Transpose from the right.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     The order q of the orthogonal matrix Q is q = m if applying from the left, or
  !>     q = n if applying from the right.
  !> 
  !>     Q is defined as a product of q-1 Householder reflectors. If
  !>     uplo indicates upper, then Q has the form
  !> 
  !>     \f[
  !>         Q = H(q-1)H(q-2)\cdots H(1).
  !>     \f]
  !> 
  !>     On the other hand, if uplo indicates lower, then Q has the form
  !> 
  !>     \f[
  !>         Q = H(1)H(2)\cdots H(q-1)
  !>     \f]
  !> 
  !>     The Householder matrices \f$H(i)\f$ are never stored, they are computed from its
  !>     corresponding Householder vectors and scalars as returned by
  !>     \ref rocsolver_ssytrd "SYTRD" in its arguments A and tau.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     side        rocblas_side.
  !>                 Specifies from which side to apply Q.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the \ref rocsolver_ssytrd "SYTRD" factorization was upper or
  !>                 lower triangular. If uplo indicates lower (or upper), then the upper (or
  !>                 lower) part of A is not used.
  !>     @param[in]
  !>     trans       rocblas_operation.
  !>                 Specifies whether the matrix Q or its transpose is to be
  !>                 applied.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 Number of rows of matrix C.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of columns of matrix C.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU of size ldaq.
  !>                 On entry, the Householder vectors as
  !>                 returned by \ref rocsolver_ssytrd "SYTRD".
  !>     @param[in]
  !>     lda         rocblas_int. lda >= q.
  !>                 Leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension at least q-1.
  !>                 The Householder scalars as returned by
  !>                 \ref rocsolver_ssytrd "SYTRD".
  !>     @param[inout]
  !>     C           pointer to type. Array on the GPU of size ldcn.
  !>                 On entry, the matrix C. On exit, it is overwritten with
  !>                 QC, CQ, Q'C, or CQ'.
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= m.
  !>                 Leading dimension of C.
  !>     
  interface rocsolver_sormtr
    function rocsolver_sormtr_(handle,side,uplo,trans,m,n,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_sormtr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sormtr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sormtr_full_rank,&
      
rocsolver_sormtr_rank_0,&
      
rocsolver_sormtr_rank_1
#endif

  end interface
  
  interface rocsolver_dormtr
    function rocsolver_dormtr_(handle,side,uplo,trans,m,n,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_dormtr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dormtr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dormtr_full_rank,&
      
rocsolver_dormtr_rank_0,&
      
rocsolver_dormtr_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief UNMTR multiplies a unitary matrix Q by a general m-by-n matrix C.
  !> 
  !>     \details
  !>     The matrix Q is applied in one of the following forms, depending on
  !>     the values of side and trans:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         QC & \: \text{No transpose from the left,}\\
  !>         Q^HC & \: \text{Conjugate transpose from the left,}\\
  !>         CQ & \: \text{No transpose from the right, and}\\
  !>         CQ^H & \: \text{Conjugate transpose from the right.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     The order q of the unitary matrix Q is q = m if applying from the left, or
  !>     q = n if applying from the right.
  !> 
  !>     Q is defined as a product of q-1 Householder reflectors. If
  !>     uplo indicates upper, then Q has the form
  !> 
  !>     \f[
  !>         Q = H(q-1)H(q-2)\cdots H(1).
  !>     \f]
  !> 
  !>     On the other hand, if uplo indicates lower, then Q has the form
  !> 
  !>     \f[
  !>         Q = H(1)H(2)\cdots H(q-1)
  !>     \f]
  !> 
  !>     The Householder matrices \f$H(i)\f$ are never stored, they are computed from its
  !>     corresponding Householder vectors and scalars as returned by
  !>     \ref rocsolver_chetrd "HETRD" in its arguments A and tau.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     side        rocblas_side.
  !>                 Specifies from which side to apply Q.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the \ref rocsolver_chetrd "HETRD" factorization was upper or
  !>                 lower triangular. If uplo indicates lower (or upper), then the upper (or
  !>                 lower) part of A is not used.
  !>     @param[in]
  !>     trans       rocblas_operation.
  !>                 Specifies whether the matrix Q or its conjugate
  !>                 transpose is to be applied.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 Number of rows of matrix C.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of columns of matrix C.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU of size ldaq.
  !>                 On entry, the Householder vectors as
  !>                 returned by \ref rocsolver_chetrd "HETRD".
  !>     @param[in]
  !>     lda         rocblas_int. lda >= q.
  !>                 Leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to type. Array on the GPU of dimension at least q-1.
  !>                 The Householder scalars as returned by
  !>                 \ref rocsolver_chetrd "HETRD".
  !>     @param[inout]
  !>     C           pointer to type. Array on the GPU of size ldcn.
  !>                 On entry, the matrix C. On exit, it is overwritten with
  !>                 QC, CQ, Q'C, or CQ'.
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= m.
  !>                 Leading dimension of C.
  !>     
  interface rocsolver_cunmtr
    function rocsolver_cunmtr_(handle,side,uplo,trans,m,n,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_cunmtr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunmtr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cunmtr_full_rank,&
      
rocsolver_cunmtr_rank_0,&
      
rocsolver_cunmtr_rank_1
#endif

  end interface
  
  interface rocsolver_zunmtr
    function rocsolver_zunmtr_(handle,side,uplo,trans,m,n,A,lda,ipiv,C,ldc) bind(c, name="rocsolver_zunmtr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunmtr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_side_left)),value :: side
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zunmtr_full_rank,&
      
rocsolver_zunmtr_rank_0,&
      
rocsolver_zunmtr_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BDSQR computes the singular value decomposition (SVD) of an
  !>     n-by-n bidiagonal matrix B, using the implicit QR algorithm.
  !> 
  !>     \details
  !>     The SVD of B has the form:
  !> 
  !>     \f[
  !>         B = QSP'
  !>     \f]
  !> 
  !>     where S is the n-by-n diagonal matrix of singular values of B, the columns of Q are the left
  !>     singular vectors of B, and the columns of P are its right singular vectors.
  !> 
  !>     The computation of the singular vectors is optional; this function accepts input matrices
  !>     U (of size nu-by-n) and V (of size n-by-nv) that are overwritten with \f$UQ\f$ and \f$P'V\f$. If nu = 0
  !>     no left vectors are computed; if nv = 0 no right vectors are computed.
  !> 
  !>     Optionally, this function can also compute \f$Q'C\f$ for a given n-by-nc input matrix C.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether B is upper or lower bidiagonal.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of matrix B.
  !>     @param[in]
  !>     nv          rocblas_int. nv >= 0.
  !>                 The number of columns of matrix V.
  !>     @param[in]
  !>     nu          rocblas_int. nu >= 0.
  !>                 The number of rows of matrix U.
  !>     @param[in]
  !>     nc          rocblas_int. nu >= 0.
  !>                 The number of columns of matrix C.
  !>     @param[inout]
  !>     D           pointer to real type. Array on the GPU of dimension n.
  !>                 On entry, the diagonal elements of B. On exit, if info = 0,
  !>                 the singular values of B in decreasing order; if info > 0,
  !>                 the diagonal elements of a bidiagonal matrix
  !>                 orthogonally equivalent to B.
  !>     @param[inout]
  !>     E           pointer to real type. Array on the GPU of dimension n-1.
  !>                 On entry, the off-diagonal elements of B. On exit, if info > 0,
  !>                 the off-diagonal elements of a bidiagonal matrix
  !>                 orthogonally equivalent to B (if info = 0 this matrix converges to zero).
  !>     @param[inout]
  !>     V           pointer to type. Array on the GPU of dimension ldvnv.
  !>                 On entry, the matrix V. On exit, it is overwritten with P'V.
  !>                 (Not referenced if nv = 0).
  !>     @param[in]
  !>     ldv         rocblas_int. ldv >= n if nv > 0, or ldv >=1 if nv = 0.
  !>                 The leading dimension of V.
  !>     @param[inout]
  !>     U           pointer to type. Array on the GPU of dimension ldun.
  !>                 On entry, the matrix U. On exit, it is overwritten with UQ.
  !>                 (Not referenced if nu = 0).
  !>     @param[in]
  !>     ldu         rocblas_int. ldu >= nu.
  !>                 The leading dimension of U.
  !>     @param[inout]
  !>     C           pointer to type. Array on the GPU of dimension ldcnc.
  !>                 On entry, the matrix C. On exit, it is overwritten with Q'C.
  !>                 (Not referenced if nc = 0).
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= n if nc > 0, or ldc >=1 if nc = 0.
  !>                 The leading dimension of C.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0, i elements of E have not converged to zero.
  !>     
  interface rocsolver_sbdsqr
    function rocsolver_sbdsqr_(handle,uplo,n,nv,nu,nc,D,E,V,ldv,U,ldu,C,ldc,myInfo) bind(c, name="rocsolver_sbdsqr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sbdsqr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nv
      integer(c_int),value :: nu
      integer(c_int),value :: nc
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sbdsqr_full_rank,&
      
rocsolver_sbdsqr_rank_0,&
      
rocsolver_sbdsqr_rank_1
#endif

  end interface
  
  interface rocsolver_dbdsqr
    function rocsolver_dbdsqr_(handle,uplo,n,nv,nu,nc,D,E,V,ldv,U,ldu,C,ldc,myInfo) bind(c, name="rocsolver_dbdsqr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dbdsqr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nv
      integer(c_int),value :: nu
      integer(c_int),value :: nc
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dbdsqr_full_rank,&
      
rocsolver_dbdsqr_rank_0,&
      
rocsolver_dbdsqr_rank_1
#endif

  end interface
  
  interface rocsolver_cbdsqr
    function rocsolver_cbdsqr_(handle,uplo,n,nv,nu,nc,D,E,V,ldv,U,ldu,C,ldc,myInfo) bind(c, name="rocsolver_cbdsqr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cbdsqr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nv
      integer(c_int),value :: nu
      integer(c_int),value :: nc
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cbdsqr_full_rank,&
      
rocsolver_cbdsqr_rank_0,&
      
rocsolver_cbdsqr_rank_1
#endif

  end interface
  
  interface rocsolver_zbdsqr
    function rocsolver_zbdsqr_(handle,uplo,n,nv,nu,nc,D,E,V,ldv,U,ldu,C,ldc,myInfo) bind(c, name="rocsolver_zbdsqr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zbdsqr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nv
      integer(c_int),value :: nu
      integer(c_int),value :: nc
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zbdsqr_full_rank,&
      
rocsolver_zbdsqr_rank_0,&
      
rocsolver_zbdsqr_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief STERF computes the eigenvalues of a symmetric tridiagonal matrix.
  !> 
  !>     \details
  !>     The eigenvalues of the symmetric tridiagonal matrix are computed by the
  !>     Pal-Walker-Kahan variant of the QLQR algorithm, and returned in
  !>     increasing order.
  !> 
  !>     The matrix is not represented explicitly, but rather as the array of
  !>     diagonal elements D and the array of symmetric off-diagonal elements E.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of the tridiagonal matrix.
  !>     @param[inout]
  !>     D           pointer to real type. Array on the GPU of dimension n.
  !>                 On entry, the diagonal elements of the tridiagonal matrix.
  !>                 On exit, if info = 0, the eigenvalues in increasing order.
  !>                 If info > 0, the diagonal elements of a tridiagonal matrix
  !>                 that is similar to the original matrix (i.e. has the same
  !>                 eigenvalues).
  !>     @param[inout]
  !>     E           pointer to real type. Array on the GPU of dimension n-1.
  !>                 On entry, the off-diagonal elements of the tridiagonal matrix.
  !>                 On exit, if info = 0, this array converges to zero.
  !>                 If info > 0, the off-diagonal elements of a tridiagonal matrix
  !>                 that is similar to the original matrix (i.e. has the same
  !>                 eigenvalues).
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0, STERF did not converge. i elements of E did not
  !>                 converge to zero.
  !>     
  interface rocsolver_ssterf
    function rocsolver_ssterf_(handle,n,D,E,myInfo) bind(c, name="rocsolver_ssterf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssterf_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssterf_rank_0,&
      
rocsolver_ssterf_rank_1
#endif

  end interface
  
  interface rocsolver_dsterf
    function rocsolver_dsterf_(handle,n,D,E,myInfo) bind(c, name="rocsolver_dsterf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsterf_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsterf_rank_0,&
      
rocsolver_dsterf_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief STEQR computes the eigenvalues and (optionally) eigenvectors of
  !>     a symmetric tridiagonal matrix.
  !> 
  !>     \details
  !>     The eigenvalues of the symmetric tridiagonal matrix are computed by the
  !>     implicit QLQR algorithm, and returned in increasing order.
  !> 
  !>     The matrix is not represented explicitly, but rather as the array of
  !>     diagonal elements D and the array of symmetric off-diagonal elements E.
  !>     When D and E correspond to the tridiagonal form of a full symmetricHermitian matrix, as returned by, e.g.,
  !>     \ref rocsolver_ssytrd "SYTRD" or \ref rocsolver_chetrd "HETRD", the eigenvectors of the original matrix can also
  !>     be computed, depending on the value of evect.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies how the eigenvectors are computed.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of the tridiagonal matrix.
  !>     @param[inout]
  !>     D           pointer to real type. Array on the GPU of dimension n.
  !>                 On entry, the diagonal elements of the tridiagonal matrix.
  !>                 On exit, if info = 0, the eigenvalues in increasing order.
  !>                 If info > 0, the diagonal elements of a tridiagonal matrix
  !>                 that is similar to the original matrix (i.e. has the same
  !>                 eigenvalues).
  !>     @param[inout]
  !>     E           pointer to real type. Array on the GPU of dimension n-1.
  !>                 On entry, the off-diagonal elements of the tridiagonal matrix.
  !>                 On exit, if info = 0, this array converges to zero.
  !>                 If info > 0, the off-diagonal elements of a tridiagonal matrix
  !>                 that is similar to the original matrix (i.e. has the same
  !>                 eigenvalues).
  !>     @param[inout]
  !>     C           pointer to type. Array on the GPU of dimension ldcn.
  !>                 On entry, if evect is original, the orthogonalunitary matrix
  !>                 used for the reduction to tridiagonal form as returned by, e.g.,
  !>                 \ref rocsolver_sorgtr "ORGTR" or \ref rocsolver_cungtr "UNGTR".
  !>                 On exit, it is overwritten with the eigenvectors of the original
  !>                 symmetricHermitian matrix (if evect is original), or the
  !>                 eigenvectors of the tridiagonal matrix (if evect is tridiagonal).
  !>                 (Not referenced if evect is none).
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= n if evect is original or tridiagonal.
  !>                 Specifies the leading dimension of C.
  !>                 (Not referenced if evect is none).
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0, STEQR did not converge. i elements of E did not
  !>                 converge to zero.
  !>     
  interface rocsolver_ssteqr
    function rocsolver_ssteqr_(handle,evect,n,D,E,C,ldc,myInfo) bind(c, name="rocsolver_ssteqr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssteqr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(c_int),value :: n
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssteqr_full_rank,&
      
rocsolver_ssteqr_rank_0,&
      
rocsolver_ssteqr_rank_1
#endif

  end interface
  
  interface rocsolver_dsteqr
    function rocsolver_dsteqr_(handle,evect,n,D,E,C,ldc,myInfo) bind(c, name="rocsolver_dsteqr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsteqr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(c_int),value :: n
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsteqr_full_rank,&
      
rocsolver_dsteqr_rank_0,&
      
rocsolver_dsteqr_rank_1
#endif

  end interface
  
  interface rocsolver_csteqr
    function rocsolver_csteqr_(handle,evect,n,D,E,C,ldc,myInfo) bind(c, name="rocsolver_csteqr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_csteqr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(c_int),value :: n
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_csteqr_full_rank,&
      
rocsolver_csteqr_rank_0,&
      
rocsolver_csteqr_rank_1
#endif

  end interface
  
  interface rocsolver_zsteqr
    function rocsolver_zsteqr_(handle,evect,n,D,E,C,ldc,myInfo) bind(c, name="rocsolver_zsteqr")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zsteqr_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(c_int),value :: n
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zsteqr_full_rank,&
      
rocsolver_zsteqr_rank_0,&
      
rocsolver_zsteqr_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief STEDC computes the eigenvalues and (optionally) eigenvectors of
  !>     a symmetric tridiagonal matrix.
  !> 
  !>     \details
  !>     This function uses the divide and conquer method to compute the eigenvectors.
  !>     The eigenvalues are returned in increasing order.
  !> 
  !>     The matrix is not represented explicitly, but rather as the array of
  !>     diagonal elements D and the array of symmetric off-diagonal elements E.
  !>     When D and E correspond to the tridiagonal form of a full symmetricHermitian matrix, as returned by, e.g.,
  !>     \ref rocsolver_ssytrd "SYTRD" or \ref rocsolver_chetrd "HETRD", the eigenvectors of the original matrix can also
  !>     be computed, depending on the value of evect.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies how the eigenvectors are computed.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of the tridiagonal matrix.
  !>     @param[inout]
  !>     D           pointer to real type. Array on the GPU of dimension n.
  !>                 On entry, the diagonal elements of the tridiagonal matrix.
  !>                 On exit, if info = 0, the eigenvalues in increasing order.
  !>     @param[inout]
  !>     E           pointer to real type. Array on the GPU of dimension n-1.
  !>                 On entry, the off-diagonal elements of the tridiagonal matrix.
  !>                 On exit, if info = 0, the values of this array are destroyed.
  !>     @param[inout]
  !>     C           pointer to type. Array on the GPU of dimension ldcn.
  !>                 On entry, if evect is original, the orthogonalunitary matrix
  !>                 used for the reduction to tridiagonal form as returned by, e.g.,
  !>                 \ref rocsolver_sorgtr "ORGTR" or \ref rocsolver_cungtr "UNGTR".
  !>                 On exit, if info = 0, it is overwritten with the eigenvectors of the original
  !>                 symmetricHermitian matrix (if evect is original), or the
  !>                 eigenvectors of the tridiagonal matrix (if evect is tridiagonal).
  !>                 (Not referenced if evect is none).
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= n if evect is original or tridiagonal.
  !>                 Specifies the leading dimension of C. (Not referenced if evect is none).
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0, STEDC failed to compute an eigenvalue on the sub-matrix formed by
  !>                 the rows and columns info(n+1) through mod(info,n+1).
  !>     
  interface rocsolver_sstedc
    function rocsolver_sstedc_(handle,evect,n,D,E,C,ldc,myInfo) bind(c, name="rocsolver_sstedc")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sstedc_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(c_int),value :: n
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sstedc_full_rank,&
      
rocsolver_sstedc_rank_0,&
      
rocsolver_sstedc_rank_1
#endif

  end interface
  
  interface rocsolver_dstedc
    function rocsolver_dstedc_(handle,evect,n,D,E,C,ldc,myInfo) bind(c, name="rocsolver_dstedc")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dstedc_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(c_int),value :: n
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dstedc_full_rank,&
      
rocsolver_dstedc_rank_0,&
      
rocsolver_dstedc_rank_1
#endif

  end interface
  
  interface rocsolver_cstedc
    function rocsolver_cstedc_(handle,evect,n,D,E,C,ldc,myInfo) bind(c, name="rocsolver_cstedc")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cstedc_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(c_int),value :: n
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cstedc_full_rank,&
      
rocsolver_cstedc_rank_0,&
      
rocsolver_cstedc_rank_1
#endif

  end interface
  
  interface rocsolver_zstedc
    function rocsolver_zstedc_(handle,evect,n,D,E,C,ldc,myInfo) bind(c, name="rocsolver_zstedc")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zstedc_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(c_int),value :: n
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zstedc_full_rank,&
      
rocsolver_zstedc_rank_0,&
      
rocsolver_zstedc_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief STEBZ computes a set of eigenvalues of a symmetric tridiagonal matrix T.
  !> 
  !>     \details
  !>     This function computes all the eigenvalues of T, all the eigenvalues in the half-open interval (vl, vu],
  !>     or the il-th through iu-th eigenvalues, depending on the value of erange.
  !> 
  !>     The eigenvalues are returned in increasing order either for the entire matrix, or grouped by independent
  !>     diagonal blocks (if they exist), depending on the value of eorder.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     erange      #rocblas_erange.
  !>                 Specifies the type of range or interval of the eigenvalues to be computed.
  !>     @param[in]
  !>     eorder      #rocblas_eorder.
  !>                 Specifies whether the computed eigenvalues will be ordered by their position in the
  !>                 entire spectrum, or grouped by independent diagonal (split off) blocks.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The order of the tridiagonal matrix T.
  !>     @param[in]
  !>     vl          real type. vl < vu.
  !>                 The lower bound of the search interval (vl, vu]. Ignored if erange indicates to look
  !>                 for all the eigenvalues of T or the eigenvalues within a set of indices.
  !>     @param[in]
  !>     vu          real type. vl < vu.
  !>                 The upper bound of the search interval (vl, vu]. Ignored if erange indicates to look
  !>                 for all the eigenvalues of T or the eigenvalues within a set of indices.
  !>     @param[in]
  !>     il          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.
  !>                 The index of the smallest eigenvalue to be computed. Ignored if erange indicates to look
  !>                 for all the eigenvalues of T or the eigenvalues in a half-open interval.
  !>     @param[in]
  !>     iu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise.
  !>                 The index of the largest eigenvalue to be computed. Ignored if erange indicates to look
  !>                 for all the eigenvalues of T or the eigenvalues in a half-open interval.
  !>     @param[in]
  !>     abstol      real type.
  !>                 The absolute tolerance. An eigenvalue is considered to be located if it lies
  !>                 in an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times
  !>                 the 1-norm of the tridiagonal form of A will be used as tolerance. If abstol=0, then the tolerance will be set
  !>                 to twice the underflow threshold; this is the tolerance that could get the most accurate results.
  !>     @param[in]
  !>     D           pointer to real type. Array on the GPU of dimension n.
  !>                 The diagonal elements of the tridiagonal matrix.
  !>     @param[in]
  !>     E           pointer to real type. Array on the GPU of dimension n-1.
  !>                 The off-diagonal elements of the tridiagonal matrix.
  !>     @param[out]
  !>     nev         pointer to a rocblas_int on the GPU.
  !>                 The total number of eigenvalues found.
  !>     @param[out]
  !>     nsplit      pointer to a rocblas_int on the GPU.
  !>                 The number of split off blocks in the matrix.
  !>     @param[out]
  !>     W           pointer to real type. Array on the GPU of dimension n.
  !>                 The first nev elements contain the computed eigenvalues. (The remaining elements
  !>                 can be used as workspace for internal computations).
  !>     @param[out]
  !>     iblock      pointer to rocblas_int. Array on the GPU of dimension n.
  !>                 The block indices corresponding to each eigenvalue. When matrix T has
  !>                 split off blocks (nsplit > 1), then if iblock[i] = k, the
  !>                 eigenvalue W[i] belongs to the k-th diagonal block from the top.
  !>     @param[out]
  !>     isplit      pointer to rocblas_int. Array on the GPU of dimension n.
  !>                 The splitting indices that divide the tridiagonal matrix into
  !>                 diagonal blocks. The k-th block stretches from the end of the (k-1)-th
  !>                 block (or the top left corner of the tridiagonal matrix,
  !>                 in the case of the 1st block) to the isplit[k]-th rowcolumn.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = 1, the bisection did not converge for some eigenvalues, i.e. the returned
  !>                 values are not as accurate as the given tolerance. The non-converged eigenvalues
  !>                 are flagged by negative entries in iblock.
  !> 
  !>     
  interface rocsolver_sstebz
    function rocsolver_sstebz_(handle,erange,eorder,n,vl,vu,il,iu,abstol,D,E,nev,nsplit,W,iblock,isplit,myInfo) bind(c, name="rocsolver_sstebz")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sstebz_
      type(c_ptr),value :: handle
      integer(kind(rocblas_erange_all)),value :: erange
      integer(kind(rocblas_eorder_blocks)),value :: eorder
      integer(c_int),value :: n
      real(c_float),value :: vl
      real(c_float),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      real(c_float),value :: abstol
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: nev
      type(c_ptr),value :: nsplit
      type(c_ptr),value :: W
      type(c_ptr),value :: iblock
      type(c_ptr),value :: isplit
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sstebz_rank_0,&
      
rocsolver_sstebz_rank_1
#endif

  end interface
  
  interface rocsolver_dstebz
    function rocsolver_dstebz_(handle,erange,eorder,n,vl,vu,il,iu,abstol,D,E,nev,nsplit,W,iblock,isplit,myInfo) bind(c, name="rocsolver_dstebz")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dstebz_
      type(c_ptr),value :: handle
      integer(kind(rocblas_erange_all)),value :: erange
      integer(kind(rocblas_eorder_blocks)),value :: eorder
      integer(c_int),value :: n
      real(c_double),value :: vl
      real(c_double),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      real(c_double),value :: abstol
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: nev
      type(c_ptr),value :: nsplit
      type(c_ptr),value :: W
      type(c_ptr),value :: iblock
      type(c_ptr),value :: isplit
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dstebz_rank_0,&
      
rocsolver_dstebz_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief STEIN computes the eigenvectors associated with a set of
  !>     provided eigenvalues of a symmetric tridiagonal matrix.
  !> 
  !>     \details
  !>     The eigenvectors of the symmetric tridiagonal matrix are computed using
  !>     inverse iteration.
  !> 
  !>     The matrix is not represented explicitly, but rather as the array of
  !>     diagonal elements D and the array of symmetric off-diagonal elements E.
  !>     The eigenvalues must be provided in the array W, as returned by \ref rocsolver_sstebz "STEBZ".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of the tridiagonal matrix.
  !>     @param[in]
  !>     D           pointer to real type. Array on the GPU of dimension n.
  !>                 The diagonal elements of the tridiagonal matrix.
  !>     @param[in]
  !>     E           pointer to real type. Array on the GPU of dimension n-1.
  !>                 The off-diagonal elements of the tridiagonal matrix.
  !>     @param[in]
  !>     nev         pointer to a rocblas_int on the GPU. 0 <= nev <= n.
  !>                 The number of provided eigenvalues, and the number of eigenvectors
  !>                 to be computed.
  !>     @param[in]
  !>     W           pointer to real type. Array on the GPU of dimension >= nev.
  !>                 A subset of nev eigenvalues of the tridiagonal matrix, as returned
  !>                 by \ref rocsolver_sstebz "STEBZ".
  !>     @param[in]
  !>     iblock      pointer to rocblas_int. Array on the GPU of dimension n.
  !>                 The block indices corresponding to each eigenvalue, as
  !>                 returned by \ref rocsolver_sstebz "STEBZ". If iblock[i] = k,
  !>                 then eigenvalue W[i] belongs to the k-th block from the top.
  !>     @param[in]
  !>     isplit      pointer to rocblas_int. Array on the GPU of dimension n.
  !>                 The splitting indices that divide the tridiagonal matrix into
  !>                 diagonal blocks, as returned by \ref rocsolver_sstebz "STEBZ".
  !>                 The k-th block stretches from the end of the (k-1)-th
  !>                 block (or the top left corner of the tridiagonal matrix,
  !>                 in the case of the 1st block) to the isplit[k]-th rowcolumn.
  !>     @param[out]
  !>     Z           pointer to type. Array on the GPU of dimension ldznev.
  !>                 On exit, contains the eigenvectors of the tridiagonal matrix
  !>                 corresponding to the provided eigenvalues, stored by columns.
  !>     @param[in]
  !>     ldz         rocblas_int. ldz >= n.
  !>                 Specifies the leading dimension of Z.
  !>     @param[out]
  !>     ifail       pointer to rocblas_int. Array on the GPU of dimension n.
  !>                 If info = 0, the first nev elements of ifail are zero.
  !>                 Otherwise, contains the indices of those eigenvectors that failed
  !>                 to converge.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0, i eigenvectors did not converge; their indices are stored in
  !>                 IFAIL.
  !> 
  !>     
  interface rocsolver_sstein
    function rocsolver_sstein_(handle,n,D,E,nev,W,iblock,isplit,Z,ldz,ifail,myInfo) bind(c, name="rocsolver_sstein")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sstein_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: nev
      type(c_ptr),value :: W
      type(c_ptr),value :: iblock
      type(c_ptr),value :: isplit
      type(c_ptr),value :: Z
      integer(c_int),value :: ldz
      type(c_ptr),value :: ifail
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sstein_rank_0,&
      
rocsolver_sstein_rank_1
#endif

  end interface
  
  interface rocsolver_dstein
    function rocsolver_dstein_(handle,n,D,E,nev,W,iblock,isplit,Z,ldz,ifail,myInfo) bind(c, name="rocsolver_dstein")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dstein_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: nev
      type(c_ptr),value :: W
      type(c_ptr),value :: iblock
      type(c_ptr),value :: isplit
      type(c_ptr),value :: Z
      integer(c_int),value :: ldz
      type(c_ptr),value :: ifail
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dstein_rank_0,&
      
rocsolver_dstein_rank_1
#endif

  end interface
  
  interface rocsolver_cstein
    function rocsolver_cstein_(handle,n,D,E,nev,W,iblock,isplit,Z,ldz,ifail,myInfo) bind(c, name="rocsolver_cstein")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cstein_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: nev
      type(c_ptr),value :: W
      type(c_ptr),value :: iblock
      type(c_ptr),value :: isplit
      type(c_ptr),value :: Z
      integer(c_int),value :: ldz
      type(c_ptr),value :: ifail
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cstein_rank_0,&
      
rocsolver_cstein_rank_1
#endif

  end interface
  
  interface rocsolver_zstein
    function rocsolver_zstein_(handle,n,D,E,nev,W,iblock,isplit,Z,ldz,ifail,myInfo) bind(c, name="rocsolver_zstein")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zstein_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: nev
      type(c_ptr),value :: W
      type(c_ptr),value :: iblock
      type(c_ptr),value :: isplit
      type(c_ptr),value :: Z
      integer(c_int),value :: ldz
      type(c_ptr),value :: ifail
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zstein_rank_0,&
      
rocsolver_zstein_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BDSVDX computes a set of singular values of a bidiagonal matrix B.
  !> 
  !>     \details
  !>     This function computes all the singular values of B, all the singular values in the half-open interval
  !>     \f$[vl, vu)\f$, or the il-th through iu-th singular values, depending on the value of srange.
  !> 
  !>     Depending on the value of svect, the corresponding singular vectors will be computed and stored as blocks
  !>     in the output matrix Z. That is,
  !> 
  !>     \f[
  !>         Z = \left[\begin{array}{c}
  !>         U\\
  !>         V
  !>         \end{array}\right]
  !>     \f]
  !> 
  !>     where U contains the corresponding left singular vectors of B, and V contains the corresponding right
  !>     singular vectors.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether B is upper or lower bidiagonal.
  !>     @param[in]
  !>     svect       #rocblas_svect.
  !>                 Specifies how the singular vectors are computed. Only rocblas_svect_none and
  !>                 rocblas_svect_singular are accepted.
  !>     @param[in]
  !>     srange      #rocblas_srange.
  !>                 Specifies the type of range or interval of the singular values to be computed.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The order of the bidiagonal matrix B.
  !>     @param[in]
  !>     D           pointer to real type. Array on the GPU of dimension n.
  !>                 The diagonal elements of the bidiagonal matrix.
  !>     @param[in]
  !>     E           pointer to real type. Array on the GPU of dimension n-1.
  !>                 The off-diagonal elements of the bidiagonal matrix.
  !>     @param[in]
  !>     vl          real type. 0 <= vl < vu.
  !>                 The lower bound of the search interval [vl, vu). Ignored if srange indicates to look
  !>                 for all the singular values of B or the singular values within a set of indices.
  !>     @param[in]
  !>     vu          real type. 0 <= vl < vu.
  !>                 The upper bound of the search interval [vl, vu). Ignored if srange indicates to look
  !>                 for all the singular values of B or the singular values within a set of indices.
  !>     @param[in]
  !>     il          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.
  !>                 The index of the largest singular value to be computed. Ignored if srange indicates to look
  !>                 for all the singular values of B or the singular values in a half-open interval.
  !>     @param[in]
  !>     iu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise.
  !>                 The index of the smallest singular value to be computed. Ignored if srange indicates to look
  !>                 for all the singular values of B or the singular values in a half-open interval.
  !>     @param[out]
  !>     nsv         pointer to a rocblas_int on the GPU.
  !>                 The total number of singular values found. If srange is rocblas_srange_all, nsv = n.
  !>                 If srange is rocblas_srange_index, nsv = iu - il + 1. Otherwise, 0 <= nsv <= n.
  !>     @param[out]
  !>     S           pointer to real type. Array on the GPU of dimension nsv.
  !>                 The first nsv elements contain the computed singular values in descending order.
  !>                 Note: If srange is rocblas_srange_value, then the value of nsv is not known in advance.
  !>                 In this case, the user should ensure that S is large enough to hold n values.
  !>     @param[out]
  !>     Z           pointer to real type. Array on the GPU of dimension ldznsv.
  !>                 If info = 0, the first nsv columns contain the computed singular vectors corresponding to the
  !>                 singular values in S. The first n rows of Z contain the matrix U, and the next n rows contain
  !>                 the matrix V. Not referenced if svect is rocblas_svect_none.
  !>                 Note: If srange is rocblas_srange_value, then the value of nsv is not known in advance.
  !>                 In this case, the user should ensure that Z is large enough to hold n columns.
  !>     @param[in]
  !>     ldz         rocblas_int. ldz >= 2n if svect is rocblas_svect_singular; ldz >= 1 otherwise.
  !>                 Specifies the leading dimension of Z.
  !>     @param[out]
  !>     ifail       pointer to rocblas_int. Array on the GPU of dimension n.
  !>                 If info = 0, the first nsv elements of ifail are zero.
  !>                 Otherwise, contains the indices of those eigenvectors that failed
  !>                 to converge, as returned by \ref rocsolver_sstein "STEIN".
  !>                 Not referenced if svect is rocblas_svect_none.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0, i eigenvectors did not converge in \ref rocsolver_sstein "STEIN"; their
  !>                 indices are stored in ifail.
  !> 
  !>     
  interface rocsolver_sbdsvdx
    function rocsolver_sbdsvdx_(handle,uplo,svect,srange,n,D,E,vl,vu,il,iu,nsv,S,Z,ldz,ifail,myInfo) bind(c, name="rocsolver_sbdsvdx")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sbdsvdx_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_svect_all)),value :: svect
      integer(kind(rocblas_srange_all)),value :: srange
      integer(c_int),value :: n
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      real(c_float),value :: vl
      real(c_float),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      type(c_ptr),value :: nsv
      type(c_ptr),value :: S
      type(c_ptr),value :: Z
      integer(c_int),value :: ldz
      type(c_ptr),value :: ifail
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sbdsvdx_rank_0,&
      
rocsolver_sbdsvdx_rank_1
#endif

  end interface
  
  interface rocsolver_dbdsvdx
    function rocsolver_dbdsvdx_(handle,uplo,svect,srange,n,D,E,vl,vu,il,iu,nsv,S,Z,ldz,ifail,myInfo) bind(c, name="rocsolver_dbdsvdx")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dbdsvdx_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_svect_all)),value :: svect
      integer(kind(rocblas_srange_all)),value :: srange
      integer(c_int),value :: n
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      real(c_double),value :: vl
      real(c_double),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      type(c_ptr),value :: nsv
      type(c_ptr),value :: S
      type(c_ptr),value :: Z
      integer(c_int),value :: ldz
      type(c_ptr),value :: ifail
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dbdsvdx_rank_0,&
      
rocsolver_dbdsvdx_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GETF2_NPVT computes the LU factorization of a general m-by-n matrix A
  !>     without partial pivoting.
  !> 
  !>     \details
  !>     (This is the unblocked Level-2-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls
  !>     could be executed with small and mid-size matrices if optimizations are enabled (default option). For more details, see the
  !>     "Tuning rocSOLVER performance" section of the Library Design Guide).
  !> 
  !>     The factorization has the form
  !> 
  !>     \f[
  !>         A = LU
  !>     \f]
  !> 
  !>     where L is lower triangular with unit
  !>     diagonal elements (lower trapezoidal if m > n), and U is upper
  !>     triangular (upper trapezoidal if m < n).
  !> 
  !>     \note
  !>     Although this routine can offer better performance, Gaussian elimination without pivoting is not backward stable.
  !>     If numerical accuracy is compromised, use the legacy-LAPACK API \ref rocsolver_sgetf2 "GETF2" routines instead.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of the matrix A.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of the matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrix A to be factored.
  !>                 On exit, the factors L and U from the factorization.
  !>                 The unit diagonal elements of L are not stored.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0, U is singular. U[i,i] is the first zero element in the diagonal. The factorization from
  !>                 this point might be incomplete.
  !>     
  interface rocsolver_sgetf2_npvt
    function rocsolver_sgetf2_npvt_(handle,m,n,A,lda,myInfo) bind(c, name="rocsolver_sgetf2_npvt")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetf2_npvt_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgetf2_npvt_full_rank,&
      
rocsolver_sgetf2_npvt_rank_0,&
      
rocsolver_sgetf2_npvt_rank_1
#endif

  end interface
  
  interface rocsolver_dgetf2_npvt
    function rocsolver_dgetf2_npvt_(handle,m,n,A,lda,myInfo) bind(c, name="rocsolver_dgetf2_npvt")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetf2_npvt_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgetf2_npvt_full_rank,&
      
rocsolver_dgetf2_npvt_rank_0,&
      
rocsolver_dgetf2_npvt_rank_1
#endif

  end interface
  
  interface rocsolver_cgetf2_npvt
    function rocsolver_cgetf2_npvt_(handle,m,n,A,lda,myInfo) bind(c, name="rocsolver_cgetf2_npvt")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetf2_npvt_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgetf2_npvt_full_rank,&
      
rocsolver_cgetf2_npvt_rank_0,&
      
rocsolver_cgetf2_npvt_rank_1
#endif

  end interface
  
  interface rocsolver_zgetf2_npvt
    function rocsolver_zgetf2_npvt_(handle,m,n,A,lda,myInfo) bind(c, name="rocsolver_zgetf2_npvt")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetf2_npvt_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgetf2_npvt_full_rank,&
      
rocsolver_zgetf2_npvt_rank_0,&
      
rocsolver_zgetf2_npvt_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GETF2_NPVT_BATCHED computes the LU factorization of a batch of
  !>     general m-by-n matrices without partial pivoting.
  !> 
  !>     \details
  !>     (This is the unblocked Level-2-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls
  !>     could be executed with small and mid-size matrices if optimizations are enabled (default option). For more details, see the
  !>     "Tuning rocSOLVER performance" section of the Library Design Guide).
  !> 
  !>     The factorization of matrix \f$A_l\f$ in the batch has the form
  !> 
  !>     \f[
  !>         A_l = L_lU_l
  !>     \f]
  !> 
  !>     where \f$L_l\f$ is lower triangular with unit
  !>     diagonal elements (lower trapezoidal if m > n), and \f$U_l\f$ is upper
  !>     triangular (upper trapezoidal if m < n).
  !> 
  !>     \note
  !>     Although this routine can offer better performance, Gaussian elimination without pivoting is not backward stable.
  !>     If numerical accuracy is compromised, use the legacy-LAPACK API \ref rocsolver_sgetf2_batched "GETF2_BATCHED" routines instead.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all matrices A_l in the batch.
  !>     @param[in,out]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrices A_l to be factored.
  !>                 On exit, the factors L_l and U_l from the factorizations.
  !>                 The unit diagonal elements of L_l are not stored.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for factorization of A_l.
  !>                 If info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero element in the diagonal. The factorization from
  !>                 this point might be incomplete.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgetf2_npvt_batched
    function rocsolver_sgetf2_npvt_batched_(handle,m,n,A,lda,myInfo,batch_count) bind(c, name="rocsolver_sgetf2_npvt_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetf2_npvt_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgetf2_npvt_batched_full_rank,&
      
rocsolver_sgetf2_npvt_batched_rank_0,&
      
rocsolver_sgetf2_npvt_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgetf2_npvt_batched
    function rocsolver_dgetf2_npvt_batched_(handle,m,n,A,lda,myInfo,batch_count) bind(c, name="rocsolver_dgetf2_npvt_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetf2_npvt_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgetf2_npvt_batched_full_rank,&
      
rocsolver_dgetf2_npvt_batched_rank_0,&
      
rocsolver_dgetf2_npvt_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgetf2_npvt_batched
    function rocsolver_cgetf2_npvt_batched_(handle,m,n,A,lda,myInfo,batch_count) bind(c, name="rocsolver_cgetf2_npvt_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetf2_npvt_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgetf2_npvt_batched_full_rank,&
      
rocsolver_cgetf2_npvt_batched_rank_0,&
      
rocsolver_cgetf2_npvt_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgetf2_npvt_batched
    function rocsolver_zgetf2_npvt_batched_(handle,m,n,A,lda,myInfo,batch_count) bind(c, name="rocsolver_zgetf2_npvt_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetf2_npvt_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgetf2_npvt_batched_full_rank,&
      
rocsolver_zgetf2_npvt_batched_rank_0,&
      
rocsolver_zgetf2_npvt_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GETF2_NPVT_STRIDED_BATCHED computes the LU factorization of a batch
  !>     of general m-by-n matrices without partial pivoting.
  !> 
  !>     \details
  !>     (This is the unblocked Level-2-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls
  !>     could be executed with small and mid-size matrices if optimizations are enabled (default option). For more details, see the
  !>     "Tuning rocSOLVER performance" section of the Library Design Guide).
  !> 
  !>     The factorization of matrix \f$A_l\f$ in the batch has the form
  !> 
  !>     \f[
  !>         A_l = L_lU_l
  !>     \f]
  !> 
  !>     where \f$L_l\f$ is lower triangular with unit
  !>     diagonal elements (lower trapezoidal if m > n), and \f$U_l\f$ is upper
  !>     triangular (upper trapezoidal if m < n).
  !> 
  !>     \note
  !>     Although this routine can offer better performance, Gaussian elimination without pivoting is not backward stable.
  !>     If numerical accuracy is compromised, use the legacy-LAPACK-like API \ref rocsolver_sgetf2_strided_batched "GETF2_STRIDED_BATCHED" routines instead.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all matrices A_l in the batch.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the m-by-n matrices A_l to be factored.
  !>                 On exit, the factors L_l and U_l from the factorization.
  !>                 The unit diagonal elements of L_l are not stored.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for factorization of A_l.
  !>                 If info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero element in the diagonal. The factorization from
  !>                 this point might be incomplete.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgetf2_npvt_strided_batched
    function rocsolver_sgetf2_npvt_strided_batched_(handle,m,n,A,lda,strideA,myInfo,batch_count) bind(c, name="rocsolver_sgetf2_npvt_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetf2_npvt_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgetf2_npvt_strided_batched_full_rank,&
      
rocsolver_sgetf2_npvt_strided_batched_rank_0,&
      
rocsolver_sgetf2_npvt_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgetf2_npvt_strided_batched
    function rocsolver_dgetf2_npvt_strided_batched_(handle,m,n,A,lda,strideA,myInfo,batch_count) bind(c, name="rocsolver_dgetf2_npvt_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetf2_npvt_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgetf2_npvt_strided_batched_full_rank,&
      
rocsolver_dgetf2_npvt_strided_batched_rank_0,&
      
rocsolver_dgetf2_npvt_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgetf2_npvt_strided_batched
    function rocsolver_cgetf2_npvt_strided_batched_(handle,m,n,A,lda,strideA,myInfo,batch_count) bind(c, name="rocsolver_cgetf2_npvt_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetf2_npvt_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgetf2_npvt_strided_batched_full_rank,&
      
rocsolver_cgetf2_npvt_strided_batched_rank_0,&
      
rocsolver_cgetf2_npvt_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgetf2_npvt_strided_batched
    function rocsolver_zgetf2_npvt_strided_batched_(handle,m,n,A,lda,strideA,myInfo,batch_count) bind(c, name="rocsolver_zgetf2_npvt_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetf2_npvt_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgetf2_npvt_strided_batched_full_rank,&
      
rocsolver_zgetf2_npvt_strided_batched_rank_0,&
      
rocsolver_zgetf2_npvt_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GETRF_NPVT computes the LU factorization of a general m-by-n matrix A
  !>     without partial pivoting.
  !> 
  !>     \details
  !>     (This is the blocked Level-3-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls
  !>     could be executed with mid-size matrices if optimizations are enabled (default option). For more details, see the
  !>     "Tuning rocSOLVER performance" section of the Library Design Guide).
  !> 
  !>     The factorization has the form
  !> 
  !>     \f[
  !>         A = LU
  !>     \f]
  !> 
  !>     where L is lower triangular with unit
  !>     diagonal elements (lower trapezoidal if m > n), and U is upper
  !>     triangular (upper trapezoidal if m < n).
  !> 
  !>     Note: Although this routine can offer better performance, Gaussian elimination without pivoting is not backward stable.
  !>     If numerical accuracy is compromised, use the legacy-LAPACK-like API \ref rocsolver_sgetrf "GETRF" routines instead.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of the matrix A.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of the matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrix A to be factored.
  !>                 On exit, the factors L and U from the factorization.
  !>                 The unit diagonal elements of L are not stored.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0, U is singular. U[i,i] is the first zero element in the diagonal. The factorization from
  !>                 this point might be incomplete.
  !>     
  interface rocsolver_sgetrf_npvt
    function rocsolver_sgetrf_npvt_(handle,m,n,A,lda,myInfo) bind(c, name="rocsolver_sgetrf_npvt")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrf_npvt_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgetrf_npvt_full_rank,&
      
rocsolver_sgetrf_npvt_rank_0,&
      
rocsolver_sgetrf_npvt_rank_1
#endif

  end interface
  
  interface rocsolver_dgetrf_npvt
    function rocsolver_dgetrf_npvt_(handle,m,n,A,lda,myInfo) bind(c, name="rocsolver_dgetrf_npvt")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrf_npvt_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgetrf_npvt_full_rank,&
      
rocsolver_dgetrf_npvt_rank_0,&
      
rocsolver_dgetrf_npvt_rank_1
#endif

  end interface
  
  interface rocsolver_cgetrf_npvt
    function rocsolver_cgetrf_npvt_(handle,m,n,A,lda,myInfo) bind(c, name="rocsolver_cgetrf_npvt")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrf_npvt_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgetrf_npvt_full_rank,&
      
rocsolver_cgetrf_npvt_rank_0,&
      
rocsolver_cgetrf_npvt_rank_1
#endif

  end interface
  
  interface rocsolver_zgetrf_npvt
    function rocsolver_zgetrf_npvt_(handle,m,n,A,lda,myInfo) bind(c, name="rocsolver_zgetrf_npvt")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrf_npvt_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgetrf_npvt_full_rank,&
      
rocsolver_zgetrf_npvt_rank_0,&
      
rocsolver_zgetrf_npvt_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GETRF_NPVT_BATCHED computes the LU factorization of a batch of
  !>     general m-by-n matrices without partial pivoting.
  !> 
  !>     \details
  !>     (This is the blocked Level-3-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls
  !>     could be executed with mid-size matrices if optimizations are enabled (default option). For more details, see the
  !>     "Tuning rocSOLVER performance" section of the Library Design Guide).
  !> 
  !>     The factorization of matrix \f$A_l\f$ in the batch has the form
  !> 
  !>     \f[
  !>         A_l = L_lU_l
  !>     \f]
  !> 
  !>     where \f$L_l\f$ is lower triangular with unit
  !>     diagonal elements (lower trapezoidal if m > n), and \f$U_l\f$ is upper
  !>     triangular (upper trapezoidal if m < n).
  !> 
  !>     Note: Although this routine can offer better performance, Gaussian elimination without pivoting is not backward stable.
  !>     If numerical accuracy is compromised, use the legacy-LAPACK-like API \ref rocsolver_sgetrf_batched "GETRF_BATCHED" routines instead.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all matrices A_l in the batch.
  !>     @param[inout]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrices A_l to be factored.
  !>                 On exit, the factors L_l and U_l from the factorizations.
  !>                 The unit diagonal elements of L_l are not stored.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for factorization of A_l.
  !>                 If info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero element in the diagonal. The factorization from
  !>                 this point might be incomplete.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !> 
  !>     
  interface rocsolver_sgetrf_npvt_batched
    function rocsolver_sgetrf_npvt_batched_(handle,m,n,A,lda,myInfo,batch_count) bind(c, name="rocsolver_sgetrf_npvt_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrf_npvt_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgetrf_npvt_batched_full_rank,&
      
rocsolver_sgetrf_npvt_batched_rank_0,&
      
rocsolver_sgetrf_npvt_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgetrf_npvt_batched
    function rocsolver_dgetrf_npvt_batched_(handle,m,n,A,lda,myInfo,batch_count) bind(c, name="rocsolver_dgetrf_npvt_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrf_npvt_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgetrf_npvt_batched_full_rank,&
      
rocsolver_dgetrf_npvt_batched_rank_0,&
      
rocsolver_dgetrf_npvt_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgetrf_npvt_batched
    function rocsolver_cgetrf_npvt_batched_(handle,m,n,A,lda,myInfo,batch_count) bind(c, name="rocsolver_cgetrf_npvt_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrf_npvt_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgetrf_npvt_batched_full_rank,&
      
rocsolver_cgetrf_npvt_batched_rank_0,&
      
rocsolver_cgetrf_npvt_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgetrf_npvt_batched
    function rocsolver_zgetrf_npvt_batched_(handle,m,n,A,lda,myInfo,batch_count) bind(c, name="rocsolver_zgetrf_npvt_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrf_npvt_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgetrf_npvt_batched_full_rank,&
      
rocsolver_zgetrf_npvt_batched_rank_0,&
      
rocsolver_zgetrf_npvt_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GETRF_NPVT_STRIDED_BATCHED computes the LU factorization of a batch
  !>     of general m-by-n matrices without partial pivoting.
  !> 
  !>     \details
  !>     (This is the blocked Level-3-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls
  !>     could be executed with mid-size matrices if optimizations are enabled (default option). For more details, see the
  !>     "Tuning rocSOLVER performance" section of the Library Design Guide).
  !> 
  !>     The factorization of matrix \f$A_l\f$ in the batch has the form
  !> 
  !>     \f[
  !>         A_l = L_lU_l
  !>     \f]
  !> 
  !>     where \f$L_l\f$ is lower triangular with unit
  !>     diagonal elements (lower trapezoidal if m > n), and \f$U_l\f$ is upper
  !>     triangular (upper trapezoidal if m < n).
  !> 
  !>     Note: Although this routine can offer better performance, Gaussian elimination without pivoting is not backward stable.
  !>     If numerical accuracy is compromised, use the legacy-LAPACK-like API \ref rocsolver_sgetrf_strided_batched "GETRF_STRIDED_BATCHED" routines instead.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all matrices A_l in the batch.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the m-by-n matrices A_l to be factored.
  !>                 On exit, the factors L_l and U_l from the factorization.
  !>                 The unit diagonal elements of L_l are not stored.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for factorization of A_l.
  !>                 If info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero element in the diagonal. The factorization from
  !>                 this point might be incomplete.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !> 
  !>     
  interface rocsolver_sgetrf_npvt_strided_batched
    function rocsolver_sgetrf_npvt_strided_batched_(handle,m,n,A,lda,strideA,myInfo,batch_count) bind(c, name="rocsolver_sgetrf_npvt_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrf_npvt_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgetrf_npvt_strided_batched_full_rank,&
      
rocsolver_sgetrf_npvt_strided_batched_rank_0,&
      
rocsolver_sgetrf_npvt_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgetrf_npvt_strided_batched
    function rocsolver_dgetrf_npvt_strided_batched_(handle,m,n,A,lda,strideA,myInfo,batch_count) bind(c, name="rocsolver_dgetrf_npvt_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrf_npvt_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgetrf_npvt_strided_batched_full_rank,&
      
rocsolver_dgetrf_npvt_strided_batched_rank_0,&
      
rocsolver_dgetrf_npvt_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgetrf_npvt_strided_batched
    function rocsolver_cgetrf_npvt_strided_batched_(handle,m,n,A,lda,strideA,myInfo,batch_count) bind(c, name="rocsolver_cgetrf_npvt_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrf_npvt_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgetrf_npvt_strided_batched_full_rank,&
      
rocsolver_cgetrf_npvt_strided_batched_rank_0,&
      
rocsolver_cgetrf_npvt_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgetrf_npvt_strided_batched
    function rocsolver_zgetrf_npvt_strided_batched_(handle,m,n,A,lda,strideA,myInfo,batch_count) bind(c, name="rocsolver_zgetrf_npvt_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrf_npvt_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgetrf_npvt_strided_batched_full_rank,&
      
rocsolver_zgetrf_npvt_strided_batched_rank_0,&
      
rocsolver_zgetrf_npvt_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GETF2 computes the LU factorization of a general m-by-n matrix A
  !>     using partial pivoting with row interchanges.
  !> 
  !>     \details
  !>     (This is the unblocked Level-2-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls
  !>     could be executed with small and mid-size matrices if optimizations are enabled (default option). For more details, see the
  !>     "Tuning rocSOLVER performance" section of the Library Design Guide).
  !> 
  !>     The factorization has the form
  !> 
  !>     \f[
  !>         A = PLU
  !>     \f]
  !> 
  !>     where P is a permutation matrix, L is lower triangular with unit
  !>     diagonal elements (lower trapezoidal if m > n), and U is upper
  !>     triangular (upper trapezoidal if m < n).
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of the matrix A.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of the matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrix A to be factored.
  !>                 On exit, the factors L and U from the factorization.
  !>                 The unit diagonal elements of L are not stored.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     ipiv        pointer to rocblas_int. Array on the GPU of dimension min(m,n).
  !>                 The vector of pivot indices. Elements of ipiv are 1-based indices.
  !>                 For 1 <= i <= min(m,n), the row i of the
  !>                 matrix was interchanged with row ipiv[i].
  !>                 Matrix P of the factorization can be derived from ipiv.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0, U is singular. U[i,i] is the first zero pivot.
  !>     
  interface rocsolver_sgetf2
    function rocsolver_sgetf2_(handle,m,n,A,lda,ipiv,myInfo) bind(c, name="rocsolver_sgetf2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetf2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgetf2_full_rank,&
      
rocsolver_sgetf2_rank_0,&
      
rocsolver_sgetf2_rank_1
#endif

  end interface
  
  interface rocsolver_dgetf2
    function rocsolver_dgetf2_(handle,m,n,A,lda,ipiv,myInfo) bind(c, name="rocsolver_dgetf2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetf2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgetf2_full_rank,&
      
rocsolver_dgetf2_rank_0,&
      
rocsolver_dgetf2_rank_1
#endif

  end interface
  
  interface rocsolver_cgetf2
    function rocsolver_cgetf2_(handle,m,n,A,lda,ipiv,myInfo) bind(c, name="rocsolver_cgetf2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetf2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgetf2_full_rank,&
      
rocsolver_cgetf2_rank_0,&
      
rocsolver_cgetf2_rank_1
#endif

  end interface
  
  interface rocsolver_zgetf2
    function rocsolver_zgetf2_(handle,m,n,A,lda,ipiv,myInfo) bind(c, name="rocsolver_zgetf2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetf2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgetf2_full_rank,&
      
rocsolver_zgetf2_rank_0,&
      
rocsolver_zgetf2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GETF2_BATCHED computes the LU factorization of a batch of general
  !>     m-by-n matrices using partial pivoting with row interchanges.
  !> 
  !>     \details
  !>     (This is the unblocked Level-2-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls
  !>     could be executed with small and mid-size matrices if optimizations are enabled (default option). For more details, see the
  !>     "Tuning rocSOLVER performance" section of the Library Design Guide).
  !> 
  !>     The factorization of matrix \f$A_l\f$ in the batch has the form
  !> 
  !>     \f[
  !>         A_l = P_lL_lU_l
  !>     \f]
  !> 
  !>     where \f$P_l\f$ is a permutation matrix, \f$L_l\f$ is lower triangular with unit
  !>     diagonal elements (lower trapezoidal if m > n), and \f$U_l\f$ is upper
  !>     triangular (upper trapezoidal if m < n).
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all matrices A_l in the batch.
  !>     @param[inout]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrices A_l to be factored.
  !>                 On exit, the factors L_l and U_l from the factorizations.
  !>                 The unit diagonal elements of L_l are not stored.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[out]
  !>     ipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors of pivot indices ipiv_l (corresponding to A_l).
  !>                 Dimension of ipiv_l is min(m,n).
  !>                 Elements of ipiv_l are 1-based indices.
  !>                 For each instance A_l in the batch and for 1 <= i <= min(m,n), the row i of the
  !>                 matrix A_l was interchanged with row ipiv_l[i].
  !>                 Matrix P_l of the factorization can be derived from ipiv_l.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value of strideP. Normal use case is strideP >= min(m,n).
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for factorization of A_l.
  !>                 If info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgetf2_batched
    function rocsolver_sgetf2_batched_(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_sgetf2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetf2_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgetf2_batched_full_rank,&
      
rocsolver_sgetf2_batched_rank_0,&
      
rocsolver_sgetf2_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgetf2_batched
    function rocsolver_dgetf2_batched_(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_dgetf2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetf2_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgetf2_batched_full_rank,&
      
rocsolver_dgetf2_batched_rank_0,&
      
rocsolver_dgetf2_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgetf2_batched
    function rocsolver_cgetf2_batched_(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_cgetf2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetf2_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgetf2_batched_full_rank,&
      
rocsolver_cgetf2_batched_rank_0,&
      
rocsolver_cgetf2_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgetf2_batched
    function rocsolver_zgetf2_batched_(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_zgetf2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetf2_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgetf2_batched_full_rank,&
      
rocsolver_zgetf2_batched_rank_0,&
      
rocsolver_zgetf2_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GETF2_STRIDED_BATCHED computes the LU factorization of a batch of
  !>     general m-by-n matrices using partial pivoting with row interchanges.
  !> 
  !>     \details
  !>     (This is the unblocked Level-2-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls
  !>     could be executed with small and mid-size matrices if optimizations are enabled (default option). For more details, see the
  !>     "Tuning rocSOLVER performance" section of the Library Design Guide).
  !> 
  !>     The factorization of matrix \f$A_l\f$ in the batch has the form
  !> 
  !>     \f[
  !>         A_l = P_lL_lU_l
  !>     \f]
  !> 
  !>     where \f$P_l\f$ is a permutation matrix, \f$L_l\f$ is lower triangular with unit
  !>     diagonal elements (lower trapezoidal if m > n), and \f$U_l\f$ is upper
  !>     triangular (upper trapezoidal if m < n).
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all matrices A_l in the batch.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the m-by-n matrices A_l to be factored.
  !>                 On exit, the factors L_l and U_l from the factorization.
  !>                 The unit diagonal elements of L_l are not stored.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan
  !>     @param[out]
  !>     ipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors of pivots indices ipiv_l (corresponding to A_l).
  !>                 Dimension of ipiv_l is min(m,n).
  !>                 Elements of ipiv_l are 1-based indices.
  !>                 For each instance A_l in the batch and for 1 <= i <= min(m,n), the row i of the
  !>                 matrix A_l was interchanged with row ipiv_l[i].
  !>                 Matrix P_l of the factorization can be derived from ipiv_l.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value of strideP. Normal use case is strideP >= min(m,n).
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for factorization of A_l.
  !>                 If info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgetf2_strided_batched
    function rocsolver_sgetf2_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_sgetf2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetf2_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgetf2_strided_batched_full_rank,&
      
rocsolver_sgetf2_strided_batched_rank_0,&
      
rocsolver_sgetf2_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgetf2_strided_batched
    function rocsolver_dgetf2_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_dgetf2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetf2_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgetf2_strided_batched_full_rank,&
      
rocsolver_dgetf2_strided_batched_rank_0,&
      
rocsolver_dgetf2_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgetf2_strided_batched
    function rocsolver_cgetf2_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_cgetf2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetf2_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgetf2_strided_batched_full_rank,&
      
rocsolver_cgetf2_strided_batched_rank_0,&
      
rocsolver_cgetf2_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgetf2_strided_batched
    function rocsolver_zgetf2_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_zgetf2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetf2_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgetf2_strided_batched_full_rank,&
      
rocsolver_zgetf2_strided_batched_rank_0,&
      
rocsolver_zgetf2_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GETRF computes the LU factorization of a general m-by-n matrix A
  !>     using partial pivoting with row interchanges.
  !> 
  !>     \details
  !>     (This is the blocked Level-3-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls
  !>     could be executed with mid-size matrices if optimizations are enabled (default option). For more details, see the
  !>     "Tuning rocSOLVER performance" section of the Library Design Guide).
  !> 
  !>     The factorization has the form
  !> 
  !>     \f[
  !>         A = PLU
  !>     \f]
  !> 
  !>     where P is a permutation matrix, L is lower triangular with unit
  !>     diagonal elements (lower trapezoidal if m > n), and U is upper
  !>     triangular (upper trapezoidal if m < n).
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of the matrix A.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of the matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrix A to be factored.
  !>                 On exit, the factors L and U from the factorization.
  !>                 The unit diagonal elements of L are not stored.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     ipiv        pointer to rocblas_int. Array on the GPU of dimension min(m,n).
  !>                 The vector of pivot indices. Elements of ipiv are 1-based indices.
  !>                 For 1 <= i <= min(m,n), the row i of the
  !>                 matrix was interchanged with row ipiv[i].
  !>                 Matrix P of the factorization can be derived from ipiv.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0, U is singular. U[i,i] is the first zero pivot.
  !>     
  interface rocsolver_sgetrf
    function rocsolver_sgetrf_(handle,m,n,A,lda,ipiv,myInfo) bind(c, name="rocsolver_sgetrf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrf_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgetrf_full_rank,&
      
rocsolver_sgetrf_rank_0,&
      
rocsolver_sgetrf_rank_1
#endif

  end interface
  
  interface rocsolver_dgetrf
    function rocsolver_dgetrf_(handle,m,n,A,lda,ipiv,myInfo) bind(c, name="rocsolver_dgetrf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrf_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgetrf_full_rank,&
      
rocsolver_dgetrf_rank_0,&
      
rocsolver_dgetrf_rank_1
#endif

  end interface
  
  interface rocsolver_cgetrf
    function rocsolver_cgetrf_(handle,m,n,A,lda,ipiv,myInfo) bind(c, name="rocsolver_cgetrf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrf_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgetrf_full_rank,&
      
rocsolver_cgetrf_rank_0,&
      
rocsolver_cgetrf_rank_1
#endif

  end interface
  
  interface rocsolver_zgetrf
    function rocsolver_zgetrf_(handle,m,n,A,lda,ipiv,myInfo) bind(c, name="rocsolver_zgetrf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrf_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgetrf_full_rank,&
      
rocsolver_zgetrf_rank_0,&
      
rocsolver_zgetrf_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GETRF_BATCHED computes the LU factorization of a batch of general
  !>     m-by-n matrices using partial pivoting with row interchanges.
  !> 
  !>     \details
  !>     (This is the blocked Level-3-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls
  !>     could be executed with mid-size matrices if optimizations are enabled (default option). For more details, see the
  !>     "Tuning rocSOLVER performance" section of the Library Design Guide).
  !> 
  !>     The factorization of matrix \f$A_l\f$ in the batch has the form
  !> 
  !>     \f[
  !>         A_l = P_lL_lU_l
  !>     \f]
  !> 
  !>     where \f$P_l\f$ is a permutation matrix, \f$L_l\f$ is lower triangular with unit
  !>     diagonal elements (lower trapezoidal if m > n), and \f$U_l\f$ is upper
  !>     triangular (upper trapezoidal if m < n).
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all matrices A_l in the batch.
  !>     @param[inout]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrices A_l to be factored.
  !>                 On exit, the factors L_l and U_l from the factorizations.
  !>                 The unit diagonal elements of L_l are not stored.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[out]
  !>     ipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors of pivot indices ipiv_l (corresponding to A_l).
  !>                 Dimension of ipiv_l is min(m,n).
  !>                 Elements of ipiv_l are 1-based indices.
  !>                 For each instance A_l in the batch and for 1 <= i <= min(m,n), the row i of the
  !>                 matrix A_l was interchanged with row ipiv_l[i].
  !>                 Matrix P_l of the factorization can be derived from ipiv_l.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value of strideP. Normal use case is strideP >= min(m,n).
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for factorization of A_l.
  !>                 If info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgetrf_batched
    function rocsolver_sgetrf_batched_(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_sgetrf_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrf_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgetrf_batched_full_rank,&
      
rocsolver_sgetrf_batched_rank_0,&
      
rocsolver_sgetrf_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgetrf_batched
    function rocsolver_dgetrf_batched_(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_dgetrf_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrf_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgetrf_batched_full_rank,&
      
rocsolver_dgetrf_batched_rank_0,&
      
rocsolver_dgetrf_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgetrf_batched
    function rocsolver_cgetrf_batched_(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_cgetrf_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrf_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgetrf_batched_full_rank,&
      
rocsolver_cgetrf_batched_rank_0,&
      
rocsolver_cgetrf_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgetrf_batched
    function rocsolver_zgetrf_batched_(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_zgetrf_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrf_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgetrf_batched_full_rank,&
      
rocsolver_zgetrf_batched_rank_0,&
      
rocsolver_zgetrf_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GETRF_STRIDED_BATCHED computes the LU factorization of a batch of
  !>     general m-by-n matrices using partial pivoting with row interchanges.
  !> 
  !>     \details
  !>     (This is the blocked Level-3-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls
  !>     could be executed with mid-size matrices if optimizations are enabled (default option). For more details, see the
  !>     "Tuning rocSOLVER performance" section of the Library Design Guide).
  !> 
  !>     The factorization of matrix \f$A_l\f$ in the batch has the form
  !> 
  !>     \f[
  !>         A_l = P_lL_lU_l
  !>     \f]
  !> 
  !>     where \f$P_l\f$ is a permutation matrix, \f$L_l\f$ is lower triangular with unit
  !>     diagonal elements (lower trapezoidal if m > n), and \f$U_l\f$ is upper
  !>     triangular (upper trapezoidal if m < n).
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all matrices A_l in the batch.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the m-by-n matrices A_l to be factored.
  !>                 On exit, the factors L_l and U_l from the factorization.
  !>                 The unit diagonal elements of L_l are not stored.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan
  !>     @param[out]
  !>     ipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors of pivots indices ipiv_l (corresponding to A_l).
  !>                 Dimension of ipiv_l is min(m,n).
  !>                 Elements of ipiv_l are 1-based indices.
  !>                 For each instance A_l in the batch and for 1 <= i <= min(m,n), the row i of the
  !>                 matrix A_l was interchanged with row ipiv_l[i].
  !>                 Matrix P_l of the factorization can be derived from ipiv_l.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value of strideP. Normal use case is strideP >= min(m,n).
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for factorization of A_l.
  !>                 If info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgetrf_strided_batched
    function rocsolver_sgetrf_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_sgetrf_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrf_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgetrf_strided_batched_full_rank,&
      
rocsolver_sgetrf_strided_batched_rank_0,&
      
rocsolver_sgetrf_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgetrf_strided_batched
    function rocsolver_dgetrf_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_dgetrf_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrf_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgetrf_strided_batched_full_rank,&
      
rocsolver_dgetrf_strided_batched_rank_0,&
      
rocsolver_dgetrf_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgetrf_strided_batched
    function rocsolver_cgetrf_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_cgetrf_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrf_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgetrf_strided_batched_full_rank,&
      
rocsolver_cgetrf_strided_batched_rank_0,&
      
rocsolver_cgetrf_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgetrf_strided_batched
    function rocsolver_zgetrf_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_zgetrf_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrf_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgetrf_strided_batched_full_rank,&
      
rocsolver_zgetrf_strided_batched_rank_0,&
      
rocsolver_zgetrf_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GEQR2 computes a QR factorization of a general m-by-n matrix A.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The factorization has the form
  !> 
  !>     \f[
  !>         A = Q\left[\begin{array}{c}
  !>         R\\
  !>         0
  !>         \end{array}\right]
  !>     \f]
  !> 
  !>     where R is upper triangular (upper trapezoidal if m < n), and Q is
  !>     a m-by-m orthogonalunitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q = H(1)H(2)\cdots H(k), \quad \text{with} \: k = \text{min}(m,n)
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H(i)\f$ is given by
  !> 
  !>     \f[
  !>         H(i) = I - \text{ipiv}[i] \cdot v_i^{} v_i'
  !>     \f]
  !> 
  !>     where the first i-1 elements of the Householder vector \f$v_i\f$ are zero, and \f$v_i[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of the matrix A.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of the matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrix to be factored.
  !>                 On exit, the elements on and above the diagonal contain the
  !>                 factor R; the elements below the diagonal are the last m - i elements
  !>                 of Householder vector v_i.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     ipiv        pointer to type. Array on the GPU of dimension min(m,n).
  !>                 The Householder scalars.
  !>     
  interface rocsolver_sgeqr2
    function rocsolver_sgeqr2_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_sgeqr2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqr2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgeqr2_full_rank,&
      
rocsolver_sgeqr2_rank_0,&
      
rocsolver_sgeqr2_rank_1
#endif

  end interface
  
  interface rocsolver_dgeqr2
    function rocsolver_dgeqr2_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_dgeqr2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqr2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgeqr2_full_rank,&
      
rocsolver_dgeqr2_rank_0,&
      
rocsolver_dgeqr2_rank_1
#endif

  end interface
  
  interface rocsolver_cgeqr2
    function rocsolver_cgeqr2_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_cgeqr2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqr2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgeqr2_full_rank,&
      
rocsolver_cgeqr2_rank_0,&
      
rocsolver_cgeqr2_rank_1
#endif

  end interface
  
  interface rocsolver_zgeqr2
    function rocsolver_zgeqr2_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_zgeqr2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqr2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgeqr2_full_rank,&
      
rocsolver_zgeqr2_rank_0,&
      
rocsolver_zgeqr2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GEQR2_BATCHED computes the QR factorization of a batch of general
  !>     m-by-n matrices.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The factorization of matrix \f$A_l\f$ in the batch has the form
  !> 
  !>     \f[
  !>         A_l = Q_l\left[\begin{array}{c}
  !>         R_l\\
  !>         0
  !>         \end{array}\right]
  !>     \f]
  !> 
  !>     where \f$R_l\f$ is upper triangular (upper trapezoidal if m < n), and \f$Q_l\f$ is
  !>     a m-by-m orthogonalunitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q_l = H_l(1)H_l(2)\cdots H_l(k), \quad \text{with} \: k = \text{min}(m,n)
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H_l(i)\f$ is given by
  !> 
  !>     \f[
  !>         H_l^{}(i) = I - \text{ipiv}_l^{}[i] \cdot v_{l_i}^{} v_{l_i}'
  !>     \f]
  !> 
  !>     where the first i-1 elements of Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all the matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all the matrices A_l in the batch.
  !>     @param[inout]
  !>     A           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrices A_l to be factored.
  !>                 On exit, the elements on and above the diagonal contain the
  !>                 factor R_l. The elements below the diagonal are the last m - i elements
  !>                 of Householder vector v_(l_i).
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[out]
  !>     ipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors ipiv_l of corresponding Householder scalars.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideP. Normal use is strideP >= min(m,n).
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgeqr2_batched
    function rocsolver_sgeqr2_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_sgeqr2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqr2_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgeqr2_batched_full_rank,&
      
rocsolver_sgeqr2_batched_rank_0,&
      
rocsolver_sgeqr2_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgeqr2_batched
    function rocsolver_dgeqr2_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_dgeqr2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqr2_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgeqr2_batched_full_rank,&
      
rocsolver_dgeqr2_batched_rank_0,&
      
rocsolver_dgeqr2_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgeqr2_batched
    function rocsolver_cgeqr2_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_cgeqr2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqr2_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgeqr2_batched_full_rank,&
      
rocsolver_cgeqr2_batched_rank_0,&
      
rocsolver_cgeqr2_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgeqr2_batched
    function rocsolver_zgeqr2_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_zgeqr2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqr2_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgeqr2_batched_full_rank,&
      
rocsolver_zgeqr2_batched_rank_0,&
      
rocsolver_zgeqr2_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GEQR2_STRIDED_BATCHED computes the QR factorization of a batch of
  !>     general m-by-n matrices.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The factorization of matrix \f$A_l\f$ in the batch has the form
  !> 
  !>     \f[
  !>         A_l = Q_l\left[\begin{array}{c}
  !>         R_l\\
  !>         0
  !>         \end{array}\right]
  !>     \f]
  !> 
  !>     where \f$R_l\f$ is upper triangular (upper trapezoidal if m < n), and \f$Q_l\f$ is
  !>     a m-by-m orthogonalunitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q_l = H_l(1)H_l(2)\cdots H_l(k), \quad \text{with} \: k = \text{min}(m,n)
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H_l(i)\f$ is given by
  !> 
  !>     \f[
  !>         H_l^{}(i) = I - \text{ipiv}_l^{}[i] \cdot v_{l_i}^{} v_{l_i}'
  !>     \f]
  !> 
  !>     where the first i-1 elements of Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all the matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all the matrices A_l in the batch.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the m-by-n matrices A_l to be factored.
  !>                 On exit, the elements on and above the diagonal contain the
  !>                 factor R_l. The elements below the diagonal are the last m - i elements
  !>                 of Householder vector v_(l_i).
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     ipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors ipiv_l of corresponding Householder scalars.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideP. Normal use is strideP >= min(m,n).
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgeqr2_strided_batched
    function rocsolver_sgeqr2_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_sgeqr2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqr2_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgeqr2_strided_batched_full_rank,&
      
rocsolver_sgeqr2_strided_batched_rank_0,&
      
rocsolver_sgeqr2_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgeqr2_strided_batched
    function rocsolver_dgeqr2_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_dgeqr2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqr2_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgeqr2_strided_batched_full_rank,&
      
rocsolver_dgeqr2_strided_batched_rank_0,&
      
rocsolver_dgeqr2_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgeqr2_strided_batched
    function rocsolver_cgeqr2_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_cgeqr2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqr2_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgeqr2_strided_batched_full_rank,&
      
rocsolver_cgeqr2_strided_batched_rank_0,&
      
rocsolver_cgeqr2_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgeqr2_strided_batched
    function rocsolver_zgeqr2_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_zgeqr2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqr2_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgeqr2_strided_batched_full_rank,&
      
rocsolver_zgeqr2_strided_batched_rank_0,&
      
rocsolver_zgeqr2_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GERQ2 computes a RQ factorization of a general m-by-n matrix A.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The factorization has the form
  !> 
  !>     \f[
  !>         A = \left[\begin{array}{cc}
  !>         0 & R
  !>         \end{array}\right] Q
  !>     \f]
  !> 
  !>     where R is upper triangular (upper trapezoidal if m > n), and Q is
  !>     a n-by-n orthogonalunitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q = H(1)'H(2)' \cdots H(k)', \quad \text{with} \: k = \text{min}(m,n).
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H(i)\f$ is given by
  !> 
  !>     \f[
  !>         H(i) = I - \text{ipiv}[i] \cdot v_i^{} v_i'
  !>     \f]
  !> 
  !>     where the last n-i elements of the Householder vector \f$v_i\f$ are zero, and \f$v_i[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of the matrix A.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of the matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrix to be factored.
  !>                 On exit, the elements on and above the (m-n)-th subdiagonal (when
  !>                 m >= n) or the (n-m)-th superdiagonal (when n > m) contain the
  !>                 factor R; the elements below the subsuperdiagonal are the first i - 1
  !>                 elements of Householder vector v_i.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     ipiv        pointer to type. Array on the GPU of dimension min(m,n).
  !>                 The Householder scalars.
  !>     
  interface rocsolver_sgerq2
    function rocsolver_sgerq2_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_sgerq2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgerq2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgerq2_full_rank,&
      
rocsolver_sgerq2_rank_0,&
      
rocsolver_sgerq2_rank_1
#endif

  end interface
  
  interface rocsolver_dgerq2
    function rocsolver_dgerq2_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_dgerq2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgerq2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgerq2_full_rank,&
      
rocsolver_dgerq2_rank_0,&
      
rocsolver_dgerq2_rank_1
#endif

  end interface
  
  interface rocsolver_cgerq2
    function rocsolver_cgerq2_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_cgerq2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgerq2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgerq2_full_rank,&
      
rocsolver_cgerq2_rank_0,&
      
rocsolver_cgerq2_rank_1
#endif

  end interface
  
  interface rocsolver_zgerq2
    function rocsolver_zgerq2_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_zgerq2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgerq2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgerq2_full_rank,&
      
rocsolver_zgerq2_rank_0,&
      
rocsolver_zgerq2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GERQ2_BATCHED computes the RQ factorization of a batch of general
  !>     m-by-n matrices.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The factorization of matrix \f$A_l\f$ in the batch has the form
  !> 
  !>     \f[
  !>         A_l = \left[\begin{array}{cc}
  !>         0 & R_l
  !>         \end{array}\right] Q_l
  !>     \f]
  !> 
  !>     where \f$R_l\f$ is upper triangular (upper trapezoidal if m > n), and \f$Q_l\f$ is
  !>     a n-by-n orthogonalunitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q_l = H_l(1)'H_l(2)' \cdots H_l(k)', \quad \text{with} \: k = \text{min}(m,n).
  !>     \f]
  !> 
  !>     Each Householder matrices \f$H_l(i)\f$ is given by
  !> 
  !>     \f[
  !>         H_l^{}(i) = I - \text{ipiv}_l^{}[i] \cdot v_{l_i}^{} v_{l_i}'
  !>     \f]
  !> 
  !>     where the last n-i elements of Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all the matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all the matrices A_l in the batch.
  !>     @param[inout]
  !>     A           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrices A_l to be factored.
  !>                 On exit, the elements on and above the (m-n)-th subdiagonal (when
  !>                 m >= n) or the (n-m)-th superdiagonal (when n > m) contain the
  !>                 factor R_l; the elements below the subsuperdiagonal are the first i - 1
  !>                 elements of Householder vector v_(l_i).
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[out]
  !>     ipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors ipiv_l of corresponding Householder scalars.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideP. Normal use is strideP >= min(m,n).
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgerq2_batched
    function rocsolver_sgerq2_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_sgerq2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgerq2_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgerq2_batched_full_rank,&
      
rocsolver_sgerq2_batched_rank_0,&
      
rocsolver_sgerq2_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgerq2_batched
    function rocsolver_dgerq2_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_dgerq2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgerq2_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgerq2_batched_full_rank,&
      
rocsolver_dgerq2_batched_rank_0,&
      
rocsolver_dgerq2_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgerq2_batched
    function rocsolver_cgerq2_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_cgerq2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgerq2_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgerq2_batched_full_rank,&
      
rocsolver_cgerq2_batched_rank_0,&
      
rocsolver_cgerq2_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgerq2_batched
    function rocsolver_zgerq2_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_zgerq2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgerq2_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgerq2_batched_full_rank,&
      
rocsolver_zgerq2_batched_rank_0,&
      
rocsolver_zgerq2_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GERQ2_STRIDED_BATCHED computes the RQ factorization of a batch of
  !>     general m-by-n matrices.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The factorization of matrix \f$A_l\f$ in the batch has the form
  !> 
  !>     \f[
  !>         A_l = \left[\begin{array}{cc}
  !>         0 & R_l
  !>         \end{array}\right] Q_l
  !>     \f]
  !> 
  !>     where \f$R_l\f$ is upper triangular (upper trapezoidal if m > n), and \f$Q_l\f$ is
  !>     a n-by-n orthogonalunitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q_l = H_l(1)'H_l(2)' \cdots H_l(k)', \quad \text{with} \: k = \text{min}(m,n).
  !>     \f]
  !> 
  !>     Each Householder matrices \f$H_l(i)\f$ is given by
  !> 
  !>     \f[
  !>         H_l^{}(i) = I - \text{ipiv}_l^{}[i] \cdot v_{l_i}^{} v_{l_i}'
  !>     \f]
  !> 
  !>     where the last n-i elements of Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all the matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all the matrices A_l in the batch.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the m-by-n matrices A_l to be factored.
  !>                 On exit, the elements on and above the (m-n)-th subdiagonal (when
  !>                 m >= n) or the (n-m)-th superdiagonal (when n > m) contain the
  !>                 factor R_l; the elements below the subsuperdiagonal are the first i - 1
  !>                 elements of Householder vector v_(l_i).
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     ipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors ipiv_l of corresponding Householder scalars.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideP. Normal use is strideP >= min(m,n).
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgerq2_strided_batched
    function rocsolver_sgerq2_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_sgerq2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgerq2_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgerq2_strided_batched_full_rank,&
      
rocsolver_sgerq2_strided_batched_rank_0,&
      
rocsolver_sgerq2_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgerq2_strided_batched
    function rocsolver_dgerq2_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_dgerq2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgerq2_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgerq2_strided_batched_full_rank,&
      
rocsolver_dgerq2_strided_batched_rank_0,&
      
rocsolver_dgerq2_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgerq2_strided_batched
    function rocsolver_cgerq2_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_cgerq2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgerq2_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgerq2_strided_batched_full_rank,&
      
rocsolver_cgerq2_strided_batched_rank_0,&
      
rocsolver_cgerq2_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgerq2_strided_batched
    function rocsolver_zgerq2_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_zgerq2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgerq2_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgerq2_strided_batched_full_rank,&
      
rocsolver_zgerq2_strided_batched_rank_0,&
      
rocsolver_zgerq2_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GEQL2 computes a QL factorization of a general m-by-n matrix A.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The factorization has the form
  !> 
  !>     \f[
  !>         A = Q\left[\begin{array}{c}
  !>         0\\
  !>         L
  !>         \end{array}\right]
  !>     \f]
  !> 
  !>     where L is lower triangular (lower trapezoidal if m < n), and Q is
  !>     a m-by-m orthogonalunitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q = H(k)H(k-1)\cdots H(1), \quad \text{with} \: k = \text{min}(m,n)
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H(i)\f$ is given by
  !> 
  !>     \f[
  !>         H(i) = I - \text{ipiv}[i] \cdot v_i^{} v_i'
  !>     \f]
  !> 
  !>     where the last m-i elements of the Householder vector \f$v_i\f$ are zero, and \f$v_i[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of the matrix A.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of the matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrix to be factored.
  !>                 On exit, the elements on and below the (m-n)-th subdiagonal (when
  !>                 m >= n) or the (n-m)-th superdiagonal (when n > m) contain the
  !>                 factor L; the elements above the subsuperdiagonal are the first i - 1
  !>                 elements of Householder vector v_i.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     ipiv        pointer to type. Array on the GPU of dimension min(m,n).
  !>                 The Householder scalars.
  !>     
  interface rocsolver_sgeql2
    function rocsolver_sgeql2_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_sgeql2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeql2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgeql2_full_rank,&
      
rocsolver_sgeql2_rank_0,&
      
rocsolver_sgeql2_rank_1
#endif

  end interface
  
  interface rocsolver_dgeql2
    function rocsolver_dgeql2_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_dgeql2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeql2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgeql2_full_rank,&
      
rocsolver_dgeql2_rank_0,&
      
rocsolver_dgeql2_rank_1
#endif

  end interface
  
  interface rocsolver_cgeql2
    function rocsolver_cgeql2_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_cgeql2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeql2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgeql2_full_rank,&
      
rocsolver_cgeql2_rank_0,&
      
rocsolver_cgeql2_rank_1
#endif

  end interface
  
  interface rocsolver_zgeql2
    function rocsolver_zgeql2_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_zgeql2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeql2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgeql2_full_rank,&
      
rocsolver_zgeql2_rank_0,&
      
rocsolver_zgeql2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GEQL2_BATCHED computes the QL factorization of a batch of general
  !>     m-by-n matrices.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The factorization of matrix \f$A_l\f$ in the batch has the form
  !> 
  !>     \f[
  !>         A_l = Q_l\left[\begin{array}{c}
  !>         0\\
  !>         L_l
  !>         \end{array}\right]
  !>     \f]
  !> 
  !>     where \f$L_l\f$ is lower triangular (lower trapezoidal if m < n), and \f$Q_l\f$ is
  !>     a m-by-m orthogonalunitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q_l = H_l(k)H_l(k-1)\cdots H_l(1), \quad \text{with} \: k = \text{min}(m,n)
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H_l(i)\f$ is given by
  !> 
  !>     \f[
  !>         H_l^{}(i) = I - \text{ipiv}_l^{}[i] \cdot v_{l_i}^{} v_{l_i}'
  !>     \f]
  !> 
  !>     where the last m-i elements of the Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all the matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all the matrices A_l in the batch.
  !>     @param[inout]
  !>     A           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrices A_l to be factored.
  !>                 On exit, the elements on and below the (m-n)-th subdiagonal (when
  !>                 m >= n) or the (n-m)-th superdiagonal (when n > m) contain the
  !>                 factor L_l; the elements above the subsuperdiagonal are the first i - 1
  !>                 elements of Householder vector v_(l_i).
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[out]
  !>     ipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors ipiv_l of corresponding Householder scalars.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideP. Normal use is strideP >= min(m,n).
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgeql2_batched
    function rocsolver_sgeql2_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_sgeql2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeql2_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgeql2_batched_full_rank,&
      
rocsolver_sgeql2_batched_rank_0,&
      
rocsolver_sgeql2_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgeql2_batched
    function rocsolver_dgeql2_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_dgeql2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeql2_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgeql2_batched_full_rank,&
      
rocsolver_dgeql2_batched_rank_0,&
      
rocsolver_dgeql2_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgeql2_batched
    function rocsolver_cgeql2_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_cgeql2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeql2_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgeql2_batched_full_rank,&
      
rocsolver_cgeql2_batched_rank_0,&
      
rocsolver_cgeql2_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgeql2_batched
    function rocsolver_zgeql2_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_zgeql2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeql2_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgeql2_batched_full_rank,&
      
rocsolver_zgeql2_batched_rank_0,&
      
rocsolver_zgeql2_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GEQL2_STRIDED_BATCHED computes the QL factorization of a batch of
  !>     general m-by-n matrices.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The factorization of matrix \f$A_l\f$ in the batch has the form
  !> 
  !>     \f[
  !>         A_l = Q_l\left[\begin{array}{c}
  !>         0\\
  !>         L_l
  !>         \end{array}\right]
  !>     \f]
  !> 
  !>     where \f$L_l\f$ is lower triangular (lower trapezoidal if m < n), and \f$Q_l\f$ is
  !>     a m-by-m orthogonalunitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q_l = H_l(k)H_l(k-1)\cdots H_l(1), \quad \text{with} \: k = \text{min}(m,n)
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H_l(i)\f$ is given by
  !> 
  !>     \f[
  !>         H_l^{}(i) = I - \text{ipiv}_l^{}[i] \cdot v_{l_i}^{} v_{l_i}'
  !>     \f]
  !> 
  !>     where the last m-i elements of the Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all the matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all the matrices A_l in the batch.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the m-by-n matrices A_l to be factored.
  !>                 On exit, the elements on and below the (m-n)-th subdiagonal (when
  !>                 m >= n) or the (n-m)-th superdiagonal (when n > m) contain the
  !>                 factor L_l; the elements above the subsuperdiagonal are the first i - 1
  !>                 elements of Householder vector v_(l_i).
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     ipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors ipiv_l of corresponding Householder scalars.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideP. Normal use is strideP >= min(m,n).
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgeql2_strided_batched
    function rocsolver_sgeql2_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_sgeql2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeql2_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgeql2_strided_batched_full_rank,&
      
rocsolver_sgeql2_strided_batched_rank_0,&
      
rocsolver_sgeql2_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgeql2_strided_batched
    function rocsolver_dgeql2_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_dgeql2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeql2_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgeql2_strided_batched_full_rank,&
      
rocsolver_dgeql2_strided_batched_rank_0,&
      
rocsolver_dgeql2_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgeql2_strided_batched
    function rocsolver_cgeql2_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_cgeql2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeql2_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgeql2_strided_batched_full_rank,&
      
rocsolver_cgeql2_strided_batched_rank_0,&
      
rocsolver_cgeql2_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgeql2_strided_batched
    function rocsolver_zgeql2_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_zgeql2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeql2_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgeql2_strided_batched_full_rank,&
      
rocsolver_zgeql2_strided_batched_rank_0,&
      
rocsolver_zgeql2_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GELQ2 computes a LQ factorization of a general m-by-n matrix A.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The factorization has the form
  !> 
  !>     \f[
  !>         A = \left[\begin{array}{cc}
  !>         L & 0
  !>         \end{array}\right] Q
  !>     \f]
  !> 
  !>     where L is lower triangular (lower trapezoidal if m > n), and Q is
  !>     a n-by-n orthogonalunitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q = H(k)'H(k-1)' \cdots H(1)', \quad \text{with} \: k = \text{min}(m,n).
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H(i)\f$ is given by
  !> 
  !>     \f[
  !>         H(i) = I - \text{ipiv}[i] \cdot v_i' v_i^{}
  !>     \f]
  !> 
  !>     where the first i-1 elements of the Householder vector \f$v_i\f$ are zero, and \f$v_i[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of the matrix A.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of the matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrix to be factored.
  !>                 On exit, the elements on and below the diagonal contain the
  !>                 factor L; the elements above the diagonal are the last n - i elements
  !>                 of Householder vector v_i.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     ipiv        pointer to type. Array on the GPU of dimension min(m,n).
  !>                 The Householder scalars.
  !>     
  interface rocsolver_sgelq2
    function rocsolver_sgelq2_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_sgelq2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgelq2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgelq2_full_rank,&
      
rocsolver_sgelq2_rank_0,&
      
rocsolver_sgelq2_rank_1
#endif

  end interface
  
  interface rocsolver_dgelq2
    function rocsolver_dgelq2_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_dgelq2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgelq2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgelq2_full_rank,&
      
rocsolver_dgelq2_rank_0,&
      
rocsolver_dgelq2_rank_1
#endif

  end interface
  
  interface rocsolver_cgelq2
    function rocsolver_cgelq2_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_cgelq2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgelq2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgelq2_full_rank,&
      
rocsolver_cgelq2_rank_0,&
      
rocsolver_cgelq2_rank_1
#endif

  end interface
  
  interface rocsolver_zgelq2
    function rocsolver_zgelq2_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_zgelq2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgelq2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgelq2_full_rank,&
      
rocsolver_zgelq2_rank_0,&
      
rocsolver_zgelq2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GELQ2_BATCHED computes the LQ factorization of a batch of general
  !>     m-by-n matrices.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The factorization of matrix \f$A_l\f$ in the batch has the form
  !> 
  !>     \f[
  !>         A_l = \left[\begin{array}{cc}
  !>         L_l & 0
  !>         \end{array}\right] Q_l
  !>     \f]
  !> 
  !>     where \f$L_l\f$ is lower triangular (lower trapezoidal if m > n), and \f$Q_l\f$ is
  !>     a n-by-n orthogonalunitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q_l = H_l(k)'H_l(k-1)' \cdots H_l(1)', \quad \text{with} \: k = \text{min}(m,n).
  !>     \f]
  !> 
  !>     Each Householder matrices \f$H_l(i)\f$ is given by
  !> 
  !>     \f[
  !>         H_l^{}(i) = I - \text{ipiv}_l^{}[i] \cdot v_{l_i}' v_{l_i}^{}
  !>     \f]
  !> 
  !>     where the first i-1 elements of Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all the matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all the matrices A_l in the batch.
  !>     @param[inout]
  !>     A           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrices A_l to be factored.
  !>                 On exit, the elements on and below the diagonal contain the
  !>                 factor L_l. The elements above the diagonal are the last n - i elements
  !>                 of Householder vector v_(l_i).
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[out]
  !>     ipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors ipiv_l of corresponding Householder scalars.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideP. Normal use is strideP >= min(m,n).
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgelq2_batched
    function rocsolver_sgelq2_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_sgelq2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgelq2_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgelq2_batched_full_rank,&
      
rocsolver_sgelq2_batched_rank_0,&
      
rocsolver_sgelq2_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgelq2_batched
    function rocsolver_dgelq2_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_dgelq2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgelq2_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgelq2_batched_full_rank,&
      
rocsolver_dgelq2_batched_rank_0,&
      
rocsolver_dgelq2_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgelq2_batched
    function rocsolver_cgelq2_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_cgelq2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgelq2_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgelq2_batched_full_rank,&
      
rocsolver_cgelq2_batched_rank_0,&
      
rocsolver_cgelq2_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgelq2_batched
    function rocsolver_zgelq2_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_zgelq2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgelq2_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgelq2_batched_full_rank,&
      
rocsolver_zgelq2_batched_rank_0,&
      
rocsolver_zgelq2_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GELQ2_STRIDED_BATCHED computes the LQ factorization of a batch of
  !>     general m-by-n matrices.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The factorization of matrix \f$A_l\f$ in the batch has the form
  !> 
  !>     \f[
  !>         A_l = \left[\begin{array}{cc}
  !>         L_l & 0
  !>         \end{array}\right] Q_l
  !>     \f]
  !> 
  !>     where \f$L_l\f$ is lower triangular (lower trapezoidal if m > n), and \f$Q_l\f$ is
  !>     a n-by-n orthogonalunitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q_l = H_l(k)'H_l(k-1)' \cdots H_l(1)', \quad \text{with} \: k = \text{min}(m,n).
  !>     \f]
  !> 
  !>     Each Householder matrices \f$H_l(i)\f$ is given by
  !> 
  !>     \f[
  !>         H_l^{}(i) = I - \text{ipiv}_l^{}[i] \cdot v_{l_i}' v_{l_i}^{}
  !>     \f]
  !> 
  !>     where the first i-1 elements of Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle    rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all the matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all the matrices A_l in the batch.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the m-by-n matrices A_l to be factored.
  !>                 On exit, the elements on and below the diagonal contain the
  !>                 factor L_l. The elements above the diagonal are the last n - i elements
  !>                 of Householder vector v_(l_i).
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     ipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors ipiv_l of corresponding Householder scalars.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideP. Normal use is strideP >= min(m,n).
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgelq2_strided_batched
    function rocsolver_sgelq2_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_sgelq2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgelq2_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgelq2_strided_batched_full_rank,&
      
rocsolver_sgelq2_strided_batched_rank_0,&
      
rocsolver_sgelq2_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgelq2_strided_batched
    function rocsolver_dgelq2_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_dgelq2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgelq2_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgelq2_strided_batched_full_rank,&
      
rocsolver_dgelq2_strided_batched_rank_0,&
      
rocsolver_dgelq2_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgelq2_strided_batched
    function rocsolver_cgelq2_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_cgelq2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgelq2_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgelq2_strided_batched_full_rank,&
      
rocsolver_cgelq2_strided_batched_rank_0,&
      
rocsolver_cgelq2_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgelq2_strided_batched
    function rocsolver_zgelq2_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_zgelq2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgelq2_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgelq2_strided_batched_full_rank,&
      
rocsolver_zgelq2_strided_batched_rank_0,&
      
rocsolver_zgelq2_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GEQRF computes a QR factorization of a general m-by-n matrix A.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The factorization has the form
  !> 
  !>     \f[
  !>         A = Q\left[\begin{array}{c}
  !>         R\\
  !>         0
  !>         \end{array}\right]
  !>     \f]
  !> 
  !>     where R is upper triangular (upper trapezoidal if m < n), and Q is
  !>     a m-by-m orthogonalunitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q = H(1)H(2)\cdots H(k), \quad \text{with} \: k = \text{min}(m,n)
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H(i)\f$ is given by
  !> 
  !>     \f[
  !>         H(i) = I - \text{ipiv}[i] \cdot v_i^{} v_i'
  !>     \f]
  !> 
  !>     where the first i-1 elements of the Householder vector \f$v_i\f$ are zero, and \f$v_i[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of the matrix A.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of the matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrix to be factored.
  !>                 On exit, the elements on and above the diagonal contain the
  !>                 factor R; the elements below the diagonal are the last m - i elements
  !>                 of Householder vector v_i.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     ipiv        pointer to type. Array on the GPU of dimension min(m,n).
  !>                 The Householder scalars.
  !>     
  interface rocsolver_sgeqrf
    function rocsolver_sgeqrf_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_sgeqrf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqrf_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgeqrf_full_rank,&
      
rocsolver_sgeqrf_rank_0,&
      
rocsolver_sgeqrf_rank_1
#endif

  end interface
  
  interface rocsolver_dgeqrf
    function rocsolver_dgeqrf_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_dgeqrf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqrf_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgeqrf_full_rank,&
      
rocsolver_dgeqrf_rank_0,&
      
rocsolver_dgeqrf_rank_1
#endif

  end interface
  
  interface rocsolver_cgeqrf
    function rocsolver_cgeqrf_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_cgeqrf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqrf_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgeqrf_full_rank,&
      
rocsolver_cgeqrf_rank_0,&
      
rocsolver_cgeqrf_rank_1
#endif

  end interface
  
  interface rocsolver_zgeqrf
    function rocsolver_zgeqrf_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_zgeqrf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqrf_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgeqrf_full_rank,&
      
rocsolver_zgeqrf_rank_0,&
      
rocsolver_zgeqrf_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GEQRF_BATCHED computes the QR factorization of a batch of general
  !>     m-by-n matrices.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The factorization of matrix \f$A_l\f$ in the batch has the form
  !> 
  !>     \f[
  !>         A_l = Q_l\left[\begin{array}{c}
  !>         R_l\\
  !>         0
  !>         \end{array}\right]
  !>     \f]
  !> 
  !>     where \f$R_l\f$ is upper triangular (upper trapezoidal if m < n), and \f$Q_l\f$ is
  !>     a m-by-m orthogonalunitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q_l = H_l(1)H_l(2)\cdots H_l(k), \quad \text{with} \: k = \text{min}(m,n)
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H_l(i)\f$ is given by
  !> 
  !>     \f[
  !>         H_l^{}(i) = I - \text{ipiv}_l^{}[i] \cdot v_{l_i}^{} v_{l_i}'
  !>     \f]
  !> 
  !>     where the first i-1 elements of Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all the matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all the matrices A_l in the batch.
  !>     @param[inout]
  !>     A           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrices A_l to be factored.
  !>                 On exit, the elements on and above the diagonal contain the
  !>                 factor R_l. The elements below the diagonal are the last m - i elements
  !>                 of Householder vector v_(l_i).
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[out]
  !>     ipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors ipiv_l of corresponding Householder scalars.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideP. Normal use is strideP >= min(m,n).
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgeqrf_batched
    function rocsolver_sgeqrf_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_sgeqrf_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqrf_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgeqrf_batched_full_rank,&
      
rocsolver_sgeqrf_batched_rank_0,&
      
rocsolver_sgeqrf_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgeqrf_batched
    function rocsolver_dgeqrf_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_dgeqrf_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqrf_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgeqrf_batched_full_rank,&
      
rocsolver_dgeqrf_batched_rank_0,&
      
rocsolver_dgeqrf_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgeqrf_batched
    function rocsolver_cgeqrf_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_cgeqrf_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqrf_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgeqrf_batched_full_rank,&
      
rocsolver_cgeqrf_batched_rank_0,&
      
rocsolver_cgeqrf_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgeqrf_batched
    function rocsolver_zgeqrf_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_zgeqrf_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqrf_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgeqrf_batched_full_rank,&
      
rocsolver_zgeqrf_batched_rank_0,&
      
rocsolver_zgeqrf_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GEQRF_STRIDED_BATCHED computes the QR factorization of a batch of
  !>     general m-by-n matrices.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The factorization of matrix \f$A_l\f$ in the batch has the form
  !> 
  !>     \f[
  !>         A_l = Q_l\left[\begin{array}{c}
  !>         R_l\\
  !>         0
  !>         \end{array}\right]
  !>     \f]
  !> 
  !>     where \f$R_l\f$ is upper triangular (upper trapezoidal if m < n), and \f$Q_l\f$ is
  !>     a m-by-m orthogonalunitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q_l = H_l(1)H_l(2)\cdots H_l(k), \quad \text{with} \: k = \text{min}(m,n)
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H_l(i)\f$ is given by
  !> 
  !>     \f[
  !>         H_l^{}(i) = I - \text{ipiv}_l^{}[i] \cdot v_{l_i}^{} v_{l_i}'
  !>     \f]
  !> 
  !>     where the first i-1 elements of Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all the matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all the matrices A_l in the batch.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the m-by-n matrices A_l to be factored.
  !>                 On exit, the elements on and above the diagonal contain the
  !>                 factor R_l. The elements below the diagonal are the last m - i elements
  !>                 of Householder vector v_(l_i).
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     ipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors ipiv_l of corresponding Householder scalars.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideP. Normal use is strideP >= min(m,n).
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgeqrf_strided_batched
    function rocsolver_sgeqrf_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_sgeqrf_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqrf_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgeqrf_strided_batched_full_rank,&
      
rocsolver_sgeqrf_strided_batched_rank_0,&
      
rocsolver_sgeqrf_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgeqrf_strided_batched
    function rocsolver_dgeqrf_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_dgeqrf_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqrf_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgeqrf_strided_batched_full_rank,&
      
rocsolver_dgeqrf_strided_batched_rank_0,&
      
rocsolver_dgeqrf_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgeqrf_strided_batched
    function rocsolver_cgeqrf_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_cgeqrf_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqrf_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgeqrf_strided_batched_full_rank,&
      
rocsolver_cgeqrf_strided_batched_rank_0,&
      
rocsolver_cgeqrf_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgeqrf_strided_batched
    function rocsolver_zgeqrf_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_zgeqrf_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqrf_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgeqrf_strided_batched_full_rank,&
      
rocsolver_zgeqrf_strided_batched_rank_0,&
      
rocsolver_zgeqrf_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GERQF computes a RQ factorization of a general m-by-n matrix A.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The factorization has the form
  !> 
  !>     \f[
  !>         A = \left[\begin{array}{cc}
  !>         0 & R
  !>         \end{array}\right] Q
  !>     \f]
  !> 
  !>     where R is upper triangular (upper trapezoidal if m > n), and Q is
  !>     a n-by-n orthogonalunitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q = H(1)'H(2)' \cdots H(k)', \quad \text{with} \: k = \text{min}(m,n).
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H(i)\f$ is given by
  !> 
  !>     \f[
  !>         H(i) = I - \text{ipiv}[i] \cdot v_i^{} v_i'
  !>     \f]
  !> 
  !>     where the last n-i elements of the Householder vector \f$v_i\f$ are zero, and \f$v_i[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of the matrix A.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of the matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrix to be factored.
  !>                 On exit, the elements on and above the (m-n)-th subdiagonal (when
  !>                 m >= n) or the (n-m)-th superdiagonal (when n > m) contain the
  !>                 factor R; the elements below the subsuperdiagonal are the first i - 1
  !>                 elements of Householder vector v_i.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     ipiv        pointer to type. Array on the GPU of dimension min(m,n).
  !>                 The Householder scalars.
  !>     
  interface rocsolver_sgerqf
    function rocsolver_sgerqf_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_sgerqf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgerqf_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgerqf_full_rank,&
      
rocsolver_sgerqf_rank_0,&
      
rocsolver_sgerqf_rank_1
#endif

  end interface
  
  interface rocsolver_dgerqf
    function rocsolver_dgerqf_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_dgerqf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgerqf_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgerqf_full_rank,&
      
rocsolver_dgerqf_rank_0,&
      
rocsolver_dgerqf_rank_1
#endif

  end interface
  
  interface rocsolver_cgerqf
    function rocsolver_cgerqf_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_cgerqf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgerqf_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgerqf_full_rank,&
      
rocsolver_cgerqf_rank_0,&
      
rocsolver_cgerqf_rank_1
#endif

  end interface
  
  interface rocsolver_zgerqf
    function rocsolver_zgerqf_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_zgerqf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgerqf_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgerqf_full_rank,&
      
rocsolver_zgerqf_rank_0,&
      
rocsolver_zgerqf_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GERQF_BATCHED computes the RQ factorization of a batch of general
  !>     m-by-n matrices.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The factorization of matrix \f$A_l\f$ in the batch has the form
  !> 
  !>     \f[
  !>         A_l = \left[\begin{array}{cc}
  !>         0 & R_l
  !>         \end{array}\right] Q_l
  !>     \f]
  !> 
  !>     where \f$R_l\f$ is upper triangular (upper trapezoidal if m > n), and \f$Q_l\f$ is
  !>     a n-by-n orthogonalunitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q_l = H_l(1)'H_l(2)' \cdots H_l(k)', \quad \text{with} \: k = \text{min}(m,n).
  !>     \f]
  !> 
  !>     Each Householder matrices \f$H_l(i)\f$ is given by
  !> 
  !>     \f[
  !>         H_l^{}(i) = I - \text{ipiv}_l^{}[i] \cdot v_{l_i}^{} v_{l_i}'
  !>     \f]
  !> 
  !>     where the last n-i elements of Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all the matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all the matrices A_l in the batch.
  !>     @param[inout]
  !>     A           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrices A_l to be factored.
  !>                 On exit, the elements on and above the (m-n)-th subdiagonal (when
  !>                 m >= n) or the (n-m)-th superdiagonal (when n > m) contain the
  !>                 factor R_l; the elements below the subsuperdiagonal are the first i - 1
  !>                 elements of Householder vector v_(l_i).
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[out]
  !>     ipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors ipiv_l of corresponding Householder scalars.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideP. Normal use is strideP >= min(m,n).
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgerqf_batched
    function rocsolver_sgerqf_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_sgerqf_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgerqf_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgerqf_batched_full_rank,&
      
rocsolver_sgerqf_batched_rank_0,&
      
rocsolver_sgerqf_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgerqf_batched
    function rocsolver_dgerqf_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_dgerqf_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgerqf_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgerqf_batched_full_rank,&
      
rocsolver_dgerqf_batched_rank_0,&
      
rocsolver_dgerqf_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgerqf_batched
    function rocsolver_cgerqf_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_cgerqf_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgerqf_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgerqf_batched_full_rank,&
      
rocsolver_cgerqf_batched_rank_0,&
      
rocsolver_cgerqf_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgerqf_batched
    function rocsolver_zgerqf_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_zgerqf_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgerqf_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgerqf_batched_full_rank,&
      
rocsolver_zgerqf_batched_rank_0,&
      
rocsolver_zgerqf_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GERQF_STRIDED_BATCHED computes the RQ factorization of a batch of
  !>     general m-by-n matrices.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The factorization of matrix \f$A_l\f$ in the batch has the form
  !> 
  !>     \f[
  !>         A_l = \left[\begin{array}{cc}
  !>         0 & R_l
  !>         \end{array}\right] Q_l
  !>     \f]
  !> 
  !>     where \f$R_l\f$ is upper triangular (upper trapezoidal if m > n), and \f$Q_l\f$ is
  !>     a n-by-n orthogonalunitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q_l = H_l(1)'H_l(2)' \cdots H_l(k)', \quad \text{with} \: k = \text{min}(m,n).
  !>     \f]
  !> 
  !>     Each Householder matrices \f$H_l(i)\f$ is given by
  !> 
  !>     \f[
  !>         H_l^{}(i) = I - \text{ipiv}_l^{}[i] \cdot v_{l_i}^{} v_{l_i}'
  !>     \f]
  !> 
  !>     where the last n-i elements of Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all the matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all the matrices A_l in the batch.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the m-by-n matrices A_l to be factored.
  !>                 On exit, the elements on and above the (m-n)-th subdiagonal (when
  !>                 m >= n) or the (n-m)-th superdiagonal (when n > m) contain the
  !>                 factor R_l; the elements below the subsuperdiagonal are the first i - 1
  !>                 elements of Householder vector v_(l_i).
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     ipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors ipiv_l of corresponding Householder scalars.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideP. Normal use is strideP >= min(m,n).
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgerqf_strided_batched
    function rocsolver_sgerqf_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_sgerqf_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgerqf_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgerqf_strided_batched_full_rank,&
      
rocsolver_sgerqf_strided_batched_rank_0,&
      
rocsolver_sgerqf_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgerqf_strided_batched
    function rocsolver_dgerqf_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_dgerqf_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgerqf_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgerqf_strided_batched_full_rank,&
      
rocsolver_dgerqf_strided_batched_rank_0,&
      
rocsolver_dgerqf_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgerqf_strided_batched
    function rocsolver_cgerqf_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_cgerqf_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgerqf_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgerqf_strided_batched_full_rank,&
      
rocsolver_cgerqf_strided_batched_rank_0,&
      
rocsolver_cgerqf_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgerqf_strided_batched
    function rocsolver_zgerqf_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_zgerqf_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgerqf_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgerqf_strided_batched_full_rank,&
      
rocsolver_zgerqf_strided_batched_rank_0,&
      
rocsolver_zgerqf_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GEQLF computes a QL factorization of a general m-by-n matrix A.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The factorization has the form
  !> 
  !>     \f[
  !>         A = Q\left[\begin{array}{c}
  !>         0\\
  !>         L
  !>         \end{array}\right]
  !>     \f]
  !> 
  !>     where L is lower triangular (lower trapezoidal if m < n), and Q is
  !>     a m-by-m orthogonalunitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q = H(k)H(k-1)\cdots H(1), \quad \text{with} \: k = \text{min}(m,n)
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H(i)\f$ is given by
  !> 
  !>     \f[
  !>         H(i) = I - \text{ipiv}[i] \cdot v_i^{} v_i'
  !>     \f]
  !> 
  !>     where the last m-i elements of the Householder vector \f$v_i\f$ are zero, and \f$v_i[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of the matrix A.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of the matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrix to be factored.
  !>                 On exit, the elements on and below the (m-n)-th subdiagonal (when
  !>                 m >= n) or the (n-m)-th superdiagonal (when n > m) contain the
  !>                 factor L; the elements above the subsuperdiagonal are the first i - 1
  !>                 elements of Householder vector v_i.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     ipiv        pointer to type. Array on the GPU of dimension min(m,n).
  !>                 The Householder scalars.
  !>     
  interface rocsolver_sgeqlf
    function rocsolver_sgeqlf_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_sgeqlf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqlf_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgeqlf_full_rank,&
      
rocsolver_sgeqlf_rank_0,&
      
rocsolver_sgeqlf_rank_1
#endif

  end interface
  
  interface rocsolver_dgeqlf
    function rocsolver_dgeqlf_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_dgeqlf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqlf_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgeqlf_full_rank,&
      
rocsolver_dgeqlf_rank_0,&
      
rocsolver_dgeqlf_rank_1
#endif

  end interface
  
  interface rocsolver_cgeqlf
    function rocsolver_cgeqlf_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_cgeqlf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqlf_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgeqlf_full_rank,&
      
rocsolver_cgeqlf_rank_0,&
      
rocsolver_cgeqlf_rank_1
#endif

  end interface
  
  interface rocsolver_zgeqlf
    function rocsolver_zgeqlf_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_zgeqlf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqlf_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgeqlf_full_rank,&
      
rocsolver_zgeqlf_rank_0,&
      
rocsolver_zgeqlf_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GEQLF_BATCHED computes the QL factorization of a batch of general
  !>     m-by-n matrices.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The factorization of matrix \f$A_l\f$ in the batch has the form
  !> 
  !>     \f[
  !>         A_l = Q_l\left[\begin{array}{c}
  !>         0\\
  !>         L_l
  !>         \end{array}\right]
  !>     \f]
  !> 
  !>     where \f$L_l\f$ is lower triangular (lower trapezoidal if m < n), and \f$Q_l\f$ is
  !>     a m-by-m orthogonalunitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q_l = H_l(k)H_l(k-1)\cdots H_l(1), \quad \text{with} \: k = \text{min}(m,n)
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H_l(i)\f$ is given by
  !> 
  !>     \f[
  !>         H_l^{}(i) = I - \text{ipiv}_l^{}[i] \cdot v_{l_i}^{} v_{l_i}'
  !>     \f]
  !> 
  !>     where the last m-i elements of the Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all the matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all the matrices A_l in the batch.
  !>     @param[inout]
  !>     A           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrices A_l to be factored.
  !>                 On exit, the elements on and below the (m-n)-th subdiagonal (when
  !>                 m >= n) or the (n-m)-th superdiagonal (when n > m) contain the
  !>                 factor L_l; the elements above the subsuperdiagonal are the first i - 1
  !>                 elements of Householder vector v_(l_i).
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[out]
  !>     ipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors ipiv_l of corresponding Householder scalars.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideP. Normal use is strideP >= min(m,n).
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgeqlf_batched
    function rocsolver_sgeqlf_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_sgeqlf_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqlf_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgeqlf_batched_full_rank,&
      
rocsolver_sgeqlf_batched_rank_0,&
      
rocsolver_sgeqlf_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgeqlf_batched
    function rocsolver_dgeqlf_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_dgeqlf_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqlf_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgeqlf_batched_full_rank,&
      
rocsolver_dgeqlf_batched_rank_0,&
      
rocsolver_dgeqlf_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgeqlf_batched
    function rocsolver_cgeqlf_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_cgeqlf_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqlf_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgeqlf_batched_full_rank,&
      
rocsolver_cgeqlf_batched_rank_0,&
      
rocsolver_cgeqlf_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgeqlf_batched
    function rocsolver_zgeqlf_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_zgeqlf_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqlf_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgeqlf_batched_full_rank,&
      
rocsolver_zgeqlf_batched_rank_0,&
      
rocsolver_zgeqlf_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GEQLF_STRIDED_BATCHED computes the QL factorization of a batch of
  !>     general m-by-n matrices.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The factorization of matrix \f$A_l\f$ in the batch has the form
  !> 
  !>     \f[
  !>         A_l = Q_l\left[\begin{array}{c}
  !>         0\\
  !>         L_l
  !>         \end{array}\right]
  !>     \f]
  !> 
  !>     where \f$L_l\f$ is lower triangular (lower trapezoidal if m < n), and \f$Q_l\f$ is
  !>     a m-by-m orthogonalunitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q_l = H_l(k)H_l(k-1)\cdots H_l(1), \quad \text{with} \: k = \text{min}(m,n)
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H_l(i)\f$ is given by
  !> 
  !>     \f[
  !>         H_l^{}(i) = I - \text{ipiv}_l^{}[i] \cdot v_{l_i}^{} v_{l_i}'
  !>     \f]
  !> 
  !>     where the last m-i elements of the Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all the matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all the matrices A_l in the batch.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the m-by-n matrices A_l to be factored.
  !>                 On exit, the elements on and below the (m-n)-th subdiagonal (when
  !>                 m >= n) or the (n-m)-th superdiagonal (when n > m) contain the
  !>                 factor L_l; the elements above the subsuperdiagonal are the first i - 1
  !>                 elements of Householder vector v_(l_i).
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     ipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors ipiv_l of corresponding Householder scalars.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideP. Normal use is strideP >= min(m,n).
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgeqlf_strided_batched
    function rocsolver_sgeqlf_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_sgeqlf_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqlf_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgeqlf_strided_batched_full_rank,&
      
rocsolver_sgeqlf_strided_batched_rank_0,&
      
rocsolver_sgeqlf_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgeqlf_strided_batched
    function rocsolver_dgeqlf_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_dgeqlf_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqlf_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgeqlf_strided_batched_full_rank,&
      
rocsolver_dgeqlf_strided_batched_rank_0,&
      
rocsolver_dgeqlf_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgeqlf_strided_batched
    function rocsolver_cgeqlf_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_cgeqlf_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqlf_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgeqlf_strided_batched_full_rank,&
      
rocsolver_cgeqlf_strided_batched_rank_0,&
      
rocsolver_cgeqlf_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgeqlf_strided_batched
    function rocsolver_zgeqlf_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_zgeqlf_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqlf_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgeqlf_strided_batched_full_rank,&
      
rocsolver_zgeqlf_strided_batched_rank_0,&
      
rocsolver_zgeqlf_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GELQF computes a LQ factorization of a general m-by-n matrix A.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The factorization has the form
  !> 
  !>     \f[
  !>         A = \left[\begin{array}{cc}
  !>         L & 0
  !>         \end{array}\right] Q
  !>     \f]
  !> 
  !>     where L is lower triangular (lower trapezoidal if m > n), and Q is
  !>     a n-by-n orthogonalunitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q = H(k)'H(k-1)' \cdots H(1)', \quad \text{with} \: k = \text{min}(m,n).
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H(i)\f$ is given by
  !> 
  !>     \f[
  !>         H(i) = I - \text{ipiv}[i] \cdot v_i' v_i^{}
  !>     \f]
  !> 
  !>     where the first i-1 elements of the Householder vector \f$v_i\f$ are zero, and \f$v_i[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of the matrix A.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of the matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrix to be factored.
  !>                 On exit, the elements on and below the diagonal contain the
  !>                 factor L; the elements above the diagonal are the last n - i elements
  !>                 of Householder vector v_i.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     ipiv        pointer to type. Array on the GPU of dimension min(m,n).
  !>                 The Householder scalars.
  !>     
  interface rocsolver_sgelqf
    function rocsolver_sgelqf_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_sgelqf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgelqf_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgelqf_full_rank,&
      
rocsolver_sgelqf_rank_0,&
      
rocsolver_sgelqf_rank_1
#endif

  end interface
  
  interface rocsolver_dgelqf
    function rocsolver_dgelqf_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_dgelqf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgelqf_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgelqf_full_rank,&
      
rocsolver_dgelqf_rank_0,&
      
rocsolver_dgelqf_rank_1
#endif

  end interface
  
  interface rocsolver_cgelqf
    function rocsolver_cgelqf_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_cgelqf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgelqf_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgelqf_full_rank,&
      
rocsolver_cgelqf_rank_0,&
      
rocsolver_cgelqf_rank_1
#endif

  end interface
  
  interface rocsolver_zgelqf
    function rocsolver_zgelqf_(handle,m,n,A,lda,ipiv) bind(c, name="rocsolver_zgelqf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgelqf_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgelqf_full_rank,&
      
rocsolver_zgelqf_rank_0,&
      
rocsolver_zgelqf_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GELQF_BATCHED computes the LQ factorization of a batch of general
  !>     m-by-n matrices.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The factorization of matrix \f$A_l\f$ in the batch has the form
  !> 
  !>     \f[
  !>         A_l = \left[\begin{array}{cc}
  !>         L_l & 0
  !>         \end{array}\right] Q_l
  !>     \f]
  !> 
  !>     where \f$L_l\f$ is lower triangular (lower trapezoidal if m > n), and \f$Q_l\f$ is
  !>     a n-by-n orthogonalunitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q_l = H_l(k)'H_l(k-1)' \cdots H_l(1)', \quad \text{with} \: k = \text{min}(m,n).
  !>     \f]
  !> 
  !>     Each Householder matrices \f$H_l(i)\f$ is given by
  !> 
  !>     \f[
  !>         H_l^{}(i) = I - \text{ipiv}_l^{}[i] \cdot v_{l_i}' v_{l_i}^{}
  !>     \f]
  !> 
  !>     where the first i-1 elements of Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all the matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all the matrices A_l in the batch.
  !>     @param[inout]
  !>     A           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrices A_l to be factored.
  !>                 On exit, the elements on and below the diagonal contain the
  !>                 factor L_l. The elements above the diagonal are the last n - i elements
  !>                 of Householder vector v_(l_i).
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[out]
  !>     ipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors ipiv_l of corresponding Householder scalars.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideP. Normal use is strideP >= min(m,n).
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgelqf_batched
    function rocsolver_sgelqf_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_sgelqf_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgelqf_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgelqf_batched_full_rank,&
      
rocsolver_sgelqf_batched_rank_0,&
      
rocsolver_sgelqf_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgelqf_batched
    function rocsolver_dgelqf_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_dgelqf_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgelqf_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgelqf_batched_full_rank,&
      
rocsolver_dgelqf_batched_rank_0,&
      
rocsolver_dgelqf_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgelqf_batched
    function rocsolver_cgelqf_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_cgelqf_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgelqf_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgelqf_batched_full_rank,&
      
rocsolver_cgelqf_batched_rank_0,&
      
rocsolver_cgelqf_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgelqf_batched
    function rocsolver_zgelqf_batched_(handle,m,n,A,lda,ipiv,strideP,batch_count) bind(c, name="rocsolver_zgelqf_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgelqf_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgelqf_batched_full_rank,&
      
rocsolver_zgelqf_batched_rank_0,&
      
rocsolver_zgelqf_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GELQF_STRIDED_BATCHED computes the LQ factorization of a batch of
  !>     general m-by-n matrices.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The factorization of matrix \f$A_l\f$ in the batch has the form
  !> 
  !>     \f[
  !>         A_l = \left[\begin{array}{cc}
  !>         L_l & 0
  !>         \end{array}\right] Q_l
  !>     \f]
  !> 
  !>     where \f$L_l\f$ is lower triangular (lower trapezoidal if m > n), and \f$Q_l\f$ is
  !>     a n-by-n orthogonalunitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q_l = H_l(k)'H_l(k-1)' \cdots H_l(1)', \quad \text{with} \: k = \text{min}(m,n).
  !>     \f]
  !> 
  !>     Each Householder matrices \f$H_l(i)\f$ is given by
  !> 
  !>     \f[
  !>         H_l^{}(i) = I - \text{ipiv}_l^{}[i] \cdot v_{l_i}' v_{l_i}^{}
  !>     \f]
  !> 
  !>     where the first i-1 elements of Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all the matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all the matrices A_l in the batch.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the m-by-n matrices A_l to be factored.
  !>                 On exit, the elements on and below the diagonal contain the
  !>                 factor L_l. The elements above the diagonal are the last n - i elements
  !>                 of Householder vector v_(l_i).
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     ipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors ipiv_l of corresponding Householder scalars.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideP. Normal use is strideP >= min(m,n).
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgelqf_strided_batched
    function rocsolver_sgelqf_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_sgelqf_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgelqf_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgelqf_strided_batched_full_rank,&
      
rocsolver_sgelqf_strided_batched_rank_0,&
      
rocsolver_sgelqf_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgelqf_strided_batched
    function rocsolver_dgelqf_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_dgelqf_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgelqf_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgelqf_strided_batched_full_rank,&
      
rocsolver_dgelqf_strided_batched_rank_0,&
      
rocsolver_dgelqf_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgelqf_strided_batched
    function rocsolver_cgelqf_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_cgelqf_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgelqf_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgelqf_strided_batched_full_rank,&
      
rocsolver_cgelqf_strided_batched_rank_0,&
      
rocsolver_cgelqf_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgelqf_strided_batched
    function rocsolver_zgelqf_strided_batched_(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count) bind(c, name="rocsolver_zgelqf_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgelqf_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgelqf_strided_batched_full_rank,&
      
rocsolver_zgelqf_strided_batched_rank_0,&
      
rocsolver_zgelqf_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GEBD2 computes the bidiagonal form of a general m-by-n matrix A.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The bidiagonal form is given by:
  !> 
  !>     \f[
  !>         B = Q'  A  P
  !>     \f]
  !> 
  !>     where B is upper bidiagonal if m >= n and lower bidiagonal if m < n, and Q and
  !>     P are orthogonalunitary matrices represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Q = H(1)H(2)\cdots H(n)\:  \text{and} \: P = G(1)G(2)\cdots G(n-1), & \: \text{if}\: m >= n, \:\text{or}\\
  !>         Q = H(1)H(2)\cdots H(m-1)\:  \text{and} \: P = G(1)G(2)\cdots G(m), & \: \text{if}\: m < n.
  !>         \end{array}
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H(i)\f$ and \f$G(i)\f$ is given by
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         H(i) = I - \text{tauq}[i] \cdot v_i^{} v_i', & \: \text{and}\\
  !>         G(i) = I - \text{taup}[i] \cdot u_i' u_i^{}.
  !>         \end{array}
  !>     \f]
  !> 
  !>     If m >= n, the first i-1 elements of the Householder vector \f$v_i\f$ are zero, and \f$v_i[i] = 1\f$;
  !>     while the first i elements of the Householder vector \f$u_i\f$ are zero, and \f$u_i[i+1] = 1\f$.
  !>     If m < n, the first i elements of the Householder vector \f$v_i\f$ are zero, and \f$v_i[i+1] = 1\f$;
  !>     while the first i-1 elements of the Householder vector \f$u_i\f$ are zero, and \f$u_i[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of the matrix A.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of the matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrix to be factored.
  !>                 On exit, the elements on the diagonal and superdiagonal (if m >= n), or
  !>                 subdiagonal (if m < n) contain the bidiagonal form B.
  !>                 If m >= n, the elements below the diagonal are the last m - i elements
  !>                 of Householder vector v_i, and the elements above the
  !>                 superdiagonal are the last n - i - 1 elements of Householder vector u_i.
  !>                 If m < n, the elements below the subdiagonal are the last m - i - 1
  !>                 elements of Householder vector v_i, and the elements above the
  !>                 diagonal are the last n - i elements of Householder vector u_i.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 specifies the leading dimension of A.
  !>     @param[out]
  !>     D           pointer to real type. Array on the GPU of dimension min(m,n).
  !>                 The diagonal elements of B.
  !>     @param[out]
  !>     E           pointer to real type. Array on the GPU of dimension min(m,n)-1.
  !>                 The off-diagonal elements of B.
  !>     @param[out]
  !>     tauq        pointer to type. Array on the GPU of dimension min(m,n).
  !>                 The Householder scalars associated with matrix Q.
  !>     @param[out]
  !>     taup        pointer to type. Array on the GPU of dimension min(m,n).
  !>                 The Householder scalars associated with matrix P.
  !>     
  interface rocsolver_sgebd2
    function rocsolver_sgebd2_(handle,m,n,A,lda,D,E,tauq,taup) bind(c, name="rocsolver_sgebd2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgebd2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: tauq
      type(c_ptr),value :: taup
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgebd2_full_rank,&
      
rocsolver_sgebd2_rank_0,&
      
rocsolver_sgebd2_rank_1
#endif

  end interface
  
  interface rocsolver_dgebd2
    function rocsolver_dgebd2_(handle,m,n,A,lda,D,E,tauq,taup) bind(c, name="rocsolver_dgebd2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgebd2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: tauq
      type(c_ptr),value :: taup
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgebd2_full_rank,&
      
rocsolver_dgebd2_rank_0,&
      
rocsolver_dgebd2_rank_1
#endif

  end interface
  
  interface rocsolver_cgebd2
    function rocsolver_cgebd2_(handle,m,n,A,lda,D,E,tauq,taup) bind(c, name="rocsolver_cgebd2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgebd2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: tauq
      type(c_ptr),value :: taup
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgebd2_full_rank,&
      
rocsolver_cgebd2_rank_0,&
      
rocsolver_cgebd2_rank_1
#endif

  end interface
  
  interface rocsolver_zgebd2
    function rocsolver_zgebd2_(handle,m,n,A,lda,D,E,tauq,taup) bind(c, name="rocsolver_zgebd2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgebd2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: tauq
      type(c_ptr),value :: taup
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgebd2_full_rank,&
      
rocsolver_zgebd2_rank_0,&
      
rocsolver_zgebd2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GEBD2_BATCHED computes the bidiagonal form of a batch of general
  !>     m-by-n matrices.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     For each instance in the batch, the bidiagonal form is given by:
  !> 
  !>     \f[
  !>         B_l^{} = Q_l'  A_l^{}  P_l^{}
  !>     \f]
  !> 
  !>     where \f$B_l\f$ is upper bidiagonal if m >= n and lower bidiagonal if m < n, and \f$Q_l\f$ and
  !>     \f$P_l\f$ are orthogonalunitary matrices represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Q_l = H_l(1)H_l(2)\cdots H_l(n)\:  \text{and} \: P_l = G_l(1)G_l(2)\cdots G_l(n-1), & \: \text{if}\: m >= n, \:\text{or}\\
  !>         Q_l = H_l(1)H_l(2)\cdots H_l(m-1)\:  \text{and} \: P_l = G_l(1)G_l(2)\cdots G_l(m), & \: \text{if}\: m < n.
  !>         \end{array}
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H_l(i)\f$ and \f$G_l(i)\f$ is given by
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         H_l^{}(i) = I - \text{tauq}_l^{}[i] \cdot v_{l_i}^{} v_{l_i}', & \: \text{and}\\
  !>         G_l^{}(i) = I - \text{taup}_l^{}[i] \cdot u_{l_i}' u_{l_i}^{}.
  !>         \end{array}
  !>     \f]
  !> 
  !>     If m >= n, the first i-1 elements of the Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i] = 1\f$;
  !>     while the first i elements of the Householder vector \f$u_{l_i}\f$ are zero, and \f$u_{l_i}[i+1] = 1\f$.
  !>     If m < n, the first i elements of the Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i+1] = 1\f$;
  !>     while the first i-1 elements of the Householder vector \f$u_{l_i}\f$ are zero, and \f$u_{l_i}[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all the matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all the matrices A_l in the batch.
  !>     @param[inout]
  !>     A           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrices A_l to be factored.
  !>                 On exit, the elements on the diagonal and superdiagonal (if m >= n), or
  !>                 subdiagonal (if m < n) contain the bidiagonal form B_l.
  !>                 If m >= n, the elements below the diagonal are the last m - i elements
  !>                 of Householder vector v_(l_i), and the elements above the
  !>                 superdiagonal are the last n - i - 1 elements of Householder vector u_(l_i).
  !>                 If m < n, the elements below the subdiagonal are the last m - i - 1
  !>                 elements of Householder vector v_(l_i), and the elements above the
  !>                 diagonal are the last n - i elements of Householder vector u_(l_i).
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[out]
  !>     D           pointer to real type. Array on the GPU (the size depends on the value of strideD).
  !>                 The diagonal elements of B_l.
  !>     @param[in]
  !>     strideD     rocblas_stride.
  !>                 Stride from the start of one vector D_l to the next one D_(l+1).
  !>                 There is no restriction for the value of strideD. Normal use case is strideD >= min(m,n).
  !>     @param[out]
  !>     E           pointer to real type. Array on the GPU (the size depends on the value of strideE).
  !>                 The off-diagonal elements of B_l.
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use case is strideE >= min(m,n)-1.
  !>     @param[out]
  !>     tauq        pointer to type. Array on the GPU (the size depends on the value of strideQ).
  !>                 Contains the vectors tauq_l of Householder scalars associated with matrices Q_l.
  !>     @param[in]
  !>     strideQ     rocblas_stride.
  !>                 Stride from the start of one vector tauq_l to the next one tauq_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideQ. Normal use is strideQ >= min(m,n).
  !>     @param[out]
  !>     taup        pointer to type. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors taup_l of Householder scalars associated with matrices P_l.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector taup_l to the next one taup_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideP. Normal use is strideP >= min(m,n).
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgebd2_batched
    function rocsolver_sgebd2_batched_(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count) bind(c, name="rocsolver_sgebd2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgebd2_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: tauq
      integer(c_int64_t),value :: strideQ
      type(c_ptr),value :: taup
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgebd2_batched_full_rank,&
      
rocsolver_sgebd2_batched_rank_0,&
      
rocsolver_sgebd2_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgebd2_batched
    function rocsolver_dgebd2_batched_(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count) bind(c, name="rocsolver_dgebd2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgebd2_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: tauq
      integer(c_int64_t),value :: strideQ
      type(c_ptr),value :: taup
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgebd2_batched_full_rank,&
      
rocsolver_dgebd2_batched_rank_0,&
      
rocsolver_dgebd2_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgebd2_batched
    function rocsolver_cgebd2_batched_(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count) bind(c, name="rocsolver_cgebd2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgebd2_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: tauq
      integer(c_int64_t),value :: strideQ
      type(c_ptr),value :: taup
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgebd2_batched_full_rank,&
      
rocsolver_cgebd2_batched_rank_0,&
      
rocsolver_cgebd2_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgebd2_batched
    function rocsolver_zgebd2_batched_(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count) bind(c, name="rocsolver_zgebd2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgebd2_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: tauq
      integer(c_int64_t),value :: strideQ
      type(c_ptr),value :: taup
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgebd2_batched_full_rank,&
      
rocsolver_zgebd2_batched_rank_0,&
      
rocsolver_zgebd2_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GEBD2_STRIDED_BATCHED computes the bidiagonal form of a batch of
  !>     general m-by-n matrices.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     For each instance in the batch, the bidiagonal form is given by:
  !> 
  !>     \f[
  !>         B_l^{} = Q_l'  A_l^{}  P_l^{}
  !>     \f]
  !> 
  !>     where \f$B_l\f$ is upper bidiagonal if m >= n and lower bidiagonal if m < n, and \f$Q_l\f$ and
  !>     \f$P_l\f$ are orthogonalunitary matrices represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Q_l = H_l(1)H_l(2)\cdots H_l(n)\:  \text{and} \: P_1 = G_l(1)G_l(2)\cdots G_l(n-1), & \: \text{if}\: m >= n, \:\text{or}\\
  !>         Q_l = H_l(1)H_l(2)\cdots H_l(m-1)\:  \text{and} \: P_1 = G_l(1)G_l(2)\cdots G_l(m), & \: \text{if}\: m < n.
  !>         \end{array}
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H_l(i)\f$ and \f$G_l(i)\f$ is given by
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         H_l^{}(i) = I - \text{tauq}_l^{}[i] \cdot v_{l_i}^{} v_{l_i}', & \: \text{and}\\
  !>         G_l^{}(i) = I - \text{taup}_l^{}[i] \cdot u_{l_i}' u_{l_i}^{}.
  !>         \end{array}
  !>     \f]
  !> 
  !>     If m >= n, the first i-1 elements of the Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i] = 1\f$;
  !>     while the first i elements of the Householder vector \f$u_{l_i}\f$ are zero, and \f$u_{l_i}[i+1] = 1\f$.
  !>     If m < n, the first i elements of the Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i+1] = 1\f$;
  !>     while the first i-1 elements of the Householder vector \f$u_{l_i}\f$ are zero, and \f$u_{l_i}[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all the matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all the matrices A_l in the batch.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the m-by-n matrices A_l to be factored.
  !>                 On exit, the elements on the diagonal and superdiagonal (if m >= n), or
  !>                 subdiagonal (if m < n) contain the bidiagonal form B_l.
  !>                 If m >= n, the elements below the diagonal are the last m - i elements
  !>                 of Householder vector v_(l_i), and the elements above the
  !>                 superdiagonal are the last n - i - 1 elements of Householder vector u_(l_i).
  !>                 If m < n, the elements below the subdiagonal are the last m - i - 1
  !>                 elements of Householder vector v_(l_i), and the elements above the
  !>                 diagonal are the last n - i elements of Householder vector u_(l_i).
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     D           pointer to real type. Array on the GPU (the size depends on the value of strideD).
  !>                 The diagonal elements of B_l.
  !>     @param[in]
  !>     strideD     rocblas_stride.
  !>                 Stride from the start of one vector D_l to the next one D_(l+1).
  !>                 There is no restriction for the value of strideD. Normal use case is strideD >= min(m,n).
  !>     @param[out]
  !>     E           pointer to real type. Array on the GPU (the size depends on the value of strideE).
  !>                 The off-diagonal elements of B_l.
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use case is strideE >= min(m,n)-1.
  !>     @param[out]
  !>     tauq        pointer to type. Array on the GPU (the size depends on the value of strideQ).
  !>                 Contains the vectors tauq_l of Householder scalars associated with matrices Q_l.
  !>     @param[in]
  !>     strideQ     rocblas_stride.
  !>                 Stride from the start of one vector tauq_l to the next one tauq_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideQ. Normal use is strideQ >= min(m,n).
  !>     @param[out]
  !>     taup        pointer to type. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors taup_l of Householder scalars associated with matrices P_l.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector taup_l to the next one taup_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideP. Normal use is strideP >= min(m,n).
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgebd2_strided_batched
    function rocsolver_sgebd2_strided_batched_(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count) bind(c, name="rocsolver_sgebd2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgebd2_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: tauq
      integer(c_int64_t),value :: strideQ
      type(c_ptr),value :: taup
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgebd2_strided_batched_full_rank,&
      
rocsolver_sgebd2_strided_batched_rank_0,&
      
rocsolver_sgebd2_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgebd2_strided_batched
    function rocsolver_dgebd2_strided_batched_(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count) bind(c, name="rocsolver_dgebd2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgebd2_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: tauq
      integer(c_int64_t),value :: strideQ
      type(c_ptr),value :: taup
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgebd2_strided_batched_full_rank,&
      
rocsolver_dgebd2_strided_batched_rank_0,&
      
rocsolver_dgebd2_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgebd2_strided_batched
    function rocsolver_cgebd2_strided_batched_(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count) bind(c, name="rocsolver_cgebd2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgebd2_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: tauq
      integer(c_int64_t),value :: strideQ
      type(c_ptr),value :: taup
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgebd2_strided_batched_full_rank,&
      
rocsolver_cgebd2_strided_batched_rank_0,&
      
rocsolver_cgebd2_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgebd2_strided_batched
    function rocsolver_zgebd2_strided_batched_(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count) bind(c, name="rocsolver_zgebd2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgebd2_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: tauq
      integer(c_int64_t),value :: strideQ
      type(c_ptr),value :: taup
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgebd2_strided_batched_full_rank,&
      
rocsolver_zgebd2_strided_batched_rank_0,&
      
rocsolver_zgebd2_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GEBRD computes the bidiagonal form of a general m-by-n matrix A.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The bidiagonal form is given by:
  !> 
  !>     \f[
  !>         B = Q'  A  P
  !>     \f]
  !> 
  !>     where B is upper bidiagonal if m >= n and lower bidiagonal if m < n, and Q and
  !>     P are orthogonalunitary matrices represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Q = H(1)H(2)\cdots H(n)\:  \text{and} \: P = G(1)G(2)\cdots G(n-1), & \: \text{if}\: m >= n, \:\text{or}\\
  !>         Q = H(1)H(2)\cdots H(m-1)\:  \text{and} \: P = G(1)G(2)\cdots G(m), & \: \text{if}\: m < n.
  !>         \end{array}
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H(i)\f$ and \f$G(i)\f$ is given by
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         H(i) = I - \text{tauq}[i] \cdot v_i^{} v_i', & \: \text{and}\\
  !>         G(i) = I - \text{taup}[i] \cdot u_i' u_i^{}.
  !>         \end{array}
  !>     \f]
  !> 
  !>     If m >= n, the first i-1 elements of the Householder vector \f$v_i\f$ are zero, and \f$v_i[i] = 1\f$;
  !>     while the first i elements of the Householder vector \f$u_i\f$ are zero, and \f$u_i[i+1] = 1\f$.
  !>     If m < n, the first i elements of the Householder vector \f$v_i\f$ are zero, and \f$v_i[i+1] = 1\f$;
  !>     while the first i-1 elements of the Householder vector \f$u_i\f$ are zero, and \f$u_i[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of the matrix A.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of the matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrix to be factored.
  !>                 On exit, the elements on the diagonal and superdiagonal (if m >= n), or
  !>                 subdiagonal (if m < n) contain the bidiagonal form B.
  !>                 If m >= n, the elements below the diagonal are the last m - i elements
  !>                 of Householder vector v_i, and the elements above the
  !>                 superdiagonal are the last n - i - 1 elements of Householder vector u_i.
  !>                 If m < n, the elements below the subdiagonal are the last m - i - 1
  !>                 elements of Householder vector v_i, and the elements above the
  !>                 diagonal are the last n - i elements of Householder vector u_i.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 specifies the leading dimension of A.
  !>     @param[out]
  !>     D           pointer to real type. Array on the GPU of dimension min(m,n).
  !>                 The diagonal elements of B.
  !>     @param[out]
  !>     E           pointer to real type. Array on the GPU of dimension min(m,n)-1.
  !>                 The off-diagonal elements of B.
  !>     @param[out]
  !>     tauq        pointer to type. Array on the GPU of dimension min(m,n).
  !>                 The Householder scalars associated with matrix Q.
  !>     @param[out]
  !>     taup        pointer to type. Array on the GPU of dimension min(m,n).
  !>                 The Householder scalars associated with matrix P.
  !>     
  interface rocsolver_sgebrd
    function rocsolver_sgebrd_(handle,m,n,A,lda,D,E,tauq,taup) bind(c, name="rocsolver_sgebrd")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgebrd_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: tauq
      type(c_ptr),value :: taup
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgebrd_full_rank,&
      
rocsolver_sgebrd_rank_0,&
      
rocsolver_sgebrd_rank_1
#endif

  end interface
  
  interface rocsolver_dgebrd
    function rocsolver_dgebrd_(handle,m,n,A,lda,D,E,tauq,taup) bind(c, name="rocsolver_dgebrd")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgebrd_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: tauq
      type(c_ptr),value :: taup
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgebrd_full_rank,&
      
rocsolver_dgebrd_rank_0,&
      
rocsolver_dgebrd_rank_1
#endif

  end interface
  
  interface rocsolver_cgebrd
    function rocsolver_cgebrd_(handle,m,n,A,lda,D,E,tauq,taup) bind(c, name="rocsolver_cgebrd")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgebrd_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: tauq
      type(c_ptr),value :: taup
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgebrd_full_rank,&
      
rocsolver_cgebrd_rank_0,&
      
rocsolver_cgebrd_rank_1
#endif

  end interface
  
  interface rocsolver_zgebrd
    function rocsolver_zgebrd_(handle,m,n,A,lda,D,E,tauq,taup) bind(c, name="rocsolver_zgebrd")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgebrd_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: tauq
      type(c_ptr),value :: taup
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgebrd_full_rank,&
      
rocsolver_zgebrd_rank_0,&
      
rocsolver_zgebrd_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GEBRD_BATCHED computes the bidiagonal form of a batch of general
  !>     m-by-n matrices.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     For each instance in the batch, the bidiagonal form is given by:
  !> 
  !>     \f[
  !>         B_l^{} = Q_l'  A_l^{}  P_l^{}
  !>     \f]
  !> 
  !>     where \f$B_l\f$ is upper bidiagonal if m >= n and lower bidiagonal if m < n, and \f$Q_l\f$ and
  !>     \f$P_l\f$ are orthogonalunitary matrices represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Q_l = H_l(1)H_l(2)\cdots H_l(n)\:  \text{and} \: P_l = G_l(1)G_l(2)\cdots G_l(n-1), & \: \text{if}\: m >= n, \:\text{or}\\
  !>         Q_l = H_l(1)H_l(2)\cdots H_l(m-1)\:  \text{and} \: P_l = G_l(1)G_l(2)\cdots G_l(m), & \: \text{if}\: m < n.
  !>         \end{array}
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H_l(i)\f$ and \f$G_l(i)\f$ is given by
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         H_l^{}(i) = I - \text{tauq}_l^{}[i] \cdot v_{l_i}^{} v_{l_i}', & \: \text{and}\\
  !>         G_l^{}(i) = I - \text{taup}_l^{}[i] \cdot u_{l_i}' u_{l_i}^{}.
  !>         \end{array}
  !>     \f]
  !> 
  !>     If m >= n, the first i-1 elements of the Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i] = 1\f$;
  !>     while the first i elements of the Householder vector \f$u_{l_i}\f$ are zero, and \f$u_{l_i}[i+1] = 1\f$.
  !>     If m < n, the first i elements of the Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i+1] = 1\f$;
  !>     while the first i-1 elements of the Householder vector \f$u_{l_i}\f$ are zero, and \f$u_{l_i}[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all the matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all the matrices A_l in the batch.
  !>     @param[inout]
  !>     A           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the m-by-n matrices A_l to be factored.
  !>                 On exit, the elements on the diagonal and superdiagonal (if m >= n), or
  !>                 subdiagonal (if m < n) contain the bidiagonal form B_l.
  !>                 If m >= n, the elements below the diagonal are the last m - i elements
  !>                 of Householder vector v_(l_i), and the elements above the
  !>                 superdiagonal are the last n - i - 1 elements of Householder vector u_(l_i).
  !>                 If m < n, the elements below the subdiagonal are the last m - i - 1
  !>                 elements of Householder vector v_(l_i), and the elements above the
  !>                 diagonal are the last n - i elements of Householder vector u_(l_i).
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[out]
  !>     D           pointer to real type. Array on the GPU (the size depends on the value of strideD).
  !>                 The diagonal elements of B_l.
  !>     @param[in]
  !>     strideD     rocblas_stride.
  !>                 Stride from the start of one vector D_l to the next one D_(l+1).
  !>                 There is no restriction for the value of strideD. Normal use case is strideD >= min(m,n).
  !>     @param[out]
  !>     E           pointer to real type. Array on the GPU (the size depends on the value of strideE).
  !>                 The off-diagonal elements of B_l.
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use case is strideE >= min(m,n)-1.
  !>     @param[out]
  !>     tauq        pointer to type. Array on the GPU (the size depends on the value of strideQ).
  !>                 Contains the vectors tauq_l of Householder scalars associated with matrices Q_l.
  !>     @param[in]
  !>     strideQ     rocblas_stride.
  !>                 Stride from the start of one vector tauq_l to the next one tauq_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideQ. Normal use is strideQ >= min(m,n).
  !>     @param[out]
  !>     taup        pointer to type. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors taup_l of Householder scalars associated with matrices P_l.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector taup_l to the next one taup_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideP. Normal use is strideP >= min(m,n).
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgebrd_batched
    function rocsolver_sgebrd_batched_(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count) bind(c, name="rocsolver_sgebrd_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgebrd_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: tauq
      integer(c_int64_t),value :: strideQ
      type(c_ptr),value :: taup
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgebrd_batched_full_rank,&
      
rocsolver_sgebrd_batched_rank_0,&
      
rocsolver_sgebrd_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgebrd_batched
    function rocsolver_dgebrd_batched_(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count) bind(c, name="rocsolver_dgebrd_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgebrd_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: tauq
      integer(c_int64_t),value :: strideQ
      type(c_ptr),value :: taup
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgebrd_batched_full_rank,&
      
rocsolver_dgebrd_batched_rank_0,&
      
rocsolver_dgebrd_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgebrd_batched
    function rocsolver_cgebrd_batched_(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count) bind(c, name="rocsolver_cgebrd_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgebrd_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: tauq
      integer(c_int64_t),value :: strideQ
      type(c_ptr),value :: taup
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgebrd_batched_full_rank,&
      
rocsolver_cgebrd_batched_rank_0,&
      
rocsolver_cgebrd_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgebrd_batched
    function rocsolver_zgebrd_batched_(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count) bind(c, name="rocsolver_zgebrd_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgebrd_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: tauq
      integer(c_int64_t),value :: strideQ
      type(c_ptr),value :: taup
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgebrd_batched_full_rank,&
      
rocsolver_zgebrd_batched_rank_0,&
      
rocsolver_zgebrd_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GEBRD_STRIDED_BATCHED computes the bidiagonal form of a batch of
  !>     general m-by-n matrices.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     For each instance in the batch, the bidiagonal form is given by:
  !> 
  !>     \f[
  !>         B_l^{} = Q_l'  A_l^{}  P_l^{}
  !>     \f]
  !> 
  !>     where \f$B_l\f$ is upper bidiagonal if m >= n and lower bidiagonal if m < n, and \f$Q_l\f$ and
  !>     \f$P_l\f$ are orthogonalunitary matrices represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Q_l = H_l(1)H_l(2)\cdots H_l(n)\:  \text{and} \: P_l = G_l(1)G_l(2)\cdots G_l(n-1), & \: \text{if}\: m >= n, \:\text{or}\\
  !>         Q_l = H_l(1)H_l(2)\cdots H_l(m-1)\:  \text{and} \: P_l = G_l(1)G_l(2)\cdots G_l(m), & \: \text{if}\: m < n.
  !>         \end{array}
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H_l(i)\f$ and \f$G_l(i)\f$ is given by
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         H_l^{}(i) = I - \text{tauq}_l^{}[i] \cdot v_{l_i}^{} v_{l_i}', & \: \text{and}\\
  !>         G_l^{}(i) = I - \text{taup}_l^{}[i] \cdot u_{l_i}' u_{l_i}^{}.
  !>         \end{array}
  !>     \f]
  !> 
  !>     If m >= n, the first i-1 elements of the Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i] = 1\f$;
  !>     while the first i elements of the Householder vector \f$u_{l_i}\f$ are zero, and \f$u_{l_i}[i+1] = 1\f$.
  !>     If m < n, the first i elements of the Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i+1] = 1\f$;
  !>     while the first i-1 elements of the Householder vector \f$u_{l_i}\f$ are zero, and \f$u_{l_i}[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all the matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all the matrices A_l in the batch.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the m-by-n matrices A_l to be factored.
  !>                 On exit, the elements on the diagonal and superdiagonal (if m >= n), or
  !>                 subdiagonal (if m < n) contain the bidiagonal form B_l.
  !>                 If m >= n, the elements below the diagonal are the last m - i elements
  !>                 of Householder vector v_(l_i), and the elements above the
  !>                 superdiagonal are the last n - i - 1 elements of Householder vector u_(l_i).
  !>                 If m < n, the elements below the subdiagonal are the last m - i - 1
  !>                 elements of Householder vector v_(l_i), and the elements above the
  !>                 diagonal are the last n - i elements of Householder vector u_(l_i).
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     D           pointer to real type. Array on the GPU (the size depends on the value of strideD).
  !>                 The diagonal elements of B_l.
  !>     @param[in]
  !>     strideD     rocblas_stride.
  !>                 Stride from the start of one vector D_l to the next one D_(l+1).
  !>                 There is no restriction for the value of strideD. Normal use case is strideD >= min(m,n).
  !>     @param[out]
  !>     E           pointer to real type. Array on the GPU (the size depends on the value of strideE).
  !>                 The off-diagonal elements of B_l.
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use case is strideE >= min(m,n)-1.
  !>     @param[out]
  !>     tauq        pointer to type. Array on the GPU (the size depends on the value of strideQ).
  !>                 Contains the vectors tauq_l of Householder scalars associated with matrices Q_l.
  !>     @param[in]
  !>     strideQ     rocblas_stride.
  !>                 Stride from the start of one vector tauq_l to the next one tauq_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideQ. Normal use is strideQ >= min(m,n).
  !>     @param[out]
  !>     taup        pointer to type. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors taup_l of Householder scalars associated with matrices P_l.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector taup_l to the next one taup_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideP. Normal use is strideP >= min(m,n).
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgebrd_strided_batched
    function rocsolver_sgebrd_strided_batched_(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count) bind(c, name="rocsolver_sgebrd_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgebrd_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: tauq
      integer(c_int64_t),value :: strideQ
      type(c_ptr),value :: taup
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgebrd_strided_batched_full_rank,&
      
rocsolver_sgebrd_strided_batched_rank_0,&
      
rocsolver_sgebrd_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgebrd_strided_batched
    function rocsolver_dgebrd_strided_batched_(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count) bind(c, name="rocsolver_dgebrd_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgebrd_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: tauq
      integer(c_int64_t),value :: strideQ
      type(c_ptr),value :: taup
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgebrd_strided_batched_full_rank,&
      
rocsolver_dgebrd_strided_batched_rank_0,&
      
rocsolver_dgebrd_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgebrd_strided_batched
    function rocsolver_cgebrd_strided_batched_(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count) bind(c, name="rocsolver_cgebrd_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgebrd_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: tauq
      integer(c_int64_t),value :: strideQ
      type(c_ptr),value :: taup
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgebrd_strided_batched_full_rank,&
      
rocsolver_cgebrd_strided_batched_rank_0,&
      
rocsolver_cgebrd_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgebrd_strided_batched
    function rocsolver_zgebrd_strided_batched_(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count) bind(c, name="rocsolver_zgebrd_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgebrd_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: tauq
      integer(c_int64_t),value :: strideQ
      type(c_ptr),value :: taup
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgebrd_strided_batched_full_rank,&
      
rocsolver_zgebrd_strided_batched_rank_0,&
      
rocsolver_zgebrd_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GETRS solves a system of n linear equations on n variables in its factorized form.
  !> 
  !>     \details
  !>     It solves one of the following systems, depending on the value of trans:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A X = B & \: \text{not transposed,}\\
  !>         A^T X = B & \: \text{transposed, or}\\
  !>         A^H X = B & \: \text{conjugate transposed.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Matrix A is defined by its triangular factors as returned by \ref rocsolver_sgetrf "GETRF".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     trans       rocblas_operation.
  !>                 Specifies the form of the system of equations.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The order of the system, i.e. the number of columns and rows of A.
  !>     @param[in]
  !>     nrhs        rocblas_int. nrhs >= 0.
  !>                 The number of right hand sides, i.e., the number of columns
  !>                 of the matrix B.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 The factors L and U of the factorization A = PLU returned by \ref rocsolver_sgetrf "GETRF".
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 The leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to rocblas_int. Array on the GPU of dimension n.
  !>                 The pivot indices returned by \ref rocsolver_sgetrf "GETRF".
  !>     @param[inout]
  !>     B           pointer to type. Array on the GPU of dimension ldbnrhs.
  !>                 On entry, the right hand side matrix B.
  !>                 On exit, the solution matrix X.
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 The leading dimension of B.
  !>    
  interface rocsolver_sgetrs
    function rocsolver_sgetrs_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb) bind(c, name="rocsolver_sgetrs")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrs_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgetrs_full_rank,&
      
rocsolver_sgetrs_rank_0,&
      
rocsolver_sgetrs_rank_1
#endif

  end interface
  
  interface rocsolver_dgetrs
    function rocsolver_dgetrs_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb) bind(c, name="rocsolver_dgetrs")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrs_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgetrs_full_rank,&
      
rocsolver_dgetrs_rank_0,&
      
rocsolver_dgetrs_rank_1
#endif

  end interface
  
  interface rocsolver_cgetrs
    function rocsolver_cgetrs_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb) bind(c, name="rocsolver_cgetrs")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrs_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgetrs_full_rank,&
      
rocsolver_cgetrs_rank_0,&
      
rocsolver_cgetrs_rank_1
#endif

  end interface
  
  interface rocsolver_zgetrs
    function rocsolver_zgetrs_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb) bind(c, name="rocsolver_zgetrs")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrs_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgetrs_full_rank,&
      
rocsolver_zgetrs_rank_0,&
      
rocsolver_zgetrs_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GETRS_BATCHED solves a batch of systems of n linear equations on n
  !>     variables in its factorized forms.
  !> 
  !>     \details
  !>     For each instance l in the batch, it solves one of the following systems, depending on the value of trans:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l X_l = B_l & \: \text{not transposed,}\\
  !>         A_l^T X_l^{} = B_l^{} & \: \text{transposed, or}\\
  !>         A_l^H X_l^{} = B_l^{} & \: \text{conjugate transposed.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Matrix \f$A_l\f$ is defined by its triangular factors as returned by \ref rocsolver_sgetrf_batched "GETRF_BATCHED".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     trans       rocblas_operation.
  !>                 Specifies the form of the system of equations of each instance in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The order of the system, i.e. the number of columns and rows of all A_l matrices.
  !>     @param[in]
  !>     nrhs        rocblas_int. nrhs >= 0.
  !>                 The number of right hand sides, i.e., the number of columns
  !>                 of all the matrices B_l.
  !>     @param[in]
  !>     A           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 The factors L_l and U_l of the factorization A_l = P_lL_lU_l returned by \ref rocsolver_sgetrf_batched "GETRF_BATCHED".
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 The leading dimension of matrices A_l.
  !>     @param[in]
  !>     ipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors ipiv_l of pivot indices returned by \ref rocsolver_sgetrf_batched "GETRF_BATCHED".
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value of strideP. Normal use case is strideP >= n.
  !>     @param[inout]
  !>     B           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldbnrhs.
  !>                 On entry, the right hand side matrices B_l.
  !>                 On exit, the solution matrix X_l of each system in the batch.
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 The leading dimension of matrices B_l.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of instances (systems) in the batch.
  !>    
  interface rocsolver_sgetrs_batched
    function rocsolver_sgetrs_batched_(handle,trans,n,nrhs,A,lda,ipiv,strideP,B,ldb,batch_count) bind(c, name="rocsolver_sgetrs_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrs_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgetrs_batched_full_rank,&
      
rocsolver_sgetrs_batched_rank_0,&
      
rocsolver_sgetrs_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgetrs_batched
    function rocsolver_dgetrs_batched_(handle,trans,n,nrhs,A,lda,ipiv,strideP,B,ldb,batch_count) bind(c, name="rocsolver_dgetrs_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrs_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgetrs_batched_full_rank,&
      
rocsolver_dgetrs_batched_rank_0,&
      
rocsolver_dgetrs_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgetrs_batched
    function rocsolver_cgetrs_batched_(handle,trans,n,nrhs,A,lda,ipiv,strideP,B,ldb,batch_count) bind(c, name="rocsolver_cgetrs_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrs_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgetrs_batched_full_rank,&
      
rocsolver_cgetrs_batched_rank_0,&
      
rocsolver_cgetrs_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgetrs_batched
    function rocsolver_zgetrs_batched_(handle,trans,n,nrhs,A,lda,ipiv,strideP,B,ldb,batch_count) bind(c, name="rocsolver_zgetrs_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrs_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgetrs_batched_full_rank,&
      
rocsolver_zgetrs_batched_rank_0,&
      
rocsolver_zgetrs_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GETRS_STRIDED_BATCHED solves a batch of systems of n linear equations
  !>     on n variables in its factorized forms.
  !> 
  !>     \details
  !>     For each instance l in the batch, it solves one of the following systems, depending on the value of trans:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l X_l = B_l & \: \text{not transposed,}\\
  !>         A_l^T X_l^{} = B_l^{} & \: \text{transposed, or}\\
  !>         A_l^H X_l^{} = B_l^{} & \: \text{conjugate transposed.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Matrix \f$A_l\f$ is defined by its triangular factors as returned by \ref rocsolver_sgetrf_strided_batched "GETRF_STRIDED_BATCHED".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     trans       rocblas_operation.
  !>                 Specifies the form of the system of equations of each instance in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The order of the system, i.e. the number of columns and rows of all A_l matrices.
  !>     @param[in]
  !>     nrhs        rocblas_int. nrhs >= 0.
  !>                 The number of right hand sides, i.e., the number of columns
  !>                 of all the matrices B_l.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 The factors L_l and U_l of the factorization A_l = P_lL_lU_l returned by \ref rocsolver_sgetrf_strided_batched "GETRF_STRIDED_BATCHED".
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 The leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[in]
  !>     ipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors ipiv_l of pivot indices returned by \ref rocsolver_sgetrf_strided_batched "GETRF_STRIDED_BATCHED".
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value of strideP. Normal use case is strideP >= n.
  !>     @param[inout]
  !>     B           pointer to type. Array on the GPU (size depends on the value of strideB).
  !>                 On entry, the right hand side matrices B_l.
  !>                 On exit, the solution matrix X_l of each system in the batch.
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 The leading dimension of matrices B_l.
  !>     @param[in]
  !>     strideB     rocblas_stride.
  !>                 Stride from the start of one matrix B_l to the next one B_(l+1).
  !>                 There is no restriction for the value of strideB. Normal use case is strideB >= ldbnrhs.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of instances (systems) in the batch.
  !>    
  interface rocsolver_sgetrs_strided_batched
    function rocsolver_sgetrs_strided_batched_(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,batch_count) bind(c, name="rocsolver_sgetrs_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrs_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgetrs_strided_batched_full_rank,&
      
rocsolver_sgetrs_strided_batched_rank_0,&
      
rocsolver_sgetrs_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgetrs_strided_batched
    function rocsolver_dgetrs_strided_batched_(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,batch_count) bind(c, name="rocsolver_dgetrs_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrs_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgetrs_strided_batched_full_rank,&
      
rocsolver_dgetrs_strided_batched_rank_0,&
      
rocsolver_dgetrs_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgetrs_strided_batched
    function rocsolver_cgetrs_strided_batched_(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,batch_count) bind(c, name="rocsolver_cgetrs_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrs_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgetrs_strided_batched_full_rank,&
      
rocsolver_cgetrs_strided_batched_rank_0,&
      
rocsolver_cgetrs_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgetrs_strided_batched
    function rocsolver_zgetrs_strided_batched_(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,batch_count) bind(c, name="rocsolver_zgetrs_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrs_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgetrs_strided_batched_full_rank,&
      
rocsolver_zgetrs_strided_batched_rank_0,&
      
rocsolver_zgetrs_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GESV solves a general system of n linear equations on n variables.
  !> 
  !>     \details
  !>     The linear system is of the form
  !> 
  !>     \f[
  !>         A X = B
  !>     \f]
  !> 
  !>     where A is a general n-by-n matrix. Matrix A is first factorized in triangular factors L and U
  !>     using \ref rocsolver_sgetrf "GETRF"; then, the solution is computed with \ref rocsolver_sgetrs "GETRS".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The order of the system, i.e. the number of columns and rows of A.
  !>     @param[in]
  !>     nrhs        rocblas_int. nrhs >= 0.
  !>                 The number of right hand sides, i.e., the number of columns
  !>                 of the matrix B.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A.
  !>                 On exit, if info = 0, the factors L and U of the LU decomposition of A returned by
  !>                 \ref rocsolver_sgetrf "GETRF".
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 The leading dimension of A.
  !>     @param[out]
  !>     ipiv        pointer to rocblas_int. Array on the GPU of dimension n.
  !>                 The pivot indices returned by \ref rocsolver_sgetrf "GETRF".
  !>     @param[inout]
  !>     B           pointer to type. Array on the GPU of dimension ldbnrhs.
  !>                 On entry, the right hand side matrix B.
  !>                 On exit, the solution matrix X.
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 The leading dimension of B.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0, U is singular, and the solution could not be computed.
  !>                 U[i,i] is the first zero element in the diagonal.
  !>    
  interface rocsolver_sgesv
    function rocsolver_sgesv_(handle,n,nrhs,A,lda,ipiv,B,ldb,myInfo) bind(c, name="rocsolver_sgesv")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesv_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgesv_full_rank,&
      
rocsolver_sgesv_rank_0,&
      
rocsolver_sgesv_rank_1
#endif

  end interface
  
  interface rocsolver_dgesv
    function rocsolver_dgesv_(handle,n,nrhs,A,lda,ipiv,B,ldb,myInfo) bind(c, name="rocsolver_dgesv")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesv_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgesv_full_rank,&
      
rocsolver_dgesv_rank_0,&
      
rocsolver_dgesv_rank_1
#endif

  end interface
  
  interface rocsolver_cgesv
    function rocsolver_cgesv_(handle,n,nrhs,A,lda,ipiv,B,ldb,myInfo) bind(c, name="rocsolver_cgesv")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesv_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgesv_full_rank,&
      
rocsolver_cgesv_rank_0,&
      
rocsolver_cgesv_rank_1
#endif

  end interface
  
  interface rocsolver_zgesv
    function rocsolver_zgesv_(handle,n,nrhs,A,lda,ipiv,B,ldb,myInfo) bind(c, name="rocsolver_zgesv")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesv_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgesv_full_rank,&
      
rocsolver_zgesv_rank_0,&
      
rocsolver_zgesv_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GESV_BATCHED solves a batch of general systems of n linear equations on n
  !>     variables.
  !> 
  !>     \details
  !>     The linear systems are of the form
  !> 
  !>     \f[
  !>         A_l X_l = B_l
  !>     \f]
  !> 
  !>     where \f$A_l\f$ is a general n-by-n matrix. Matrix \f$A_l\f$ is first factorized in triangular factors \f$L_l\f$ and \f$U_l\f$
  !>     using \ref rocsolver_sgetrf_batched "GETRF_BATCHED"; then, the solutions are computed with \ref rocsolver_sgetrs_batched "GETRS_BATCHED".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The order of the system, i.e. the number of columns and rows of all A_l matrices.
  !>     @param[in]
  !>     nrhs        rocblas_int. nrhs >= 0.
  !>                 The number of right hand sides, i.e., the number of columns
  !>                 of all the matrices B_l.
  !>     @param[inout]
  !>     A           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the matrices A_l.
  !>                 On exit, if info[l] = 0, the factors L_l and U_l of the LU decomposition of A_l returned by
  !>                 \ref rocsolver_sgetrf_batched "GETRF_BATCHED".
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 The leading dimension of matrices A_l.
  !>     @param[out]
  !>     ipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).
  !>                 The vectors ipiv_l of pivot indices returned by \ref rocsolver_sgetrf_batched "GETRF_BATCHED".
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value of strideP. Normal use case is strideP >= n.
  !>     @param[inout]
  !>     B           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldbnrhs.
  !>                 On entry, the right hand side matrices B_l.
  !>                 On exit, the solution matrix X_l of each system in the batch.
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 The leading dimension of matrices B_l.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for A_l.
  !>                 If info[l] = i > 0, U_l is singular, and the solution could not be computed.
  !>                 U_l[i,i] is the first zero element in the diagonal.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of instances (systems) in the batch.
  !>    
  interface rocsolver_sgesv_batched
    function rocsolver_sgesv_batched_(handle,n,nrhs,A,lda,ipiv,strideP,B,ldb,myInfo,batch_count) bind(c, name="rocsolver_sgesv_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesv_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgesv_batched_full_rank,&
      
rocsolver_sgesv_batched_rank_0,&
      
rocsolver_sgesv_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgesv_batched
    function rocsolver_dgesv_batched_(handle,n,nrhs,A,lda,ipiv,strideP,B,ldb,myInfo,batch_count) bind(c, name="rocsolver_dgesv_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesv_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgesv_batched_full_rank,&
      
rocsolver_dgesv_batched_rank_0,&
      
rocsolver_dgesv_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgesv_batched
    function rocsolver_cgesv_batched_(handle,n,nrhs,A,lda,ipiv,strideP,B,ldb,myInfo,batch_count) bind(c, name="rocsolver_cgesv_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesv_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgesv_batched_full_rank,&
      
rocsolver_cgesv_batched_rank_0,&
      
rocsolver_cgesv_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgesv_batched
    function rocsolver_zgesv_batched_(handle,n,nrhs,A,lda,ipiv,strideP,B,ldb,myInfo,batch_count) bind(c, name="rocsolver_zgesv_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesv_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgesv_batched_full_rank,&
      
rocsolver_zgesv_batched_rank_0,&
      
rocsolver_zgesv_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GESV_STRIDED_BATCHED solves a batch of general systems of n linear equations
  !>     on n variables.
  !> 
  !>     \details
  !>     The linear systems are of the form
  !> 
  !>     \f[
  !>         A_l X_l = B_l
  !>     \f]
  !> 
  !>     where \f$A_l\f$ is a general n-by-n matrix. Matrix \f$A_l\f$ is first factorized in triangular factors \f$L_l\f$ and \f$U_l\f$
  !>     using \ref rocsolver_sgetrf_strided_batched "GETRF_STRIDED_BATCHED"; then, the solutions are computed with
  !>     \ref rocsolver_sgetrs_strided_batched "GETRS_STRIDED_BATCHED".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The order of the system, i.e. the number of columns and rows of all A_l matrices.
  !>     @param[in]
  !>     nrhs        rocblas_int. nrhs >= 0.
  !>                 The number of right hand sides, i.e., the number of columns
  !>                 of all the matrices B_l.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the matrices A_l.
  !>                 On exit, if info[l] = 0, the factors L_l and U_l of the LU decomposition of A_l returned by
  !>                 \ref rocsolver_sgetrf_strided_batched "GETRF_STRIDED_BATCHED".
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 The leading dimension of matrices A_l.
  !>     @param[inout]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     ipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).
  !>                 The vectors ipiv_l of pivot indices returned by \ref rocsolver_sgetrf_strided_batched "GETRF_STRIDED_BATCHED".
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value of strideP. Normal use case is strideP >= n.
  !>     @param[inout]
  !>     B           pointer to type. Array on the GPU (size depends on the value of strideB).
  !>                 On entry, the right hand side matrices B_l.
  !>                 On exit, the solution matrix X_l of each system in the batch.
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 The leading dimension of matrices B_l.
  !>     @param[in]
  !>     strideB     rocblas_stride.
  !>                 Stride from the start of one matrix B_l to the next one B_(l+1).
  !>                 There is no restriction for the value of strideB. Normal use case is strideB >= ldbnrhs.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for A_l.
  !>                 If info[l] = i > 0, U_l is singular, and the solution could not be computed.
  !>                 U_l[i,i] is the first zero element in the diagonal.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of instances (systems) in the batch.
  !>    
  interface rocsolver_sgesv_strided_batched
    function rocsolver_sgesv_strided_batched_(handle,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batch_count) bind(c, name="rocsolver_sgesv_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesv_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgesv_strided_batched_full_rank,&
      
rocsolver_sgesv_strided_batched_rank_0,&
      
rocsolver_sgesv_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgesv_strided_batched
    function rocsolver_dgesv_strided_batched_(handle,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batch_count) bind(c, name="rocsolver_dgesv_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesv_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgesv_strided_batched_full_rank,&
      
rocsolver_dgesv_strided_batched_rank_0,&
      
rocsolver_dgesv_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgesv_strided_batched
    function rocsolver_cgesv_strided_batched_(handle,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batch_count) bind(c, name="rocsolver_cgesv_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesv_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgesv_strided_batched_full_rank,&
      
rocsolver_cgesv_strided_batched_rank_0,&
      
rocsolver_cgesv_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgesv_strided_batched
    function rocsolver_zgesv_strided_batched_(handle,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batch_count) bind(c, name="rocsolver_zgesv_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesv_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgesv_strided_batched_full_rank,&
      
rocsolver_zgesv_strided_batched_rank_0,&
      
rocsolver_zgesv_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GETRI inverts a general n-by-n matrix A using the LU factorization
  !>     computed by \ref rocsolver_sgetrf "GETRF".
  !> 
  !>     \details
  !>     The inverse is computed by solving the linear system
  !> 
  !>     \f[
  !>         A^{-1}L = U^{-1}
  !>     \f]
  !> 
  !>     where L is the lower triangular factor of A with unit diagonal elements, and U is the
  !>     upper triangular factor.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of the matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the factors L and U of the factorization A = PLU returned by \ref rocsolver_sgetrf "GETRF".
  !>                 On exit, the inverse of A if info = 0; otherwise undefined.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to rocblas_int. Array on the GPU of dimension n.
  !>                 The pivot indices returned by \ref rocsolver_sgetrf "GETRF".
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0, U is singular. U[i,i] is the first zero pivot.
  !>     
  interface rocsolver_sgetri
    function rocsolver_sgetri_(handle,n,A,lda,ipiv,myInfo) bind(c, name="rocsolver_sgetri")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgetri_full_rank,&
      
rocsolver_sgetri_rank_0,&
      
rocsolver_sgetri_rank_1
#endif

  end interface
  
  interface rocsolver_dgetri
    function rocsolver_dgetri_(handle,n,A,lda,ipiv,myInfo) bind(c, name="rocsolver_dgetri")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgetri_full_rank,&
      
rocsolver_dgetri_rank_0,&
      
rocsolver_dgetri_rank_1
#endif

  end interface
  
  interface rocsolver_cgetri
    function rocsolver_cgetri_(handle,n,A,lda,ipiv,myInfo) bind(c, name="rocsolver_cgetri")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgetri_full_rank,&
      
rocsolver_cgetri_rank_0,&
      
rocsolver_cgetri_rank_1
#endif

  end interface
  
  interface rocsolver_zgetri
    function rocsolver_zgetri_(handle,n,A,lda,ipiv,myInfo) bind(c, name="rocsolver_zgetri")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgetri_full_rank,&
      
rocsolver_zgetri_rank_0,&
      
rocsolver_zgetri_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GETRI_BATCHED inverts a batch of general n-by-n matrices using
  !>     the LU factorization computed by \ref rocsolver_sgetrf_batched "GETRF_BATCHED".
  !> 
  !>     \details
  !>     The inverse of matrix \f$A_l\f$ in the batch is computed by solving the linear system
  !> 
  !>     \f[
  !>         A_l^{-1} L_l^{} = U_l^{-1}
  !>     \f]
  !> 
  !>     where \f$L_l\f$ is the lower triangular factor of \f$A_l\f$ with unit diagonal elements, and \f$U_l\f$ is the
  !>     upper triangular factor.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of all matrices A_l in the batch.
  !>     @param[inout]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the factors L_l and U_l of the factorization A_l = P_lL_lU_l returned by
  !>                 \ref rocsolver_sgetrf_batched "GETRF_BATCHED".
  !>                 On exit, the inverses of A_l if info[l] = 0; otherwise undefined.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     ipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).
  !>                 The pivot indices returned by \ref rocsolver_sgetrf_batched "GETRF_BATCHED".
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+j).
  !>                 There is no restriction for the value of strideP. Normal use case is strideP >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for inversion of A_l.
  !>                 If info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgetri_batched
    function rocsolver_sgetri_batched_(handle,n,A,lda,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_sgetri_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgetri_batched_full_rank,&
      
rocsolver_sgetri_batched_rank_0,&
      
rocsolver_sgetri_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgetri_batched
    function rocsolver_dgetri_batched_(handle,n,A,lda,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_dgetri_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgetri_batched_full_rank,&
      
rocsolver_dgetri_batched_rank_0,&
      
rocsolver_dgetri_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgetri_batched
    function rocsolver_cgetri_batched_(handle,n,A,lda,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_cgetri_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgetri_batched_full_rank,&
      
rocsolver_cgetri_batched_rank_0,&
      
rocsolver_cgetri_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgetri_batched
    function rocsolver_zgetri_batched_(handle,n,A,lda,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_zgetri_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgetri_batched_full_rank,&
      
rocsolver_zgetri_batched_rank_0,&
      
rocsolver_zgetri_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GETRI_STRIDED_BATCHED inverts a batch of general n-by-n matrices
  !>     using the LU factorization computed by \ref rocsolver_sgetrf_strided_batched "GETRF_STRIDED_BATCHED".
  !> 
  !>     \details
  !>     The inverse of matrix \f$A_l\f$ in the batch is computed by solving the linear system
  !> 
  !>     \f[
  !>         A_l^{-1} L_l^{} = U_l^{-1}
  !>     \f]
  !> 
  !>     where \f$L_l\f$ is the lower triangular factor of \f$A_l\f$ with unit diagonal elements, and \f$U_l\f$ is the
  !>     upper triangular factor.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of all matrices A_l in the batch.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the factors L_l and U_l of the factorization A_l = P_lL_lU_l returned by
  !>                 \ref rocsolver_sgetrf_strided_batched "GETRF_STRIDED_BATCHED".
  !>                 On exit, the inverses of A_l if info[l] = 0; otherwise undefined.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan
  !>     @param[in]
  !>     ipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).
  !>                 The pivot indices returned by \ref rocsolver_sgetrf_strided_batched "GETRF_STRIDED_BATCHED".
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value of strideP. Normal use case is strideP >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for inversion of A_l.
  !>                 If info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgetri_strided_batched
    function rocsolver_sgetri_strided_batched_(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_sgetri_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgetri_strided_batched_full_rank,&
      
rocsolver_sgetri_strided_batched_rank_0,&
      
rocsolver_sgetri_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgetri_strided_batched
    function rocsolver_dgetri_strided_batched_(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_dgetri_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgetri_strided_batched_full_rank,&
      
rocsolver_dgetri_strided_batched_rank_0,&
      
rocsolver_dgetri_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgetri_strided_batched
    function rocsolver_cgetri_strided_batched_(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_cgetri_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgetri_strided_batched_full_rank,&
      
rocsolver_cgetri_strided_batched_rank_0,&
      
rocsolver_cgetri_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgetri_strided_batched
    function rocsolver_zgetri_strided_batched_(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_zgetri_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgetri_strided_batched_full_rank,&
      
rocsolver_zgetri_strided_batched_rank_0,&
      
rocsolver_zgetri_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GETRI_NPVT inverts a general n-by-n matrix A using the LU factorization
  !>     computed by \ref rocsolver_sgetrf_npvt "GETRF_NPVT".
  !> 
  !>     \details
  !>     The inverse is computed by solving the linear system
  !> 
  !>     \f[
  !>         A^{-1}L = U^{-1}
  !>     \f]
  !> 
  !>     where L is the lower triangular factor of A with unit diagonal elements, and U is the
  !>     upper triangular factor.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of the matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the factors L and U of the factorization A = LU returned by \ref rocsolver_sgetrf_npvt "GETRF_NPVT".
  !>                 On exit, the inverse of A if info = 0; otherwise undefined.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0, U is singular. U[i,i] is the first zero pivot.
  !>     
  interface rocsolver_sgetri_npvt
    function rocsolver_sgetri_npvt_(handle,n,A,lda,myInfo) bind(c, name="rocsolver_sgetri_npvt")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_npvt_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgetri_npvt_full_rank,&
      
rocsolver_sgetri_npvt_rank_0,&
      
rocsolver_sgetri_npvt_rank_1
#endif

  end interface
  
  interface rocsolver_dgetri_npvt
    function rocsolver_dgetri_npvt_(handle,n,A,lda,myInfo) bind(c, name="rocsolver_dgetri_npvt")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_npvt_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgetri_npvt_full_rank,&
      
rocsolver_dgetri_npvt_rank_0,&
      
rocsolver_dgetri_npvt_rank_1
#endif

  end interface
  
  interface rocsolver_cgetri_npvt
    function rocsolver_cgetri_npvt_(handle,n,A,lda,myInfo) bind(c, name="rocsolver_cgetri_npvt")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_npvt_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgetri_npvt_full_rank,&
      
rocsolver_cgetri_npvt_rank_0,&
      
rocsolver_cgetri_npvt_rank_1
#endif

  end interface
  
  interface rocsolver_zgetri_npvt
    function rocsolver_zgetri_npvt_(handle,n,A,lda,myInfo) bind(c, name="rocsolver_zgetri_npvt")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_npvt_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgetri_npvt_full_rank,&
      
rocsolver_zgetri_npvt_rank_0,&
      
rocsolver_zgetri_npvt_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GETRI_NPVT_BATCHED inverts a batch of general n-by-n matrices using
  !>     the LU factorization computed by \ref rocsolver_sgetrf_npvt_batched "GETRF_NPVT_BATCHED".
  !> 
  !>     \details
  !>     The inverse of matrix \f$A_l\f$ in the batch is computed by solving the linear system
  !> 
  !>     \f[
  !>         A_l^{-1} L_l^{} = U_l^{-1}
  !>     \f]
  !> 
  !>     where \f$L_l\f$ is the lower triangular factor of \f$A_l\f$ with unit diagonal elements, and \f$U_l\f$ is the
  !>     upper triangular factor.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of all matrices A_l in the batch.
  !>     @param[inout]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the factors L_l and U_l of the factorization A_l = L_lU_l returned by
  !>                 \ref rocsolver_sgetrf_npvt_batched "GETRF_NPVT_BATCHED".
  !>                 On exit, the inverses of A_l if info[l] = 0; otherwise undefined.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for inversion of A_l.
  !>                 If info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgetri_npvt_batched
    function rocsolver_sgetri_npvt_batched_(handle,n,A,lda,myInfo,batch_count) bind(c, name="rocsolver_sgetri_npvt_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_npvt_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgetri_npvt_batched_full_rank,&
      
rocsolver_sgetri_npvt_batched_rank_0,&
      
rocsolver_sgetri_npvt_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgetri_npvt_batched
    function rocsolver_dgetri_npvt_batched_(handle,n,A,lda,myInfo,batch_count) bind(c, name="rocsolver_dgetri_npvt_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_npvt_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgetri_npvt_batched_full_rank,&
      
rocsolver_dgetri_npvt_batched_rank_0,&
      
rocsolver_dgetri_npvt_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgetri_npvt_batched
    function rocsolver_cgetri_npvt_batched_(handle,n,A,lda,myInfo,batch_count) bind(c, name="rocsolver_cgetri_npvt_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_npvt_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgetri_npvt_batched_full_rank,&
      
rocsolver_cgetri_npvt_batched_rank_0,&
      
rocsolver_cgetri_npvt_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgetri_npvt_batched
    function rocsolver_zgetri_npvt_batched_(handle,n,A,lda,myInfo,batch_count) bind(c, name="rocsolver_zgetri_npvt_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_npvt_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgetri_npvt_batched_full_rank,&
      
rocsolver_zgetri_npvt_batched_rank_0,&
      
rocsolver_zgetri_npvt_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GETRI_NPVT_STRIDED_BATCHED inverts a batch of general n-by-n matrices
  !>     using the LU factorization computed by \ref rocsolver_sgetrf_npvt_strided_batched "GETRF_NPVT_STRIDED_BATCHED".
  !> 
  !>     \details
  !>     The inverse of matrix \f$A_l\f$ in the batch is computed by solving the linear system
  !> 
  !>     \f[
  !>         A_l^{-1} L_l^{} = U_l^{-1}
  !>     \f]
  !> 
  !>     where \f$L_l\f$ is the lower triangular factor of \f$A_l\f$ with unit diagonal elements, and \f$U_l\f$ is the
  !>     upper triangular factor.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of all matrices A_l in the batch.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the factors L_l and U_l of the factorization A_l = L_lU_l returned by
  !>                 \ref rocsolver_sgetrf_npvt_strided_batched "GETRF_NPVT_STRIDED_BATCHED".
  !>                 On exit, the inverses of A_l if info[l] = 0; otherwise undefined.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for inversion of A_l.
  !>                 If info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgetri_npvt_strided_batched
    function rocsolver_sgetri_npvt_strided_batched_(handle,n,A,lda,strideA,myInfo,batch_count) bind(c, name="rocsolver_sgetri_npvt_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_npvt_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgetri_npvt_strided_batched_full_rank,&
      
rocsolver_sgetri_npvt_strided_batched_rank_0,&
      
rocsolver_sgetri_npvt_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgetri_npvt_strided_batched
    function rocsolver_dgetri_npvt_strided_batched_(handle,n,A,lda,strideA,myInfo,batch_count) bind(c, name="rocsolver_dgetri_npvt_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_npvt_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgetri_npvt_strided_batched_full_rank,&
      
rocsolver_dgetri_npvt_strided_batched_rank_0,&
      
rocsolver_dgetri_npvt_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgetri_npvt_strided_batched
    function rocsolver_cgetri_npvt_strided_batched_(handle,n,A,lda,strideA,myInfo,batch_count) bind(c, name="rocsolver_cgetri_npvt_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_npvt_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgetri_npvt_strided_batched_full_rank,&
      
rocsolver_cgetri_npvt_strided_batched_rank_0,&
      
rocsolver_cgetri_npvt_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgetri_npvt_strided_batched
    function rocsolver_zgetri_npvt_strided_batched_(handle,n,A,lda,strideA,myInfo,batch_count) bind(c, name="rocsolver_zgetri_npvt_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_npvt_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgetri_npvt_strided_batched_full_rank,&
      
rocsolver_zgetri_npvt_strided_batched_rank_0,&
      
rocsolver_zgetri_npvt_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GELS solves an overdetermined (or underdetermined) linear system defined by an m-by-n
  !>     matrix A, and a corresponding matrix B, using the QR factorization computed by \ref rocsolver_sgeqrf "GEQRF" (or the LQ
  !>     factorization computed by \ref rocsolver_sgelqf "GELQF").
  !> 
  !>     \details
  !>     Depending on the value of trans, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A X = B & \: \text{not transposed, or}\\
  !>         A' X = B & \: \text{transposed if real, or conjugate transposed if complex}
  !>         \end{array}
  !>     \f]
  !> 
  !>     If m >= n (or m < n in the case of transposeconjugate transpose), the system is overdetermined
  !>     and a least-squares solution approximating X is found by minimizing
  !> 
  !>     \f[
  !>         || B - A  X || \quad \text{(or} \: || B - A' X ||\text{)}
  !>     \f]
  !> 
  !>     If m < n (or m >= n in the case of transposeconjugate transpose), the system is underdetermined
  !>     and a unique solution for X is chosen such that \f$|| X ||\f$ is minimal.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     trans       rocblas_operation.
  !>                 Specifies the form of the system of equations.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of matrix A.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of matrix A.
  !>     @param[in]
  !>     nrhs        rocblas_int. nrhs >= 0.
  !>                 The number of columns of matrices B and X;
  !>                 i.e., the columns on the right hand side.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A.
  !>                 On exit, the QR (or LQ) factorization of A as returned by \ref rocsolver_sgeqrf "GEQRF" (or \ref rocsolver_sgelqf "GELQF").
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrix A.
  !>     @param[inout]
  !>     B           pointer to type. Array on the GPU of dimension ldbnrhs.
  !>                 On entry, the matrix B.
  !>                 On exit, when info = 0, B is overwritten by the solution vectors (and the residuals in
  !>                 the overdetermined cases) stored as columns.
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= max(m,n).
  !>                 Specifies the leading dimension of matrix B.
  !>     @param[out]
  !>     info        pointer to rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0, the solution could not be computed because input matrix A is
  !>                 rank deficient; the i-th diagonal element of its triangular factor is zero.
  !>     
  interface rocsolver_sgels
    function rocsolver_sgels_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo) bind(c, name="rocsolver_sgels")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgels_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgels_full_rank,&
      
rocsolver_sgels_rank_0,&
      
rocsolver_sgels_rank_1
#endif

  end interface
  
  interface rocsolver_dgels
    function rocsolver_dgels_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo) bind(c, name="rocsolver_dgels")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgels_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgels_full_rank,&
      
rocsolver_dgels_rank_0,&
      
rocsolver_dgels_rank_1
#endif

  end interface
  
  interface rocsolver_cgels
    function rocsolver_cgels_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo) bind(c, name="rocsolver_cgels")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgels_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgels_full_rank,&
      
rocsolver_cgels_rank_0,&
      
rocsolver_cgels_rank_1
#endif

  end interface
  
  interface rocsolver_zgels
    function rocsolver_zgels_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo) bind(c, name="rocsolver_zgels")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgels_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgels_full_rank,&
      
rocsolver_zgels_rank_0,&
      
rocsolver_zgels_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GELS_BATCHED solves a batch of overdetermined (or underdetermined) linear systems
  !>     defined by a set of m-by-n matrices \f$A_l\f$, and corresponding matrices \f$B_l\f$, using the
  !>     QR factorizations computed by \ref rocsolver_sgeqrf_batched "GEQRF_BATCHED" (or the LQ factorizations computed by \ref rocsolver_sgelqf_batched "GELQF_BATCHED").
  !> 
  !>     \details
  !>     For each instance in the batch, depending on the value of trans, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l X_l = B_l & \: \text{not transposed, or}\\
  !>         A_l' X_l^{} = B_l^{} & \: \text{transposed if real, or conjugate transposed if complex}
  !>         \end{array}
  !>     \f]
  !> 
  !>     If m >= n (or m < n in the case of transposeconjugate transpose), the system is overdetermined
  !>     and a least-squares solution approximating X_l is found by minimizing
  !> 
  !>     \f[
  !>         || B_l - A_l  X_l || \quad \text{(or} \: || B_l^{} - A_l' X_l^{} ||\text{)}
  !>     \f]
  !> 
  !>     If m < n (or m >= n in the case of transposeconjugate transpose), the system is underdetermined
  !>     and a unique solution for X_l is chosen such that \f$|| X_l ||\f$ is minimal.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     trans       rocblas_operation.
  !>                 Specifies the form of the system of equations.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all matrices A_l in the batch.
  !>     @param[in]
  !>     nrhs        rocblas_int. nrhs >= 0.
  !>                 The number of columns of all matrices B_l and X_l in the batch;
  !>                 i.e., the columns on the right hand side.
  !>     @param[inout]
  !>     A           array of pointer to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the matrices A_l.
  !>                 On exit, the QR (or LQ) factorizations of A_l as returned by \ref rocsolver_sgeqrf_batched "GEQRF_BATCHED"
  !>                 (or \ref rocsolver_sgelqf_batched "GELQF_BATCHED").
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[inout]
  !>     B           array of pointer to type. Each pointer points to an array on the GPU of dimension ldbnrhs.
  !>                 On entry, the matrices B_l.
  !>                 On exit, when info[l] = 0, B_l is overwritten by the solution vectors (and the residuals in
  !>                 the overdetermined cases) stored as columns.
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= max(m,n).
  !>                 Specifies the leading dimension of matrices B_l.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for solution of A_l.
  !>                 If info[l] = i > 0, the solution of A_l could not be computed because input
  !>                 matrix A_l is rank deficient; the i-th diagonal element of its triangular factor is zero.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgels_batched
    function rocsolver_sgels_batched_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,batch_count) bind(c, name="rocsolver_sgels_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgels_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgels_batched_full_rank,&
      
rocsolver_sgels_batched_rank_0,&
      
rocsolver_sgels_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgels_batched
    function rocsolver_dgels_batched_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,batch_count) bind(c, name="rocsolver_dgels_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgels_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgels_batched_full_rank,&
      
rocsolver_dgels_batched_rank_0,&
      
rocsolver_dgels_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgels_batched
    function rocsolver_cgels_batched_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,batch_count) bind(c, name="rocsolver_cgels_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgels_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgels_batched_full_rank,&
      
rocsolver_cgels_batched_rank_0,&
      
rocsolver_cgels_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgels_batched
    function rocsolver_zgels_batched_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,batch_count) bind(c, name="rocsolver_zgels_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgels_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgels_batched_full_rank,&
      
rocsolver_zgels_batched_rank_0,&
      
rocsolver_zgels_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GELS_STRIDED_BATCHED solves a batch of overdetermined (or underdetermined) linear
  !>     systems defined by a set of m-by-n matrices \f$A_l\f$, and corresponding matrices \f$B_l\f$,
  !>     using the QR factorizations computed by \ref rocsolver_sgeqrf_strided_batched "GEQRF_STRIDED_BATCHED"
  !>     (or the LQ factorizations computed by \ref rocsolver_sgelqf_strided_batched "GELQF_STRIDED_BATCHED").
  !> 
  !>     \details
  !>     For each instance in the batch, depending on the value of trans, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l X_l = B_l & \: \text{not transposed, or}\\
  !>         A_l' X_l^{} = B_l^{} & \: \text{transposed if real, or conjugate transposed if complex}
  !>         \end{array}
  !>     \f]
  !> 
  !>     If m >= n (or m < n in the case of transposeconjugate transpose), the system is overdetermined
  !>     and a least-squares solution approximating X_l is found by minimizing
  !> 
  !>     \f[
  !>         || B_l - A_l  X_l || \quad \text{(or} \: || B_l^{} - A_l' X_l^{} ||\text{)}
  !>     \f]
  !> 
  !>     If m < n (or m >= n in the case of transposeconjugate transpose), the system is underdetermined
  !>     and a unique solution for X_l is chosen such that \f$|| X_l ||\f$ is minimal.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     trans       rocblas_operation.
  !>                 Specifies the form of the system of equations.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all matrices A_l in the batch.
  !>     @param[in]
  !>     nrhs        rocblas_int. nrhs >= 0.
  !>                 The number of columns of all matrices B_l and X_l in the batch;
  !>                 i.e., the columns on the right hand side.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the matrices A_l.
  !>                 On exit, the QR (or LQ) factorizations of A_l as returned by \ref rocsolver_sgeqrf_strided_batched "GEQRF_STRIDED_BATCHED"
  !>                 (or \ref rocsolver_sgelqf_strided_batched "GELQF_STRIDED_BATCHED").
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan
  !>     @param[inout]
  !>     B           pointer to type. Array on the GPU (the size depends on the value of strideB).
  !>                 On entry, the matrices B_l.
  !>                 On exit, when info[l] = 0, each B_l is overwritten by the solution vectors (and the residuals in
  !>                 the overdetermined cases) stored as columns.
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= max(m,n).
  !>                 Specifies the leading dimension of matrices B_l.
  !>     @param[in]
  !>     strideB     rocblas_stride.
  !>                 Stride from the start of one matrix B_l to the next one B_(l+1).
  !>                 There is no restriction for the value of strideB. Normal use case is strideB >= ldbnrhs
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for solution of A_l.
  !>                 If info[l] = i > 0, the solution of A_l could not be computed because input
  !>                 matrix A_l is rank deficient; the i-th diagonal element of its triangular factor is zero.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgels_strided_batched
    function rocsolver_sgels_strided_batched_(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count) bind(c, name="rocsolver_sgels_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgels_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgels_strided_batched_full_rank,&
      
rocsolver_sgels_strided_batched_rank_0,&
      
rocsolver_sgels_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgels_strided_batched
    function rocsolver_dgels_strided_batched_(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count) bind(c, name="rocsolver_dgels_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgels_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgels_strided_batched_full_rank,&
      
rocsolver_dgels_strided_batched_rank_0,&
      
rocsolver_dgels_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgels_strided_batched
    function rocsolver_cgels_strided_batched_(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count) bind(c, name="rocsolver_cgels_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgels_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgels_strided_batched_full_rank,&
      
rocsolver_cgels_strided_batched_rank_0,&
      
rocsolver_cgels_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgels_strided_batched
    function rocsolver_zgels_strided_batched_(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count) bind(c, name="rocsolver_zgels_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgels_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_operation_none)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgels_strided_batched_full_rank,&
      
rocsolver_zgels_strided_batched_rank_0,&
      
rocsolver_zgels_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief POTF2 computes the Cholesky factorization of a real symmetric (complex
  !>     Hermitian) positive definite matrix A.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The factorization has the form:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A = U'U & \: \text{if uplo is upper, or}\\
  !>         A = LL' & \: \text{if uplo is lower.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     U is an upper triangular matrix and L is lower triangular.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the factorization is upper or lower triangular.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A to be factored. On exit, the lower or upper triangular factor.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful factorization of matrix A.
  !>                 If info = i > 0, the leading minor of order i of A is not positive definite.
  !>                 The factorization stopped at this point.
  !>     
  interface rocsolver_spotf2
    function rocsolver_spotf2_(handle,uplo,n,A,lda,myInfo) bind(c, name="rocsolver_spotf2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotf2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_spotf2_full_rank,&
      
rocsolver_spotf2_rank_0,&
      
rocsolver_spotf2_rank_1
#endif

  end interface
  
  interface rocsolver_dpotf2
    function rocsolver_dpotf2_(handle,uplo,n,A,lda,myInfo) bind(c, name="rocsolver_dpotf2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotf2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dpotf2_full_rank,&
      
rocsolver_dpotf2_rank_0,&
      
rocsolver_dpotf2_rank_1
#endif

  end interface
  
  interface rocsolver_cpotf2
    function rocsolver_cpotf2_(handle,uplo,n,A,lda,myInfo) bind(c, name="rocsolver_cpotf2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotf2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cpotf2_full_rank,&
      
rocsolver_cpotf2_rank_0,&
      
rocsolver_cpotf2_rank_1
#endif

  end interface
  
  interface rocsolver_zpotf2
    function rocsolver_zpotf2_(handle,uplo,n,A,lda,myInfo) bind(c, name="rocsolver_zpotf2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotf2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zpotf2_full_rank,&
      
rocsolver_zpotf2_rank_0,&
      
rocsolver_zpotf2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief POTF2_BATCHED computes the Cholesky factorization of a
  !>     batch of real symmetric (complex Hermitian) positive definite matrices.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The factorization of matrix \f$A_l\f$ in the batch has the form:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l^{} = U_l'U_l^{} & \: \text{if uplo is upper, or}\\
  !>         A_l^{} = L_l^{}L_l' & \: \text{if uplo is lower.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     \f$U_l\f$ is an upper triangular matrix and \f$L_l\f$ is lower triangular.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the factorization is upper or lower triangular.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of matrix A_l.
  !>     @param[inout]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the matrices A_l to be factored. On exit, the upper or lower triangular factors.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A_l.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful factorization of matrix A_l.
  !>                 If info[l] = i > 0, the leading minor of order i of A_l is not positive definite.
  !>                 The l-th factorization stopped at this point.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_spotf2_batched
    function rocsolver_spotf2_batched_(handle,uplo,n,A,lda,myInfo,batch_count) bind(c, name="rocsolver_spotf2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotf2_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_spotf2_batched_full_rank,&
      
rocsolver_spotf2_batched_rank_0,&
      
rocsolver_spotf2_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dpotf2_batched
    function rocsolver_dpotf2_batched_(handle,uplo,n,A,lda,myInfo,batch_count) bind(c, name="rocsolver_dpotf2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotf2_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dpotf2_batched_full_rank,&
      
rocsolver_dpotf2_batched_rank_0,&
      
rocsolver_dpotf2_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cpotf2_batched
    function rocsolver_cpotf2_batched_(handle,uplo,n,A,lda,myInfo,batch_count) bind(c, name="rocsolver_cpotf2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotf2_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cpotf2_batched_full_rank,&
      
rocsolver_cpotf2_batched_rank_0,&
      
rocsolver_cpotf2_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zpotf2_batched
    function rocsolver_zpotf2_batched_(handle,uplo,n,A,lda,myInfo,batch_count) bind(c, name="rocsolver_zpotf2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotf2_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zpotf2_batched_full_rank,&
      
rocsolver_zpotf2_batched_rank_0,&
      
rocsolver_zpotf2_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief POTF2_STRIDED_BATCHED computes the Cholesky factorization of a
  !>     batch of real symmetric (complex Hermitian) positive definite matrices.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The factorization of matrix \f$A_l\f$ in the batch has the form:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l^{} = U_l'U_l^{} & \: \text{if uplo is upper, or}\\
  !>         A_l^{} = L_l^{}L_l' & \: \text{if uplo is lower.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     \f$U_l\f$ is an upper triangular matrix and \f$L_l\f$ is lower triangular.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the factorization is upper or lower triangular.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of matrix A_l.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the matrices A_l to be factored. On exit, the upper or lower triangular factors.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A_l.
  !>     @param[in]
  !>     strideA    rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful factorization of matrix A_l.
  !>                 If info[l] = i > 0, the leading minor of order i of A_l is not positive definite.
  !>                 The l-th factorization stopped at this point.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_spotf2_strided_batched
    function rocsolver_spotf2_strided_batched_(handle,uplo,n,A,lda,strideA,myInfo,batch_count) bind(c, name="rocsolver_spotf2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotf2_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_spotf2_strided_batched_full_rank,&
      
rocsolver_spotf2_strided_batched_rank_0,&
      
rocsolver_spotf2_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dpotf2_strided_batched
    function rocsolver_dpotf2_strided_batched_(handle,uplo,n,A,lda,strideA,myInfo,batch_count) bind(c, name="rocsolver_dpotf2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotf2_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dpotf2_strided_batched_full_rank,&
      
rocsolver_dpotf2_strided_batched_rank_0,&
      
rocsolver_dpotf2_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cpotf2_strided_batched
    function rocsolver_cpotf2_strided_batched_(handle,uplo,n,A,lda,strideA,myInfo,batch_count) bind(c, name="rocsolver_cpotf2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotf2_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cpotf2_strided_batched_full_rank,&
      
rocsolver_cpotf2_strided_batched_rank_0,&
      
rocsolver_cpotf2_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zpotf2_strided_batched
    function rocsolver_zpotf2_strided_batched_(handle,uplo,n,A,lda,strideA,myInfo,batch_count) bind(c, name="rocsolver_zpotf2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotf2_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zpotf2_strided_batched_full_rank,&
      
rocsolver_zpotf2_strided_batched_rank_0,&
      
rocsolver_zpotf2_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief POTRF computes the Cholesky factorization of a real symmetric (complex
  !>     Hermitian) positive definite matrix A.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The factorization has the form:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A = U'U & \: \text{if uplo is upper, or}\\
  !>         A = LL' & \: \text{if uplo is lower.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     U is an upper triangular matrix and L is lower triangular.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the factorization is upper or lower triangular.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A to be factored. On exit, the lower or upper triangular factor.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful factorization of matrix A.
  !>                 If info = i > 0, the leading minor of order i of A is not positive definite.
  !>                 The factorization stopped at this point.
  !>     
  interface rocsolver_spotrf
    function rocsolver_spotrf_(handle,uplo,n,A,lda,myInfo) bind(c, name="rocsolver_spotrf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotrf_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_spotrf_full_rank,&
      
rocsolver_spotrf_rank_0,&
      
rocsolver_spotrf_rank_1
#endif

  end interface
  
  interface rocsolver_dpotrf
    function rocsolver_dpotrf_(handle,uplo,n,A,lda,myInfo) bind(c, name="rocsolver_dpotrf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotrf_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dpotrf_full_rank,&
      
rocsolver_dpotrf_rank_0,&
      
rocsolver_dpotrf_rank_1
#endif

  end interface
  
  interface rocsolver_cpotrf
    function rocsolver_cpotrf_(handle,uplo,n,A,lda,myInfo) bind(c, name="rocsolver_cpotrf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotrf_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cpotrf_full_rank,&
      
rocsolver_cpotrf_rank_0,&
      
rocsolver_cpotrf_rank_1
#endif

  end interface
  
  interface rocsolver_zpotrf
    function rocsolver_zpotrf_(handle,uplo,n,A,lda,myInfo) bind(c, name="rocsolver_zpotrf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotrf_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zpotrf_full_rank,&
      
rocsolver_zpotrf_rank_0,&
      
rocsolver_zpotrf_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief POTRF_BATCHED computes the Cholesky factorization of a
  !>     batch of real symmetric (complex Hermitian) positive definite matrices.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The factorization of matrix \f$A_l\f$ in the batch has the form:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l^{} = U_l'U_l^{} & \: \text{if uplo is upper, or}\\
  !>         A_l^{} = L_l^{}L_l' & \: \text{if uplo is lower.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     \f$U_l\f$ is an upper triangular matrix and \f$L_l\f$ is lower triangular.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the factorization is upper or lower triangular.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of matrix A_l.
  !>     @param[inout]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the matrices A_l to be factored. On exit, the upper or lower triangular factors.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A_l.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful factorization of matrix A_l.
  !>                 If info[l] = i > 0, the leading minor of order i of A_l is not positive definite.
  !>                 The l-th factorization stopped at this point.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_spotrf_batched
    function rocsolver_spotrf_batched_(handle,uplo,n,A,lda,myInfo,batch_count) bind(c, name="rocsolver_spotrf_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotrf_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_spotrf_batched_full_rank,&
      
rocsolver_spotrf_batched_rank_0,&
      
rocsolver_spotrf_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dpotrf_batched
    function rocsolver_dpotrf_batched_(handle,uplo,n,A,lda,myInfo,batch_count) bind(c, name="rocsolver_dpotrf_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotrf_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dpotrf_batched_full_rank,&
      
rocsolver_dpotrf_batched_rank_0,&
      
rocsolver_dpotrf_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cpotrf_batched
    function rocsolver_cpotrf_batched_(handle,uplo,n,A,lda,myInfo,batch_count) bind(c, name="rocsolver_cpotrf_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotrf_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cpotrf_batched_full_rank,&
      
rocsolver_cpotrf_batched_rank_0,&
      
rocsolver_cpotrf_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zpotrf_batched
    function rocsolver_zpotrf_batched_(handle,uplo,n,A,lda,myInfo,batch_count) bind(c, name="rocsolver_zpotrf_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotrf_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zpotrf_batched_full_rank,&
      
rocsolver_zpotrf_batched_rank_0,&
      
rocsolver_zpotrf_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief POTRF_STRIDED_BATCHED computes the Cholesky factorization of a
  !>     batch of real symmetric (complex Hermitian) positive definite matrices.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The factorization of matrix \f$A_l\f$ in the batch has the form:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l^{} = U_l'U_l^{} & \: \text{if uplo is upper, or}\\
  !>         A_l^{} = L_l^{}L_l' & \: \text{if uplo is lower.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     \f$U_l\f$ is an upper triangular matrix and \f$L_l\f$ is lower triangular.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the factorization is upper or lower triangular.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of matrix A_l.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the matrices A_l to be factored. On exit, the upper or lower triangular factors.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful factorization of matrix A_l.
  !>                 If info[l] = i > 0, the leading minor of order i of A_l is not positive definite.
  !>                 The l-th factorization stopped at this point.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_spotrf_strided_batched
    function rocsolver_spotrf_strided_batched_(handle,uplo,n,A,lda,strideA,myInfo,batch_count) bind(c, name="rocsolver_spotrf_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotrf_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_spotrf_strided_batched_full_rank,&
      
rocsolver_spotrf_strided_batched_rank_0,&
      
rocsolver_spotrf_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dpotrf_strided_batched
    function rocsolver_dpotrf_strided_batched_(handle,uplo,n,A,lda,strideA,myInfo,batch_count) bind(c, name="rocsolver_dpotrf_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotrf_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dpotrf_strided_batched_full_rank,&
      
rocsolver_dpotrf_strided_batched_rank_0,&
      
rocsolver_dpotrf_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cpotrf_strided_batched
    function rocsolver_cpotrf_strided_batched_(handle,uplo,n,A,lda,strideA,myInfo,batch_count) bind(c, name="rocsolver_cpotrf_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotrf_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cpotrf_strided_batched_full_rank,&
      
rocsolver_cpotrf_strided_batched_rank_0,&
      
rocsolver_cpotrf_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zpotrf_strided_batched
    function rocsolver_zpotrf_strided_batched_(handle,uplo,n,A,lda,strideA,myInfo,batch_count) bind(c, name="rocsolver_zpotrf_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotrf_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zpotrf_strided_batched_full_rank,&
      
rocsolver_zpotrf_strided_batched_rank_0,&
      
rocsolver_zpotrf_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief POTRS solves a symmetrichermitian system of n linear equations on n variables in its factorized form.
  !> 
  !>     \details
  !>     It solves the system
  !> 
  !>     \f[
  !>         A X = B
  !>     \f]
  !> 
  !>     where A is a real symmetric (complex hermitian) positive definite matrix defined by its triangular factor
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A = U'U & \: \text{if uplo is upper, or}\\
  !>         A = LL' & \: \text{if uplo is lower.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     as returned by \ref rocsolver_spotrf "POTRF".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the factorization is upper or lower triangular.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The order of the system, i.e. the number of columns and rows of A.
  !>     @param[in]
  !>     nrhs        rocblas_int. nrhs >= 0.
  !>                 The number of right hand sides, i.e., the number of columns
  !>                 of the matrix B.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 The factor L or U of the Cholesky factorization of A returned by \ref rocsolver_spotrf "POTRF".
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 The leading dimension of A.
  !>     @param[inout]
  !>     B           pointer to type. Array on the GPU of dimension ldbnrhs.
  !>                 On entry, the right hand side matrix B.
  !>                 On exit, the solution matrix X.
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 The leading dimension of B.
  !>    
  interface rocsolver_spotrs
    function rocsolver_spotrs_(handle,uplo,n,nrhs,A,lda,B,ldb) bind(c, name="rocsolver_spotrs")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotrs_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_spotrs_full_rank,&
      
rocsolver_spotrs_rank_0,&
      
rocsolver_spotrs_rank_1
#endif

  end interface
  
  interface rocsolver_dpotrs
    function rocsolver_dpotrs_(handle,uplo,n,nrhs,A,lda,B,ldb) bind(c, name="rocsolver_dpotrs")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotrs_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dpotrs_full_rank,&
      
rocsolver_dpotrs_rank_0,&
      
rocsolver_dpotrs_rank_1
#endif

  end interface
  
  interface rocsolver_cpotrs
    function rocsolver_cpotrs_(handle,uplo,n,nrhs,A,lda,B,ldb) bind(c, name="rocsolver_cpotrs")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotrs_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cpotrs_full_rank,&
      
rocsolver_cpotrs_rank_0,&
      
rocsolver_cpotrs_rank_1
#endif

  end interface
  
  interface rocsolver_zpotrs
    function rocsolver_zpotrs_(handle,uplo,n,nrhs,A,lda,B,ldb) bind(c, name="rocsolver_zpotrs")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotrs_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zpotrs_full_rank,&
      
rocsolver_zpotrs_rank_0,&
      
rocsolver_zpotrs_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief POTRS_BATCHED solves a batch of symmetrichermitian systems of n linear equations on n
  !>     variables in its factorized forms.
  !> 
  !>     \details
  !>     For each instance l in the batch, it solves the system
  !> 
  !>     \f[
  !>         A_l X_l = B_l
  !>     \f]
  !> 
  !>     where \f$A_l\f$ is a real symmetric (complex hermitian) positive definite matrix defined by its
  !>     triangular factor
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l^{} = U_l'U_l^{} & \: \text{if uplo is upper, or}\\
  !>         A_l^{} = L_l^{}L_l' & \: \text{if uplo is lower.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     as returned by \ref rocsolver_spotrf "POTRF_BATCHED".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the factorization is upper or lower triangular.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The order of the system, i.e. the number of columns and rows of all A_l matrices.
  !>     @param[in]
  !>     nrhs        rocblas_int. nrhs >= 0.
  !>                 The number of right hand sides, i.e., the number of columns
  !>                 of all the matrices B_l.
  !>     @param[in]
  !>     A           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 The factor L_l or U_l of the Cholesky factorization of A_l returned by \ref rocsolver_spotrf_batched "POTRF_BATCHED".
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 The leading dimension of matrices A_l.
  !>     @param[inout]
  !>     B           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldbnrhs.
  !>                 On entry, the right hand side matrices B_l.
  !>                 On exit, the solution matrix X_l of each system in the batch.
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 The leading dimension of matrices B_l.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of instances (systems) in the batch.
  !>    
  interface rocsolver_spotrs_batched
    function rocsolver_spotrs_batched_(handle,uplo,n,nrhs,A,lda,B,ldb,batch_count) bind(c, name="rocsolver_spotrs_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotrs_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_spotrs_batched_full_rank,&
      
rocsolver_spotrs_batched_rank_0,&
      
rocsolver_spotrs_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dpotrs_batched
    function rocsolver_dpotrs_batched_(handle,uplo,n,nrhs,A,lda,B,ldb,batch_count) bind(c, name="rocsolver_dpotrs_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotrs_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dpotrs_batched_full_rank,&
      
rocsolver_dpotrs_batched_rank_0,&
      
rocsolver_dpotrs_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cpotrs_batched
    function rocsolver_cpotrs_batched_(handle,uplo,n,nrhs,A,lda,B,ldb,batch_count) bind(c, name="rocsolver_cpotrs_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotrs_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cpotrs_batched_full_rank,&
      
rocsolver_cpotrs_batched_rank_0,&
      
rocsolver_cpotrs_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zpotrs_batched
    function rocsolver_zpotrs_batched_(handle,uplo,n,nrhs,A,lda,B,ldb,batch_count) bind(c, name="rocsolver_zpotrs_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotrs_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zpotrs_batched_full_rank,&
      
rocsolver_zpotrs_batched_rank_0,&
      
rocsolver_zpotrs_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief POTRS_STRIDED_BATCHED solves a batch of symmetrichermitian systems of n linear equations
  !>     on n variables in its factorized forms.
  !> 
  !>     \details
  !>     For each instance l in the batch, it solves the system
  !> 
  !>     \f[
  !>         A_l X_l = B_l
  !>     \f]
  !> 
  !>     where \f$A_l\f$ is a real symmetric (complex hermitian) positive definite matrix defined by its
  !>     triangular factor
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l^{} = U_l'U_l^{} & \: \text{if uplo is upper, or}\\
  !>         A_l^{} = L_l^{}L_l' & \: \text{if uplo is lower.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     as returned by \ref rocsolver_spotrf "POTRF_STRIDED_BATCHED".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the factorization is upper or lower triangular.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The order of the system, i.e. the number of columns and rows of all A_l matrices.
  !>     @param[in]
  !>     nrhs        rocblas_int. nrhs >= 0.
  !>                 The number of right hand sides, i.e., the number of columns
  !>                 of all the matrices B_l.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 The factor L_l or U_l of the Cholesky factorization of A_l returned by \ref rocsolver_spotrf_strided_batched "POTRF_STRIDED_BATCHED".
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 The leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[inout]
  !>     B           pointer to type. Array on the GPU (size depends on the value of strideB).
  !>                 On entry, the right hand side matrices B_l.
  !>                 On exit, the solution matrix X_l of each system in the batch.
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 The leading dimension of matrices B_l.
  !>     @param[in]
  !>     strideB     rocblas_stride.
  !>                 Stride from the start of one matrix B_l to the next one B_(l+1).
  !>                 There is no restriction for the value of strideB. Normal use case is strideB >= ldbnrhs.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of instances (systems) in the batch.
  !>    
  interface rocsolver_spotrs_strided_batched
    function rocsolver_spotrs_strided_batched_(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,batch_count) bind(c, name="rocsolver_spotrs_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotrs_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_spotrs_strided_batched_full_rank,&
      
rocsolver_spotrs_strided_batched_rank_0,&
      
rocsolver_spotrs_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dpotrs_strided_batched
    function rocsolver_dpotrs_strided_batched_(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,batch_count) bind(c, name="rocsolver_dpotrs_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotrs_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dpotrs_strided_batched_full_rank,&
      
rocsolver_dpotrs_strided_batched_rank_0,&
      
rocsolver_dpotrs_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cpotrs_strided_batched
    function rocsolver_cpotrs_strided_batched_(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,batch_count) bind(c, name="rocsolver_cpotrs_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotrs_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cpotrs_strided_batched_full_rank,&
      
rocsolver_cpotrs_strided_batched_rank_0,&
      
rocsolver_cpotrs_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zpotrs_strided_batched
    function rocsolver_zpotrs_strided_batched_(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,batch_count) bind(c, name="rocsolver_zpotrs_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotrs_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zpotrs_strided_batched_full_rank,&
      
rocsolver_zpotrs_strided_batched_rank_0,&
      
rocsolver_zpotrs_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief POSV solves a symmetrichermitian system of n linear equations on n variables.
  !> 
  !>     \details
  !>     It solves the system
  !> 
  !>     \f[
  !>         A X = B
  !>     \f]
  !> 
  !>     where A is a real symmetric (complex hermitian) positive definite matrix. Matrix A is first
  !>     factorized as \f$A=LL'\f$ or \f$A=U'U\f$, depending on the value of uplo, using \ref rocsolver_spotrf "POTRF";
  !>     then, the solution is computed with \ref rocsolver_spotrs "POTRS".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the factorization is upper or lower triangular.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The order of the system, i.e. the number of columns and rows of A.
  !>     @param[in]
  !>     nrhs        rocblas_int. nrhs >= 0.
  !>                 The number of right hand sides, i.e., the number of columns
  !>                 of the matrix B.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the symmetrichermitian matrix A.
  !>                 On exit, if info = 0, the factor L or U of the Cholesky factorization of A returned by
  !>                 \ref rocsolver_spotrf "POTRF".
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 The leading dimension of A.
  !>     @param[inout]
  !>     B           pointer to type. Array on the GPU of dimension ldbnrhs.
  !>                 On entry, the right hand side matrix B.
  !>                 On exit, the solution matrix X.
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 The leading dimension of B.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0, the leading minor of order i of A is not positive definite.
  !>                 The solution could not be computed.
  !>    
  interface rocsolver_sposv
    function rocsolver_sposv_(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo) bind(c, name="rocsolver_sposv")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sposv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sposv_full_rank,&
      
rocsolver_sposv_rank_0,&
      
rocsolver_sposv_rank_1
#endif

  end interface
  
  interface rocsolver_dposv
    function rocsolver_dposv_(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo) bind(c, name="rocsolver_dposv")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dposv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dposv_full_rank,&
      
rocsolver_dposv_rank_0,&
      
rocsolver_dposv_rank_1
#endif

  end interface
  
  interface rocsolver_cposv
    function rocsolver_cposv_(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo) bind(c, name="rocsolver_cposv")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cposv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cposv_full_rank,&
      
rocsolver_cposv_rank_0,&
      
rocsolver_cposv_rank_1
#endif

  end interface
  
  interface rocsolver_zposv
    function rocsolver_zposv_(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo) bind(c, name="rocsolver_zposv")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zposv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zposv_full_rank,&
      
rocsolver_zposv_rank_0,&
      
rocsolver_zposv_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief POSV_BATCHED solves a batch of symmetrichermitian systems of n linear equations on n
  !>     variables.
  !> 
  !>     \details
  !>     For each instance l in the batch, it solves the system
  !> 
  !>     \f[
  !>         A_l X_l = B_l
  !>     \f]
  !> 
  !>     where \f$A_l\f$ is a real symmetric (complex hermitian) positive definite matrix. Matrix \f$A_l\f$ is first
  !>     factorized as \f$A_l^{}=L_l^{}L_l'\f$ or \f$A_l^{}=U_l'U_l^{}\f$, depending on the value of uplo, using \ref rocsolver_spotrf_batched "POTRF_BATCHED";
  !>     then, the solution is computed with \ref rocsolver_spotrs_batched "POTRS_BATCHED".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the factorization is upper or lower triangular.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The order of the system, i.e. the number of columns and rows of all A_l matrices.
  !>     @param[in]
  !>     nrhs        rocblas_int. nrhs >= 0.
  !>                 The number of right hand sides, i.e., the number of columns
  !>                 of all the matrices B_l.
  !>     @param[inout]
  !>     A           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the symmetrichermitian matrices A_l.
  !>                 On exit, if info[l] = 0, the factor L_l or U_l of the Cholesky factorization of A_l returned by
  !>                 \ref rocsolver_spotrf_batched "POTRF_BATCHED".
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 The leading dimension of matrices A_l.
  !>     @param[inout]
  !>     B           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldbnrhs.
  !>                 On entry, the right hand side matrices B_l.
  !>                 On exit, the solution matrix X_l of each system in the batch.
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 The leading dimension of matrices B_l.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit.
  !>                 If info[l] = i > 0, the leading minor of order i of A_l is not positive definite.
  !>                 The l-th solution could not be computed.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of instances (systems) in the batch.
  !>    
  interface rocsolver_sposv_batched
    function rocsolver_sposv_batched_(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo,batch_count) bind(c, name="rocsolver_sposv_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sposv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sposv_batched_full_rank,&
      
rocsolver_sposv_batched_rank_0,&
      
rocsolver_sposv_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dposv_batched
    function rocsolver_dposv_batched_(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo,batch_count) bind(c, name="rocsolver_dposv_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dposv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dposv_batched_full_rank,&
      
rocsolver_dposv_batched_rank_0,&
      
rocsolver_dposv_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cposv_batched
    function rocsolver_cposv_batched_(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo,batch_count) bind(c, name="rocsolver_cposv_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cposv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cposv_batched_full_rank,&
      
rocsolver_cposv_batched_rank_0,&
      
rocsolver_cposv_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zposv_batched
    function rocsolver_zposv_batched_(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo,batch_count) bind(c, name="rocsolver_zposv_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zposv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zposv_batched_full_rank,&
      
rocsolver_zposv_batched_rank_0,&
      
rocsolver_zposv_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief POSV_STRIDED_BATCHED solves a batch of symmetrichermitian systems of n linear equations
  !>     on n variables.
  !> 
  !>     \details
  !>     For each instance l in the batch, it solves the system
  !> 
  !>     \f[
  !>         A_l X_l = B_l
  !>     \f]
  !> 
  !>     where \f$A_l\f$ is a real symmetric (complex hermitian) positive definite matrix. Matrix \f$A_l\f$ is first
  !>     factorized as \f$A_l^{}=L_l^{}L_l'\f$ or \f$A_l^{}=U_l'U_l^{}\f$, depending on the value of uplo, using \ref rocsolver_spotrf_strided_batched "POTRF_STRIDED_BATCHED";
  !>     then, the solution is computed with \ref rocsolver_spotrs_strided_batched "POTRS_STRIDED_BATCHED".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the factorization is upper or lower triangular.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The order of the system, i.e. the number of columns and rows of all A_l matrices.
  !>     @param[in]
  !>     nrhs        rocblas_int. nrhs >= 0.
  !>                 The number of right hand sides, i.e., the number of columns
  !>                 of all the matrices B_l.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the symmetrichermitian matrices A_l.
  !>                 On exit, if info[l] = 0, the factor L_l or U_l of the Cholesky factorization of A_l returned by
  !>                 \ref rocsolver_spotrf_strided_batched "POTRF_STRIDED_BATCHED".
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 The leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[inout]
  !>     B           pointer to type. Array on the GPU (size depends on the value of strideB).
  !>                 On entry, the right hand side matrices B_l.
  !>                 On exit, the solution matrix X_l of each system in the batch.
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 The leading dimension of matrices B_l.
  !>     @param[in]
  !>     strideB     rocblas_stride.
  !>                 Stride from the start of one matrix B_l to the next one B_(l+1).
  !>                 There is no restriction for the value of strideB. Normal use case is strideB >= ldbnrhs.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit.
  !>                 If info[l] = i > 0, the leading minor of order i of A_l is not positive definite.
  !>                 The l-th solution could not be computed.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of instances (systems) in the batch.
  !>    
  interface rocsolver_sposv_strided_batched
    function rocsolver_sposv_strided_batched_(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count) bind(c, name="rocsolver_sposv_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sposv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sposv_strided_batched_full_rank,&
      
rocsolver_sposv_strided_batched_rank_0,&
      
rocsolver_sposv_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dposv_strided_batched
    function rocsolver_dposv_strided_batched_(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count) bind(c, name="rocsolver_dposv_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dposv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dposv_strided_batched_full_rank,&
      
rocsolver_dposv_strided_batched_rank_0,&
      
rocsolver_dposv_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cposv_strided_batched
    function rocsolver_cposv_strided_batched_(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count) bind(c, name="rocsolver_cposv_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cposv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cposv_strided_batched_full_rank,&
      
rocsolver_cposv_strided_batched_rank_0,&
      
rocsolver_cposv_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zposv_strided_batched
    function rocsolver_zposv_strided_batched_(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count) bind(c, name="rocsolver_zposv_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zposv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zposv_strided_batched_full_rank,&
      
rocsolver_zposv_strided_batched_rank_0,&
      
rocsolver_zposv_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief POTRI inverts a symmetrichermitian positive definite matrix A.
  !> 
  !>     \details
  !>     The inverse of matrix \f$A\f$ is computed as
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A^{-1} = U^{-1} {U^{-1}}' & \: \text{if uplo is upper, or}\\
  !>         A^{-1} = {L^{-1}}' L^{-1} & \: \text{if uplo is lower.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     where \f$U\f$ or \f$L\f$ is the triangular factor of the Cholesky factorization of \f$A\f$ returned by
  !>     \ref rocsolver_spotrf "POTRF".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the factorization is upper or lower triangular.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the factor L or U of the Cholesky factorization of A returned by
  !>                 \ref rocsolver_spotrf "POTRF".
  !>                 On exit, the inverse of A if info = 0.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit for inversion of A.
  !>                 If info = i > 0, A is singular. L[i,i] or U[i,i] is zero.
  !>     
  interface rocsolver_spotri
    function rocsolver_spotri_(handle,uplo,n,A,lda,myInfo) bind(c, name="rocsolver_spotri")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotri_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_spotri_full_rank,&
      
rocsolver_spotri_rank_0,&
      
rocsolver_spotri_rank_1
#endif

  end interface
  
  interface rocsolver_dpotri
    function rocsolver_dpotri_(handle,uplo,n,A,lda,myInfo) bind(c, name="rocsolver_dpotri")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotri_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dpotri_full_rank,&
      
rocsolver_dpotri_rank_0,&
      
rocsolver_dpotri_rank_1
#endif

  end interface
  
  interface rocsolver_cpotri
    function rocsolver_cpotri_(handle,uplo,n,A,lda,myInfo) bind(c, name="rocsolver_cpotri")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotri_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cpotri_full_rank,&
      
rocsolver_cpotri_rank_0,&
      
rocsolver_cpotri_rank_1
#endif

  end interface
  
  interface rocsolver_zpotri
    function rocsolver_zpotri_(handle,uplo,n,A,lda,myInfo) bind(c, name="rocsolver_zpotri")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotri_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zpotri_full_rank,&
      
rocsolver_zpotri_rank_0,&
      
rocsolver_zpotri_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief POTRI_BATCHED inverts a batch of symmetrichermitian positive definite matrices \f$A_l\f$.
  !> 
  !>     \details
  !>     The inverse of matrix \f$A_l\f$ in the batch is computed as
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l^{-1} = U_l^{-1} {U_l^{-1}}' & \: \text{if uplo is upper, or}\\
  !>         A_l^{-1} = {L_l^{-1}}' L_l^{-1} & \: \text{if uplo is lower.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     where \f$U_l\f$ or \f$L_l\f$ is the triangular factor of the Cholesky factorization of \f$A_l\f$ returned by
  !>     \ref rocsolver_spotrf_batched "POTRF_BATCHED".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the factorization is upper or lower triangular.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of matrix A_l.
  !>     @param[inout]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the factor L_l or U_l of the Cholesky factorization of A_l returned by
  !>                 \ref rocsolver_spotrf_batched "POTRF_BATCHED".
  !>                 On exit, the inverses of A_l if info[l] = 0.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A_l.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for inversion of A_l.
  !>                 If info[l] = i > 0, A_l is singular. L_l[i,i] or U_l[i,i] is zero.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_spotri_batched
    function rocsolver_spotri_batched_(handle,uplo,n,A,lda,myInfo,batch_count) bind(c, name="rocsolver_spotri_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotri_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_spotri_batched_full_rank,&
      
rocsolver_spotri_batched_rank_0,&
      
rocsolver_spotri_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dpotri_batched
    function rocsolver_dpotri_batched_(handle,uplo,n,A,lda,myInfo,batch_count) bind(c, name="rocsolver_dpotri_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotri_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dpotri_batched_full_rank,&
      
rocsolver_dpotri_batched_rank_0,&
      
rocsolver_dpotri_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cpotri_batched
    function rocsolver_cpotri_batched_(handle,uplo,n,A,lda,myInfo,batch_count) bind(c, name="rocsolver_cpotri_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotri_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cpotri_batched_full_rank,&
      
rocsolver_cpotri_batched_rank_0,&
      
rocsolver_cpotri_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zpotri_batched
    function rocsolver_zpotri_batched_(handle,uplo,n,A,lda,myInfo,batch_count) bind(c, name="rocsolver_zpotri_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotri_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zpotri_batched_full_rank,&
      
rocsolver_zpotri_batched_rank_0,&
      
rocsolver_zpotri_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief POTRI_STRIDED_BATCHED inverts a batch of symmetrichermitian positive definite matrices \f$A_l\f$.
  !> 
  !>     \details
  !>     The inverse of matrix \f$A_l\f$ in the batch is computed as
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l^{-1} = U_l^{-1} {U_l^{-1}}' & \: \text{if uplo is upper, or}\\
  !>         A_l^{-1} = {L_l^{-1}}' L_l^{-1} & \: \text{if uplo is lower.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     where \f$U_l\f$ or \f$L_l\f$ is the triangular factor of the Cholesky factorization of \f$A_l\f$ returned by
  !>     \ref rocsolver_spotrf_strided_batched "POTRF_STRIDED_BATCHED".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the factorization is upper or lower triangular.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of matrix A_l.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the factor L_l or U_l of the Cholesky factorization of A_l returned by
  !>                 \ref rocsolver_spotrf_strided_batched "POTRF_STRIDED_BATCHED".
  !>                 On exit, the inverses of A_l if info[l] = 0.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for inversion of A_l.
  !>                 If info[l] = i > 0, A_l is singular. L_l[i,i] or U_l[i,i] is zero.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_spotri_strided_batched
    function rocsolver_spotri_strided_batched_(handle,uplo,n,A,lda,strideA,myInfo,batch_count) bind(c, name="rocsolver_spotri_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotri_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_spotri_strided_batched_full_rank,&
      
rocsolver_spotri_strided_batched_rank_0,&
      
rocsolver_spotri_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dpotri_strided_batched
    function rocsolver_dpotri_strided_batched_(handle,uplo,n,A,lda,strideA,myInfo,batch_count) bind(c, name="rocsolver_dpotri_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotri_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dpotri_strided_batched_full_rank,&
      
rocsolver_dpotri_strided_batched_rank_0,&
      
rocsolver_dpotri_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cpotri_strided_batched
    function rocsolver_cpotri_strided_batched_(handle,uplo,n,A,lda,strideA,myInfo,batch_count) bind(c, name="rocsolver_cpotri_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotri_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cpotri_strided_batched_full_rank,&
      
rocsolver_cpotri_strided_batched_rank_0,&
      
rocsolver_cpotri_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zpotri_strided_batched
    function rocsolver_zpotri_strided_batched_(handle,uplo,n,A,lda,strideA,myInfo,batch_count) bind(c, name="rocsolver_zpotri_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotri_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zpotri_strided_batched_full_rank,&
      
rocsolver_zpotri_strided_batched_rank_0,&
      
rocsolver_zpotri_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GESVD computes the singular values and optionally the singular
  !>     vectors of a general m-by-n matrix A (Singular Value Decomposition).
  !> 
  !>     \details
  !>     The SVD of matrix A is given by:
  !> 
  !>     \f[
  !>         A = U  S  V'
  !>     \f]
  !> 
  !>     where the m-by-n matrix S is zero except, possibly, for its min(m,n)
  !>     diagonal elements, which are the singular values of A. U and V are orthogonal
  !>     (unitary) matrices. The first min(m,n) columns of U and V are the left and
  !>     right singular vectors of A, respectively.
  !> 
  !>     The computation of the singular vectors is optional and it is controlled by
  !>     the function arguments left_svect and right_svect as described below. When
  !>     computed, this function returns the transpose (or transpose conjugate) of the
  !>     right singular vectors, i.e. the rows of V'.
  !> 
  !>     left_svect and right_svect are #rocblas_svect enums that can take the
  !>     following values:
  !> 
  !>     - rocblas_svect_all: the entire matrix U (or V') is computed,
  !>     - rocblas_svect_singular: only the singular vectors (first min(m,n)
  !>       columns of U or rows of V') are computed,
  !>     - rocblas_svect_overwrite: the first
  !>       columns (or rows) of A are overwritten with the singular vectors, or
  !>     - rocblas_svect_none: no columns (or rows) of U (or V') are computed, i.e.
  !>       no singular vectors.
  !> 
  !>     left_svect and right_svect cannot both be set to overwrite. When neither is
  !>     set to overwrite, the contents of A are destroyed by the time the function
  !>     returns.
  !> 
  !>    \note
  !>     When m >> n (or n >> m) the algorithm could be sped up by compressing
  !>     the matrix A via a QR (or LQ) factorization, and working with the triangular
  !>     factor afterwards (thin-SVD). If the singular vectors are also requested, its
  !>     computation could be sped up as well via executing some intermediate
  !>     operations out-of-place, and relying more on matrix multiplications (GEMMs);
  !>     this will require, however, a larger memory workspace. The parameter fast_alg
  !>     controls whether the fast algorithm is executed or not. For more details, see
  !>     the "Tuning rocSOLVER performance" and "Memory model" sections of the documentation.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     left_svect  #rocblas_svect.
  !>                 Specifies how the left singular vectors are computed.
  !>     @param[in]
  !>     right_svect #rocblas_svect.
  !>                 Specifies how the right singular vectors are computed.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of matrix A.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A.
  !>                 On exit, if left_svect (or right_svect) is equal to overwrite,
  !>                 the first columns (or rows) contain the left (or right) singular vectors;
  !>                 otherwise, the contents of A are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 The leading dimension of A.
  !>     @param[out]
  !>     S           pointer to real type. Array on the GPU of dimension min(m,n).
  !>                 The singular values of A in decreasing order.
  !>     @param[out]
  !>     U           pointer to type. Array on the GPU of dimension ldumin(m,n) if
  !>                 left_svect is set to singular, or ldum when left_svect is equal to all.
  !>                 The matrix of left singular vectors stored as columns. Not
  !>                 referenced if left_svect is set to overwrite or none.
  !>     @param[in]
  !>     ldu         rocblas_int. ldu >= m if left_svect is all or singular; ldu >= 1 otherwise.
  !>                 The leading dimension of U.
  !>     @param[out]
  !>     V           pointer to type. Array on the GPU of dimension ldvn.
  !>                 The matrix of right singular vectors stored as rows (transposed  conjugate-transposed).
  !>                 Not referenced if right_svect is set to overwrite or none.
  !>     @param[in]
  !>     ldv         rocblas_int. ldv >= n if right_svect is all; ldv >= min(m,n) if right_svect is
  !>                 set to singular; or ldv >= 1 otherwise.
  !>                 The leading dimension of V.
  !>     @param[out]
  !>     E           pointer to real type. Array on the GPU of dimension min(m,n)-1.
  !>                 This array is used to work internally with the bidiagonal matrix
  !>                 B associated with A (using \ref rocsolver_sbdsqr "BDSQR"). On exit, if info > 0, it contains the
  !>                 unconverged off-diagonal elements of B (or properly speaking, a bidiagonal
  !>                 matrix orthogonally equivalent to B). The diagonal elements of this matrix
  !>                 are in S; those that converged correspond to a subset of the singular values
  !>                 of A (not necessarily ordered).
  !>     @param[in]
  !>     fast_alg    #rocblas_workmode.
  !>                 If set to rocblas_outofplace, the function will execute the
  !>                 fast thin-SVD version of the algorithm when possible.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0, \ref rocsolver_sbdsqr "BDSQR" did not converge. i elements of E did not converge to zero.
  !>     
  interface rocsolver_sgesvd
    function rocsolver_sgesvd_(handle,left_svect,right_svect,m,n,A,lda,S,U,ldu,V,ldv,E,fast_alg,myInfo) bind(c, name="rocsolver_sgesvd")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvd_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: S
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      type(c_ptr),value :: E
      integer(kind(rocblas_outofplace)),value :: fast_alg
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgesvd_full_rank,&
      
rocsolver_sgesvd_rank_0,&
      
rocsolver_sgesvd_rank_1
#endif

  end interface
  
  interface rocsolver_dgesvd
    function rocsolver_dgesvd_(handle,left_svect,right_svect,m,n,A,lda,S,U,ldu,V,ldv,E,fast_alg,myInfo) bind(c, name="rocsolver_dgesvd")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvd_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: S
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      type(c_ptr),value :: E
      integer(kind(rocblas_outofplace)),value :: fast_alg
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgesvd_full_rank,&
      
rocsolver_dgesvd_rank_0,&
      
rocsolver_dgesvd_rank_1
#endif

  end interface
  
  interface rocsolver_cgesvd
    function rocsolver_cgesvd_(handle,left_svect,right_svect,m,n,A,lda,S,U,ldu,V,ldv,E,fast_alg,myInfo) bind(c, name="rocsolver_cgesvd")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvd_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: S
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      type(c_ptr),value :: E
      integer(kind(rocblas_outofplace)),value :: fast_alg
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgesvd_full_rank,&
      
rocsolver_cgesvd_rank_0,&
      
rocsolver_cgesvd_rank_1
#endif

  end interface
  
  interface rocsolver_zgesvd
    function rocsolver_zgesvd_(handle,left_svect,right_svect,m,n,A,lda,S,U,ldu,V,ldv,E,fast_alg,myInfo) bind(c, name="rocsolver_zgesvd")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvd_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: S
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      type(c_ptr),value :: E
      integer(kind(rocblas_outofplace)),value :: fast_alg
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgesvd_full_rank,&
      
rocsolver_zgesvd_rank_0,&
      
rocsolver_zgesvd_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GESVD_BATCHED computes the singular values and optionally the
  !>     singular vectors of a batch of general m-by-n matrices A_l (Singular Value
  !>     Decomposition).
  !> 
  !>     \details
  !>     The SVD of matrix A_l in the batch is given by:
  !> 
  !>     \f[
  !>         A_l^{} = U_l^{}  S_l^{}  V_l'
  !>     \f]
  !> 
  !>     where the m-by-n matrix \f$S_l\f$ is zero except, possibly, for its min(m,n)
  !>     diagonal elements, which are the singular values of \f$A_l\f$. \f$U_l\f$ and \f$V_l\f$ are
  !>     orthogonal (unitary) matrices. The first min(m,n) columns of \f$U_l\f$ and \f$V_l\f$ are
  !>     the left and right singular vectors of \f$A_l\f$, respectively.
  !> 
  !>     The computation of the singular vectors is optional and it is controlled by
  !>     the function arguments left_svect and right_svect as described below. When
  !>     computed, this function returns the transpose (or transpose conjugate) of the
  !>     right singular vectors, i.e. the rows of \f$V_l'\f$.
  !> 
  !>     left_svect and right_svect are #rocblas_svect enums that can take the
  !>     following values:
  !> 
  !>     - rocblas_svect_all: the entire matrix \f$U_l\f$ (or \f$V_l'\f$) is computed,
  !>     - rocblas_svect_singular: only the singular vectors (first min(m,n)
  !>       columns of \f$U_l\f$ or rows of \f$V_l'\f$) are computed,
  !>     - rocblas_svect_overwrite: the
  !>       first columns (or rows) of \f$A_l\f$ are overwritten with the singular vectors, or
  !>     - rocblas_svect_none: no columns (or rows) of \f$U_l\f$ (or \f$V_l'\f$) are computed,
  !>       i.e. no singular vectors.
  !> 
  !>     left_svect and right_svect cannot both be set to overwrite. When neither is
  !>     set to overwrite, the contents of \f$A_l\f$ are destroyed by the time the function
  !>     returns.
  !> 
  !>     \note
  !>     When m >> n (or n >> m) the algorithm could be sped up by compressing
  !>     the matrix \f$A_l\f$ via a QR (or LQ) factorization, and working with the
  !>     triangular factor afterwards (thin-SVD). If the singular vectors are also
  !>     requested, its computation could be sped up as well via executing some
  !>     intermediate operations out-of-place, and relying more on matrix
  !>     multiplications (GEMMs); this will require, however, a larger memory
  !>     workspace. The parameter fast_alg controls whether the fast algorithm is
  !>     executed or not. For more details, see the "Tuning rocSOLVER performance"
  !>     and "Memory model" sections of the documentation.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     left_svect  #rocblas_svect.
  !>                 Specifies how the left singular vectors are computed.
  !>     @param[in]
  !>     right_svect #rocblas_svect.
  !>                 Specifies how the right singular vectors are computed.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all matrices A_l in the batch.
  !>     @param[inout]
  !>     A           Array of pointers to type. Each pointer points to an array on
  !>                 the GPU of dimension ldan.
  !>                 On entry, the matrices A_l.
  !>                 On exit, if left_svect (or right_svect) is equal to overwrite,
  !>                 the first columns (or rows) of A_l contain the left (or right)
  !>                 corresponding singular vectors; otherwise, the contents of A_l are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 The leading dimension of A_l.
  !>     @param[out]
  !>     S           pointer to real type. Array on the GPU (the size depends on the value of strideS).
  !>                 The singular values of A_l in decreasing order.
  !>     @param[in]
  !>     strideS     rocblas_stride.
  !>                 Stride from the start of one vector S_l to the next one S_(l+1).
  !>                 There is no restriction for the value of strideS.
  !>                 Normal use case is strideS >= min(m,n).
  !>     @param[out]
  !>     U           pointer to type. Array on the GPU (the side depends on the value of strideU).
  !>                 The matrices U_l of left singular vectors stored as columns.
  !>                 Not referenced if left_svect is set to overwrite or none.
  !>     @param[in]
  !>     ldu         rocblas_int. ldu >= m if left_svect is all or singular; ldu >= 1 otherwise.
  !>                 The leading dimension of U_l.
  !>     @param[in]
  !>     strideU     rocblas_stride.
  !>                 Stride from the start of one matrix U_l to the next one U_(l+1).
  !>                 There is no restriction for the value of strideU.
  !>                 Normal use case is strideU >= ldumin(m,n) if left_svect is set to singular,
  !>                 or strideU >= ldum when left_svect is equal to all.
  !>     @param[out]
  !>     V           pointer to type. Array on the GPU (the size depends on the value of strideV).
  !>                 The matrices V_l of right singular vectors stored as rows (transposed  conjugate-transposed).
  !>                 Not referenced if right_svect is set to overwrite or none.
  !>     @param[in]
  !>     ldv         rocblas_int. ldv >= n if right_svect is all; ldv >= min(m,n) if
  !>                 right_svect is set to singular; or ldv >= 1 otherwise.
  !>                 The leading dimension of V_l.
  !>     @param[in]
  !>     strideV     rocblas_stride.
  !>                 Stride from the start of one matrix V_l to the next one V_(l+1).
  !>                 There is no restriction for the value of strideV.
  !>                 Normal use case is strideV >= ldvn.
  !>     @param[out]
  !>     E           pointer to real type. Array on the GPU (the size depends on the value of strideE).
  !>                 This array is used to work internally with the bidiagonal matrix B_l associated with A_l (using \ref rocsolver_sbdsqr "BDSQR").
  !>                 On exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of B_l (or properly speaking,
  !>                 a bidiagonal matrix orthogonally equivalent to B_l). The diagonal elements of this matrix are in S_l;
  !>                 those that converged correspond to a subset of the singular values of A_l (not necessarily ordered).
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use case is strideE >= min(m,n)-1.
  !>     @param[in]
  !>     fast_alg    #rocblas_workmode.
  !>                 If set to rocblas_outofplace, the function will execute the fast thin-SVD version
  !>                 of the algorithm when possible.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info[l] = 0, successful exit.
  !>                 If info[l] = i > 0, \ref rocsolver_sbdsqr "BDSQR" did not converge. i elements of E_l did not converge to zero.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgesvd_batched
    function rocsolver_sgesvd_batched_(handle,left_svect,right_svect,m,n,A,lda,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count) bind(c, name="rocsolver_sgesvd_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvd_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: S
      integer(c_int64_t),value :: strideS
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      integer(c_int64_t),value :: strideU
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      integer(c_int64_t),value :: strideV
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      integer(kind(rocblas_outofplace)),value :: fast_alg
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgesvd_batched_full_rank,&
      
rocsolver_sgesvd_batched_rank_0,&
      
rocsolver_sgesvd_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgesvd_batched
    function rocsolver_dgesvd_batched_(handle,left_svect,right_svect,m,n,A,lda,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count) bind(c, name="rocsolver_dgesvd_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvd_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: S
      integer(c_int64_t),value :: strideS
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      integer(c_int64_t),value :: strideU
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      integer(c_int64_t),value :: strideV
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      integer(kind(rocblas_outofplace)),value :: fast_alg
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgesvd_batched_full_rank,&
      
rocsolver_dgesvd_batched_rank_0,&
      
rocsolver_dgesvd_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgesvd_batched
    function rocsolver_cgesvd_batched_(handle,left_svect,right_svect,m,n,A,lda,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count) bind(c, name="rocsolver_cgesvd_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvd_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: S
      integer(c_int64_t),value :: strideS
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      integer(c_int64_t),value :: strideU
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      integer(c_int64_t),value :: strideV
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      integer(kind(rocblas_outofplace)),value :: fast_alg
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgesvd_batched_full_rank,&
      
rocsolver_cgesvd_batched_rank_0,&
      
rocsolver_cgesvd_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgesvd_batched
    function rocsolver_zgesvd_batched_(handle,left_svect,right_svect,m,n,A,lda,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count) bind(c, name="rocsolver_zgesvd_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvd_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: S
      integer(c_int64_t),value :: strideS
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      integer(c_int64_t),value :: strideU
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      integer(c_int64_t),value :: strideV
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      integer(kind(rocblas_outofplace)),value :: fast_alg
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgesvd_batched_full_rank,&
      
rocsolver_zgesvd_batched_rank_0,&
      
rocsolver_zgesvd_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GESVD_STRIDED_BATCHED computes the singular values and optionally the
  !>     singular vectors of a batch of general m-by-n matrices A_l (Singular Value
  !>     Decomposition).
  !> 
  !>     \details
  !>     The SVD of matrix A_l in the batch is given by:
  !> 
  !>     \f[
  !>         A_l^{} = U_l^{}  S_l^{}  V_l'
  !>     \f]
  !> 
  !>     where the m-by-n matrix \f$S_l\f$ is zero except, possibly, for its min(m,n)
  !>     diagonal elements, which are the singular values of \f$A_l\f$. \f$U_l\f$ and \f$V_l\f$ are
  !>     orthogonal (unitary) matrices. The first min(m,n) columns of \f$U_l\f$ and \f$V_l\f$ are
  !>     the left and right singular vectors of \f$A_l\f$, respectively.
  !> 
  !>     The computation of the singular vectors is optional and it is controlled by
  !>     the function arguments left_svect and right_svect as described below. When
  !>     computed, this function returns the transpose (or transpose conjugate) of the
  !>     right singular vectors, i.e. the rows of \f$V_l'\f$.
  !> 
  !>     left_svect and right_svect are #rocblas_svect enums that can take the
  !>     following values:
  !> 
  !>     - rocblas_svect_all: the entire matrix \f$U_l\f$ (or \f$V_l'\f$) is computed,
  !>     - rocblas_svect_singular: only the singular vectors (first min(m,n)
  !>       columns of \f$U_l\f$ or rows of \f$V_l'\f$) are computed,
  !>     - rocblas_svect_overwrite: the
  !>       first columns (or rows) of \f$A_l\f$ are overwritten with the singular vectors, or
  !>     - rocblas_svect_none: no columns (or rows) of \f$U_l\f$ (or \f$V_l'\f$) are computed,
  !>       i.e. no singular vectors.
  !> 
  !>     left_svect and right_svect cannot both be set to overwrite. When neither is
  !>     set to overwrite, the contents of \f$A_l\f$ are destroyed by the time the function
  !>     returns.
  !> 
  !>     \note
  !>     When m >> n (or n >> m) the algorithm could be sped up by compressing
  !>     the matrix \f$A_l\f$ via a QR (or LQ) factorization, and working with the
  !>     triangular factor afterwards (thin-SVD). If the singular vectors are also
  !>     requested, its computation could be sped up as well via executing some
  !>     intermediate operations out-of-place, and relying more on matrix
  !>     multiplications (GEMMs); this will require, however, a larger memory
  !>     workspace. The parameter fast_alg controls whether the fast algorithm is
  !>     executed or not. For more details, see the "Tuning rocSOLVER performance"
  !>     and "Memory model" sections of the documentation.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     left_svect  #rocblas_svect.
  !>                 Specifies how the left singular vectors are computed.
  !>     @param[in]
  !>     right_svect #rocblas_svect.
  !>                 Specifies how the right singular vectors are computed.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all matrices A_l in the batch.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the matrices A_l. On exit, if left_svect (or right_svect) is equal to
  !>                 overwrite, the first columns (or rows) of A_l contain the left (or right)
  !>                 corresponding singular vectors; otherwise, the contents of A_l are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 The leading dimension of A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA.
  !>                 Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     S           pointer to real type. Array on the GPU (the size depends on the value of strideS).
  !>                 The singular values of A_l in decreasing order.
  !>     @param[in]
  !>     strideS     rocblas_stride.
  !>                 Stride from the start of one vector S_l to the next one S_(l+1).
  !>                 There is no restriction for the value of strideS.
  !>                 Normal use case is strideS >= min(m,n).
  !>     @param[out]
  !>     U           pointer to type. Array on the GPU (the side depends on the value of strideU).
  !>                 The matrices U_l of left singular vectors stored as columns.
  !>                 Not referenced if left_svect is set to overwrite or none.
  !>     @param[in]
  !>     ldu         rocblas_int. ldu >= m if left_svect is all or singular; ldu >= 1 otherwise.
  !>                 The leading dimension of U_l.
  !>     @param[in]
  !>     strideU     rocblas_stride.
  !>                 Stride from the start of one matrix U_l to the next one U_(l+1).
  !>                 There is no restriction for the value of strideU.
  !>                 Normal use case is strideU >= ldumin(m,n) if left_svect is set to singular,
  !>                 or strideU >= ldum when left_svect is equal to all.
  !>     @param[out]
  !>     V           pointer to type. Array on the GPU (the size depends on the value of strideV).
  !>                 The matrices V_l of right singular vectors stored as rows (transposed  conjugate-transposed).
  !>                 Not referenced if right_svect is set to overwrite or none.
  !>     @param[in]
  !>     ldv         rocblas_int. ldv >= n if right_svect is all; ldv >= min(m,n) if right_svect is
  !>                 set to singular; or ldv >= 1 otherwise.
  !>                 The leading dimension of V_l.
  !>     @param[in]
  !>     strideV     rocblas_stride.
  !>                 Stride from the start of one matrix V_l to the next one V_(l+1).
  !>                 There is no restriction for the value of strideV.
  !>                 Normal use case is strideV >= ldvn.
  !>     @param[out]
  !>     E           pointer to real type. Array on the GPU (the size depends on the value of strideE).
  !>                 This array is used to work internally with the bidiagonal matrix B_l associated with A_l (using \ref rocsolver_sbdsqr "BDSQR").
  !>                 On exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of B_l (or properly speaking,
  !>                 a bidiagonal matrix orthogonally equivalent to B_l). The diagonal elements of this matrix are in S_l;
  !>                 those that converged correspond to a subset of the singular values of A_l (not necessarily ordered).
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE.
  !>                 Normal use case is strideE >= min(m,n)-1.
  !>     @param[in]
  !>     fast_alg    #rocblas_workmode.
  !>                 If set to rocblas_outofplace, the function will execute the fast thin-SVD version
  !>                 of the algorithm when possible.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info[l] = 0, successful exit.
  !>                 If info[l] = i > 0, BDSQR did not converge. i elements of E_l did not converge to zero.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgesvd_strided_batched
    function rocsolver_sgesvd_strided_batched_(handle,left_svect,right_svect,m,n,A,lda,strideA,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count) bind(c, name="rocsolver_sgesvd_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvd_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: S
      integer(c_int64_t),value :: strideS
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      integer(c_int64_t),value :: strideU
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      integer(c_int64_t),value :: strideV
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      integer(kind(rocblas_outofplace)),value :: fast_alg
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgesvd_strided_batched_full_rank,&
      
rocsolver_sgesvd_strided_batched_rank_0,&
      
rocsolver_sgesvd_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgesvd_strided_batched
    function rocsolver_dgesvd_strided_batched_(handle,left_svect,right_svect,m,n,A,lda,strideA,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count) bind(c, name="rocsolver_dgesvd_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvd_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: S
      integer(c_int64_t),value :: strideS
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      integer(c_int64_t),value :: strideU
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      integer(c_int64_t),value :: strideV
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      integer(kind(rocblas_outofplace)),value :: fast_alg
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgesvd_strided_batched_full_rank,&
      
rocsolver_dgesvd_strided_batched_rank_0,&
      
rocsolver_dgesvd_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgesvd_strided_batched
    function rocsolver_cgesvd_strided_batched_(handle,left_svect,right_svect,m,n,A,lda,strideA,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count) bind(c, name="rocsolver_cgesvd_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvd_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: S
      integer(c_int64_t),value :: strideS
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      integer(c_int64_t),value :: strideU
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      integer(c_int64_t),value :: strideV
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      integer(kind(rocblas_outofplace)),value :: fast_alg
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgesvd_strided_batched_full_rank,&
      
rocsolver_cgesvd_strided_batched_rank_0,&
      
rocsolver_cgesvd_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgesvd_strided_batched
    function rocsolver_zgesvd_strided_batched_(handle,left_svect,right_svect,m,n,A,lda,strideA,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count) bind(c, name="rocsolver_zgesvd_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvd_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: S
      integer(c_int64_t),value :: strideS
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      integer(c_int64_t),value :: strideU
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      integer(c_int64_t),value :: strideV
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      integer(kind(rocblas_outofplace)),value :: fast_alg
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgesvd_strided_batched_full_rank,&
      
rocsolver_zgesvd_strided_batched_rank_0,&
      
rocsolver_zgesvd_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GESVDJ computes the singular values and optionally the singular
  !>     vectors of a general m-by-n matrix A (Singular Value Decomposition).
  !> 
  !>     \details
  !>     The SVD of matrix A is given by:
  !> 
  !>     \f[
  !>         A = U  S  V'
  !>     \f]
  !> 
  !>     where the m-by-n matrix S is zero except, possibly, for its min(m,n)
  !>     diagonal elements, which are the singular values of A. U and V are orthogonal
  !>     (unitary) matrices. The first min(m,n) columns of U and V are the left and
  !>     right singular vectors of A, respectively.
  !> 
  !>     The computation of the singular vectors is optional and it is controlled by
  !>     the function arguments left_svect and right_svect as described below. When
  !>     computed, this function returns the transpose (or transpose conjugate) of the
  !>     right singular vectors, i.e. the rows of V'.
  !> 
  !>     left_svect and right_svect are #rocblas_svect enums that can take the
  !>     following values:
  !> 
  !>     - rocblas_svect_all: the entire matrix U (or V') is computed,
  !>     - rocblas_svect_singular: the singular vectors (first min(m,n)
  !>       columns of U or rows of V') are computed, or
  !>     - rocblas_svect_none: no columns (or rows) of U (or V') are computed, i.e.
  !>       no singular vectors.
  !> 
  !>     The singular values are computed by applying QR factorization to AV if m >= n
  !>     (resp. LQ factorization to U'A if m < n), where V (resp. U) is found as the
  !>     eigenvectors of A'A (resp. AA') using the Jacobi eigenvalue algorithm.
  !> 
  !>     \note
  !>     In order to carry out calculations, this method may synchronize the stream contained within the
  !>     rocblas_handle.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     left_svect  #rocblas_svect.
  !>                 Specifies how the left singular vectors are computed.
  !>                 rocblas_svect_overwrite is not supported.
  !>     @param[in]
  !>     right_svect #rocblas_svect.
  !>                 Specifies how the right singular vectors are computed.
  !>                 rocblas_svect_overwrite is not supported.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of matrix A.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A.
  !>                 On exit, the contents of A are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 The leading dimension of A.
  !>     @param[in]
  !>     abstol      real type.
  !>                 The absolute tolerance. The algorithm is considered to have converged once off(A'A)
  !>                 is <= norm(A'A)  abstol [resp. off(AA') <= norm(AA')  abstol]. If abstol <= 0,
  !>                 then the tolerance will be set to machine precision.
  !>     @param[out]
  !>     residual    pointer to real type on the GPU.
  !>                 The Frobenius norm of the off-diagonal elements of A'A (resp. AA') at the final
  !>                 iteration.
  !>     @param[in]
  !>     max_sweeps  rocblas_int. max_sweeps > 0.
  !>                 Maximum number of sweeps (iterations) to be used by the algorithm.
  !>     @param[out]
  !>     n_sweeps    pointer to a rocblas_int on the GPU.
  !>                 The actual number of sweeps (iterations) used by the algorithm.
  !>     @param[out]
  !>     S           pointer to real type. Array on the GPU of dimension min(m,n).
  !>                 The singular values of A in decreasing order.
  !>     @param[out]
  !>     U           pointer to type. Array on the GPU of dimension ldumin(m,n) if
  !>                 left_svect is set to singular, or ldum when left_svect is equal to all.
  !>                 The matrix of left singular vectors stored as columns. Not
  !>                 referenced if left_svect is set to none.
  !>     @param[in]
  !>     ldu         rocblas_int. ldu >= m if left_svect is set to all or singular; ldu >= 1 otherwise.
  !>                 The leading dimension of U.
  !>     @param[out]
  !>     V           pointer to type. Array on the GPU of dimension ldvn.
  !>                 The matrix of right singular vectors stored as rows (transposed  conjugate-transposed).
  !>                 Not referenced if right_svect is set to none.
  !>     @param[in]
  !>     ldv         rocblas_int. ldv >= n if right_svect is set to all; ldv >= min(m,n) if right_svect is
  !>                 set to singular; or ldv >= 1 otherwise.
  !>                 The leading dimension of V.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit. If info = 1, the algorithm did not converge.
  !>     
  interface rocsolver_sgesvdj
    function rocsolver_sgesvdj_(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,U,ldu,V,ldv,myInfo) bind(c, name="rocsolver_sgesvdj")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvdj_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_float),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: S
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgesvdj_full_rank,&
      
rocsolver_sgesvdj_rank_0,&
      
rocsolver_sgesvdj_rank_1
#endif

  end interface
  
  interface rocsolver_dgesvdj
    function rocsolver_dgesvdj_(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,U,ldu,V,ldv,myInfo) bind(c, name="rocsolver_dgesvdj")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvdj_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_double),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: S
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgesvdj_full_rank,&
      
rocsolver_dgesvdj_rank_0,&
      
rocsolver_dgesvdj_rank_1
#endif

  end interface
  
  interface rocsolver_cgesvdj
    function rocsolver_cgesvdj_(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,U,ldu,V,ldv,myInfo) bind(c, name="rocsolver_cgesvdj")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvdj_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_float),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: S
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgesvdj_full_rank,&
      
rocsolver_cgesvdj_rank_0,&
      
rocsolver_cgesvdj_rank_1
#endif

  end interface
  
  interface rocsolver_zgesvdj
    function rocsolver_zgesvdj_(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,U,ldu,V,ldv,myInfo) bind(c, name="rocsolver_zgesvdj")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvdj_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_double),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: S
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgesvdj_full_rank,&
      
rocsolver_zgesvdj_rank_0,&
      
rocsolver_zgesvdj_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GESVDJ_BATCHED computes the singular values and optionally the
  !>     singular vectors of a batch of general m-by-n matrix A (Singular Value
  !>     Decomposition).
  !> 
  !>     \details
  !>     The SVD of matrix A_l in the batch is given by:
  !> 
  !>     \f[
  !>         A_l = U_l  S_l  V_l'
  !>     \f]
  !> 
  !>     where the m-by-n matrix \f$S_l\f$ is zero except, possibly, for its min(m,n)
  !>     diagonal elements, which are the singular values of \f$A_l\f$. \f$U_l\f$ and \f$V_l\f$ are
  !>     orthogonal (unitary) matrices. The first min(m,n) columns of \f$U_l\f$ and \f$V_l\f$ are
  !>     the left and right singular vectors of \f$A_l\f$, respectively.
  !> 
  !>     The computation of the singular vectors is optional and it is controlled by
  !>     the function arguments left_svect and right_svect as described below. When
  !>     computed, this function returns the transpose (or transpose conjugate) of the
  !>     right singular vectors, i.e. the rows of \f$V_l'\f$.
  !> 
  !>     left_svect and right_svect are #rocblas_svect enums that can take the
  !>     following values:
  !> 
  !>     - rocblas_svect_all: the entire matrix \f$U_l\f$ (or \f$V_l'\f$) is computed,
  !>     - rocblas_svect_singular: the singular vectors (first min(m,n)
  !>       columns of \f$U_l\f$ or rows of \f$V_l'\f$) are computed, or
  !>     - rocblas_svect_none: no columns (or rows) of \f$U_l\f$ (or \f$V_l'\f$) are computed,
  !>       i.e. no singular vectors.
  !> 
  !>     The singular values are computed by applying QR factorization to \f$A_lV_l\f$ if m >= n
  !>     (resp. LQ factorization to \f$U_l'A_l\f$ if m < n), where \f$V_l\f$ (resp. \f$U_l\f$) is
  !>     found as the eigenvectors of \f$A_l'A_l\f$ (resp. \f$A_lA_l'\f$) using the Jacobi
  !>     eigenvalue algorithm.
  !> 
  !>     \note
  !>     In order to carry out calculations, this method may synchronize the stream contained within the
  !>     rocblas_handle.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     left_svect  #rocblas_svect.
  !>                 Specifies how the left singular vectors are computed.
  !>                 rocblas_svect_overwrite is not supported.
  !>     @param[in]
  !>     right_svect #rocblas_svect.
  !>                 Specifies how the right singular vectors are computed.
  !>                 rocblas_svect_overwrite is not supported.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all matrices A_l in the batch.
  !>     @param[inout]
  !>     A           Array of pointers to type. Each pointer points to an array on
  !>                 the GPU of dimension ldan.
  !>                 On entry, the matrices A_l.
  !>                 On exit, the contents of A_l are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 The leading dimension of A_l.
  !>     @param[in]
  !>     abstol      real type.
  !>                 The absolute tolerance. The algorithm is considered to have converged once off(A_l'A_l)
  !>                 is <= norm(A_l'A_l)  abstol [resp. off(A_lA_l') <= norm(A_lA_l')  abstol]. If abstol <= 0,
  !>                 then the tolerance will be set to machine precision.
  !>     @param[out]
  !>     residual    pointer to real type on the GPU.
  !>                 The Frobenius norm of the off-diagonal elements of A_l'A_l (resp. A_lA_l') at the final
  !>                 iteration.
  !>     @param[in]
  !>     max_sweeps  rocblas_int. max_sweeps > 0.
  !>                 Maximum number of sweeps (iterations) to be used by the algorithm.
  !>     @param[out]
  !>     n_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 The actual number of sweeps (iterations) used by the algorithm for each batch instance.
  !>     @param[out]
  !>     S           pointer to real type. Array on the GPU (the size depends on the value of strideS).
  !>                 The singular values of A_l in decreasing order.
  !>     @param[in]
  !>     strideS     rocblas_stride.
  !>                 Stride from the start of one vector S_l to the next one S(l+1).
  !>                 There is no restriction for the value of strideS.
  !>                 Normal use case is strideS >= min(m,n).
  !>     @param[out]
  !>     U           pointer to type. Array on the GPU (the side depends on the value of strideU).
  !>                 The matrices U_l of left singular vectors stored as columns.
  !>                 Not referenced if left_svect is set to none.
  !>     @param[in]
  !>     ldu         rocblas_int. ldu >= m if left_svect is set to all or singular; ldu >= 1 otherwise.
  !>                 The leading dimension of U_l.
  !>     @param[in]
  !>     strideU     rocblas_stride.
  !>                 Stride from the start of one matrix U_l to the next one U(l+1).
  !>                 There is no restriction for the value of strideU.
  !>                 Normal use case is strideU >= ldumin(m,n) if left_svect is set to singular,
  !>                 or strideU >= ldum when left_svect is equal to all.
  !>     @param[out]
  !>     V           pointer to type. Array on the GPU (the size depends on the value of strideV).
  !>                 The matrices V_l of right singular vectors stored as rows (transposed  conjugate-transposed).
  !>                 Not referenced if right_svect is set to none.
  !>     @param[in]
  !>     ldv         rocblas_int. ldv >= n if right_svect is set to all; ldv >= min(m,n) if right_svect is
  !>                 set to singular; or ldv >= 1 otherwise.
  !>                 The leading dimension of V.
  !>     @param[in]
  !>     strideV     rocblas_stride.
  !>                 Stride from the start of one matrix V_l to the next one V(l+1).
  !>                 There is no restriction for the value of strideV.
  !>                 Normal use case is strideV >= ldvn.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info[l] = 0, successful exit. If info[l] = 1, the algorithm did not converge.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgesvdj_batched
    function rocsolver_sgesvdj_batched_(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count) bind(c, name="rocsolver_sgesvdj_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvdj_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_float),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: S
      integer(c_int64_t),value :: strideS
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      integer(c_int64_t),value :: strideU
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      integer(c_int64_t),value :: strideV
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgesvdj_batched_full_rank,&
      
rocsolver_sgesvdj_batched_rank_0,&
      
rocsolver_sgesvdj_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgesvdj_batched
    function rocsolver_dgesvdj_batched_(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count) bind(c, name="rocsolver_dgesvdj_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvdj_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_double),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: S
      integer(c_int64_t),value :: strideS
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      integer(c_int64_t),value :: strideU
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      integer(c_int64_t),value :: strideV
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgesvdj_batched_full_rank,&
      
rocsolver_dgesvdj_batched_rank_0,&
      
rocsolver_dgesvdj_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgesvdj_batched
    function rocsolver_cgesvdj_batched_(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count) bind(c, name="rocsolver_cgesvdj_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvdj_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_float),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: S
      integer(c_int64_t),value :: strideS
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      integer(c_int64_t),value :: strideU
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      integer(c_int64_t),value :: strideV
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgesvdj_batched_full_rank,&
      
rocsolver_cgesvdj_batched_rank_0,&
      
rocsolver_cgesvdj_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgesvdj_batched
    function rocsolver_zgesvdj_batched_(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count) bind(c, name="rocsolver_zgesvdj_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvdj_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_double),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: S
      integer(c_int64_t),value :: strideS
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      integer(c_int64_t),value :: strideU
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      integer(c_int64_t),value :: strideV
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgesvdj_batched_full_rank,&
      
rocsolver_zgesvdj_batched_rank_0,&
      
rocsolver_zgesvdj_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GESVDJ_STRIDED_BATCHED computes the singular values and optionally the
  !>     singular vectors of a batch of general m-by-n matrix A (Singular Value
  !>     Decomposition).
  !> 
  !>     \details
  !>     The SVD of matrix A_l in the batch is given by:
  !> 
  !>     \f[
  !>         A_l = U_l  S_l  V_l'
  !>     \f]
  !> 
  !>     where the m-by-n matrix \f$S_l\f$ is zero except, possibly, for its min(m,n)
  !>     diagonal elements, which are the singular values of \f$A_l\f$. \f$U_l\f$ and \f$V_l\f$ are
  !>     orthogonal (unitary) matrices. The first min(m,n) columns of \f$U_l\f$ and \f$V_l\f$ are
  !>     the left and right singular vectors of \f$A_l\f$, respectively.
  !> 
  !>     The computation of the singular vectors is optional and it is controlled by
  !>     the function arguments left_svect and right_svect as described below. When
  !>     computed, this function returns the transpose (or transpose conjugate) of the
  !>     right singular vectors, i.e. the rows of \f$V_l'\f$.
  !> 
  !>     left_svect and right_svect are #rocblas_svect enums that can take the
  !>     following values:
  !> 
  !>     - rocblas_svect_all: the entire matrix \f$U_l\f$ (or \f$V_l'\f$) is computed,
  !>     - rocblas_svect_singular: the singular vectors (first min(m,n)
  !>       columns of \f$U_l\f$ or rows of \f$V_l'\f$) are computed, or
  !>     - rocblas_svect_none: no columns (or rows) of \f$U_l\f$ (or \f$V_l'\f$) are computed,
  !>       i.e. no singular vectors.
  !> 
  !>     The singular values are computed by applying QR factorization to \f$A_lV_l\f$ if m >= n
  !>     (resp. LQ factorization to \f$U_l'A_l\f$ if m < n), where \f$V_l\f$ (resp. \f$U_l\f$) is
  !>     found as the eigenvectors of \f$A_l'A_l\f$ (resp. \f$A_lA_l'\f$) using the Jacobi
  !>     eigenvalue algorithm.
  !> 
  !>     \note
  !>     In order to carry out calculations, this method may synchronize the stream contained within the
  !>     rocblas_handle.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     left_svect  #rocblas_svect.
  !>                 Specifies how the left singular vectors are computed.
  !>                 rocblas_svect_overwrite is not supported.
  !>     @param[in]
  !>     right_svect #rocblas_svect.
  !>                 Specifies how the right singular vectors are computed.
  !>                 rocblas_svect_overwrite is not supported.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of all matrices A_l in the batch.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of all matrices A_l in the batch.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the matrices A_l.
  !>                 On exit, the contents of A_l are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 The leading dimension of A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(j+1).
  !>                 There is no restriction for the value of strideA.
  !>                 Normal use case is strideA >= ldan.
  !>     @param[in]
  !>     abstol      real type.
  !>                 The absolute tolerance. The algorithm is considered to have converged once off(A_l'A_l)
  !>                 is <= norm(A_l'A_l)  abstol [resp. off(A_lA_l') <= norm(A_lA_l')  abstol]. If abstol <= 0,
  !>                 then the tolerance will be set to machine precision.
  !>     @param[out]
  !>     residual    pointer to real type on the GPU.
  !>                 The Frobenius norm of the off-diagonal elements of A_l'A_l (resp. A_lA_l') at the final
  !>                 iteration.
  !>     @param[in]
  !>     max_sweeps  rocblas_int. max_sweeps > 0.
  !>                 Maximum number of sweeps (iterations) to be used by the algorithm.
  !>     @param[out]
  !>     n_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 The actual number of sweeps (iterations) used by the algorithm for each batch instance.
  !>     @param[out]
  !>     S           pointer to real type. Array on the GPU (the size depends on the value of strideS).
  !>                 The singular values of A_l in decreasing order.
  !>     @param[in]
  !>     strideS     rocblas_stride.
  !>                 Stride from the start of one vector S_l to the next one S_(j+1).
  !>                 There is no restriction for the value of strideS.
  !>                 Normal use case is strideS >= min(m,n).
  !>     @param[out]
  !>     U           pointer to type. Array on the GPU (the side depends on the value of strideU).
  !>                 The matrices U_l of left singular vectors stored as columns.
  !>                 Not referenced if left_svect is set to none.
  !>     @param[in]
  !>     ldu         rocblas_int. ldu >= m if left_svect is set to all or singular; ldu >= 1 otherwise.
  !>                 The leading dimension of U_l.
  !>     @param[in]
  !>     strideU     rocblas_stride.
  !>                 Stride from the start of one matrix U_l to the next one U_(j+1).
  !>                 There is no restriction for the value of strideU.
  !>                 Normal use case is strideU >= ldumin(m,n) if left_svect is set to singular,
  !>                 or strideU >= ldum when left_svect is equal to all.
  !>     @param[out]
  !>     V           pointer to type. Array on the GPU (the size depends on the value of strideV).
  !>                 The matrices V_l of right singular vectors stored as rows (transposed  conjugate-transposed).
  !>                 Not referenced if right_svect is set to none.
  !>     @param[in]
  !>     ldv         rocblas_int. ldv >= n if right_svect is set to all; ldv >= min(m,n) if right_svect is
  !>                 set to singular; or ldv >= 1 otherwise.
  !>                 The leading dimension of V.
  !>     @param[in]
  !>     strideV     rocblas_stride.
  !>                 Stride from the start of one matrix V_l to the next one V_(j+1).
  !>                 There is no restriction for the value of strideV.
  !>                 Normal use case is strideV >= ldvn.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info[l] = 0, successful exit. If info[l] = 1, the algorithm did not converge.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgesvdj_strided_batched
    function rocsolver_sgesvdj_strided_batched_(handle,left_svect,right_svect,m,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count) bind(c, name="rocsolver_sgesvdj_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvdj_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_float),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: S
      integer(c_int64_t),value :: strideS
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      integer(c_int64_t),value :: strideU
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      integer(c_int64_t),value :: strideV
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgesvdj_strided_batched_full_rank,&
      
rocsolver_sgesvdj_strided_batched_rank_0,&
      
rocsolver_sgesvdj_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgesvdj_strided_batched
    function rocsolver_dgesvdj_strided_batched_(handle,left_svect,right_svect,m,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count) bind(c, name="rocsolver_dgesvdj_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvdj_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_double),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: S
      integer(c_int64_t),value :: strideS
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      integer(c_int64_t),value :: strideU
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      integer(c_int64_t),value :: strideV
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgesvdj_strided_batched_full_rank,&
      
rocsolver_dgesvdj_strided_batched_rank_0,&
      
rocsolver_dgesvdj_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgesvdj_strided_batched
    function rocsolver_cgesvdj_strided_batched_(handle,left_svect,right_svect,m,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count) bind(c, name="rocsolver_cgesvdj_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvdj_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_float),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: S
      integer(c_int64_t),value :: strideS
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      integer(c_int64_t),value :: strideU
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      integer(c_int64_t),value :: strideV
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgesvdj_strided_batched_full_rank,&
      
rocsolver_cgesvdj_strided_batched_rank_0,&
      
rocsolver_cgesvdj_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgesvdj_strided_batched
    function rocsolver_zgesvdj_strided_batched_(handle,left_svect,right_svect,m,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count) bind(c, name="rocsolver_zgesvdj_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvdj_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_double),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: S
      integer(c_int64_t),value :: strideS
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      integer(c_int64_t),value :: strideU
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      integer(c_int64_t),value :: strideV
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgesvdj_strided_batched_full_rank,&
      
rocsolver_zgesvdj_strided_batched_rank_0,&
      
rocsolver_zgesvdj_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GESVDX computes a set of singular values and optionally the corresponding singular
  !>     vectors of a general m-by-n matrix A (partial Singular Value Decomposition).
  !> 
  !>     \details
  !>     This function computes all the singular values of A, all the singular values in the half-open interval
  !>     \f$[vl, vu)\f$, or the il-th through iu-th singular values, depending on the value of srange.
  !> 
  !>     The full SVD of matrix A is given by:
  !> 
  !>     \f[
  !>         A = U  S  V'
  !>     \f]
  !> 
  !>     where the m-by-n matrix S is zero except, possibly, for its min(m,n)
  !>     diagonal elements, which are the singular values of A. U and V are orthogonal
  !>     (unitary) matrices. The first min(m,n) columns of U and V are the left and
  !>     right singular vectors of A, respectively.
  !> 
  !>     The computation of the singular vectors is optional and it is controlled by
  !>     the function arguments left_svect and right_svect as described below. When
  !>     computed, this function returns the transpose (or transpose conjugate) of the
  !>     right singular vectors, i.e. the rows of V'.
  !> 
  !>     left_svect and right_svect are #rocblas_svect enums that, for this function, can take the
  !>     following values:
  !> 
  !>     - rocblas_svect_singular: the singular vectors (first min(m,n)
  !>       columns of U or rows of V') corresponding to the computed singular values are computed,
  !>     - rocblas_svect_none: no columns (or rows) of U (or V') are computed, i.e.
  !>       no singular vectors.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     left_svect  #rocblas_svect.
  !>                 Specifies if the left singular vectors are computed.
  !>     @param[in]
  !>     right_svect #rocblas_svect.
  !>                 Specifies if the right singular vectors are computed.
  !>     @param[in]
  !>     srange      #rocblas_srange.
  !>                 Specifies the type of range or interval of the singular values to be computed.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of matrix A.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A.
  !>                 On exit, the contents of A are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 The leading dimension of A.
  !>     @param[in]
  !>     vl          real type. 0 <= vl < vu.
  !>                 The lower bound of the search interval [vl, vu). Ignored if srange indicates to look
  !>                 for all the singular values of A or the singular values within a set of indices.
  !>     @param[in]
  !>     vu          real type. 0 <= vl < vu.
  !>                 The upper bound of the search interval [vl, vu). Ignored if srange indicates to look
  !>                 for all the singular values of A or the singular values within a set of indices.
  !>     @param[in]
  !>     il          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.
  !>                 The index of the largest singular value to be computed. Ignored if srange indicates to look
  !>                 for all the singular values of A or the singular values in a half-open interval.
  !>     @param[in]
  !>     iu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise.
  !>                 The index of the smallest singular value to be computed. Ignored if srange indicates to look
  !>                 for all the singular values of A or the singular values in a half-open interval.
  !>     @param[out]
  !>     nsv         pointer to a rocblas_int on the GPU.
  !>                 The total number of singular values found. If srange is rocblas_srange_all, nsv = min(m,n).
  !>                 If srange is rocblas_srange_index, nsv = iu - il + 1. Otherwise, 0 <= nsv <= min(m,n).
  !>     @param[out]
  !>     S           pointer to real type. Array on the GPU of dimension nsv.
  !>                 The first nsv elements contain the computed singular values in descending order.
  !>                 Note: If srange is rocblas_srange_value, then the value of nsv is not known in advance.
  !>                 In this case, the user should ensure that S is large enough to hold min(m,n) values.
  !>     @param[out]
  !>     U           pointer to type. Array on the GPU of dimension ldunsv.
  !>                 The matrix of left singular vectors stored as columns. Not
  !>                 referenced if left_svect is set to none.
  !>                 Note: If srange is rocblas_srange_value, then the value of nsv is not known in advance.
  !>                 In this case, the user should ensure that U is large enough to hold min(m,n) columns.
  !>     @param[in]
  !>     ldu         rocblas_int. ldu >= m if left_svect singular; ldu >= 1 otherwise.
  !>                 The leading dimension of U.
  !>     @param[out]
  !>     V           pointer to type. Array on the GPU of dimension ldvn.
  !>                 The matrix of right singular vectors stored as rows (transposed  conjugate-transposed).
  !>                 Not referenced if right_svect is set to none.
  !>     @param[in]
  !>     ldv         rocblas_int. ldv >= nsv if right_svect is set to singular; or ldv >= 1 otherwise.
  !>                 The leading dimension of V.
  !>                 Note: If srange is rocblas_srange_value, then the value of nsv is not known in advance.
  !>                 In this case, the user should ensure that V is large enough to hold min(m,n) rows.
  !>     @param[out]
  !>     ifail       pointer to rocblas_int. Array on the GPU of dimension min(m,n).
  !>                 If info = 0, the first nsv elements of ifail are zero.
  !>                 Otherwise, contains the indices of those eigenvectors that failed
  !>                 to converge, as returned by \ref rocsolver_sbdsvdx "BDSVDX".
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0, i eigenvectors did not converge in \ref rocsolver_sbdsvdx "BDSVDX"; their
  !>                 indices are stored in ifail.
  !>     
  interface rocsolver_sgesvdx
    function rocsolver_sgesvdx_(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,U,ldu,V,ldv,ifail,myInfo) bind(c, name="rocsolver_sgesvdx")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvdx_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(kind(rocblas_srange_all)),value :: srange
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_float),value :: vl
      real(c_float),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      type(c_ptr),value :: nsv
      type(c_ptr),value :: S
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      type(c_ptr),value :: ifail
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgesvdx_full_rank,&
      
rocsolver_sgesvdx_rank_0,&
      
rocsolver_sgesvdx_rank_1
#endif

  end interface
  
  interface rocsolver_dgesvdx
    function rocsolver_dgesvdx_(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,U,ldu,V,ldv,ifail,myInfo) bind(c, name="rocsolver_dgesvdx")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvdx_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(kind(rocblas_srange_all)),value :: srange
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_double),value :: vl
      real(c_double),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      type(c_ptr),value :: nsv
      type(c_ptr),value :: S
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      type(c_ptr),value :: ifail
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgesvdx_full_rank,&
      
rocsolver_dgesvdx_rank_0,&
      
rocsolver_dgesvdx_rank_1
#endif

  end interface
  
  interface rocsolver_cgesvdx
    function rocsolver_cgesvdx_(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,U,ldu,V,ldv,ifail,myInfo) bind(c, name="rocsolver_cgesvdx")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvdx_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(kind(rocblas_srange_all)),value :: srange
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_float),value :: vl
      real(c_float),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      type(c_ptr),value :: nsv
      type(c_ptr),value :: S
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      type(c_ptr),value :: ifail
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgesvdx_full_rank,&
      
rocsolver_cgesvdx_rank_0,&
      
rocsolver_cgesvdx_rank_1
#endif

  end interface
  
  interface rocsolver_zgesvdx
    function rocsolver_zgesvdx_(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,U,ldu,V,ldv,ifail,myInfo) bind(c, name="rocsolver_zgesvdx")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvdx_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(kind(rocblas_srange_all)),value :: srange
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_double),value :: vl
      real(c_double),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      type(c_ptr),value :: nsv
      type(c_ptr),value :: S
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      type(c_ptr),value :: ifail
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgesvdx_full_rank,&
      
rocsolver_zgesvdx_rank_0,&
      
rocsolver_zgesvdx_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GESVDX_BATCHED computes a set of singular values and optionally the corresponding singular
  !>     vectors of a batch of general m-by-n matrices \f$A_l\f$ (partial Singular Value Decomposition).
  !> 
  !>     \details
  !>     This function computes all the singular values of \f$A_l\f$, all the singular values in the half-open interval
  !>     \f$[vl, vu)\f$, or the il-th through iu-th singular values, depending on the value of srange.
  !> 
  !>     The full SVD of matrix \f$A_l\f$  is given by:
  !> 
  !>     \f[
  !>         A_l = U_l  S_l  V_l'
  !>     \f]
  !> 
  !>     where the m-by-n matrix \f$S_l\f$  is zero except, possibly, for its min(m,n)
  !>     diagonal elements, which are the singular values of \f$A_l\f$ . \f$U_l\f$  and \f$V_l\f$  are orthogonal
  !>     (unitary) matrices. The first min(m,n) columns of \f$U_l\f$  and \f$V_l\f$  are the left and
  !>     right singular vectors of \f$A_l\f$ , respectively.
  !> 
  !>     The computation of the singular vectors is optional and it is controlled by
  !>     the function arguments left_svect and right_svect as described below. When
  !>     computed, this function returns the transpose (or transpose conjugate) of the
  !>     right singular vectors, i.e. the rows of \f$V_l'\f$.
  !> 
  !>     left_svect and right_svect are #rocblas_svect enums that, for this function, can take the
  !>     following values:
  !> 
  !>     - rocblas_svect_singular: the singular vectors (first min(m,n)
  !>       columns of \f$U_l\f$  or rows of \f$V_l'\f$ ) corresponding to the computed singular values are computed,
  !>     - rocblas_svect_none: no columns (or rows) of \f$U_l\f$  (or \f$V_l'\f$ ) are computed, i.e.
  !>       no singular vectors.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     left_svect  #rocblas_svect.
  !>                 Specifies if the left singular vectors are computed.
  !>     @param[in]
  !>     right_svect #rocblas_svect.
  !>                 Specifies if the right singular vectors are computed.
  !>     @param[in]
  !>     srange      #rocblas_srange.
  !>                 Specifies the type of range or interval of the singular values to be computed.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of matrix A_l.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of matrix A_l.
  !>     @param[inout]
  !>     A           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the matrices A_l.
  !>                 On exit, the contents of A_l are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 The leading dimension of A_l.
  !>     @param[in]
  !>     vl          real type. 0 <= vl < vu.
  !>                 The lower bound of the search interval [vl, vu). Ignored if srange indicates to look
  !>                 for all the singular values of A_l or the singular values within a set of indices.
  !>     @param[in]
  !>     vu          real type. 0 <= vl < vu.
  !>                 The upper bound of the search interval [vl, vu). Ignored if srange indicates to look
  !>                 for all the singular values of A_l or the singular values within a set of indices.
  !>     @param[in]
  !>     il          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.
  !>                 The index of the largest singular value to be computed. Ignored if srange indicates to look
  !>                 for all the singular values of A_l or the singular values in a half-open interval.
  !>     @param[in]
  !>     iu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise.
  !>                 The index of the smallest singular value to be computed. Ignored if srange indicates to look
  !>                 for all the singular values of A_l or the singular values in a half-open interval.
  !>     @param[out]
  !>     nsv         pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 The total number of singular values found. If srange is rocblas_srange_all, nsv[l] = min(m,n).
  !>                 If srange is rocblas_srange_index, nsv[l] = iu - il + 1. Otherwise, 0 <= nsv[l] <= min(m,n).
  !>     @param[out]
  !>     S           pointer to real type. Array on the GPU (the size depends on the value of strideS).
  !>                 The first nsv_l elements contain the computed singular values in descending order.
  !>                 (The remaining elements may be used as workspace for internal computations).
  !>     @param[in]
  !>     strideS     rocblas_stride.
  !>                 Stride from the start of one vector S_l to the next one S_(l+1).
  !>                 There is no restriction for the value of strideS. Normal use case is strideS >= nsv_l.
  !>                 Note: If srange is rocblas_srange_value, then the value of nsv_l is not known in advance.
  !>                 In this case, the user should ensure that S_l is large enough to hold min(m,n) values.
  !>     @param[out]
  !>     U           pointer to type. Array on the GPU (the size depends on the value of strideU).
  !>                 The matrix U_l of left singular vectors stored as columns. Not
  !>                 referenced if left_svect is set to none.
  !>     @param[in]
  !>     ldu         rocblas_int. ldu >= m if left_svect singular; ldu >= 1 otherwise.
  !>                 The leading dimension of U_l.
  !>     @param[in]
  !>     strideU     rocblas_stride.
  !>                 Stride from the start of one matrix U_l to the next one U_(l+1).
  !>                 There is no restriction for the value of strideU. Normal use case is strideU >= ldunsv_l.
  !>                 Note: If srange is rocblas_srange_value, then the value of nsv_l is not known in advance.
  !>                 In this case, the user should ensure that U_l is large enough to hold min(m,n) columns.
  !>     @param[out]
  !>     V           pointer to type. Array on the GPU (the size depends on the value of strideV).
  !>                 The matrix V_l of right singular vectors stored as rows (transposed  conjugate-transposed).
  !>                 Not referenced if right_svect is set to none.
  !>     @param[in]
  !>     ldv         rocblas_int. ldv >= nsv_l if right_svect is set to singular; or ldv >= 1 otherwise.
  !>                 The leading dimension of V_l.
  !>                 Note: If srange is rocblas_srange_value, then the value of nsv_l is not known in advance.
  !>                 In this case, the user should ensure that V_l is large enough to hold min(m,n) rows.
  !>     @param[in]
  !>     strideV     rocblas_stride.
  !>                 Stride from the start of one matrix V_l to the next one V_(l+1).
  !>                 There is no restriction for the value of strideV. Normal use case is strideV >= ldvn.
  !>     @param[out]
  !>     ifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).
  !>                 If info[l] = 0, the first nsv[l] elements of ifail_l are zero.
  !>                 Otherwise, contains the indices of those eigenvectors that failed
  !>                 to converge, as returned by \ref rocsolver_sbdsvdx "BDSVDX".
  !>     @param[in]
  !>     strideF     rocblas_stride.
  !>                 Stride from the start of one vector ifail_l to the next one ifail_(l+1).
  !>                 There is no restriction for the value of strideF. Normal use case is strideF >= min(m,n).
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info[l] = 0, successful exit.
  !>                 If info[l] = i > 0, i eigenvectors did not converge in \ref rocsolver_sbdsvdx "BDSVDX"; their
  !>                 indices are stored in ifail_l.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgesvdx_batched
    function rocsolver_sgesvdx_batched_(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count) bind(c, name="rocsolver_sgesvdx_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvdx_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(kind(rocblas_srange_all)),value :: srange
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_float),value :: vl
      real(c_float),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      type(c_ptr),value :: nsv
      type(c_ptr),value :: S
      integer(c_int64_t),value :: strideS
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      integer(c_int64_t),value :: strideU
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      integer(c_int64_t),value :: strideV
      type(c_ptr),value :: ifail
      integer(c_int64_t),value :: strideF
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgesvdx_batched_full_rank,&
      
rocsolver_sgesvdx_batched_rank_0,&
      
rocsolver_sgesvdx_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgesvdx_batched
    function rocsolver_dgesvdx_batched_(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count) bind(c, name="rocsolver_dgesvdx_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvdx_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(kind(rocblas_srange_all)),value :: srange
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_double),value :: vl
      real(c_double),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      type(c_ptr),value :: nsv
      type(c_ptr),value :: S
      integer(c_int64_t),value :: strideS
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      integer(c_int64_t),value :: strideU
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      integer(c_int64_t),value :: strideV
      type(c_ptr),value :: ifail
      integer(c_int64_t),value :: strideF
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgesvdx_batched_full_rank,&
      
rocsolver_dgesvdx_batched_rank_0,&
      
rocsolver_dgesvdx_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgesvdx_batched
    function rocsolver_cgesvdx_batched_(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count) bind(c, name="rocsolver_cgesvdx_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvdx_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(kind(rocblas_srange_all)),value :: srange
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_float),value :: vl
      real(c_float),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      type(c_ptr),value :: nsv
      type(c_ptr),value :: S
      integer(c_int64_t),value :: strideS
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      integer(c_int64_t),value :: strideU
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      integer(c_int64_t),value :: strideV
      type(c_ptr),value :: ifail
      integer(c_int64_t),value :: strideF
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgesvdx_batched_full_rank,&
      
rocsolver_cgesvdx_batched_rank_0,&
      
rocsolver_cgesvdx_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgesvdx_batched
    function rocsolver_zgesvdx_batched_(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count) bind(c, name="rocsolver_zgesvdx_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvdx_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(kind(rocblas_srange_all)),value :: srange
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_double),value :: vl
      real(c_double),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      type(c_ptr),value :: nsv
      type(c_ptr),value :: S
      integer(c_int64_t),value :: strideS
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      integer(c_int64_t),value :: strideU
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      integer(c_int64_t),value :: strideV
      type(c_ptr),value :: ifail
      integer(c_int64_t),value :: strideF
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgesvdx_batched_full_rank,&
      
rocsolver_zgesvdx_batched_rank_0,&
      
rocsolver_zgesvdx_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GESVDX_STRIDED_BATCHED computes a set of singular values and optionally the corresponding singular
  !>     vectors of a batch of general m-by-n matrices \f$A_l\f$ (partial Singular Value Decomposition).
  !> 
  !>     \details
  !>     This function computes all the singular values of \f$A_l\f$, all the singular values in the half-open interval
  !>     \f$[vl, vu)\f$, or the il-th through iu-th singular values, depending on the value of srange.
  !> 
  !>     The full SVD of matrix \f$A_l\f$  is given by:
  !> 
  !>     \f[
  !>         A_l = U_l  S_l  V_l'
  !>     \f]
  !> 
  !>     where the m-by-n matrix \f$S_l\f$  is zero except, possibly, for its min(m,n)
  !>     diagonal elements, which are the singular values of \f$A_l\f$ . \f$U_l\f$  and \f$V_l\f$  are orthogonal
  !>     (unitary) matrices. The first min(m,n) columns of \f$U_l\f$  and \f$V_l\f$  are the left and
  !>     right singular vectors of \f$A_l\f$ , respectively.
  !> 
  !>     The computation of the singular vectors is optional and it is controlled by
  !>     the function arguments left_svect and right_svect as described below. When
  !>     computed, this function returns the transpose (or transpose conjugate) of the
  !>     right singular vectors, i.e. the rows of \f$V_l'\f$.
  !> 
  !>     left_svect and right_svect are #rocblas_svect enums that, for this function, can take the
  !>     following values:
  !> 
  !>     - rocblas_svect_singular: the singular vectors (first min(m,n)
  !>       columns of \f$U_l\f$  or rows of \f$V_l'\f$ ) corresponding to the computed singular values are computed,
  !>     - rocblas_svect_none: no columns (or rows) of \f$U_l\f$  (or \f$V_l'\f$ ) are computed, i.e.
  !>       no singular vectors.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     left_svect  #rocblas_svect.
  !>                 Specifies if the left singular vectors are computed.
  !>     @param[in]
  !>     right_svect #rocblas_svect.
  !>                 Specifies if the right singular vectors are computed.
  !>     @param[in]
  !>     srange      #rocblas_srange.
  !>                 Specifies the type of range or interval of the singular values to be computed.
  !>     @param[in]
  !>     m           rocblas_int. m >= 0.
  !>                 The number of rows of matrix A_l.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of columns of matrix A_l.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the matrices A_l.
  !>                 On exit, the contents of A_l are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= m.
  !>                 The leading dimension of A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[in]
  !>     vl          real type. 0 <= vl < vu.
  !>                 The lower bound of the search interval [vl, vu). Ignored if srange indicates to look
  !>                 for all the singular values of A_l or the singular values within a set of indices.
  !>     @param[in]
  !>     vu          real type. 0 <= vl < vu.
  !>                 The upper bound of the search interval [vl, vu). Ignored if srange indicates to look
  !>                 for all the singular values of A_l or the singular values within a set of indices.
  !>     @param[in]
  !>     il          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.
  !>                 The index of the largest singular value to be computed. Ignored if srange indicates to look
  !>                 for all the singular values of A_l or the singular values in a half-open interval.
  !>     @param[in]
  !>     iu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise.
  !>                 The index of the smallest singular value to be computed. Ignored if srange indicates to look
  !>                 for all the singular values of A_l or the singular values in a half-open interval.
  !>     @param[out]
  !>     nsv         pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 The total number of singular values found. If srange is rocblas_srange_all, nsv[l] = min(m,n).
  !>                 If srange is rocblas_srange_index, nsv[l] = iu - il + 1. Otherwise, 0 <= nsv[l] <= min(m,n).
  !>     @param[out]
  !>     S           pointer to real type. Array on the GPU (the size depends on the value of strideS).
  !>                 The first nsv_l elements contain the computed singular values in descending order.
  !>                 (The remaining elements may be used as workspace for internal computations).
  !>     @param[in]
  !>     strideS     rocblas_stride.
  !>                 Stride from the start of one vector S_l to the next one S_(l+1).
  !>                 There is no restriction for the value of strideS. Normal use case is strideS >= nsv_l.
  !>                 Note: If srange is rocblas_srange_value, then the value of nsv_l is not known in advance.
  !>                 In this case, the user should ensure that S_l is large enough to hold min(m,n) values.
  !>     @param[out]
  !>     U           pointer to type. Array on the GPU (the size depends on the value of strideU).
  !>                 The matrix U_l of left singular vectors stored as columns. Not
  !>                 referenced if left_svect is set to none.
  !>     @param[in]
  !>     ldu         rocblas_int. ldu >= m if left_svect singular; ldu >= 1 otherwise.
  !>                 The leading dimension of U_l.
  !>     @param[in]
  !>     strideU     rocblas_stride.
  !>                 Stride from the start of one matrix U_l to the next one U_(l+1).
  !>                 There is no restriction for the value of strideU. Normal use case is strideU >= ldunsv_l.
  !>                 Note: If srange is rocblas_srange_value, then the value of nsv_l is not known in advance.
  !>                 In this case, the user should ensure that U_l is large enough to hold min(m,n) columns.
  !>     @param[out]
  !>     V           pointer to type. Array on the GPU (the size depends on the value of strideV).
  !>                 The matrix V_l of right singular vectors stored as rows (transposed  conjugate-transposed).
  !>                 Not referenced if right_svect is set to none.
  !>     @param[in]
  !>     ldv         rocblas_int. ldv >= nsv_l if right_svect is set to singular; or ldv >= 1 otherwise.
  !>                 The leading dimension of V_l.
  !>                 Note: If srange is rocblas_srange_value, then the value of nsv_l is not known in advance.
  !>                 In this case, the user should ensure that V_l is large enough to hold min(m,n) rows.
  !>     @param[in]
  !>     strideV     rocblas_stride.
  !>                 Stride from the start of one matrix V_l to the next one V_(l+1).
  !>                 There is no restriction for the value of strideV. Normal use case is strideV >= ldvn.
  !>     @param[out]
  !>     ifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).
  !>                 If info[l] = 0, the first nsv[l] elements of ifail_l are zero.
  !>                 Otherwise, contains the indices of those eigenvectors that failed
  !>                 to converge, as returned by \ref rocsolver_sbdsvdx "BDSVDX".
  !>     @param[in]
  !>     strideF     rocblas_stride.
  !>                 Stride from the start of one vector ifail_l to the next one ifail_(l+1).
  !>                 There is no restriction for the value of strideF. Normal use case is strideF >= min(m,n).
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info[l] = 0, successful exit.
  !>                 If info[l] = i > 0, i eigenvectors did not converge in \ref rocsolver_sbdsvdx "BDSVDX"; their
  !>                 indices are stored in ifail_l.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgesvdx_strided_batched
    function rocsolver_sgesvdx_strided_batched_(handle,left_svect,right_svect,srange,m,n,A,lda,strideA,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count) bind(c, name="rocsolver_sgesvdx_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvdx_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(kind(rocblas_srange_all)),value :: srange
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_float),value :: vl
      real(c_float),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      type(c_ptr),value :: nsv
      type(c_ptr),value :: S
      integer(c_int64_t),value :: strideS
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      integer(c_int64_t),value :: strideU
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      integer(c_int64_t),value :: strideV
      type(c_ptr),value :: ifail
      integer(c_int64_t),value :: strideF
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgesvdx_strided_batched_full_rank,&
      
rocsolver_sgesvdx_strided_batched_rank_0,&
      
rocsolver_sgesvdx_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgesvdx_strided_batched
    function rocsolver_dgesvdx_strided_batched_(handle,left_svect,right_svect,srange,m,n,A,lda,strideA,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count) bind(c, name="rocsolver_dgesvdx_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvdx_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(kind(rocblas_srange_all)),value :: srange
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_double),value :: vl
      real(c_double),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      type(c_ptr),value :: nsv
      type(c_ptr),value :: S
      integer(c_int64_t),value :: strideS
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      integer(c_int64_t),value :: strideU
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      integer(c_int64_t),value :: strideV
      type(c_ptr),value :: ifail
      integer(c_int64_t),value :: strideF
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgesvdx_strided_batched_full_rank,&
      
rocsolver_dgesvdx_strided_batched_rank_0,&
      
rocsolver_dgesvdx_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgesvdx_strided_batched
    function rocsolver_cgesvdx_strided_batched_(handle,left_svect,right_svect,srange,m,n,A,lda,strideA,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count) bind(c, name="rocsolver_cgesvdx_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvdx_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(kind(rocblas_srange_all)),value :: srange
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_float),value :: vl
      real(c_float),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      type(c_ptr),value :: nsv
      type(c_ptr),value :: S
      integer(c_int64_t),value :: strideS
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      integer(c_int64_t),value :: strideU
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      integer(c_int64_t),value :: strideV
      type(c_ptr),value :: ifail
      integer(c_int64_t),value :: strideF
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgesvdx_strided_batched_full_rank,&
      
rocsolver_cgesvdx_strided_batched_rank_0,&
      
rocsolver_cgesvdx_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgesvdx_strided_batched
    function rocsolver_zgesvdx_strided_batched_(handle,left_svect,right_svect,srange,m,n,A,lda,strideA,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count) bind(c, name="rocsolver_zgesvdx_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvdx_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_svect_all)),value :: left_svect
      integer(kind(rocblas_svect_all)),value :: right_svect
      integer(kind(rocblas_srange_all)),value :: srange
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_double),value :: vl
      real(c_double),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      type(c_ptr),value :: nsv
      type(c_ptr),value :: S
      integer(c_int64_t),value :: strideS
      type(c_ptr),value :: U
      integer(c_int),value :: ldu
      integer(c_int64_t),value :: strideU
      type(c_ptr),value :: V
      integer(c_int),value :: ldv
      integer(c_int64_t),value :: strideV
      type(c_ptr),value :: ifail
      integer(c_int64_t),value :: strideF
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgesvdx_strided_batched_full_rank,&
      
rocsolver_zgesvdx_strided_batched_rank_0,&
      
rocsolver_zgesvdx_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYTD2 computes the tridiagonal form of a real symmetric matrix A.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The tridiagonal form is given by:
  !> 
  !>     \f[
  !>         T = Q'  A  Q
  !>     \f]
  !> 
  !>     where T is symmetric tridiagonal and Q is an orthogonal matrix represented as the product
  !>     of Householder matrices
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Q = H(1)H(2)\cdots H(n-1) & \: \text{if uplo indicates lower, or}\\
  !>         Q = H(n-1)H(n-2)\cdots H(1) & \: \text{if uplo indicates upper.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H(i)\f$ is given by
  !> 
  !>     \f[
  !>         H(i) = I - \text{tau}[i] \cdot v_i^{}  v_i'
  !>     \f]
  !> 
  !>     where tau[i] is the corresponding Householder scalar. When uplo indicates lower, the first i
  !>     elements of the Householder vector \f$v_i\f$ are zero, and \f$v_i[i+1] = 1\f$. If uplo indicates upper,
  !>     the last n-i elements of the Householder vector \f$v_i\f$ are zero, and \f$v_i[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the symmetric matrix A is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower)
  !>                 part of A is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of the matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix to be factored.
  !>                 On exit, if upper, then the elements on the diagonal and superdiagonal
  !>                 contain the tridiagonal form T; the elements above the superdiagonal contain
  !>                 the first i-1 elements of the Householder vectors v_i stored as columns.
  !>                 If lower, then the elements on the diagonal and subdiagonal
  !>                 contain the tridiagonal form T; the elements below the subdiagonal contain
  !>                 the last n-i-1 elements of the Householder vectors v_i stored as columns.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 The leading dimension of A.
  !>     @param[out]
  !>     D           pointer to type. Array on the GPU of dimension n.
  !>                 The diagonal elements of T.
  !>     @param[out]
  !>     E           pointer to type. Array on the GPU of dimension n-1.
  !>                 The off-diagonal elements of T.
  !>     @param[out]
  !>     tau         pointer to type. Array on the GPU of dimension n-1.
  !>                 The Householder scalars.
  !>     
  interface rocsolver_ssytd2
    function rocsolver_ssytd2_(handle,uplo,n,A,lda,D,E,tau) bind(c, name="rocsolver_ssytd2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytd2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      real(c_float) :: tau
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssytd2_full_rank,&
      
rocsolver_ssytd2_rank_0,&
      
rocsolver_ssytd2_rank_1
#endif

  end interface
  
  interface rocsolver_dsytd2
    function rocsolver_dsytd2_(handle,uplo,n,A,lda,D,E,tau) bind(c, name="rocsolver_dsytd2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytd2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      real(c_double) :: tau
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsytd2_full_rank,&
      
rocsolver_dsytd2_rank_0,&
      
rocsolver_dsytd2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HETD2 computes the tridiagonal form of a complex hermitian matrix A.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The tridiagonal form is given by:
  !> 
  !>     \f[
  !>         T = Q'  A  Q
  !>     \f]
  !> 
  !>     where T is hermitian tridiagonal and Q is an unitary matrix represented as the product
  !>     of Householder matrices
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Q = H(1)H(2)\cdots H(n-1) & \: \text{if uplo indicates lower, or}\\
  !>         Q = H(n-1)H(n-2)\cdots H(1) & \: \text{if uplo indicates upper.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H(i)\f$ is given by
  !> 
  !>     \f[
  !>         H(i) = I - \text{tau}[i] \cdot v_i^{}  v_i'
  !>     \f]
  !> 
  !>     where tau[i] is the corresponding Householder scalar. When uplo indicates lower, the first i
  !>     elements of the Householder vector \f$v_i\f$ are zero, and \f$v_i[i+1] = 1\f$. If uplo indicates upper,
  !>     the last n-i elements of the Householder vector \f$v_i\f$ are zero, and \f$v_i[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the hermitian matrix A is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower)
  !>                 part of A is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of the matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix to be factored.
  !>                 On exit, if upper, then the elements on the diagonal and superdiagonal
  !>                 contain the tridiagonal form T; the elements above the superdiagonal contain
  !>                 the first i-1 elements of the Householders vector v_i stored as columns.
  !>                 If lower, then the elements on the diagonal and subdiagonal
  !>                 contain the tridiagonal form T; the elements below the subdiagonal contain
  !>                 the last n-i-1 elements of the Householder vectors v_i stored as columns.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 The leading dimension of A.
  !>     @param[out]
  !>     D           pointer to real type. Array on the GPU of dimension n.
  !>                 The diagonal elements of T.
  !>     @param[out]
  !>     E           pointer to real type. Array on the GPU of dimension n-1.
  !>                 The off-diagonal elements of T.
  !>     @param[out]
  !>     tau         pointer to type. Array on the GPU of dimension n-1.
  !>                 The Householder scalars.
  !>     
  interface rocsolver_chetd2
    function rocsolver_chetd2_(handle,uplo,n,A,lda,D,E,tau) bind(c, name="rocsolver_chetd2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chetd2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      complex(c_float_complex) :: tau
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_chetd2_full_rank,&
      
rocsolver_chetd2_rank_0,&
      
rocsolver_chetd2_rank_1
#endif

  end interface
  
  interface rocsolver_zhetd2
    function rocsolver_zhetd2_(handle,uplo,n,A,lda,D,E,tau) bind(c, name="rocsolver_zhetd2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhetd2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      complex(c_double_complex) :: tau
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zhetd2_full_rank,&
      
rocsolver_zhetd2_rank_0,&
      
rocsolver_zhetd2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYTD2_BATCHED computes the tridiagonal form of a batch of real symmetric matrices A_l.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The tridiagonal form of \f$A_l\f$ is given by:
  !> 
  !>     \f[
  !>         T_l^{} = Q_l'  A_l^{}  Q_l^{}
  !>     \f]
  !> 
  !>     where \f$T_l\f$ is symmetric tridiagonal and \f$Q_l\f$ is an orthogonal matrix represented as the product
  !>     of Householder matrices
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Q_l = H_l(1)H_l(2)\cdots H_l(n-1) & \: \text{if uplo indicates lower, or}\\
  !>         Q_l = H_l(n-1)H_l(n-2)\cdots H_l(1) & \: \text{if uplo indicates upper.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H_l(i)\f$ is given by
  !> 
  !>     \f[
  !>         H_l^{}(i) = I - \text{tau}_l^{}[i] \cdot v_{l_i}^{}  v_{l_i}'
  !>     \f]
  !> 
  !>     where \f$\text{tau}_l[i]\f$ is the corresponding Householder scalar. When uplo indicates lower, the first i
  !>     elements of the Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i+1] = 1\f$. If uplo indicates upper,
  !>     the last n-i elements of the Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the symmetric matrix A_l is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower)
  !>                 part of A_l is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of the matrices A_l.
  !>     @param[inout]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the matrices A_l to be factored.
  !>                 On exit, if upper, then the elements on the diagonal and superdiagonal
  !>                 contain the tridiagonal form T_l; the elements above the superdiagonal contain
  !>                 the first i-1 elements of the Householder vectors v_(l_i) stored as columns.
  !>                 If lower, then the elements on the diagonal and subdiagonal
  !>                 contain the tridiagonal form T_l; the elements below the subdiagonal contain
  !>                 the last n-i-1 elements of the Householder vectors v_(l_i) stored as columns.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 The leading dimension of A_l.
  !>     @param[out]
  !>     D           pointer to type. Array on the GPU (the size depends on the value of strideD).
  !>                 The diagonal elements of T_l.
  !>     @param[in]
  !>     strideD     rocblas_stride.
  !>                 Stride from the start of one vector D_l to the next one D_(l+1).
  !>                 There is no restriction for the value of strideD. Normal use case is strideD >= n.
  !>     @param[out]
  !>     E           pointer to type. Array on the GPU (the size depends on the value of strideE).
  !>                 The off-diagonal elements of T_l.
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use case is strideE >= n-1.
  !>     @param[out]
  !>     tau         pointer to type. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors tau_l of corresponding Householder scalars.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector tau_l to the next one tau_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideP. Normal use is strideP >= n-1.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_ssytd2_batched
    function rocsolver_ssytd2_batched_(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count) bind(c, name="rocsolver_ssytd2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytd2_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      real(c_float) :: tau
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssytd2_batched_full_rank,&
      
rocsolver_ssytd2_batched_rank_0,&
      
rocsolver_ssytd2_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dsytd2_batched
    function rocsolver_dsytd2_batched_(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count) bind(c, name="rocsolver_dsytd2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytd2_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      real(c_double) :: tau
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsytd2_batched_full_rank,&
      
rocsolver_dsytd2_batched_rank_0,&
      
rocsolver_dsytd2_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HETD2_BATCHED computes the tridiagonal form of a batch of complex hermitian matrices A_l.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The tridiagonal form of \f$A_l\f$ is given by:
  !> 
  !>     \f[
  !>         T_l^{} = Q_l'  A_l^{}  Q_l^{}
  !>     \f]
  !> 
  !>     where \f$T_l\f$ is Hermitian tridiagonal and \f$Q_l\f$ is a unitary matrix represented as the product
  !>     of Householder matrices
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Q_l = H_l(1)H_l(2)\cdots H_l(n-1) & \: \text{if uplo indicates lower, or}\\
  !>         Q_l = H_l(n-1)H_l(n-2)\cdots H_l(1) & \: \text{if uplo indicates upper.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H_l(i)\f$ is given by
  !> 
  !>     \f[
  !>         H_l^{}(i) = I - \text{tau}_l[i] \cdot v_{l_i}^{}  v_{l_i}'
  !>     \f]
  !> 
  !>     where \f$\text{tau}_l[i]\f$ is the corresponding Householder scalar. When uplo indicates lower, the first i
  !>     elements of the Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i+1] = 1\f$. If uplo indicates upper,
  !>     the last n-i elements of the Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the hermitian matrix A_l is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower)
  !>                 part of A_l is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of the matrices A_l.
  !>     @param[inout]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the matrices A_l to be factored.
  !>                 On exit, if upper, then the elements on the diagonal and superdiagonal
  !>                 contain the tridiagonal form T_l; the elements above the superdiagonal contain
  !>                 the first i-1 elements of the Householder vectors v_(l_i) stored as columns.
  !>                 If lower, then the elements on the diagonal and subdiagonal
  !>                 contain the tridiagonal form T_l; the elements below the subdiagonal contain
  !>                 the last n-i-1 elements of the Householder vectors v_(l_i) stored as columns.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 The leading dimension of A_l.
  !>     @param[out]
  !>     D           pointer to real type. Array on the GPU (the size depends on the value of strideD).
  !>                 The diagonal elements of T_l.
  !>     @param[in]
  !>     strideD     rocblas_stride.
  !>                 Stride from the start of one vector D_l to the next one D_(l+1).
  !>                 There is no restriction for the value of strideD. Normal use case is strideD >= n.
  !>     @param[out]
  !>     E           pointer to real type. Array on the GPU (the size depends on the value of strideE).
  !>                 The off-diagonal elements of T_l.
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use case is strideE >= n-1.
  !>     @param[out]
  !>     tau         pointer to type. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors tau_l of corresponding Householder scalars.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector tau_l to the next one tau_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideP. Normal use is strideP >= n-1.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !> 
  !>     
  interface rocsolver_chetd2_batched
    function rocsolver_chetd2_batched_(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count) bind(c, name="rocsolver_chetd2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chetd2_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      complex(c_float_complex) :: tau
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_chetd2_batched_full_rank,&
      
rocsolver_chetd2_batched_rank_0,&
      
rocsolver_chetd2_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zhetd2_batched
    function rocsolver_zhetd2_batched_(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count) bind(c, name="rocsolver_zhetd2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhetd2_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      complex(c_double_complex) :: tau
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zhetd2_batched_full_rank,&
      
rocsolver_zhetd2_batched_rank_0,&
      
rocsolver_zhetd2_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYTD2_STRIDED_BATCHED computes the tridiagonal form of a batch of real symmetric matrices A_l.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The tridiagonal form of \f$A_l\f$ is given by:
  !> 
  !>     \f[
  !>         T_l^{} = Q_l'  A_l^{}  Q_l^{}
  !>     \f]
  !> 
  !>     where \f$T_l\f$ is symmetric tridiagonal and \f$Q_l\f$ is an orthogonal matrix represented as the product
  !>     of Householder matrices
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Q_l = H_l(1)H_l(2)\cdots H_l(n-1) & \: \text{if uplo indicates lower, or}\\
  !>         Q_l = H_l(n-1)H_l(n-2)\cdots H_l(1) & \: \text{if uplo indicates upper.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H_l(i)\f$ is given by
  !> 
  !>     \f[
  !>         H_l^{}(i) = I - \text{tau}_l[i] \cdot v_{l_i}^{}  v_{l_i}'
  !>     \f]
  !> 
  !>     where \f$\text{tau}_l[i]\f$ is the corresponding Householder scalar. When uplo indicates lower, the first i
  !>     elements of the Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i+1] = 1\f$. If uplo indicates upper,
  !>     the last n-i elements of the Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the symmetric matrix A_l is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower)
  !>                 part of A_l is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of the matrices A_l.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the matrices A_l to be factored.
  !>                 On exit, if upper, then the elements on the diagonal and superdiagonal
  !>                 contain the tridiagonal form T_l; the elements above the superdiagonal contain
  !>                 the first i-1 elements of the Householder vectors v_(l_i) stored as columns.
  !>                 If lower, then the elements on the diagonal and subdiagonal
  !>                 contain the tridiagonal form T_l; the elements below the subdiagonal contain
  !>                 the last n-i-1 elements of the Householder vectors v_(l_i) stored as columns.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 The leading dimension of A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     D           pointer to type. Array on the GPU (the size depends on the value of strideD).
  !>                 The diagonal elements of T_l.
  !>     @param[in]
  !>     strideD     rocblas_stride.
  !>                 Stride from the start of one vector D_l to the next one D_(l+1).
  !>                 There is no restriction for the value of strideD. Normal use case is strideD >= n.
  !>     @param[out]
  !>     E           pointer to type. Array on the GPU (the size depends on the value of strideE).
  !>                 The off-diagonal elements of T_l.
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use case is strideE >= n-1.
  !>     @param[out]
  !>     tau         pointer to type. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors tau_l of corresponding Householder scalars.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector tau_l to the next one tau_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideP. Normal use is strideP >= n-1.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_ssytd2_strided_batched
    function rocsolver_ssytd2_strided_batched_(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count) bind(c, name="rocsolver_ssytd2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytd2_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      real(c_float) :: tau
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssytd2_strided_batched_full_rank,&
      
rocsolver_ssytd2_strided_batched_rank_0,&
      
rocsolver_ssytd2_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dsytd2_strided_batched
    function rocsolver_dsytd2_strided_batched_(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count) bind(c, name="rocsolver_dsytd2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytd2_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      real(c_double) :: tau
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsytd2_strided_batched_full_rank,&
      
rocsolver_dsytd2_strided_batched_rank_0,&
      
rocsolver_dsytd2_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HETD2_STRIDED_BATCHED computes the tridiagonal form of a batch of complex hermitian matrices A_l.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The tridiagonal form of \f$A_l\f$ is given by:
  !> 
  !>     \f[
  !>         T_l^{} = Q_l'  A_l^{}  Q_l^{}
  !>     \f]
  !> 
  !>     where \f$T_l\f$ is Hermitian tridiagonal and \f$Q_l\f$ is a unitary matrix represented as the product
  !>     of Householder matrices
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Q_l = H_l(1)H_l(2)\cdots H_l(n-1) & \: \text{if uplo indicates lower, or}\\
  !>         Q_l = H_l(n-1)H_l(n-2)\cdots H_l(1) & \: \text{if uplo indicates upper.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H_l(i)\f$ is given by
  !> 
  !>     \f[
  !>         H_l^{}(i) = I - \text{tau}_l[i] \cdot v_{l_i}^{}  v_{l_i}'
  !>     \f]
  !> 
  !>     where \f$\text{tau}_l[i]\f$ is the corresponding Householder scalar. When uplo indicates lower, the first i
  !>     elements of the Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i+1] = 1\f$. If uplo indicates upper,
  !>     the last n-i elements of the Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the hermitian matrix A_l is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower)
  !>                 part of A_l is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of the matrices A_l.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the matrices A_l to be factored.
  !>                 On exit, if upper, then the elements on the diagonal and superdiagonal
  !>                 contain the tridiagonal form T_l; the elements above the superdiagonal contain
  !>                 the first i-1 elements of the Householder vectors v_(l_i) stored as columns.
  !>                 If lower, then the elements on the diagonal and subdiagonal
  !>                 contain the tridiagonal form T_l; the elements below the subdiagonal contain
  !>                 the last n-i-1 elements of the Householder vectors v_(l_i) stored as columns.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 The leading dimension of A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     D           pointer to real type. Array on the GPU (the size depends on the value of strideD).
  !>                 The diagonal elements of T_l.
  !>     @param[in]
  !>     strideD     rocblas_stride.
  !>                 Stride from the start of one vector D_l to the next one D_(l+1).
  !>                 There is no restriction for the value of strideD. Normal use case is strideD >= n.
  !>     @param[out]
  !>     E           pointer to real type. Array on the GPU (the size depends on the value of strideE).
  !>                 The off-diagonal elements of T_l.
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use case is strideE >= n-1.
  !>     @param[out]
  !>     tau         pointer to type. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors tau_l of corresponding Householder scalars.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector tau_l to the next one tau_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideP. Normal use is strideP >= n-1.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_chetd2_strided_batched
    function rocsolver_chetd2_strided_batched_(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count) bind(c, name="rocsolver_chetd2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chetd2_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      complex(c_float_complex) :: tau
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_chetd2_strided_batched_full_rank,&
      
rocsolver_chetd2_strided_batched_rank_0,&
      
rocsolver_chetd2_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zhetd2_strided_batched
    function rocsolver_zhetd2_strided_batched_(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count) bind(c, name="rocsolver_zhetd2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhetd2_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      complex(c_double_complex) :: tau
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zhetd2_strided_batched_full_rank,&
      
rocsolver_zhetd2_strided_batched_rank_0,&
      
rocsolver_zhetd2_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYTRD computes the tridiagonal form of a real symmetric matrix A.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The tridiagonal form is given by:
  !> 
  !>     \f[
  !>         T = Q'  A  Q
  !>     \f]
  !> 
  !>     where T is symmetric tridiagonal and Q is an orthogonal matrix represented as the product
  !>     of Householder matrices
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Q = H(1)H(2)\cdots H_(n-1) & \: \text{if uplo indicates lower, or}\\
  !>         Q = H(n-1)H(n-2)\cdots H(1) & \: \text{if uplo indicates upper.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H(i)\f$ is given by
  !> 
  !>     \f[
  !>         H(i) = I - \text{tau}[i] \cdot v_i^{}  v_i'
  !>     \f]
  !> 
  !>     where tau[i] is the corresponding Householder scalar. When uplo indicates lower, the first i
  !>     elements of the Householder vector \f$v_i\f$ are zero, and \f$v_i[i+1] = 1\f$. If uplo indicates upper,
  !>     the last n-i elements of the Householder vector \f$v_i\f$ are zero, and \f$v_i[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the symmetric matrix A is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower)
  !>                 part of A is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of the matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix to be factored.
  !>                 On exit, if upper, then the elements on the diagonal and superdiagonal
  !>                 contain the tridiagonal form T; the elements above the superdiagonal contain
  !>                 the first i-1 elements of the Householder vectors v_i stored as columns.
  !>                 If lower, then the elements on the diagonal and subdiagonal
  !>                 contain the tridiagonal form T; the elements below the subdiagonal contain
  !>                 the last n-i-1 elements of the Householder vectors v_i stored as columns.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 The leading dimension of A.
  !>     @param[out]
  !>     D           pointer to type. Array on the GPU of dimension n.
  !>                 The diagonal elements of T.
  !>     @param[out]
  !>     E           pointer to type. Array on the GPU of dimension n-1.
  !>                 The off-diagonal elements of T.
  !>     @param[out]
  !>     tau         pointer to type. Array on the GPU of dimension n-1.
  !>                 The Householder scalars.
  !>     
  interface rocsolver_ssytrd
    function rocsolver_ssytrd_(handle,uplo,n,A,lda,D,E,tau) bind(c, name="rocsolver_ssytrd")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytrd_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      real(c_float) :: tau
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssytrd_full_rank,&
      
rocsolver_ssytrd_rank_0,&
      
rocsolver_ssytrd_rank_1
#endif

  end interface
  
  interface rocsolver_dsytrd
    function rocsolver_dsytrd_(handle,uplo,n,A,lda,D,E,tau) bind(c, name="rocsolver_dsytrd")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytrd_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      real(c_double) :: tau
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsytrd_full_rank,&
      
rocsolver_dsytrd_rank_0,&
      
rocsolver_dsytrd_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HETRD computes the tridiagonal form of a complex hermitian matrix A.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The tridiagonal form is given by:
  !> 
  !>     \f[
  !>         T = Q'  A  Q
  !>     \f]
  !> 
  !>     where T is hermitian tridiagonal and Q is an unitary matrix represented as the product
  !>     of Householder matrices
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Q = H(1)H(2)\cdots H(n-1) & \: \text{if uplo indicates lower, or}\\
  !>         Q = H(n-1)H(n-2)\cdots H(1) & \: \text{if uplo indicates upper.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H(i)\f$ is given by
  !> 
  !>     \f[
  !>         H(i) = I - \text{tau}[i] \cdot v_i^{}  v_i'
  !>     \f]
  !> 
  !>     where tau[i] is the corresponding Householder scalar. When uplo indicates lower, the first i
  !>     elements of the Householder vector \f$v_i\f$ are zero, and \f$v_i[i+1] = 1\f$. If uplo indicates upper,
  !>     the last n-i elements of the Householder vector \f$v_i\f$ are zero, and \f$v_i[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the hermitian matrix A is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower)
  !>                 part of A is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of the matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix to be factored.
  !>                 On exit, if upper, then the elements on the diagonal and superdiagonal
  !>                 contain the tridiagonal form T; the elements above the superdiagonal contain
  !>                 the first i-1 elements of the Householder vectors v_i stored as columns.
  !>                 If lower, then the elements on the diagonal and subdiagonal
  !>                 contain the tridiagonal form T; the elements below the subdiagonal contain
  !>                 the last n-i-1 elements of the Householder vectors v_i stored as columns.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 The leading dimension of A.
  !>     @param[out]
  !>     D           pointer to real type. Array on the GPU of dimension n.
  !>                 The diagonal elements of T.
  !>     @param[out]
  !>     E           pointer to real type. Array on the GPU of dimension n-1.
  !>                 The off-diagonal elements of T.
  !>     @param[out]
  !>     tau         pointer to type. Array on the GPU of dimension n-1.
  !>                 The Householder scalars.
  !>     
  interface rocsolver_chetrd
    function rocsolver_chetrd_(handle,uplo,n,A,lda,D,E,tau) bind(c, name="rocsolver_chetrd")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chetrd_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      complex(c_float_complex) :: tau
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_chetrd_full_rank,&
      
rocsolver_chetrd_rank_0,&
      
rocsolver_chetrd_rank_1
#endif

  end interface
  
  interface rocsolver_zhetrd
    function rocsolver_zhetrd_(handle,uplo,n,A,lda,D,E,tau) bind(c, name="rocsolver_zhetrd")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhetrd_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      complex(c_double_complex) :: tau
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zhetrd_full_rank,&
      
rocsolver_zhetrd_rank_0,&
      
rocsolver_zhetrd_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYTRD_BATCHED computes the tridiagonal form of a batch of real symmetric matrices A_l.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The tridiagonal form of \f$A_l\f$ is given by:
  !> 
  !>     \f[
  !>         T_l^{} = Q_l'  A_l^{}  Q_l^{}
  !>     \f]
  !> 
  !>     where \f$T_l\f$ is symmetric tridiagonal and \f$Q_l\f$ is an orthogonal matrix represented as the product
  !>     of Householder matrices
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Q_l = H_l(1)H_l(2)\cdots H_l(n-1) & \: \text{if uplo indicates lower, or}\\
  !>         Q_l = H_l(n-1)H_l(n-2)\cdots H_l(1) & \: \text{if uplo indicates upper.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H_l(i)\f$ is given by
  !> 
  !>     \f[
  !>         H_l^{}(i) = I - \text{tau}_l[i] \cdot v_{l_i}^{}  v_{l_i}'
  !>     \f]
  !> 
  !>     where \f$\text{tau}_l[i]\f$ is the corresponding Householder scalar. When uplo indicates lower, the first i
  !>     elements of the Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i+1] = 1\f$. If uplo indicates upper,
  !>     the last n-i elements of the Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the symmetric matrix A_l is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower)
  !>                 part of A_l is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of the matrices A_l.
  !>     @param[inout]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the matrices A_l to be factored.
  !>                 On exit, if upper, then the elements on the diagonal and superdiagonal
  !>                 contain the tridiagonal form T_l; the elements above the superdiagonal contain
  !>                 the first i-1 elements of the Householder vectors v_(l_i) stored as columns.
  !>                 If lower, then the elements on the diagonal and subdiagonal
  !>                 contain the tridiagonal form T_l; the elements below the subdiagonal contain
  !>                 the last n-i-1 elements of the Householder vectors v_(l_i) stored as columns.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 The leading dimension of A_l.
  !>     @param[out]
  !>     D           pointer to type. Array on the GPU (the size depends on the value of strideD).
  !>                 The diagonal elements of T_l.
  !>     @param[in]
  !>     strideD     rocblas_stride.
  !>                 Stride from the start of one vector D_l to the next one D_(l+1).
  !>                 There is no restriction for the value of strideD. Normal use case is strideD >= n.
  !>     @param[out]
  !>     E           pointer to type. Array on the GPU (the size depends on the value of strideE).
  !>                 The off-diagonal elements of T_l.
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use case is strideE >= n-1.
  !>     @param[out]
  !>     tau         pointer to type. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors tau_l of corresponding Householder scalars.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector tau_l to the next one tau_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideP. Normal use is strideP >= n-1.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_ssytrd_batched
    function rocsolver_ssytrd_batched_(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count) bind(c, name="rocsolver_ssytrd_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytrd_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      real(c_float) :: tau
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssytrd_batched_full_rank,&
      
rocsolver_ssytrd_batched_rank_0,&
      
rocsolver_ssytrd_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dsytrd_batched
    function rocsolver_dsytrd_batched_(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count) bind(c, name="rocsolver_dsytrd_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytrd_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      real(c_double) :: tau
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsytrd_batched_full_rank,&
      
rocsolver_dsytrd_batched_rank_0,&
      
rocsolver_dsytrd_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HETRD_BATCHED computes the tridiagonal form of a batch of complex hermitian matrices A_l.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The tridiagonal form of \f$A_l\f$ is given by:
  !> 
  !>     \f[
  !>         T_l^{} = Q_l'  A_l^{}  Q_l^{}
  !>     \f]
  !> 
  !>     where \f$T_l\f$ is Hermitian tridiagonal and \f$Q_l\f$ is a unitary matrix represented as the product
  !>     of Householder matrices
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Q_l = H_l(1)H_l(2)\cdots H_l(n-1) & \: \text{if uplo indicates lower, or}\\
  !>         Q_l = H_l(n-1)H_l(n-2)\cdots H_l(1) & \: \text{if uplo indicates upper.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H_l(i)\f$ is given by
  !> 
  !>     \f[
  !>         H_l^{}(i) = I - \text{tau}_l[i] \cdot v_{l_i}^{}  v_{l_i}'
  !>     \f]
  !> 
  !>     where \f$\text{tau}_l[i]\f$ is the corresponding Householder scalar. When uplo indicates lower, the first i
  !>     elements of the Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i+1] = 1\f$. If uplo indicates upper,
  !>     the last n-i elements of the Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the hermitian matrix A_l is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower)
  !>                 part of A_l is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of the matrices A_l.
  !>     @param[inout]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the matrices A_l to be factored.
  !>                 On exit, if upper, then the elements on the diagonal and superdiagonal
  !>                 contain the tridiagonal form T_l; the elements above the superdiagonal contain
  !>                 the first i-1 elements of the Householder vectors v_(l_i) stored as columns.
  !>                 If lower, then the elements on the diagonal and subdiagonal
  !>                 contain the tridiagonal form T_l; the elements below the subdiagonal contain
  !>                 the last n-i-1 elements of the Householder vectors v_(l_i) stored as columns.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 The leading dimension of A_l.
  !>     @param[out]
  !>     D           pointer to real type. Array on the GPU (the size depends on the value of strideD).
  !>                 The diagonal elements of T_l.
  !>     @param[in]
  !>     strideD     rocblas_stride.
  !>                 Stride from the start of one vector D_l to the next one D_(l+1).
  !>                 There is no restriction for the value of strideD. Normal use case is strideD >= n.
  !>     @param[out]
  !>     E          pointer to real type. Array on the GPU (the size depends on the value of strideE).
  !>                 The off-diagonal elements of T_l.
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use case is strideE >= n-1.
  !>     @param[out]
  !>     tau         pointer to type. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors tau_l of corresponding Householder scalars.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector tau_l to the next one tau_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideP. Normal use is strideP >= n-1.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_chetrd_batched
    function rocsolver_chetrd_batched_(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count) bind(c, name="rocsolver_chetrd_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chetrd_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      complex(c_float_complex) :: tau
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_chetrd_batched_full_rank,&
      
rocsolver_chetrd_batched_rank_0,&
      
rocsolver_chetrd_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zhetrd_batched
    function rocsolver_zhetrd_batched_(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count) bind(c, name="rocsolver_zhetrd_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhetrd_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      complex(c_double_complex) :: tau
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zhetrd_batched_full_rank,&
      
rocsolver_zhetrd_batched_rank_0,&
      
rocsolver_zhetrd_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYTRD_STRIDED_BATCHED computes the tridiagonal form of a batch of real symmetric matrices A_l.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The tridiagonal form of \f$A_l\f$ is given by:
  !> 
  !>     \f[
  !>         T_l^{} = Q_l'  A_l^{}  Q_l^{}
  !>     \f]
  !> 
  !>     where \f$T_l\f$ is symmetric tridiagonal and \f$Q_l\f$ is an orthogonal matrix represented as the product
  !>     of Householder matrices
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Q_l = H_l(1)H_l(2)\cdots H_l(n-1) & \: \text{if uplo indicates lower, or}\\
  !>         Q_l = H_l(n-1)H_l(n-2)\cdots H_l(1) & \: \text{if uplo indicates upper.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H_l(i)\f$ is given by
  !> 
  !>     \f[
  !>         H_l^{}(i) = I - \text{tau}_l[i] \cdot v_{l_i}^{}  v_{l_i}'
  !>     \f]
  !> 
  !>     where \f$\text{tau}_l[i]\f$ is the corresponding Householder scalar. When uplo indicates lower, the first i
  !>     elements of the Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i+1] = 1\f$. If uplo indicates upper,
  !>     the last n-i elements of the Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the symmetric matrix A_l is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower)
  !>                 part of A_l is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of the matrices A_l.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the matrices A_l to be factored.
  !>                 On exit, if upper, then the elements on the diagonal and superdiagonal
  !>                 contain the tridiagonal form T_l; the elements above the superdiagonal contain
  !>                 the first i-1 elements of the Householder vectors v_(l_i) stored as columns.
  !>                 If lower, then the elements on the diagonal and subdiagonal
  !>                 contain the tridiagonal form T_l; the elements below the subdiagonal contain
  !>                 the last n-i-1 elements of the Householder vectors v_(l_i) stored as columns.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 The leading dimension of A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     D           pointer to type. Array on the GPU (the size depends on the value of strideD).
  !>                 The diagonal elements of T_l.
  !>     @param[in]
  !>     strideD     rocblas_stride.
  !>                 Stride from the start of one vector D_l to the next one D_(l+1).
  !>                 There is no restriction for the value of strideD. Normal use case is strideD >= n.
  !>     @param[out]
  !>     E           pointer to type. Array on the GPU (the size depends on the value of strideE).
  !>                 The off-diagonal elements of T_l.
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use case is strideE >= n-1.
  !>     @param[out]
  !>     tau         pointer to type. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors tau_l of corresponding Householder scalars.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector tau_l to the next one tau_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideP. Normal use is strideP >= n-1.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_ssytrd_strided_batched
    function rocsolver_ssytrd_strided_batched_(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count) bind(c, name="rocsolver_ssytrd_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytrd_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      real(c_float) :: tau
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssytrd_strided_batched_full_rank,&
      
rocsolver_ssytrd_strided_batched_rank_0,&
      
rocsolver_ssytrd_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dsytrd_strided_batched
    function rocsolver_dsytrd_strided_batched_(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count) bind(c, name="rocsolver_dsytrd_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytrd_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      real(c_double) :: tau
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsytrd_strided_batched_full_rank,&
      
rocsolver_dsytrd_strided_batched_rank_0,&
      
rocsolver_dsytrd_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HETRD_STRIDED_BATCHED computes the tridiagonal form of a batch of complex hermitian matrices A_l.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The tridiagonal form of \f$A_l\f$ is given by:
  !> 
  !>     \f[
  !>         T_l^{} = Q_l'  A_l^{}  Q_l^{}
  !>     \f]
  !> 
  !>     where \f$T_l\f$ is Hermitian tridiagonal and \f$Q_l\f$ is a unitary matrix represented as the product
  !>     of Householder matrices
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Q_l = H_l(1)H_l(2)\cdots H_l(n-1) & \: \text{if uplo indicates lower, or}\\
  !>         Q_l = H_l(n-1)H_l(n-2)\cdots H_l(1) & \: \text{if uplo indicates upper.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H_l(i)\f$ is given by
  !> 
  !>     \f[
  !>         H_l^{}(i) = I - \text{tau}_l[i] \cdot v_{l_i}^{}  v_{l_i}'
  !>     \f]
  !> 
  !>     where \f$\text{tau}_l[i]\f$ is the corresponding Householder scalar. When uplo indicates lower, the first i
  !>     elements of the Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i+1] = 1\f$. If uplo indicates upper,
  !>     the last n-i elements of the Householder vector \f$v_{l_i}\f$ are zero, and \f$v_{l_i}[i] = 1\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the hermitian matrix A_l is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower)
  !>                 part of A_l is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of the matrices A_l.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the matrices A_l to be factored.
  !>                 On exit, if upper, then the elements on the diagonal and superdiagonal
  !>                 contain the tridiagonal form T_l; the elements above the superdiagonal contain
  !>                 the first i-1 elements of the Householder vectors v_(l_i) stored as columns.
  !>                 If lower, then the elements on the diagonal and subdiagonal
  !>                 contain the tridiagonal form T_l; the elements below the subdiagonal contain
  !>                 the last n-i-1 elements of the Householder vectors v_(l_i) stored as columns.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 The leading dimension of A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     D           pointer to real type. Array on the GPU (the size depends on the value of strideD).
  !>                 The diagonal elements of T_l.
  !>     @param[in]
  !>     strideD     rocblas_stride.
  !>                 Stride from the start of one vector D_l to the next one D_(l+1).
  !>                 There is no restriction for the value of strideD. Normal use case is strideD >= n.
  !>     @param[out]
  !>     E           pointer to real type. Array on the GPU (the size depends on the value of strideE).
  !>                 The off-diagonal elements of T_l.
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use case is strideE >= n-1.
  !>     @param[out]
  !>     tau         pointer to type. Array on the GPU (the size depends on the value of strideP).
  !>                 Contains the vectors tau_l of corresponding Householder scalars.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector tau_l to the next one tau_(l+1).
  !>                 There is no restriction for the value
  !>                 of strideP. Normal use is strideP >= n-1.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_chetrd_strided_batched
    function rocsolver_chetrd_strided_batched_(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count) bind(c, name="rocsolver_chetrd_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chetrd_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      complex(c_float_complex) :: tau
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_chetrd_strided_batched_full_rank,&
      
rocsolver_chetrd_strided_batched_rank_0,&
      
rocsolver_chetrd_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zhetrd_strided_batched
    function rocsolver_zhetrd_strided_batched_(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count) bind(c, name="rocsolver_zhetrd_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhetrd_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      complex(c_double_complex) :: tau
      integer(c_int64_t),value :: strideP
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zhetrd_strided_batched_full_rank,&
      
rocsolver_zhetrd_strided_batched_rank_0,&
      
rocsolver_zhetrd_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYGS2 reduces a real symmetric-definite generalized eigenproblem to standard
  !>     form.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A X = \lambda B X & \: \text{1st form,}\\
  !>         A B X = \lambda X & \: \text{2nd form, or}\\
  !>         B A X = \lambda X & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype.
  !> 
  !>     If the problem is of the 1st form, then A is overwritten with
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U^{-T} A U^{-1}, & \: \text{or}\\
  !>         L^{-1} A L^{-T},
  !>         \end{array}
  !>     \f]
  !> 
  !>     where the symmetric-definite matrix B has been factorized as either \f$U^T U\f$ or
  !>     \f$L L^T\f$ as returned by \ref rocsolver_spotrf "POTRF", depending on the value of uplo.
  !> 
  !>     If the problem is of the 2nd or 3rd form, then A is overwritten with
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U A U^T, & \: \text{or}\\
  !>         L^T A L,
  !>         \end{array}
  !>     \f]
  !> 
  !>     also depending on the value of uplo.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblem.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the matrix A is stored, and
  !>                 whether the factorization applied to B was upper or lower triangular.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) parts of A and
  !>                 B are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A. On exit, the transformed matrix associated with
  !>                 the equivalent standard eigenvalue problem.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     B           pointer to type. Array on the GPU of dimension ldbn.
  !>                 The triangular factor of the matrix B, as returned by \ref rocsolver_spotrf "POTRF".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B.
  !>     
  interface rocsolver_ssygs2
    function rocsolver_ssygs2_(handle,itype,uplo,n,A,lda,B,ldb) bind(c, name="rocsolver_ssygs2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygs2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssygs2_full_rank,&
      
rocsolver_ssygs2_rank_0,&
      
rocsolver_ssygs2_rank_1
#endif

  end interface
  
  interface rocsolver_dsygs2
    function rocsolver_dsygs2_(handle,itype,uplo,n,A,lda,B,ldb) bind(c, name="rocsolver_dsygs2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygs2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsygs2_full_rank,&
      
rocsolver_dsygs2_rank_0,&
      
rocsolver_dsygs2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEGS2 reduces a hermitian-definite generalized eigenproblem to standard form.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A X = \lambda B X & \: \text{1st form,}\\
  !>         A B X = \lambda X & \: \text{2nd form, or}\\
  !>         B A X = \lambda X & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype.
  !> 
  !>     If the problem is of the 1st form, then A is overwritten with
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U^{-H} A U^{-1}, & \: \text{or}\\
  !>         L^{-1} A L^{-H},
  !>         \end{array}
  !>     \f]
  !> 
  !>     where the hermitian-definite matrix B has been factorized as either \f$U^H U\f$ or
  !>     \f$L L^H\f$ as returned by \ref rocsolver_spotrf "POTRF", depending on the value of uplo.
  !> 
  !>     If the problem is of the 2nd or 3rd form, then A is overwritten with
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U A U^H, & \: \text{or}\\
  !>         L^H A L,
  !>         \end{array}
  !>     \f]
  !> 
  !>     also depending on the value of uplo.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblem.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the matrix A is stored, and
  !>                 whether the factorization applied to B was upper or lower triangular.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) parts of A and
  !>                 B are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A. On exit, the transformed matrix associated with
  !>                 the equivalent standard eigenvalue problem.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     B           pointer to type. Array on the GPU of dimension ldbn.
  !>                 The triangular factor of the matrix B, as returned by \ref rocsolver_spotrf "POTRF".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B.
  !>     
  interface rocsolver_chegs2
    function rocsolver_chegs2_(handle,itype,uplo,n,A,lda,B,ldb) bind(c, name="rocsolver_chegs2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegs2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_chegs2_full_rank,&
      
rocsolver_chegs2_rank_0,&
      
rocsolver_chegs2_rank_1
#endif

  end interface
  
  interface rocsolver_zhegs2
    function rocsolver_zhegs2_(handle,itype,uplo,n,A,lda,B,ldb) bind(c, name="rocsolver_zhegs2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegs2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zhegs2_full_rank,&
      
rocsolver_zhegs2_rank_0,&
      
rocsolver_zhegs2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYGS2_BATCHED reduces a batch of real symmetric-definite generalized eigenproblems
  !>     to standard form.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     For each instance in the batch, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l X_l = \lambda B_l X_l & \: \text{1st form,}\\
  !>         A_l B_l X_l = \lambda X_l & \: \text{2nd form, or}\\
  !>         B_l A_l X_l = \lambda X_l & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype.
  !> 
  !>     If the problem is of the 1st form, then \f$A_l\f$ is overwritten with
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U_l^{-T} A_l^{} U_l^{-1}, & \: \text{or}\\
  !>         L_l^{-1} A_l^{} L_l^{-T},
  !>         \end{array}
  !>     \f]
  !> 
  !>     where the symmetric-definite matrix \f$B_l\f$ has been factorized as either \f$U_l^T U_l^{}\f$ or
  !>     \f$L_l^{} L_l^T\f$ as returned by \ref rocsolver_spotrf "POTRF", depending on the value of uplo.
  !> 
  !>     If the problem is of the 2nd or 3rd form, then A is overwritten with
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U_l^{} A_l^{} U_l^T, & \: \text{or}\\
  !>         L_l^T A_l^{} L_l^{},
  !>         \end{array}
  !>     \f]
  !> 
  !>     also depending on the value of uplo.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblems.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the matrices A_l are stored, and
  !>                 whether the factorization applied to B_l was upper or lower triangular.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) parts of A_l and
  !>                 B_l are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the matrices A_l. On exit, the transformed matrices associated with
  !>                 the equivalent standard eigenvalue problems.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A_l.
  !>     @param[out]
  !>     B           array of pointers to type. Each pointer points to an array on the GPU of dimension ldbn.
  !>                 The triangular factors of the matrices B_l, as returned by \ref rocsolver_spotrf_batched "POTRF_BATCHED".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B_l.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_ssygs2_batched
    function rocsolver_ssygs2_batched_(handle,itype,uplo,n,A,lda,B,ldb,batch_count) bind(c, name="rocsolver_ssygs2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygs2_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssygs2_batched_full_rank,&
      
rocsolver_ssygs2_batched_rank_0,&
      
rocsolver_ssygs2_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dsygs2_batched
    function rocsolver_dsygs2_batched_(handle,itype,uplo,n,A,lda,B,ldb,batch_count) bind(c, name="rocsolver_dsygs2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygs2_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsygs2_batched_full_rank,&
      
rocsolver_dsygs2_batched_rank_0,&
      
rocsolver_dsygs2_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEGS2_BATCHED reduces a batch of hermitian-definite generalized eigenproblems to
  !>     standard form.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     For each instance in the batch, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l X_l = \lambda B_l X_l & \: \text{1st form,}\\
  !>         A_l B_l X_l = \lambda X_l & \: \text{2nd form, or}\\
  !>         B_l A_l X_l = \lambda X_l & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype.
  !> 
  !>     If the problem is of the 1st form, then \f$A_l\f$ is overwritten with
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U_l^{-H} A_l^{} U_l^{-1}, & \: \text{or}\\
  !>         L_l^{-1} A_l^{} L_l^{-H},
  !>         \end{array}
  !>     \f]
  !> 
  !>     where the hermitian-definite matrix \f$B_l\f$ has been factorized as either \f$U_l^H U_l^{}\f$ or
  !>     \f$L_l^{} L_l^H\f$ as returned by \ref rocsolver_spotrf "POTRF", depending on the value of uplo.
  !> 
  !>     If the problem is of the 2nd or 3rd form, then A is overwritten with
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U_l^{} A_l^{} U_l^H, & \: \text{or}\\
  !>         L_l^H A_l^{} L_l^{},
  !>         \end{array}
  !>     \f]
  !> 
  !>     also depending on the value of uplo.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblems.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the matrices A_l are stored, and
  !>                 whether the factorization applied to B_l was upper or lower triangular.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) parts of A_l and
  !>                 B_l are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the matrices A_l. On exit, the transformed matrices associated with
  !>                 the equivalent standard eigenvalue problems.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A_l.
  !>     @param[out]
  !>     B           array of pointers to type. Each pointer points to an array on the GPU of dimension ldbn.
  !>                 The triangular factors of the matrices B_l, as returned by \ref rocsolver_spotrf_batched "POTRF_BATCHED".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B_l.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_chegs2_batched
    function rocsolver_chegs2_batched_(handle,itype,uplo,n,A,lda,B,ldb,batch_count) bind(c, name="rocsolver_chegs2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegs2_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_chegs2_batched_full_rank,&
      
rocsolver_chegs2_batched_rank_0,&
      
rocsolver_chegs2_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zhegs2_batched
    function rocsolver_zhegs2_batched_(handle,itype,uplo,n,A,lda,B,ldb,batch_count) bind(c, name="rocsolver_zhegs2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegs2_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zhegs2_batched_full_rank,&
      
rocsolver_zhegs2_batched_rank_0,&
      
rocsolver_zhegs2_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYGS2_STRIDED_BATCHED reduces a batch of real symmetric-definite generalized
  !>     eigenproblems to standard form.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     For each instance in the batch, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l X_l = \lambda B_l X_l & \: \text{1st form,}\\
  !>         A_l B_l X_l = \lambda X_l & \: \text{2nd form, or}\\
  !>         B_l A_l X_l = \lambda X_l & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype.
  !> 
  !>     If the problem is of the 1st form, then \f$A_l\f$ is overwritten with
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U_l^{-T} A_l^{} U_l^{-1}, & \: \text{or}\\
  !>         L_l^{-1} A_l^{} L_l^{-T},
  !>         \end{array}
  !>     \f]
  !> 
  !>     where the symmetric-definite matrix \f$B_l\f$ has been factorized as either \f$U_l^T U_l^{}\f$ or
  !>     \f$L_l^{} L_l^T\f$ as returned by \ref rocsolver_spotrf "POTRF", depending on the value of uplo.
  !> 
  !>     If the problem is of the 2nd or 3rd form, then A is overwritten with
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U_l^{} A_l^{} U_l^T, & \: \text{or}\\
  !>         L_l^T A_l^{} L_l^{},
  !>         \end{array}
  !>     \f]
  !> 
  !>     also depending on the value of uplo.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblems.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the matrices A_l are stored, and
  !>                 whether the factorization applied to B_l was upper or lower triangular.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) parts of A_l and
  !>                 B_l are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the matrices A_l. On exit, the transformed matrices associated with
  !>                 the equivalent standard eigenvalue problems.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     B           pointer to type. Array on the GPU (the size depends on the value of strideB).
  !>                 The triangular factors of the matrices B_l, as returned by \ref rocsolver_spotrf_strided_batched "POTRF_STRIDED_BATCHED".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B_l.
  !>     @param[in]
  !>     strideB     rocblas_stride.
  !>                 Stride from the start of one matrix B_l to the next one B_(l+1).
  !>                 There is no restriction for the value of strideB. Normal use case is strideB >= ldbn.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_ssygs2_strided_batched
    function rocsolver_ssygs2_strided_batched_(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count) bind(c, name="rocsolver_ssygs2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygs2_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssygs2_strided_batched_full_rank,&
      
rocsolver_ssygs2_strided_batched_rank_0,&
      
rocsolver_ssygs2_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dsygs2_strided_batched
    function rocsolver_dsygs2_strided_batched_(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count) bind(c, name="rocsolver_dsygs2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygs2_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsygs2_strided_batched_full_rank,&
      
rocsolver_dsygs2_strided_batched_rank_0,&
      
rocsolver_dsygs2_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEGS2_STRIDED_BATCHED reduces a batch of hermitian-definite generalized
  !>     eigenproblems to standard form.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     For each instance in the batch, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l X_l = \lambda B_l X_l & \: \text{1st form,}\\
  !>         A_l B_l X_l = \lambda X_l & \: \text{2nd form, or}\\
  !>         B_l A_l X_l = \lambda X_l & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype.
  !> 
  !>     If the problem is of the 1st form, then \f$A_l\f$ is overwritten with
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U_l^{-H} A_l^{} U_l^{-1}, & \: \text{or}\\
  !>         L_l^{-1} A_l^{} L_l^{-H},
  !>         \end{array}
  !>     \f]
  !> 
  !>     where the hermitian-definite matrix \f$B_l\f$ has been factorized as either \f$U_l^H U_l^{}\f$ or
  !>     \f$L_l^{} L_l^H\f$ as returned by \ref rocsolver_spotrf "POTRF", depending on the value of uplo.
  !> 
  !>     If the problem is of the 2nd or 3rd form, then A is overwritten with
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U_l^{} A_l^{} U_l^H, & \: \text{or}\\
  !>         L_l^H A_l^{} L_l^{},
  !>         \end{array}
  !>     \f]
  !> 
  !>     also depending on the value of uplo.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblems.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the matrices A_l are stored, and
  !>                 whether the factorization applied to B_l was upper or lower triangular.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) parts of A_l and
  !>                 B_l are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the matrices A_l. On exit, the transformed matrices associated with
  !>                 the equivalent standard eigenvalue problems.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     B           pointer to type. Array on the GPU (the size depends on the value of strideB).
  !>                 The triangular factors of the matrices B_l, as returned by \ref rocsolver_spotrf_strided_batched "POTRF_STRIDED_BATCHED".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B_l.
  !>     @param[in]
  !>     strideB     rocblas_stride.
  !>                 Stride from the start of one matrix B_l to the next one B_(l+1).
  !>                 There is no restriction for the value of strideB. Normal use case is strideB >= ldbn.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_chegs2_strided_batched
    function rocsolver_chegs2_strided_batched_(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count) bind(c, name="rocsolver_chegs2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegs2_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_chegs2_strided_batched_full_rank,&
      
rocsolver_chegs2_strided_batched_rank_0,&
      
rocsolver_chegs2_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zhegs2_strided_batched
    function rocsolver_zhegs2_strided_batched_(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count) bind(c, name="rocsolver_zhegs2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegs2_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zhegs2_strided_batched_full_rank,&
      
rocsolver_zhegs2_strided_batched_rank_0,&
      
rocsolver_zhegs2_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYGST reduces a real symmetric-definite generalized eigenproblem to standard
  !>     form.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A X = \lambda B X & \: \text{1st form,}\\
  !>         A B X = \lambda X & \: \text{2nd form, or}\\
  !>         B A X = \lambda X & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype.
  !> 
  !>     If the problem is of the 1st form, then A is overwritten with
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U^{-T} A U^{-1}, & \: \text{or}\\
  !>         L^{-1} A L^{-T},
  !>         \end{array}
  !>     \f]
  !> 
  !>     where the symmetric-definite matrix B has been factorized as either \f$U^T U\f$ or
  !>     \f$L L^T\f$ as returned by \ref rocsolver_spotrf "POTRF", depending on the value of uplo.
  !> 
  !>     If the problem is of the 2nd or 3rd form, then A is overwritten with
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U A U^T, & \: \text{or}\\
  !>         L^T A L,
  !>         \end{array}
  !>     \f]
  !> 
  !>     also depending on the value of uplo.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblem.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the matrix A is stored, and
  !>                 whether the factorization applied to B was upper or lower triangular.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) parts of A and
  !>                 B are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A. On exit, the transformed matrix associated with
  !>                 the equivalent standard eigenvalue problem.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     B           pointer to type. Array on the GPU of dimension ldbn.
  !>                 The triangular factor of the matrix B, as returned by \ref rocsolver_spotrf "POTRF".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B.
  !>     
  interface rocsolver_ssygst
    function rocsolver_ssygst_(handle,itype,uplo,n,A,lda,B,ldb) bind(c, name="rocsolver_ssygst")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygst_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssygst_full_rank,&
      
rocsolver_ssygst_rank_0,&
      
rocsolver_ssygst_rank_1
#endif

  end interface
  
  interface rocsolver_dsygst
    function rocsolver_dsygst_(handle,itype,uplo,n,A,lda,B,ldb) bind(c, name="rocsolver_dsygst")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygst_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsygst_full_rank,&
      
rocsolver_dsygst_rank_0,&
      
rocsolver_dsygst_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEGST reduces a hermitian-definite generalized eigenproblem to standard form.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A X = \lambda B X & \: \text{1st form,}\\
  !>         A B X = \lambda X & \: \text{2nd form, or}\\
  !>         B A X = \lambda X & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype.
  !> 
  !>     If the problem is of the 1st form, then A is overwritten with
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U^{-H} A U^{-1}, & \: \text{or}\\
  !>         L^{-1} A L^{-H},
  !>         \end{array}
  !>     \f]
  !> 
  !>     where the hermitian-definite matrix B has been factorized as either \f$U^H U\f$ or
  !>     \f$L L^H\f$ as returned by \ref rocsolver_spotrf "POTRF", depending on the value of uplo.
  !> 
  !>     If the problem is of the 2nd or 3rd form, then A is overwritten with
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U A U^H, & \: \text{or}\\
  !>         L^H A L,
  !>         \end{array}
  !>     \f]
  !> 
  !>     also depending on the value of uplo.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblem.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the matrix A is stored, and
  !>                 whether the factorization applied to B was upper or lower triangular.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) parts of A and
  !>                 B are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A. On exit, the transformed matrix associated with
  !>                 the equivalent standard eigenvalue problem.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     B           pointer to type. Array on the GPU of dimension ldbn.
  !>                 The triangular factor of the matrix B, as returned by \ref rocsolver_spotrf "POTRF".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B.
  !>     
  interface rocsolver_chegst
    function rocsolver_chegst_(handle,itype,uplo,n,A,lda,B,ldb) bind(c, name="rocsolver_chegst")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegst_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_chegst_full_rank,&
      
rocsolver_chegst_rank_0,&
      
rocsolver_chegst_rank_1
#endif

  end interface
  
  interface rocsolver_zhegst
    function rocsolver_zhegst_(handle,itype,uplo,n,A,lda,B,ldb) bind(c, name="rocsolver_zhegst")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegst_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zhegst_full_rank,&
      
rocsolver_zhegst_rank_0,&
      
rocsolver_zhegst_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYGST_BATCHED reduces a batch of real symmetric-definite generalized eigenproblems
  !>     to standard form.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     For each instance in the batch, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l X_l = \lambda B_l X_l & \: \text{1st form,}\\
  !>         A_l B_l X_l = \lambda X_l & \: \text{2nd form, or}\\
  !>         B_l A_l X_l = \lambda X_l & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype.
  !> 
  !>     If the problem is of the 1st form, then \f$A_l\f$ is overwritten with
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U_l^{-T} A_l^{} U_l^{-1}, & \: \text{or}\\
  !>         L_l^{-1} A_l^{} L_l^{-T},
  !>         \end{array}
  !>     \f]
  !> 
  !>     where the symmetric-definite matrix \f$B_l\f$ has been factorized as either \f$U_l^T U_l^{}\f$ or
  !>     \f$L_l^{} L_l^T\f$ as returned by \ref rocsolver_spotrf "POTRF", depending on the value of uplo.
  !> 
  !>     If the problem is of the 2nd or 3rd form, then A is overwritten with
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U_l^{} A_l^{} U_l^T, & \: \text{or}\\
  !>         L_l^T A_l^{} L_l^{},
  !>         \end{array}
  !>     \f]
  !> 
  !>     also depending on the value of uplo.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblems.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the matrices A_l are stored, and
  !>                 whether the factorization applied to B_l was upper or lower triangular.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) parts of A_l and
  !>                 B_l are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the matrices A_l. On exit, the transformed matrices associated with
  !>                 the equivalent standard eigenvalue problems.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A_l.
  !>     @param[out]
  !>     B           array of pointers to type. Each pointer points to an array on the GPU of dimension ldbn.
  !>                 The triangular factors of the matrices B_l, as returned by \ref rocsolver_spotrf_batched "POTRF_BATCHED".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B_l.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_ssygst_batched
    function rocsolver_ssygst_batched_(handle,itype,uplo,n,A,lda,B,ldb,batch_count) bind(c, name="rocsolver_ssygst_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygst_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssygst_batched_full_rank,&
      
rocsolver_ssygst_batched_rank_0,&
      
rocsolver_ssygst_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dsygst_batched
    function rocsolver_dsygst_batched_(handle,itype,uplo,n,A,lda,B,ldb,batch_count) bind(c, name="rocsolver_dsygst_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygst_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsygst_batched_full_rank,&
      
rocsolver_dsygst_batched_rank_0,&
      
rocsolver_dsygst_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEGST_BATCHED reduces a batch of hermitian-definite generalized eigenproblems to
  !>     standard form.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     For each instance in the batch, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l X_l = \lambda B_l X_l & \: \text{1st form,}\\
  !>         A_l B_l X_l = \lambda X_l & \: \text{2nd form, or}\\
  !>         B_l A_l X_l = \lambda X_l & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype.
  !> 
  !>     If the problem is of the 1st form, then \f$A_l\f$ is overwritten with
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U_l^{-H} A_l^{} U_l^{-1}, & \: \text{or}\\
  !>         L_l^{-1} A_l^{} L_l^{-H},
  !>         \end{array}
  !>     \f]
  !> 
  !>     where the hermitian-definite matrix \f$B_l\f$ has been factorized as either \f$U_l^H U_l^{}\f$ or
  !>     \f$L_l^{} L_l^H\f$ as returned by \ref rocsolver_spotrf "POTRF", depending on the value of uplo.
  !> 
  !>     If the problem is of the 2nd or 3rd form, then A is overwritten with
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U_l^{} A_l^{} U_l^H, & \: \text{or}\\
  !>         L_l^H A_l^{} L_l^{},
  !>         \end{array}
  !>     \f]
  !> 
  !>     also depending on the value of uplo.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblems.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the matrices A_l are stored, and
  !>                 whether the factorization applied to B_l was upper or lower triangular.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) parts of A_l and
  !>                 B_l are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the matrices A_l. On exit, the transformed matrices associated with
  !>                 the equivalent standard eigenvalue problems.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A_l.
  !>     @param[out]
  !>     B           array of pointers to type. Each pointer points to an array on the GPU of dimension ldbn.
  !>                 The triangular factors of the matrices B_l, as returned by \ref rocsolver_spotrf_batched "POTRF_BATCHED".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B_l.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_chegst_batched
    function rocsolver_chegst_batched_(handle,itype,uplo,n,A,lda,B,ldb,batch_count) bind(c, name="rocsolver_chegst_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegst_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_chegst_batched_full_rank,&
      
rocsolver_chegst_batched_rank_0,&
      
rocsolver_chegst_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zhegst_batched
    function rocsolver_zhegst_batched_(handle,itype,uplo,n,A,lda,B,ldb,batch_count) bind(c, name="rocsolver_zhegst_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegst_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zhegst_batched_full_rank,&
      
rocsolver_zhegst_batched_rank_0,&
      
rocsolver_zhegst_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYGST_STRIDED_BATCHED reduces a batch of real symmetric-definite generalized
  !>     eigenproblems to standard form.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     For each instance in the batch, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l X_l = \lambda B_l X_l & \: \text{1st form,}\\
  !>         A_l B_l X_l = \lambda X_l & \: \text{2nd form, or}\\
  !>         B_l A_l X_l = \lambda X_l & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype.
  !> 
  !>     If the problem is of the 1st form, then \f$A_l\f$ is overwritten with
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U_l^{-T} A_l^{} U_l^{-1}, & \: \text{or}\\
  !>         L_l^{-1} A_l^{} L_l^{-T},
  !>         \end{array}
  !>     \f]
  !> 
  !>     where the symmetric-definite matrix \f$B_l\f$ has been factorized as either \f$U_l^T U_l^{}\f$ or
  !>     \f$L_l^{} L_l^T\f$ as returned by \ref rocsolver_spotrf "POTRF", depending on the value of uplo.
  !> 
  !>     If the problem is of the 2nd or 3rd form, then A is overwritten with
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U_l^{} A_l^{} U_l^T, & \: \text{or}\\
  !>         L_l^T A_l^{} L_l^{},
  !>         \end{array}
  !>     \f]
  !> 
  !>     also depending on the value of uplo.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblems.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the matrices A_l are stored, and
  !>                 whether the factorization applied to B_l was upper or lower triangular.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) parts of A_l and
  !>                 B_l are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the matrices A_l. On exit, the transformed matrices associated with
  !>                 the equivalent standard eigenvalue problems.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     B           pointer to type. Array on the GPU (the size depends on the value of strideB).
  !>                 The triangular factors of the matrices B_l, as returned by \ref rocsolver_spotrf_strided_batched "POTRF_STRIDED_BATCHED".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B_l.
  !>     @param[in]
  !>     strideB     rocblas_stride.
  !>                 Stride from the start of one matrix B_l to the next one B_(l+1).
  !>                 There is no restriction for the value of strideB. Normal use case is strideB >= ldbn.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_ssygst_strided_batched
    function rocsolver_ssygst_strided_batched_(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count) bind(c, name="rocsolver_ssygst_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygst_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssygst_strided_batched_full_rank,&
      
rocsolver_ssygst_strided_batched_rank_0,&
      
rocsolver_ssygst_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dsygst_strided_batched
    function rocsolver_dsygst_strided_batched_(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count) bind(c, name="rocsolver_dsygst_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygst_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsygst_strided_batched_full_rank,&
      
rocsolver_dsygst_strided_batched_rank_0,&
      
rocsolver_dsygst_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEGST_STRIDED_BATCHED reduces a batch of hermitian-definite generalized
  !>     eigenproblems to standard form.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     For each instance in the batch, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l X_l = \lambda B_l X_l & \: \text{1st form,}\\
  !>         A_l B_l X_l = \lambda X_l & \: \text{2nd form, or}\\
  !>         B_l A_l X_l = \lambda X_l & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype.
  !> 
  !>     If the problem is of the 1st form, then \f$A_l\f$ is overwritten with
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U_l^{-H} A_l^{} U_l^{-1}, & \: \text{or}\\
  !>         L_l^{-1} A_l^{} L_l^{-H},
  !>         \end{array}
  !>     \f]
  !> 
  !>     where the hermitian-definite matrix \f$B_l\f$ has been factorized as either \f$U_l^H U_l^{}\f$ or
  !>     \f$L_l^{} L_l^H\f$ as returned by \ref rocsolver_spotrf "POTRF", depending on the value of uplo.
  !> 
  !>     If the problem is of the 2nd or 3rd form, then A is overwritten with
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U_l^{} A_l^{} U_l^H, & \: \text{or}\\
  !>         L_l^H A_l^{} L_l^{},
  !>         \end{array}
  !>     \f]
  !> 
  !>     also depending on the value of uplo.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblems.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the matrices A_l are stored, and
  !>                 whether the factorization applied to B_l was upper or lower triangular.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) parts of A_l and
  !>                 B_l are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the matrices A_l. On exit, the transformed matrices associated with
  !>                 the equivalent standard eigenvalue problems.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     B           pointer to type. Array on the GPU (the size depends on the value of strideB).
  !>                 The triangular factors of the matrices B_l, as returned by \ref rocsolver_spotrf_strided_batched "POTRF_STRIDED_BATCHED".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B_l.
  !>     @param[in]
  !>     strideB     rocblas_stride.
  !>                 Stride from the start of one matrix B_l to the next one B_(l+1).
  !>                 There is no restriction for the value of strideB. Normal use case is strideB >= ldbn.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_chegst_strided_batched
    function rocsolver_chegst_strided_batched_(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count) bind(c, name="rocsolver_chegst_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegst_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_chegst_strided_batched_full_rank,&
      
rocsolver_chegst_strided_batched_rank_0,&
      
rocsolver_chegst_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zhegst_strided_batched
    function rocsolver_zhegst_strided_batched_(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count) bind(c, name="rocsolver_zhegst_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegst_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zhegst_strided_batched_full_rank,&
      
rocsolver_zhegst_strided_batched_rank_0,&
      
rocsolver_zhegst_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYEV computes the eigenvalues and optionally the eigenvectors of a real symmetric
  !>     matrix A.
  !> 
  !>     \details
  !>     The eigenvalues are returned in ascending order. The eigenvectors are computed depending
  !>     on the value of evect. The computed eigenvectors are orthonormal.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the symmetric matrix A is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A
  !>                 is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of rows and columns of matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A. On exit, the eigenvectors of A if they were computed and
  !>                 the algorithm converged; otherwise the contents of A are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrix A.
  !>     @param[out]
  !>     D           pointer to type. Array on the GPU of dimension n.
  !>                 The eigenvalues of A in increasing order.
  !>     @param[out]
  !>     E           pointer to type. Array on the GPU of dimension n.
  !>                 This array is used to work internally with the tridiagonal matrix T associated with A.
  !>                 On exit, if info > 0, it contains the unconverged off-diagonal elements of T
  !>                 (or properly speaking, a tridiagonal matrix equivalent to T). The diagonal elements
  !>                 of this matrix are in D; those that converged correspond to a subset of the
  !>                 eigenvalues of A (not necessarily ordered).
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit. If info = i > 0, the algorithm did not converge.
  !>                 i elements of E did not converge to zero.
  !>     
  interface rocsolver_ssyev
    function rocsolver_ssyev_(handle,evect,uplo,n,A,lda,D,E,myInfo) bind(c, name="rocsolver_ssyev")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyev_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssyev_full_rank,&
      
rocsolver_ssyev_rank_0,&
      
rocsolver_ssyev_rank_1
#endif

  end interface
  
  interface rocsolver_dsyev
    function rocsolver_dsyev_(handle,evect,uplo,n,A,lda,D,E,myInfo) bind(c, name="rocsolver_dsyev")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyev_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsyev_full_rank,&
      
rocsolver_dsyev_rank_0,&
      
rocsolver_dsyev_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEEV computes the eigenvalues and optionally the eigenvectors of a Hermitian matrix A.
  !> 
  !>     \details
  !>     The eigenvalues are returned in ascending order. The eigenvectors are computed depending
  !>     on the value of evect. The computed eigenvectors are orthonormal.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the Hermitian matrix A is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A
  !>                 is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of rows and columns of matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A. On exit, the eigenvectors of A if they were computed and
  !>                 the algorithm converged; otherwise the contents of A are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrix A.
  !>     @param[out]
  !>     D           pointer to real type. Array on the GPU of dimension n.
  !>                 The eigenvalues of A in increasing order.
  !>     @param[out]
  !>     E           pointer to real type. Array on the GPU of dimension n.
  !>                 This array is used to work internally with the tridiagonal matrix T associated with A.
  !>                 On exit, if info > 0, it contains the unconverged off-diagonal elements of T
  !>                 (or properly speaking, a tridiagonal matrix equivalent to T). The diagonal elements
  !>                 of this matrix are in D; those that converged correspond to a subset of the
  !>                 eigenvalues of A (not necessarily ordered).
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit. If info = i > 0, the algorithm did not converge.
  !>                 i elements of E did not converge to zero.
  !>     
  interface rocsolver_cheev
    function rocsolver_cheev_(handle,evect,uplo,n,A,lda,D,E,myInfo) bind(c, name="rocsolver_cheev")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheev_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cheev_full_rank,&
      
rocsolver_cheev_rank_0,&
      
rocsolver_cheev_rank_1
#endif

  end interface
  
  interface rocsolver_zheev
    function rocsolver_zheev_(handle,evect,uplo,n,A,lda,D,E,myInfo) bind(c, name="rocsolver_zheev")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheev_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zheev_full_rank,&
      
rocsolver_zheev_rank_0,&
      
rocsolver_zheev_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYEV_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of
  !>     real symmetric matrices A_l.
  !> 
  !>     \details
  !>     The eigenvalues are returned in ascending order. The eigenvectors are computed depending
  !>     on the value of evect. The computed eigenvectors are orthonormal.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the symmetric matrices A_l is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A_l
  !>                 is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of rows and columns of matrices A_l.
  !>     @param[inout]
  !>     A           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and
  !>                 the algorithm converged; otherwise the contents of A_l are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[out]
  !>     D           pointer to type. Array on the GPU (the size depends on the value of strideD).
  !>                 The eigenvalues of A_l in increasing order.
  !>     @param[in]
  !>     strideD     rocblas_stride.
  !>                 Stride from the start of one vector D_l to the next one D_(l+1).
  !>                 There is no restriction for the value of strideD. Normal use case is strideD >= n.
  !>     @param[out]
  !>     E           pointer to type. Array on the GPU (the size depends on the value of strideE).
  !>                 This array is used to work internally with the tridiagonal matrix T_l associated with A_l.
  !>                 On exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of T_l
  !>                 (or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements
  !>                 of this matrix are in D_l; those that converged correspond to a subset of the
  !>                 eigenvalues of A_l (not necessarily ordered).
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use case is strideE >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for matrix A_l. If info[l] = i > 0, the algorithm did not converge.
  !>                 i elements of E_l did not converge to zero.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_ssyev_batched
    function rocsolver_ssyev_batched_(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_ssyev_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyev_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssyev_batched_full_rank,&
      
rocsolver_ssyev_batched_rank_0,&
      
rocsolver_ssyev_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dsyev_batched
    function rocsolver_dsyev_batched_(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_dsyev_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyev_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsyev_batched_full_rank,&
      
rocsolver_dsyev_batched_rank_0,&
      
rocsolver_dsyev_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEEV_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of
  !>     Hermitian matrices A_l.
  !> 
  !>     \details
  !>     The eigenvalues are returned in ascending order. The eigenvectors are computed depending
  !>     on the value of evect. The computed eigenvectors are orthonormal.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the Hermitian matrices A_l is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A_l
  !>                 is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of rows and columns of matrices A_l.
  !>     @param[inout]
  !>     A           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and
  !>                 the algorithm converged; otherwise the contents of A_l are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[out]
  !>     D           pointer to real type. Array on the GPU (the size depends on the value of strideD).
  !>                 The eigenvalues of A_l in increasing order.
  !>     @param[in]
  !>     strideD     rocblas_stride.
  !>                 Stride from the start of one vector D_l to the next one D_(l+1).
  !>                 There is no restriction for the value of strideD. Normal use case is strideD >= n.
  !>     @param[out]
  !>     E           pointer to real type. Array on the GPU (the size depends on the value of strideE).
  !>                 This array is used to work internally with the tridiagonal matrix T_l associated with A_l.
  !>                 On exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of T_l
  !>                 (or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements
  !>                 of this matrix are in D_l; those that converged correspond to a subset of the
  !>                 eigenvalues of A_l (not necessarily ordered).
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use case is strideE >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for matrix A_l. If info[l] = i > 0, the algorithm did not converge.
  !>                 i elements of E_l did not converge to zero.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_cheev_batched
    function rocsolver_cheev_batched_(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_cheev_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheev_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cheev_batched_full_rank,&
      
rocsolver_cheev_batched_rank_0,&
      
rocsolver_cheev_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zheev_batched
    function rocsolver_zheev_batched_(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_zheev_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheev_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zheev_batched_full_rank,&
      
rocsolver_zheev_batched_rank_0,&
      
rocsolver_zheev_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYEV_STRIDED_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of
  !>     real symmetric matrices A_l.
  !> 
  !>     \details
  !>     The eigenvalues are returned in ascending order. The eigenvectors are computed depending
  !>     on the value of evect. The computed eigenvectors are orthonormal.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the symmetric matrices A_l is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A_l
  !>                 is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of rows and columns of matrices A_l.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and
  !>                 the algorithm converged; otherwise the contents of A_l are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     D           pointer to type. Array on the GPU (the size depends on the value of strideD).
  !>                 The eigenvalues of A_l in increasing order.
  !>     @param[in]
  !>     strideD     rocblas_stride.
  !>                 Stride from the start of one vector D_l to the next one D_(l+1).
  !>                 There is no restriction for the value of strideD. Normal use case is strideD >= n.
  !>     @param[out]
  !>     E           pointer to type. Array on the GPU (the size depends on the value of strideE).
  !>                 This array is used to work internally with the tridiagonal matrix T_l associated with A_l.
  !>                 On exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of T_l
  !>                 (or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements
  !>                 of this matrix are in D_l; those that converged correspond to a subset of the
  !>                 eigenvalues of A_l (not necessarily ordered).
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use case is strideE >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for matrix A_l. If info[l] = i > 0, the algorithm did not converge.
  !>                 i elements of E_l did not converge to zero.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_ssyev_strided_batched
    function rocsolver_ssyev_strided_batched_(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_ssyev_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyev_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssyev_strided_batched_full_rank,&
      
rocsolver_ssyev_strided_batched_rank_0,&
      
rocsolver_ssyev_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dsyev_strided_batched
    function rocsolver_dsyev_strided_batched_(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_dsyev_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyev_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsyev_strided_batched_full_rank,&
      
rocsolver_dsyev_strided_batched_rank_0,&
      
rocsolver_dsyev_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEEV_STRIDED_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of
  !>     Hermitian matrices A_l.
  !> 
  !>     \details
  !>     The eigenvalues are returned in ascending order. The eigenvectors are computed depending
  !>     on the value of evect. The computed eigenvectors are orthonormal.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the Hermitian matrices A_l is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A_l
  !>                 is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of rows and columns of matrices A_l.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and
  !>                 the algorithm converged; otherwise the contents of A_l are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     D           pointer to real type. Array on the GPU (the size depends on the value of strideD).
  !>                 The eigenvalues of A_l in increasing order.
  !>     @param[in]
  !>     strideD     rocblas_stride.
  !>                 Stride from the start of one vector D_l to the next one D_(l+1).
  !>                 There is no restriction for the value of strideD. Normal use case is strideD >= n.
  !>     @param[out]
  !>     E           pointer to real type. Array on the GPU (the size depends on the value of strideE).
  !>                 This array is used to work internally with the tridiagonal matrix T_l associated with A_l.
  !>                 On exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of T_l
  !>                 (or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements
  !>                 of this matrix are in D_l; those that converged correspond to a subset of the
  !>                 eigenvalues of A_l (not necessarily ordered).
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use case is strideE >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for matrix A_l. If info[l] = i > 0, the algorithm did not converge.
  !>                 i elements of E_l did not converge to zero.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_cheev_strided_batched
    function rocsolver_cheev_strided_batched_(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_cheev_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheev_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cheev_strided_batched_full_rank,&
      
rocsolver_cheev_strided_batched_rank_0,&
      
rocsolver_cheev_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zheev_strided_batched
    function rocsolver_zheev_strided_batched_(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_zheev_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheev_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zheev_strided_batched_full_rank,&
      
rocsolver_zheev_strided_batched_rank_0,&
      
rocsolver_zheev_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYEVD computes the eigenvalues and optionally the eigenvectors of a real symmetric
  !>     matrix A.
  !> 
  !>     \details
  !>     The eigenvalues are returned in ascending order. The eigenvectors are computed using a
  !>     divide-and-conquer algorithm, depending on the value of evect. The computed eigenvectors
  !>     are orthonormal.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the symmetric matrix A is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A
  !>                 is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of rows and columns of matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A. On exit, the eigenvectors of A if they were computed and
  !>                 the algorithm converged; otherwise the contents of A are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrix A.
  !>     @param[out]
  !>     D           pointer to type. Array on the GPU of dimension n.
  !>                 The eigenvalues of A in increasing order.
  !>     @param[out]
  !>     E           pointer to type. Array on the GPU of dimension n.
  !>                 This array is used to work internally with the tridiagonal matrix T associated with A.
  !>                 On exit, if info > 0, it contains the unconverged off-diagonal elements of T
  !>                 (or properly speaking, a tridiagonal matrix equivalent to T). The diagonal elements
  !>                 of this matrix are in D; those that converged correspond to a subset of the
  !>                 eigenvalues of A (not necessarily ordered).
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0 and evect is rocblas_evect_none, the algorithm did not converge.
  !>                 i elements of E did not converge to zero.
  !>                 If info = i > 0 and evect is rocblas_evect_original, the algorithm failed to
  !>                 compute an eigenvalue in the submatrix from [i(n+1), i(n+1)] to [i%(n+1), i%(n+1)].
  !>     
  interface rocsolver_ssyevd
    function rocsolver_ssyevd_(handle,evect,uplo,n,A,lda,D,E,myInfo) bind(c, name="rocsolver_ssyevd")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevd_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssyevd_full_rank,&
      
rocsolver_ssyevd_rank_0,&
      
rocsolver_ssyevd_rank_1
#endif

  end interface
  
  interface rocsolver_dsyevd
    function rocsolver_dsyevd_(handle,evect,uplo,n,A,lda,D,E,myInfo) bind(c, name="rocsolver_dsyevd")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevd_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsyevd_full_rank,&
      
rocsolver_dsyevd_rank_0,&
      
rocsolver_dsyevd_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEEVD computes the eigenvalues and optionally the eigenvectors of a Hermitian matrix A.
  !> 
  !>     \details
  !>     The eigenvalues are returned in ascending order. The eigenvectors are computed using a
  !>     divide-and-conquer algorithm, depending on the value of evect. The computed eigenvectors
  !>     are orthonormal.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the Hermitian matrix A is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A
  !>                 is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of rows and columns of matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A. On exit, the eigenvectors of A if they were computed and
  !>                 the algorithm converged; otherwise the contents of A are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrix A.
  !>     @param[out]
  !>     D           pointer to real type. Array on the GPU of dimension n.
  !>                 The eigenvalues of A in increasing order.
  !>     @param[out]
  !>     E           pointer to real type. Array on the GPU of dimension n.
  !>                 This array is used to work internally with the tridiagonal matrix T associated with A.
  !>                 On exit, if info > 0, it contains the unconverged off-diagonal elements of T
  !>                 (or properly speaking, a tridiagonal matrix equivalent to T). The diagonal elements
  !>                 of this matrix are in D; those that converged correspond to a subset of the
  !>                 eigenvalues of A (not necessarily ordered).
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0 and evect is rocblas_evect_none, the algorithm did not converge.
  !>                 i elements of E did not converge to zero.
  !>                 If info = i > 0 and evect is rocblas_evect_original, the algorithm failed to
  !>                 compute an eigenvalue in the submatrix from [i(n+1), i(n+1)] to [i%(n+1), i%(n+1)].
  !>     
  interface rocsolver_cheevd
    function rocsolver_cheevd_(handle,evect,uplo,n,A,lda,D,E,myInfo) bind(c, name="rocsolver_cheevd")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevd_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cheevd_full_rank,&
      
rocsolver_cheevd_rank_0,&
      
rocsolver_cheevd_rank_1
#endif

  end interface
  
  interface rocsolver_zheevd
    function rocsolver_zheevd_(handle,evect,uplo,n,A,lda,D,E,myInfo) bind(c, name="rocsolver_zheevd")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevd_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zheevd_full_rank,&
      
rocsolver_zheevd_rank_0,&
      
rocsolver_zheevd_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYEVD_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of
  !>     real symmetric matrices A_l.
  !> 
  !>     \details
  !>     The eigenvalues are returned in ascending order. The eigenvectors are computed using a
  !>     divide-and-conquer algorithm, depending on the value of evect. The computed eigenvectors
  !>     are orthonormal.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the symmetric matrices A_l is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A_l
  !>                 is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of rows and columns of matrices A_l.
  !>     @param[inout]
  !>     A           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and
  !>                 the algorithm converged; otherwise the contents of A_l are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[out]
  !>     D           pointer to type. Array on the GPU (the size depends on the value of strideD).
  !>                 The eigenvalues of A_l in increasing order.
  !>     @param[in]
  !>     strideD     rocblas_stride.
  !>                 Stride from the start of one vector D_l to the next one D_(l+1).
  !>                 There is no restriction for the value of strideD. Normal use case is strideD >= n.
  !>     @param[out]
  !>     E           pointer to type. Array on the GPU (the size depends on the value of strideE).
  !>                 This array is used to work internally with the tridiagonal matrix T_l associated with A_l.
  !>                 On exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of T_l
  !>                 (or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements
  !>                 of this matrix are in D_l; those that converged correspond to a subset of the
  !>                 eigenvalues of A_l (not necessarily ordered).
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use case is strideE >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for matrix A_l.
  !>                 If info[l] = i > 0 and evect is rocblas_evect_none, the algorithm did not converge.
  !>                 i elements of E_l did not converge to zero.
  !>                 If info[l] = i > 0 and evect is rocblas_evect_original, the algorithm failed to
  !>                 compute an eigenvalue in the submatrix from [i(n+1), i(n+1)] to [i%(n+1), i%(n+1)].
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_ssyevd_batched
    function rocsolver_ssyevd_batched_(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_ssyevd_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevd_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssyevd_batched_full_rank,&
      
rocsolver_ssyevd_batched_rank_0,&
      
rocsolver_ssyevd_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dsyevd_batched
    function rocsolver_dsyevd_batched_(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_dsyevd_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevd_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsyevd_batched_full_rank,&
      
rocsolver_dsyevd_batched_rank_0,&
      
rocsolver_dsyevd_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEEVD_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of
  !>     Hermitian matrices A_l.
  !> 
  !>     \details
  !>     The eigenvalues are returned in ascending order. The eigenvectors are computed using a
  !>     divide-and-conquer algorithm, depending on the value of evect. The computed eigenvectors
  !>     are orthonormal.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the Hermitian matrices A_l is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A_l
  !>                 is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of rows and columns of matrices A_l.
  !>     @param[inout]
  !>     A           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and
  !>                 the algorithm converged; otherwise the contents of A_l are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[out]
  !>     D           pointer to real type. Array on the GPU (the size depends on the value of strideD).
  !>                 The eigenvalues of A_l in increasing order.
  !>     @param[in]
  !>     strideD     rocblas_stride.
  !>                 Stride from the start of one vector D_l to the next one D_(l+1).
  !>                 There is no restriction for the value of strideD. Normal use case is strideD >= n.
  !>     @param[out]
  !>     E           pointer to real type. Array on the GPU (the size depends on the value of strideE).
  !>                 This array is used to work internally with the tridiagonal matrix T_l associated with A_l.
  !>                 On exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of T_l
  !>                 (or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements
  !>                 of this matrix are in D_l; those that converged correspond to a subset of the
  !>                 eigenvalues of A_l (not necessarily ordered).
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use case is strideE >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for matrix A_l.
  !>                 If info[l] = i > 0 and evect is rocblas_evect_none, the algorithm did not converge.
  !>                 i elements of E_l did not converge to zero.
  !>                 If info[l] = i > 0 and evect is rocblas_evect_original, the algorithm failed to
  !>                 compute an eigenvalue in the submatrix from [i(n+1), i(n+1)] to [i%(n+1), i%(n+1)].
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_cheevd_batched
    function rocsolver_cheevd_batched_(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_cheevd_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevd_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cheevd_batched_full_rank,&
      
rocsolver_cheevd_batched_rank_0,&
      
rocsolver_cheevd_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zheevd_batched
    function rocsolver_zheevd_batched_(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_zheevd_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevd_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zheevd_batched_full_rank,&
      
rocsolver_zheevd_batched_rank_0,&
      
rocsolver_zheevd_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYEVD_STRIDED_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of
  !>     real symmetric matrices A_l.
  !> 
  !>     \details
  !>     The eigenvalues are returned in ascending order. The eigenvectors are computed using a
  !>     divide-and-conquer algorithm, depending on the value of evect. The computed eigenvectors
  !>     are orthonormal.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the symmetric matrices A_l is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A_l
  !>                 is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of rows and columns of matrices A_l.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and
  !>                 the algorithm converged; otherwise the contents of A_l are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     D           pointer to type. Array on the GPU (the size depends on the value of strideD).
  !>                 The eigenvalues of A_l in increasing order.
  !>     @param[in]
  !>     strideD     rocblas_stride.
  !>                 Stride from the start of one vector D_l to the next one D_(l+1).
  !>                 There is no restriction for the value of strideD. Normal use case is strideD >= n.
  !>     @param[out]
  !>     E           pointer to type. Array on the GPU (the size depends on the value of strideE).
  !>                 This array is used to work internally with the tridiagonal matrix T_l associated with A_l.
  !>                 On exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of T_l
  !>                 (or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements
  !>                 of this matrix are in D_l; those that converged correspond to a subset of the
  !>                 eigenvalues of A_l (not necessarily ordered).
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use case is strideE >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for matrix A_l.
  !>                 If info[l] = i > 0 and evect is rocblas_evect_none, the algorithm did not converge.
  !>                 i elements of E_l did not converge to zero.
  !>                 If info[l] = i > 0 and evect is rocblas_evect_original, the algorithm failed to
  !>                 compute an eigenvalue in the submatrix from [i(n+1), i(n+1)] to [i%(n+1), i%(n+1)].
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_ssyevd_strided_batched
    function rocsolver_ssyevd_strided_batched_(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_ssyevd_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevd_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssyevd_strided_batched_full_rank,&
      
rocsolver_ssyevd_strided_batched_rank_0,&
      
rocsolver_ssyevd_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dsyevd_strided_batched
    function rocsolver_dsyevd_strided_batched_(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_dsyevd_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevd_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsyevd_strided_batched_full_rank,&
      
rocsolver_dsyevd_strided_batched_rank_0,&
      
rocsolver_dsyevd_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEEVD_STRIDED_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of
  !>     Hermitian matrices A_l.
  !> 
  !>     \details
  !>     The eigenvalues are returned in ascending order. The eigenvectors are computed using a
  !>     divide-and-conquer algorithm, depending on the value of evect. The computed eigenvectors
  !>     are orthonormal.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the Hermitian matrices A_l is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A_l
  !>                 is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of rows and columns of matrices A_l.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and
  !>                 the algorithm converged; otherwise the contents of A_l are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     D           pointer to real type. Array on the GPU (the size depends on the value of strideD).
  !>                 The eigenvalues of A_l in increasing order.
  !>     @param[in]
  !>     strideD     rocblas_stride.
  !>                 Stride from the start of one vector D_l to the next one D_(l+1).
  !>                 There is no restriction for the value of strideD. Normal use case is strideD >= n.
  !>     @param[out]
  !>     E           pointer to real type. Array on the GPU (the size depends on the value of strideE).
  !>                 This array is used to work internally with the tridiagonal matrix T_l associated with A_l.
  !>                 On exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of T_l
  !>                 (or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements
  !>                 of this matrix are in D_l; those that converged correspond to a subset of the
  !>                 eigenvalues of A_l (not necessarily ordered).
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use case is strideE >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for matrix A_l.
  !>                 If info[l] = i > 0 and evect is rocblas_evect_none, the algorithm did not converge.
  !>                 i elements of E_l did not converge to zero.
  !>                 If info[l] = i > 0 and evect is rocblas_evect_original, the algorithm failed to
  !>                 compute an eigenvalue in the submatrix from [i(n+1), i(n+1)] to [i%(n+1), i%(n+1)].
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_cheevd_strided_batched
    function rocsolver_cheevd_strided_batched_(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_cheevd_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevd_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cheevd_strided_batched_full_rank,&
      
rocsolver_cheevd_strided_batched_rank_0,&
      
rocsolver_cheevd_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zheevd_strided_batched
    function rocsolver_zheevd_strided_batched_(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_zheevd_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevd_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zheevd_strided_batched_full_rank,&
      
rocsolver_zheevd_strided_batched_rank_0,&
      
rocsolver_zheevd_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYEVJ computes the eigenvalues and optionally the eigenvectors of a real symmetric
  !>     matrix A.
  !> 
  !>     \details
  !>     The eigenvalues are found using the iterative Jacobi algorithm and are returned in an order
  !>     depending on the value of esort.
  !>     The eigenvectors are computed depending on the value of evect. The computed eigenvectors are orthonormal.
  !> 
  !>     At the \f$k\f$-th iteration (or "sweep"), \f$A\f$ is transformed by a product of Jacobi rotations \f$V\f$ as
  !> 
  !>     \f[
  !>         A^{(k)} = V' A^{(k-1)} V
  !>     \f]
  !> 
  !>     such that \f$off(A^{(k)}) < off(A^{(k-1)})\f$, where \f$A^{(0)} = A\f$ and \f$off(A^{(k)})\f$ is the
  !>     Frobenius norm of the off-diagonal elements of \f$A^{(k)}\f$. As \f$off(A^{(k)}) \rightarrow 0\f$, the
  !>     diagonal elements of \f$A^{(k)}\f$ increasingly resemble the eigenvalues of \f$A\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     esort       #rocblas_esort.
  !>                 Specifies the order of the returned eigenvalues. If esort is
  !>                 rocblas_esort_ascending, then the eigenvalues are sorted and returned in ascending order.
  !>                 If esort is rocblas_esort_none, then the order of the returned eigenvalues is unspecified.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the symmetric matrix A is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A
  !>                 is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of rows and columns of matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A. On exit, the eigenvectors of A if they were computed and
  !>                 the algorithm converged; otherwise the contents of A are unchanged.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrix A.
  !>     @param[in]
  !>     abstol      type.
  !>                 The absolute tolerance. The algorithm is considered to have converged once off(A)
  !>                 is <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.
  !>     @param[out]
  !>     residual    pointer to type on the GPU.
  !>                 The Frobenius norm of the off-diagonal elements of A (i.e. off(A)) at the final iteration.
  !>     @param[in]
  !>     max_sweeps  rocblas_int. max_sweeps > 0.
  !>                 Maximum number of sweeps (iterations) to be used by the algorithm.
  !>     @param[out]
  !>     n_sweeps    pointer to a rocblas_int on the GPU.
  !>                 The actual number of sweeps (iterations) used by the algorithm.
  !>     @param[out]
  !>     W           pointer to type. Array on the GPU of dimension n.
  !>                 The eigenvalues of A in increasing order.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit. If info = 1, the algorithm did not converge.
  !>     
  interface rocsolver_ssyevj
    function rocsolver_ssyevj_(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,myInfo) bind(c, name="rocsolver_ssyevj")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevj_
      type(c_ptr),value :: handle
      integer(kind(rocblas_esort_none)),value :: esort
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_float),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: W
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssyevj_full_rank,&
      
rocsolver_ssyevj_rank_0,&
      
rocsolver_ssyevj_rank_1
#endif

  end interface
  
  interface rocsolver_dsyevj
    function rocsolver_dsyevj_(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,myInfo) bind(c, name="rocsolver_dsyevj")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevj_
      type(c_ptr),value :: handle
      integer(kind(rocblas_esort_none)),value :: esort
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_double),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: W
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsyevj_full_rank,&
      
rocsolver_dsyevj_rank_0,&
      
rocsolver_dsyevj_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEEVJ computes the eigenvalues and optionally the eigenvectors of a complex Hermitian
  !>     matrix A.
  !> 
  !>     \details
  !>     The eigenvalues are found using the iterative Jacobi algorithm and are returned in an order
  !>     depending on the value of esort.
  !>     The eigenvectors are computed depending on the value of evect. The computed eigenvectors are orthonormal.
  !> 
  !>     At the \f$k\f$-th iteration (or "sweep"), \f$A\f$ is transformed by a product of Jacobi rotations \f$V\f$ as
  !> 
  !>     \f[
  !>         A^{(k)} = V' A^{(k-1)} V
  !>     \f]
  !> 
  !>     such that \f$off(A^{(k)}) < off(A^{(k-1)})\f$, where \f$A^{(0)} = A\f$ and \f$off(A^{(k)})\f$ is the
  !>     Frobenius norm of the off-diagonal elements of \f$A^{(k)}\f$. As \f$off(A^{(k)}) \rightarrow 0\f$, the
  !>     diagonal elements of \f$A^{(k)}\f$ increasingly resemble the eigenvalues of \f$A\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     esort       #rocblas_esort.
  !>                 Specifies the order of the returned eigenvalues. If esort is
  !>                 rocblas_esort_ascending, then the eigenvalues are sorted and returned in ascending order.
  !>                 If esort is rocblas_esort_none, then the order of the returned eigenvalues is unspecified.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the Hermitian matrix A is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A
  !>                 is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of rows and columns of matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A. On exit, the eigenvectors of A if they were computed and
  !>                 the algorithm converged; otherwise the contents of A are unchanged.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrix A.
  !>     @param[in]
  !>     abstol      real type.
  !>                 The absolute tolerance. The algorithm is considered to have converged once off(A)
  !>                 is <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.
  !>     @param[out]
  !>     residual    pointer to real type on the GPU.
  !>                 The Frobenius norm of the off-diagonal elements of A (i.e. off(A)) at the final iteration.
  !>     @param[in]
  !>     max_sweeps  rocblas_int. max_sweeps > 0.
  !>                 Maximum number of sweeps (iterations) to be used by the algorithm.
  !>     @param[out]
  !>     n_sweeps    pointer to a rocblas_int on the GPU.
  !>                 The actual number of sweeps (iterations) used by the algorithm.
  !>     @param[out]
  !>     W           pointer to real type. Array on the GPU of dimension n.
  !>                 The eigenvalues of A in increasing order.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit. If info = 1, the algorithm did not converge.
  !>     
  interface rocsolver_cheevj
    function rocsolver_cheevj_(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,myInfo) bind(c, name="rocsolver_cheevj")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevj_
      type(c_ptr),value :: handle
      integer(kind(rocblas_esort_none)),value :: esort
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_float),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: W
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cheevj_full_rank,&
      
rocsolver_cheevj_rank_0,&
      
rocsolver_cheevj_rank_1
#endif

  end interface
  
  interface rocsolver_zheevj
    function rocsolver_zheevj_(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,myInfo) bind(c, name="rocsolver_zheevj")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevj_
      type(c_ptr),value :: handle
      integer(kind(rocblas_esort_none)),value :: esort
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_double),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: W
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zheevj_full_rank,&
      
rocsolver_zheevj_rank_0,&
      
rocsolver_zheevj_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYEVJ_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of
  !>     real symmetric matrices A_l.
  !> 
  !>     \details
  !>     The eigenvalues are found using the iterative Jacobi algorithm and are returned in an order
  !>     depending on the value of esort.
  !>     The eigenvectors are computed depending on the value of evect. The computed eigenvectors are orthonormal.
  !> 
  !>     At the \f$k\f$-th iteration (or "sweep"), \f$A_l\f$ is transformed by a product of Jacobi rotations \f$V_l\f$ as
  !> 
  !>     \f[
  !>         A_l^{(k)} = V_l' A_l^{(k-1)} V_l^{}
  !>     \f]
  !> 
  !>     such that \f$off(A_l^{(k)}) < off(A_l^{(k-1)})\f$, where \f$A_l^{(0)} = A_l\f$ and \f$off(A_l^{(k)})\f$ is the
  !>     Frobenius norm of the off-diagonal elements of \f$A_l^{(k)}\f$. As \f$off(A_l^{(k)}) \rightarrow 0\f$, the
  !>     diagonal elements of \f$A_l^{(k)}\f$ increasingly resemble the eigenvalues of \f$A_l\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     esort       #rocblas_esort.
  !>                 Specifies the order of the returned eigenvalues. If esort is
  !>                 rocblas_esort_ascending, then the eigenvalues are sorted and returned in ascending order.
  !>                 If esort is rocblas_esort_none, then the order of the returned eigenvalues is unspecified.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the symmetric matrices A_l is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A_l
  !>                 is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of rows and columns of matrices A_l.
  !>     @param[inout]
  !>     A           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and
  !>                 the algorithm converged; otherwise the contents of A_l are unchanged.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     abstol      type.
  !>                 The absolute tolerance. The algorithm is considered to have converged once off(A_l)
  !>                 is <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.
  !>     @param[out]
  !>     residual    pointer to type. Array of batch_count scalars on the GPU.
  !>                 The Frobenius norm of the off-diagonal elements of A_l (i.e. off(A_l)) at the final iteration.
  !>     @param[in]
  !>     max_sweeps  rocblas_int. max_sweeps > 0.
  !>                 Maximum number of sweeps (iterations) to be used by the algorithm.
  !>     @param[out]
  !>     n_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 The actual number of sweeps (iterations) used by the algorithm for each batch instance.
  !>     @param[out]
  !>     W           pointer to type. Array on the GPU (the size depends on the value of strideW).
  !>                 The eigenvalues of A_l in increasing order.
  !>     @param[in]
  !>     strideW     rocblas_stride.
  !>                 Stride from the start of one vector W_l to the next one W_(l+1).
  !>                 There is no restriction for the value of strideW. Normal use case is strideW >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for matrix A_l. If info[l] = 1, the algorithm did not converge.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_ssyevj_batched
    function rocsolver_ssyevj_batched_(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count) bind(c, name="rocsolver_ssyevj_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevj_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_esort_none)),value :: esort
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_float),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssyevj_batched_full_rank,&
      
rocsolver_ssyevj_batched_rank_0,&
      
rocsolver_ssyevj_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dsyevj_batched
    function rocsolver_dsyevj_batched_(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count) bind(c, name="rocsolver_dsyevj_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevj_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_esort_none)),value :: esort
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_double),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsyevj_batched_full_rank,&
      
rocsolver_dsyevj_batched_rank_0,&
      
rocsolver_dsyevj_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEEVJ_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of
  !>     complex Hermitian matrices A_l.
  !> 
  !>     \details
  !>     The eigenvalues are found using the iterative Jacobi algorithm and are returned in an order
  !>     depending on the value of esort.
  !>     The eigenvectors are computed depending on the value of evect. The computed eigenvectors are orthonormal.
  !> 
  !>     At the \f$k\f$-th iteration (or "sweep"), \f$A_l\f$ is transformed by a product of Jacobi rotations \f$V_l\f$ as
  !> 
  !>     \f[
  !>         A_l^{(k)} = V_l' A_l^{(k-1)} V_l^{}
  !>     \f]
  !> 
  !>     such that \f$off(A_l^{(k)}) < off(A_l^{(k-1)})\f$, where \f$A_l^{(0)} = A_l\f$ and \f$off(A_l^{(k)})\f$ is the
  !>     Frobenius norm of the off-diagonal elements of \f$A_l^{(k)}\f$. As \f$off(A_l^{(k)}) \rightarrow 0\f$, the
  !>     diagonal elements of \f$A_l^{(k)}\f$ increasingly resemble the eigenvalues of \f$A_l\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     esort       #rocblas_esort.
  !>                 Specifies the order of the returned eigenvalues. If esort is
  !>                 rocblas_esort_ascending, then the eigenvalues are sorted and returned in ascending order.
  !>                 If esort is rocblas_esort_none, then the order of the returned eigenvalues is unspecified.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the Hermitian matrices A_l is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A_l
  !>                 is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of rows and columns of matrices A_l.
  !>     @param[inout]
  !>     A           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and
  !>                 the algorithm converged; otherwise the contents of A_l are unchanged.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     abstol      real type.
  !>                 The absolute tolerance. The algorithm is considered to have converged once off(A_l)
  !>                 is <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.
  !>     @param[out]
  !>     residual    pointer to real type. Array of batch_count scalars on the GPU.
  !>                 The Frobenius norm of the off-diagonal elements of A_l (i.e. off(A_l)) at the final iteration.
  !>     @param[in]
  !>     max_sweeps  rocblas_int. max_sweeps > 0.
  !>                 Maximum number of sweeps (iterations) to be used by the algorithm.
  !>     @param[out]
  !>     n_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 The actual number of sweeps (iterations) used by the algorithm for each batch instance.
  !>     @param[out]
  !>     W           pointer to real type. Array on the GPU (the size depends on the value of strideW).
  !>                 The eigenvalues of A_l in increasing order.
  !>     @param[in]
  !>     strideW     rocblas_stride.
  !>                 Stride from the start of one vector W_l to the next one W_(l+1).
  !>                 There is no restriction for the value of strideW. Normal use case is strideW >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for matrix A_l. If info[l] = 1, the algorithm did not converge.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_cheevj_batched
    function rocsolver_cheevj_batched_(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count) bind(c, name="rocsolver_cheevj_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevj_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_esort_none)),value :: esort
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_float),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cheevj_batched_full_rank,&
      
rocsolver_cheevj_batched_rank_0,&
      
rocsolver_cheevj_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zheevj_batched
    function rocsolver_zheevj_batched_(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count) bind(c, name="rocsolver_zheevj_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevj_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_esort_none)),value :: esort
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_double),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zheevj_batched_full_rank,&
      
rocsolver_zheevj_batched_rank_0,&
      
rocsolver_zheevj_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYEVJ_STRIDED_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of
  !>     real symmetric matrices A_l.
  !> 
  !>     \details
  !>     The eigenvalues are found using the iterative Jacobi algorithm and are returned in an order
  !>     depending on the value of esort.
  !>     The eigenvectors are computed depending on the value of evect. The computed eigenvectors are orthonormal.
  !> 
  !>     At the \f$k\f$-th iteration (or "sweep"), \f$A_l\f$ is transformed by a product of Jacobi rotations \f$V_l\f$ as
  !> 
  !>     \f[
  !>         A_l^{(k)} = V_l' A_l^{(k-1)} V_l^{}
  !>     \f]
  !> 
  !>     such that \f$off(A_l^{(k)}) < off(A_l^{(k-1)})\f$, where \f$A_l^{(0)} = A_l\f$ and \f$off(A_l^{(k)})\f$ is the
  !>     Frobenius norm of the off-diagonal elements of \f$A_l^{(k)}\f$. As \f$off(A_l^{(k)}) \rightarrow 0\f$, the
  !>     diagonal elements of \f$A_l^{(k)}\f$ increasingly resemble the eigenvalues of \f$A_l\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     esort       #rocblas_esort.
  !>                 Specifies the order of the returned eigenvalues. If esort is
  !>                 rocblas_esort_ascending, then the eigenvalues are sorted and returned in ascending order.
  !>                 If esort is rocblas_esort_none, then the order of the returned eigenvalues is unspecified.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the symmetric matrices A_l is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A_l
  !>                 is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of rows and columns of matrices A_l.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and
  !>                 the algorithm converged; otherwise the contents of A_l are unchanged.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[in]
  !>     abstol      type.
  !>                 The absolute tolerance. The algorithm is considered to have converged once off(A_l)
  !>                 is <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.
  !>     @param[out]
  !>     residual    pointer to type. Array of batch_count scalars on the GPU.
  !>                 The Frobenius norm of the off-diagonal elements of A_l (i.e. off(A_l)) at the final iteration.
  !>     @param[in]
  !>     max_sweeps  rocblas_int. max_sweeps > 0.
  !>                 Maximum number of sweeps (iterations) to be used by the algorithm.
  !>     @param[out]
  !>     n_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 The actual number of sweeps (iterations) used by the algorithm for each batch instance.
  !>     @param[out]
  !>     W           pointer to type. Array on the GPU (the size depends on the value of strideW).
  !>                 The eigenvalues of A_l in increasing order.
  !>     @param[in]
  !>     strideW     rocblas_stride.
  !>                 Stride from the start of one vector W_l to the next one W_(l+1).
  !>                 There is no restriction for the value of strideW. Normal use case is strideW >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for matrix A_l. If info[l] = 1, the algorithm did not converge.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_ssyevj_strided_batched
    function rocsolver_ssyevj_strided_batched_(handle,esort,evect,uplo,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count) bind(c, name="rocsolver_ssyevj_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevj_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_esort_none)),value :: esort
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_float),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssyevj_strided_batched_full_rank,&
      
rocsolver_ssyevj_strided_batched_rank_0,&
      
rocsolver_ssyevj_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dsyevj_strided_batched
    function rocsolver_dsyevj_strided_batched_(handle,esort,evect,uplo,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count) bind(c, name="rocsolver_dsyevj_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevj_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_esort_none)),value :: esort
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_double),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsyevj_strided_batched_full_rank,&
      
rocsolver_dsyevj_strided_batched_rank_0,&
      
rocsolver_dsyevj_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEEVJ_STRIDED_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of
  !>     complex Hermitian matrices A_l.
  !> 
  !>     \details
  !>     The eigenvalues are found using the iterative Jacobi algorithm and are returned in an order
  !>     depending on the value of esort.
  !>     The eigenvectors are computed depending on the value of evect. The computed eigenvectors are orthonormal.
  !> 
  !>     At the \f$k\f$-th iteration (or "sweep"), \f$A_l\f$ is transformed by a product of Jacobi rotations \f$V_l\f$ as
  !> 
  !>     \f[
  !>         A_l^{(k)} = V_l' A_l^{(k-1)} V_l^{}
  !>     \f]
  !> 
  !>     such that \f$off(A_l^{(k)}) < off(A_l^{(k-1)})\f$, where \f$A_l^{(0)} = A_l\f$ and \f$off(A_l^{(k)})\f$ is the
  !>     Frobenius norm of the off-diagonal elements of \f$A_l^{(k)}\f$. As \f$off(A_l^{(k)}) \rightarrow 0\f$, the
  !>     diagonal elements of \f$A_l^{(k)}\f$ increasingly resemble the eigenvalues of \f$A_l\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     esort       #rocblas_esort.
  !>                 Specifies the order of the returned eigenvalues. If esort is
  !>                 rocblas_esort_ascending, then the eigenvalues are sorted and returned in ascending order.
  !>                 If esort is rocblas_esort_none, then the order of the returned eigenvalues is unspecified.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the Hermitian matrices A_l is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A_l
  !>                 is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of rows and columns of matrices A_l.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and
  !>                 the algorithm converged; otherwise the contents of A_l are unchanged.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[in]
  !>     abstol      real type.
  !>                 The absolute tolerance. The algorithm is considered to have converged once off(A_l)
  !>                 is <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.
  !>     @param[out]
  !>     residual    pointer to real type. Array of batch_count scalars on the GPU.
  !>                 The Frobenius norm of the off-diagonal elements of A_l (i.e. off(A_l)) at the final iteration.
  !>     @param[in]
  !>     max_sweeps  rocblas_int. max_sweeps > 0.
  !>                 Maximum number of sweeps (iterations) to be used by the algorithm.
  !>     @param[out]
  !>     n_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 The actual number of sweeps (iterations) used by the algorithm for each batch instance.
  !>     @param[out]
  !>     W           pointer to real type. Array on the GPU (the size depends on the value of strideW).
  !>                 The eigenvalues of A_l in increasing order.
  !>     @param[in]
  !>     strideW     rocblas_stride.
  !>                 Stride from the start of one vector W_l to the next one W_(l+1).
  !>                 There is no restriction for the value of strideW. Normal use case is strideW >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for matrix A_l. If info[l] = 1, the algorithm did not converge.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_cheevj_strided_batched
    function rocsolver_cheevj_strided_batched_(handle,esort,evect,uplo,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count) bind(c, name="rocsolver_cheevj_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevj_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_esort_none)),value :: esort
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_float),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cheevj_strided_batched_full_rank,&
      
rocsolver_cheevj_strided_batched_rank_0,&
      
rocsolver_cheevj_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zheevj_strided_batched
    function rocsolver_zheevj_strided_batched_(handle,esort,evect,uplo,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count) bind(c, name="rocsolver_zheevj_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevj_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_esort_none)),value :: esort
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_double),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zheevj_strided_batched_full_rank,&
      
rocsolver_zheevj_strided_batched_rank_0,&
      
rocsolver_zheevj_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYEVX computes a set of the eigenvalues and optionally the corresponding eigenvectors of a
  !>     real symmetric matrix A.
  !> 
  !>     \details
  !>     This function computes all the eigenvalues of A, all the eigenvalues in the half-open interval \f$(vl, vu]\f$,
  !>     or the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,
  !>     the eigenvectors for these eigenvalues will be computed as well.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     erange      #rocblas_erange.
  !>                 Specifies the type of range or interval of the eigenvalues to be computed.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the symmetric matrix A is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A
  !>                 is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of rows and columns of matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A. On exit, the contents of A are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrix A.
  !>     @param[in]
  !>     vl          type. vl < vu.
  !>                 The lower bound of the search interval (vl, vu]. Ignored if range indicates to look
  !>                 for all the eigenvalues of A or the eigenvalues within a set of indices.
  !>     @param[in]
  !>     vu          type. vl < vu.
  !>                 The upper bound of the search interval (vl, vu]. Ignored if range indicates to look
  !>                 for all the eigenvalues of A or the eigenvalues within a set of indices.
  !>     @param[in]
  !>     il          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.
  !>                 The index of the smallest eigenvalue to be computed. Ignored if range indicates to look
  !>                 for all the eigenvalues of A or the eigenvalues in a half-open interval.
  !>     @param[in]
  !>     iu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..
  !>                 The index of the largest eigenvalue to be computed. Ignored if range indicates to look
  !>                 for all the eigenvalues of A or the eigenvalues in a half-open interval.
  !>     @param[in]
  !>     abstol      type.
  !>                 The absolute tolerance. An eigenvalue is considered to be located if it lies
  !>                 in an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times
  !>                 the 1-norm of the tridiagonal form of A will be used as tolerance. If abstol=0, then the tolerance will be set
  !>                 to twice the underflow threshold; this is the tolerance that could get the most accurate results.
  !>     @param[out]
  !>     nev         pointer to a rocblas_int on the GPU.
  !>                 The total number of eigenvalues found. If erange is rocblas_erange_all, nev = n.
  !>                 If erange is rocblas_erange_index, nev = iu - il + 1. Otherwise, 0 <= nev <= n.
  !>     @param[out]
  !>     W           pointer to type. Array on the GPU of dimension n.
  !>                 The first nev elements contain the computed eigenvalues. (The remaining elements
  !>                 can be used as workspace for internal computations).
  !>     @param[out]
  !>     Z           pointer to type. Array on the GPU of dimension ldznev.
  !>                 On exit, if evect is not rocblas_evect_none and info = 0, the first nev columns contain
  !>                 the eigenvectors of A corresponding to the output eigenvalues. Not referenced if
  !>                 evect is rocblas_evect_none.
  !>                 Note: If erange is rocblas_range_value, then the values of nev are not known in advance.
  !>                 The user should ensure that Z is large enough to hold n columns, as all n columns
  !>                 can be used as workspace for internal computations.
  !>     @param[in]
  !>     ldz         rocblas_int. ldz >= n.
  !>                 Specifies the leading dimension of matrix Z.
  !>     @param[out]
  !>     ifail       pointer to rocblas_int. Array on the GPU of dimension n.
  !>                 If info = 0, the first nev elements of ifail are zero.
  !>                 Otherwise, contains the indices of those eigenvectors that failed
  !>                 to converge. Not referenced if evect is rocblas_evect_none.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0, the algorithm did not converge. i columns of Z did not converge.
  !>     
  interface rocsolver_ssyevx
    function rocsolver_ssyevx_(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo) bind(c, name="rocsolver_ssyevx")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevx_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_erange_all)),value :: erange
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_float),value :: vl
      real(c_float),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      real(c_float),value :: abstol
      type(c_ptr),value :: nev
      type(c_ptr),value :: W
      type(c_ptr),value :: Z
      integer(c_int),value :: ldz
      type(c_ptr),value :: ifail
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssyevx_full_rank,&
      
rocsolver_ssyevx_rank_0,&
      
rocsolver_ssyevx_rank_1
#endif

  end interface
  
  interface rocsolver_dsyevx
    function rocsolver_dsyevx_(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo) bind(c, name="rocsolver_dsyevx")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevx_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_erange_all)),value :: erange
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_double),value :: vl
      real(c_double),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      real(c_double),value :: abstol
      type(c_ptr),value :: nev
      type(c_ptr),value :: W
      type(c_ptr),value :: Z
      integer(c_int),value :: ldz
      type(c_ptr),value :: ifail
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsyevx_full_rank,&
      
rocsolver_dsyevx_rank_0,&
      
rocsolver_dsyevx_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEEVX computes a set of the eigenvalues and optionally the corresponding eigenvectors of a
  !>     Hermitian matrix A.
  !> 
  !>     \details
  !>     This function computes all the eigenvalues of A, all the eigenvalues in the half-open interval \f$(vl, vu]\f$,
  !>     or the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,
  !>     the eigenvectors for these eigenvalues will be computed as well.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     erange      #rocblas_erange.
  !>                 Specifies the type of range or interval of the eigenvalues to be computed.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the symmetric matrix A is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A
  !>                 is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of rows and columns of matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A. On exit, the contents of A are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrix A.
  !>     @param[in]
  !>     vl          real type. vl < vu.
  !>                 The lower bound of the search interval (vl, vu]. Ignored if range indicates to look
  !>                 for all the eigenvalues of A or the eigenvalues within a set of indices.
  !>     @param[in]
  !>     vu          real type. vl < vu.
  !>                 The upper bound of the search interval (vl, vu]. Ignored if range indicates to look
  !>                 for all the eigenvalues of A or the eigenvalues within a set of indices.
  !>     @param[in]
  !>     il          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.
  !>                 The index of the smallest eigenvalue to be computed. Ignored if range indicates to look
  !>                 for all the eigenvalues of A or the eigenvalues in a half-open interval.
  !>     @param[in]
  !>     iu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..
  !>                 The index of the largest eigenvalue to be computed. Ignored if range indicates to look
  !>                 for all the eigenvalues of A or the eigenvalues in a half-open interval.
  !>     @param[in]
  !>     abstol      real type.
  !>                 The absolute tolerance. An eigenvalue is considered to be located if it lies
  !>                 in an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times
  !>                 the 1-norm of the tridiagonal form of A will be used as tolerance. If abstol=0, then the tolerance will be set
  !>                 to twice the underflow threshold; this is the tolerance that could get the most accurate results.
  !>     @param[out]
  !>     nev         pointer to a rocblas_int on the GPU.
  !>                 The total number of eigenvalues found. If erange is rocblas_erange_all, nev = n.
  !>                 If erange is rocblas_erange_index, nev = iu - il + 1. Otherwise, 0 <= nev <= n.
  !>     @param[out]
  !>     W           pointer to real type. Array on the GPU of dimension n.
  !>                 The first nev elements contain the computed eigenvalues. (The remaining elements
  !>                 can be used as workspace for internal computations).
  !>     @param[out]
  !>     Z           pointer to type. Array on the GPU of dimension ldznev.
  !>                 On exit, if evect is not rocblas_evect_none and info = 0, the first nev columns contain
  !>                 the eigenvectors of A corresponding to the output eigenvalues. Not referenced if
  !>                 evect is rocblas_evect_none.
  !>                 Note: If erange is rocblas_range_value, then the values of nev are not known in advance.
  !>                 The user should ensure that Z is large enough to hold n columns, as all n columns
  !>                 can be used as workspace for internal computations.
  !>     @param[in]
  !>     ldz         rocblas_int. ldz >= n.
  !>                 Specifies the leading dimension of matrix Z.
  !>     @param[out]
  !>     ifail       pointer to rocblas_int. Array on the GPU of dimension n.
  !>                 If info = 0, the first nev elements of ifail are zero.
  !>                 Otherwise, contains the indices of those eigenvectors that failed
  !>                 to converge. Not referenced if evect is rocblas_evect_none.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0, the algorithm did not converge. i columns of Z did not converge.
  !>     
  interface rocsolver_cheevx
    function rocsolver_cheevx_(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo) bind(c, name="rocsolver_cheevx")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevx_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_erange_all)),value :: erange
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_float),value :: vl
      real(c_float),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      real(c_float),value :: abstol
      type(c_ptr),value :: nev
      type(c_ptr),value :: W
      type(c_ptr),value :: Z
      integer(c_int),value :: ldz
      type(c_ptr),value :: ifail
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cheevx_full_rank,&
      
rocsolver_cheevx_rank_0,&
      
rocsolver_cheevx_rank_1
#endif

  end interface
  
  interface rocsolver_zheevx
    function rocsolver_zheevx_(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo) bind(c, name="rocsolver_zheevx")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevx_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_erange_all)),value :: erange
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      real(c_double),value :: vl
      real(c_double),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      real(c_double),value :: abstol
      type(c_ptr),value :: nev
      type(c_ptr),value :: W
      type(c_ptr),value :: Z
      integer(c_int),value :: ldz
      type(c_ptr),value :: ifail
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zheevx_full_rank,&
      
rocsolver_zheevx_rank_0,&
      
rocsolver_zheevx_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYEVX_BATCHED computes a set of the eigenvalues and optionally the corresponding eigenvectors
  !>     of a batch of real symmetric matrices A_l.
  !> 
  !>     \details
  !>     This function computes all the eigenvalues of A_l, all the eigenvalues in the half-open interval \f$(vl, vu]\f$,
  !>     or the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,
  !>     the eigenvectors for these eigenvalues will be computed as well.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     erange      #rocblas_erange.
  !>                 Specifies the type of range or interval of the eigenvalues to be computed.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the symmetric matrices A_l is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A_l
  !>                 is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of rows and columns of matrices A_l.
  !>     @param[inout]
  !>     A           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the matrices A_l. On exit, the contents of A_l are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     vl          type. vl < vu.
  !>                 The lower bound of the search interval (vl, vu]. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues within a set of indices.
  !>     @param[in]
  !>     vu          type. vl < vu.
  !>                 The upper bound of the search interval (vl, vu]. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues within a set of indices.
  !>     @param[in]
  !>     il          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.
  !>                 The index of the smallest eigenvalue to be computed. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues in a half-open interval.
  !>     @param[in]
  !>     iu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..
  !>                 The index of the largest eigenvalue to be computed. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues in a half-open interval.
  !>     @param[in]
  !>     abstol      type.
  !>                 The absolute tolerance. An eigenvalue is considered to be located if it lies
  !>                 in an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times
  !>                 the 1-norm of the tridiagonal form of A_l will be used as tolerance. If abstol=0, then the tolerance will be set
  !>                 to twice the underflow threshold; this is the tolerance that could get the most accurate results.
  !>     @param[out]
  !>     nev         pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 The total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.
  !>                 If erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.
  !>     @param[out]
  !>     W           pointer to type. Array on the GPU (the size depends on the value of strideW).
  !>                 The first nev[l] elements contain the computed eigenvalues. (The remaining elements
  !>                 can be used as workspace for internal computations).
  !>     @param[in]
  !>     strideW     rocblas_stride.
  !>                 Stride from the start of one vector W_l to the next one W_(l+1).
  !>                 There is no restriction for the value of strideW. Normal use case is strideW >= n.
  !>     @param[out]
  !>     Z           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldznev[l].
  !>                 On exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain
  !>                 the eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if
  !>                 evect is rocblas_evect_none.
  !>                 Note: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.
  !>                 The user should ensure that Z_l is large enough to hold n columns, as all n columns
  !>                 can be used as workspace for internal computations.
  !>     @param[in]
  !>     ldz         rocblas_int. ldz >= n.
  !>                 Specifies the leading dimension of matrices Z_l.
  !>     @param[out]
  !>     ifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).
  !>                 If info[l] = 0, the first nev[l] elements of ifail_l are zero.
  !>                 Otherwise, contains the indices of those eigenvectors that failed
  !>                 to converge. Not referenced if evect is rocblas_evect_none.
  !>     @param[in]
  !>     strideF     rocblas_stride.
  !>                 Stride from the start of one vector ifail_l to the next one ifail_(l+1).
  !>                 There is no restriction for the value of strideF. Normal use case is strideF >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for matrix A_l.
  !>                 If info[l] = i > 0, the algorithm did not converge. i columns of Z_l did not converge.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_ssyevx_batched
    function rocsolver_ssyevx_batched_(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count) bind(c, name="rocsolver_ssyevx_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevx_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_erange_all)),value :: erange
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_float),value :: vl
      real(c_float),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      real(c_float),value :: abstol
      type(c_ptr),value :: nev
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr) :: Z
      integer(c_int),value :: ldz
      type(c_ptr),value :: ifail
      integer(c_int64_t),value :: strideF
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssyevx_batched_full_rank,&
      
rocsolver_ssyevx_batched_rank_0,&
      
rocsolver_ssyevx_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dsyevx_batched
    function rocsolver_dsyevx_batched_(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count) bind(c, name="rocsolver_dsyevx_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevx_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_erange_all)),value :: erange
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_double),value :: vl
      real(c_double),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      real(c_double),value :: abstol
      type(c_ptr),value :: nev
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr) :: Z
      integer(c_int),value :: ldz
      type(c_ptr),value :: ifail
      integer(c_int64_t),value :: strideF
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsyevx_batched_full_rank,&
      
rocsolver_dsyevx_batched_rank_0,&
      
rocsolver_dsyevx_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEEVX_BATCHED computes a set of the eigenvalues and optionally the corresponding eigenvectors
  !>     of a batch of Hermitian matrices A_l.
  !> 
  !>     \details
  !>     This function computes all the eigenvalues of A_l, all the eigenvalues in the half-open interval \f$(vl, vu]\f$,
  !>     or the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,
  !>     the eigenvectors for these eigenvalues will be computed as well.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     erange      #rocblas_erange.
  !>                 Specifies the type of range or interval of the eigenvalues to be computed.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the symmetric matrices A_l is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A_l
  !>                 is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of rows and columns of matrices A_l.
  !>     @param[inout]
  !>     A           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the matrices A_l. On exit, the contents of A_l are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     vl          real type. vl < vu.
  !>                 The lower bound of the search interval (vl, vu]. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues within a set of indices.
  !>     @param[in]
  !>     vu          real type. vl < vu.
  !>                 The upper bound of the search interval (vl, vu]. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues within a set of indices.
  !>     @param[in]
  !>     il          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.
  !>                 The index of the smallest eigenvalue to be computed. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues in a half-open interval.
  !>     @param[in]
  !>     iu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..
  !>                 The index of the largest eigenvalue to be computed. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues in a half-open interval.
  !>     @param[in]
  !>     abstol      real type.
  !>                 The absolute tolerance. An eigenvalue is considered to be located if it lies
  !>                 in an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times
  !>                 the 1-norm of the tridiagonal form of A_l will be used as tolerance. If abstol=0, then the tolerance will be set
  !>                 to twice the underflow threshold; this is the tolerance that could get the most accurate results.
  !>     @param[out]
  !>     nev         pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 The total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.
  !>                 If erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.
  !>     @param[out]
  !>     W           pointer to real type. Array on the GPU (the size depends on the value of strideW).
  !>                 The first nev[l] elements contain the computed eigenvalues. (The remaining elements
  !>                 can be used as workspace for internal computations).
  !>     @param[in]
  !>     strideW     rocblas_stride.
  !>                 Stride from the start of one vector W_l to the next one W_(l+1).
  !>                 There is no restriction for the value of strideW. Normal use case is strideW >= n.
  !>     @param[out]
  !>     Z           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldznev[l].
  !>                 On exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain
  !>                 the eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if
  !>                 evect is rocblas_evect_none.
  !>                 Note: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.
  !>                 The user should ensure that Z_l is large enough to hold n columns, as all n columns
  !>                 can be used as workspace for internal computations.
  !>     @param[in]
  !>     ldz         rocblas_int. ldz >= n.
  !>                 Specifies the leading dimension of matrices Z_l.
  !>     @param[out]
  !>     ifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).
  !>                 If info[l] = 0, the first nev[l] elements of ifail_l are zero.
  !>                 Otherwise, contains the indices of those eigenvectors that failed
  !>                 to converge. Not referenced if evect is rocblas_evect_none.
  !>     @param[in]
  !>     strideF     rocblas_stride.
  !>                 Stride from the start of one vector ifail_l to the next one ifail_(l+1).
  !>                 There is no restriction for the value of strideF. Normal use case is strideF >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for matrix A_l.
  !>                 If info[l] = i > 0, the algorithm did not converge. i columns of Z_l did not converge.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_cheevx_batched
    function rocsolver_cheevx_batched_(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count) bind(c, name="rocsolver_cheevx_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevx_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_erange_all)),value :: erange
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_float),value :: vl
      real(c_float),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      real(c_float),value :: abstol
      type(c_ptr),value :: nev
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr) :: Z
      integer(c_int),value :: ldz
      type(c_ptr),value :: ifail
      integer(c_int64_t),value :: strideF
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cheevx_batched_full_rank,&
      
rocsolver_cheevx_batched_rank_0,&
      
rocsolver_cheevx_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zheevx_batched
    function rocsolver_zheevx_batched_(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count) bind(c, name="rocsolver_zheevx_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevx_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_erange_all)),value :: erange
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      real(c_double),value :: vl
      real(c_double),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      real(c_double),value :: abstol
      type(c_ptr),value :: nev
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr) :: Z
      integer(c_int),value :: ldz
      type(c_ptr),value :: ifail
      integer(c_int64_t),value :: strideF
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zheevx_batched_full_rank,&
      
rocsolver_zheevx_batched_rank_0,&
      
rocsolver_zheevx_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYEVX_STRIDED_BATCHED computes a set of the eigenvalues and optionally the corresponding eigenvectors
  !>     of a batch of real symmetric matrices A_l.
  !> 
  !>     \details
  !>     This function computes all the eigenvalues of A_l, all the eigenvalues in the half-open interval \f$(vl, vu]\f$,
  !>     or the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,
  !>     the eigenvectors for these eigenvalues will be computed as well.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     erange      #rocblas_erange.
  !>                 Specifies the type of range or interval of the eigenvalues to be computed.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the symmetric matrices A_l is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A_l
  !>                 is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of rows and columns of matrices A_l.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the matrices A_l. On exit, the contents of A_l are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[in]
  !>     vl          type. vl < vu.
  !>                 The lower bound of the search interval (vl, vu]. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues within a set of indices.
  !>     @param[in]
  !>     vu          type. vl < vu.
  !>                 The upper bound of the search interval (vl, vu]. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues within a set of indices.
  !>     @param[in]
  !>     il          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.
  !>                 The index of the smallest eigenvalue to be computed. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues in a half-open interval.
  !>     @param[in]
  !>     iu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..
  !>                 The index of the largest eigenvalue to be computed. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues in a half-open interval.
  !>     @param[in]
  !>     abstol      type.
  !>                 The absolute tolerance. An eigenvalue is considered to be located if it lies
  !>                 in an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times
  !>                 the 1-norm of the tridiagonal form of A_l will be used as tolerance. If abstol=0, then the tolerance will be set
  !>                 to twice the underflow threshold; this is the tolerance that could get the most accurate results.
  !>     @param[out]
  !>     nev         pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 The total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.
  !>                 If erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.
  !>     @param[out]
  !>     W           pointer to type. Array on the GPU (the size depends on the value of strideW).
  !>                 The first nev[l] elements contain the computed eigenvalues. (The remaining elements
  !>                 can be used as workspace for internal computations).
  !>     @param[in]
  !>     strideW     rocblas_stride.
  !>                 Stride from the start of one vector W_l to the next one W_(l+1).
  !>                 There is no restriction for the value of strideW. Normal use case is strideW >= n.
  !>     @param[out]
  !>     Z           pointer to type. Array on the GPU (the size depends on the value of strideZ).
  !>                 On exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain
  !>                 the eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if
  !>                 evect is rocblas_evect_none.
  !>     @param[in]
  !>     ldz         rocblas_int. ldz >= n.
  !>                 Specifies the leading dimension of matrices Z_l.
  !>     @param[in]
  !>     strideZ     rocblas_stride.
  !>                 Stride from the start of one matrix Z_l to the next one Z_(l+1).
  !>                 There is no restriction for the value of strideZ. Normal use case is strideZ >= ldznev[l].
  !>                 Note: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.
  !>                 The user should ensure that Z_l is large enough to hold n columns, as all n columns
  !>                 can be used as workspace for internal computations.
  !>     @param[out]
  !>     ifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).
  !>                 If info[l] = 0, the first nev[l] elements of ifail_l are zero.
  !>                 Otherwise, contains the indices of those eigenvectors that failed
  !>                 to converge. Not referenced if evect is rocblas_evect_none.
  !>     @param[in]
  !>     strideF     rocblas_stride.
  !>                 Stride from the start of one vector ifail_l to the next one ifail_(l+1).
  !>                 There is no restriction for the value of strideF. Normal use case is strideF >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for matrix A_l.
  !>                 If info[l] = i > 0, the algorithm did not converge. i columns of Z_l did not converge.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_ssyevx_strided_batched
    function rocsolver_ssyevx_strided_batched_(handle,evect,erange,uplo,n,A,lda,strideA,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count) bind(c, name="rocsolver_ssyevx_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevx_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_erange_all)),value :: erange
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_float),value :: vl
      real(c_float),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      real(c_float),value :: abstol
      type(c_ptr),value :: nev
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr),value :: Z
      integer(c_int),value :: ldz
      integer(c_int64_t),value :: strideZ
      type(c_ptr),value :: ifail
      integer(c_int64_t),value :: strideF
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssyevx_strided_batched_full_rank,&
      
rocsolver_ssyevx_strided_batched_rank_0,&
      
rocsolver_ssyevx_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dsyevx_strided_batched
    function rocsolver_dsyevx_strided_batched_(handle,evect,erange,uplo,n,A,lda,strideA,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count) bind(c, name="rocsolver_dsyevx_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevx_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_erange_all)),value :: erange
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_double),value :: vl
      real(c_double),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      real(c_double),value :: abstol
      type(c_ptr),value :: nev
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr),value :: Z
      integer(c_int),value :: ldz
      integer(c_int64_t),value :: strideZ
      type(c_ptr),value :: ifail
      integer(c_int64_t),value :: strideF
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsyevx_strided_batched_full_rank,&
      
rocsolver_dsyevx_strided_batched_rank_0,&
      
rocsolver_dsyevx_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEEVX_STRIDED_BATCHED computes a set of the eigenvalues and optionally the corresponding eigenvectors
  !>     of a batch of Hermitian matrices A_l.
  !> 
  !>     \details
  !>     This function computes all the eigenvalues of A_l, all the eigenvalues in the half-open interval \f$(vl, vu]\f$,
  !>     or the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,
  !>     the eigenvectors for these eigenvalues will be computed as well.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     erange      #rocblas_erange.
  !>                 Specifies the type of range or interval of the eigenvalues to be computed.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the symmetric matrices A_l is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower) part of A_l
  !>                 is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 Number of rows and columns of matrices A_l.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the matrices A_l. On exit, the contents of A_l are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[in]
  !>     vl          real type. vl < vu.
  !>                 The lower bound of the search interval (vl, vu]. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues within a set of indices.
  !>     @param[in]
  !>     vu          real type. vl < vu.
  !>                 The upper bound of the search interval (vl, vu]. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues within a set of indices.
  !>     @param[in]
  !>     il          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.
  !>                 The index of the smallest eigenvalue to be computed. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues in a half-open interval.
  !>     @param[in]
  !>     iu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..
  !>                 The index of the largest eigenvalue to be computed. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues in a half-open interval.
  !>     @param[in]
  !>     abstol      real type.
  !>                 The absolute tolerance. An eigenvalue is considered to be located if it lies
  !>                 in an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times
  !>                 the 1-norm of the tridiagonal form of A_l will be used as tolerance. If abstol=0, then the tolerance will be set
  !>                 to twice the underflow threshold; this is the tolerance that could get the most accurate results.
  !>     @param[out]
  !>     nev         pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 The total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.
  !>                 If erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.
  !>     @param[out]
  !>     W           pointer to real type. Array on the GPU (the size depends on the value of strideW).
  !>                 The first nev[l] elements contain the computed eigenvalues. (The remaining elements
  !>                 can be used as workspace for internal computations).
  !>     @param[in]
  !>     strideW     rocblas_stride.
  !>                 Stride from the start of one vector W_l to the next one W_(l+1).
  !>                 There is no restriction for the value of strideW. Normal use case is strideW >= n.
  !>     @param[out]
  !>     Z           pointer to type. Array on the GPU (the size depends on the value of strideZ).
  !>                 On exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain
  !>                 the eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if
  !>                 evect is rocblas_evect_none.
  !>     @param[in]
  !>     ldz         rocblas_int. ldz >= n.
  !>                 Specifies the leading dimension of matrices Z_l.
  !>     @param[in]
  !>     strideZ     rocblas_stride.
  !>                 Stride from the start of one matrix Z_l to the next one Z_(l+1).
  !>                 There is no restriction for the value of strideZ. Normal use case is strideZ >= ldznev[l].
  !>                 Note: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.
  !>                 The user should ensure that Z_l is large enough to hold n columns, as all n columns
  !>                 can be used as workspace for internal computations.
  !>     @param[out]
  !>     ifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).
  !>                 If info[l] = 0, the first nev[l] elements of ifail_l are zero.
  !>                 Otherwise, contains the indices of those eigenvectors that failed
  !>                 to converge. Not referenced if evect is rocblas_evect_none.
  !>     @param[in]
  !>     strideF     rocblas_stride.
  !>                 Stride from the start of one vector ifail_l to the next one ifail_(l+1).
  !>                 There is no restriction for the value of strideF. Normal use case is strideF >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for matrix A_l.
  !>                 If info[l] = i > 0, the algorithm did not converge. i columns of Z_l did not converge.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_cheevx_strided_batched
    function rocsolver_cheevx_strided_batched_(handle,evect,erange,uplo,n,A,lda,strideA,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count) bind(c, name="rocsolver_cheevx_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevx_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_erange_all)),value :: erange
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_float),value :: vl
      real(c_float),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      real(c_float),value :: abstol
      type(c_ptr),value :: nev
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr),value :: Z
      integer(c_int),value :: ldz
      integer(c_int64_t),value :: strideZ
      type(c_ptr),value :: ifail
      integer(c_int64_t),value :: strideF
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cheevx_strided_batched_full_rank,&
      
rocsolver_cheevx_strided_batched_rank_0,&
      
rocsolver_cheevx_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zheevx_strided_batched
    function rocsolver_zheevx_strided_batched_(handle,evect,erange,uplo,n,A,lda,strideA,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count) bind(c, name="rocsolver_zheevx_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevx_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_erange_all)),value :: erange
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_double),value :: vl
      real(c_double),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      real(c_double),value :: abstol
      type(c_ptr),value :: nev
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr),value :: Z
      integer(c_int),value :: ldz
      integer(c_int64_t),value :: strideZ
      type(c_ptr),value :: ifail
      integer(c_int64_t),value :: strideF
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zheevx_strided_batched_full_rank,&
      
rocsolver_zheevx_strided_batched_rank_0,&
      
rocsolver_zheevx_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYGV computes the eigenvalues and (optionally) eigenvectors of
  !>     a real generalized symmetric-definite eigenproblem.
  !> 
  !>     \details
  !>     The problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A X = \lambda B X & \: \text{1st form,}\\
  !>         A B X = \lambda X & \: \text{2nd form, or}\\
  !>         B A X = \lambda X & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype. The eigenvectors are computed depending on the
  !>     value of evect.
  !> 
  !>     When computed, the matrix Z of eigenvectors is normalized as follows:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Z^T B Z=I & \: \text{if 1st or 2nd form, or}\\
  !>         Z^T B^{-1} Z=I & \: \text{if 3rd form.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblem.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower parts of the matrices
  !>                 A and B are stored. If uplo indicates lower (or upper),
  !>                 then the upper (or lower) parts of A and B are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the symmetric matrix A. On exit, if evect is original,
  !>                 the normalized matrix Z of eigenvectors. If evect is none, then the upper or lower triangular
  !>                 part of the matrix A (including the diagonal) is destroyed,
  !>                 depending on the value of uplo.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     B           pointer to type. Array on the GPU of dimension ldbn.
  !>                 On entry, the symmetric positive definite matrix B. On exit, the
  !>                 triangular factor of B as returned by \ref rocsolver_spotrf "POTRF".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B.
  !>     @param[out]
  !>     D           pointer to type. Array on the GPU of dimension n.
  !>                 On exit, the eigenvalues in increasing order.
  !>     @param[out]
  !>     E           pointer to type. Array on the GPU of dimension n.
  !>                 This array is used to work internally with the tridiagonal matrix T associated with
  !>                 the reduced eigenvalue problem.
  !>                 On exit, if 0 < info <= n, it contains the unconverged off-diagonal elements of T
  !>                 (or properly speaking, a tridiagonal matrix equivalent to T). The diagonal elements
  !>                 of this matrix are in D; those that converged correspond to a subset of the
  !>                 eigenvalues (not necessarily ordered).
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i <= n, i off-diagonal elements of an intermediate
  !>                 tridiagonal form did not converge to zero.
  !>                 If info = n + i, the leading minor of order i of B is not
  !>                 positive definite.
  !>     
  interface rocsolver_ssygv
    function rocsolver_ssygv_(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo) bind(c, name="rocsolver_ssygv")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssygv_full_rank,&
      
rocsolver_ssygv_rank_0,&
      
rocsolver_ssygv_rank_1
#endif

  end interface
  
  interface rocsolver_dsygv
    function rocsolver_dsygv_(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo) bind(c, name="rocsolver_dsygv")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsygv_full_rank,&
      
rocsolver_dsygv_rank_0,&
      
rocsolver_dsygv_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEGV computes the eigenvalues and (optionally) eigenvectors of
  !>     a complex generalized hermitian-definite eigenproblem.
  !> 
  !>     \details
  !>     The problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A X = \lambda B X & \: \text{1st form,}\\
  !>         A B X = \lambda X & \: \text{2nd form, or}\\
  !>         B A X = \lambda X & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype. The eigenvectors are computed depending on the
  !>     value of evect.
  !> 
  !>     When computed, the matrix Z of eigenvectors is normalized as follows:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Z^H B Z=I & \: \text{if 1st or 2nd form, or}\\
  !>         Z^H B^{-1} Z=I & \: \text{if 3rd form.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblem.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower parts of the matrices
  !>                 A and B are stored. If uplo indicates lower (or upper),
  !>                 then the upper (or lower) parts of A and B are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the hermitian matrix A. On exit, if evect is original,
  !>                 the normalized matrix Z of eigenvectors. If evect is none, then the upper or lower triangular
  !>                 part of the matrix A (including the diagonal) is destroyed,
  !>                 depending on the value of uplo.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     B           pointer to type. Array on the GPU of dimension ldbn.
  !>                 On entry, the hermitian positive definite matrix B. On exit, the
  !>                 triangular factor of B as returned by \ref rocsolver_spotrf "POTRF".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B.
  !>     @param[out]
  !>     D           pointer to real type. Array on the GPU of dimension n.
  !>                 On exit, the eigenvalues in increasing order.
  !>     @param[out]
  !>     E           pointer to real type. Array on the GPU of dimension n.
  !>                 This array is used to work internally with the tridiagonal matrix T associated with
  !>                 the reduced eigenvalue problem.
  !>                 On exit, if 0 < info <= n, it contains the unconverged off-diagonal elements of T
  !>                 (or properly speaking, a tridiagonal matrix equivalent to T). The diagonal elements
  !>                 of this matrix are in D; those that converged correspond to a subset of the
  !>                 eigenvalues (not necessarily ordered).
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i <= n, i off-diagonal elements of an intermediate
  !>                 tridiagonal form did not converge to zero.
  !>                 If info = n + i, the leading minor of order i of B is not
  !>                 positive definite.
  !>     
  interface rocsolver_chegv
    function rocsolver_chegv_(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo) bind(c, name="rocsolver_chegv")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_chegv_full_rank,&
      
rocsolver_chegv_rank_0,&
      
rocsolver_chegv_rank_1
#endif

  end interface
  
  interface rocsolver_zhegv
    function rocsolver_zhegv_(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo) bind(c, name="rocsolver_zhegv")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegv_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zhegv_full_rank,&
      
rocsolver_zhegv_rank_0,&
      
rocsolver_zhegv_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYGV_BATCHED computes the eigenvalues and (optionally)
  !>     eigenvectors of a batch of real generalized symmetric-definite eigenproblems.
  !> 
  !>     \details
  !>     For each instance in the batch, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l X_l = \lambda B_l X_l & \: \text{1st form,}\\
  !>         A_l B_l X_l = \lambda X_l & \: \text{2nd form, or}\\
  !>         B_l A_l X_l = \lambda X_l & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype. The eigenvectors are computed depending on the
  !>     value of evect.
  !> 
  !>     When computed, the matrix \f$Z_l\f$ of eigenvectors is normalized as follows:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Z_l^T B_l^{} Z_l^{}=I & \: \text{if 1st or 2nd form, or}\\
  !>         Z_l^T B_l^{-1} Z_l^{}=I & \: \text{if 3rd form.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblems.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower parts of the matrices
  !>                 A_l and B_l are stored. If uplo indicates lower (or upper),
  !>                 then the upper (or lower) parts of A_l and B_l are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the symmetric matrices A_l. On exit, if evect is original,
  !>                 the normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular
  !>                 part of the matrices A_l (including the diagonal) are destroyed,
  !>                 depending on the value of uplo.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A_l.
  !>     @param[out]
  !>     B           array of pointers to type. Each pointer points to an array on the GPU of dimension ldbn.
  !>                 On entry, the symmetric positive definite matrices B_l. On exit, the
  !>                 triangular factor of B_l as returned by \ref rocsolver_spotrf_batched "POTRF_BATCHED".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B_l.
  !>     @param[out]
  !>     D           pointer to type. Array on the GPU (the size depends on the value of strideD).
  !>                 On exit, the eigenvalues in increasing order.
  !>     @param[in]
  !>     strideD     rocblas_stride.
  !>                 Stride from the start of one vector D_l to the next one D_(l+1).
  !>                 There is no restriction for the value of strideD. Normal use is strideD >= n.
  !>     @param[out]
  !>     E           pointer to type. Array on the GPU (the size depends on the value of strideE).
  !>                 This array is used to work internally with the tridiagonal matrix T_l associated with
  !>                 the l-th reduced eigenvalue problem.
  !>                 On exit, if 0 < info[l] <= n, E_l contains the unconverged off-diagonal elements of T_l
  !>                 (or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements
  !>                 of this matrix are in D_l; those that converged correspond to a subset of the
  !>                 eigenvalues (not necessarily ordered).
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use is strideE >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit of batch instance l.
  !>                 If info[l] = i <= n, i off-diagonal elements of an intermediate
  !>                 tridiagonal form did not converge to zero.
  !>                 If info[l] = n + i, the leading minor of order i of B_l is not
  !>                 positive definite.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_ssygv_batched
    function rocsolver_ssygv_batched_(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_ssygv_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssygv_batched_full_rank,&
      
rocsolver_ssygv_batched_rank_0,&
      
rocsolver_ssygv_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dsygv_batched
    function rocsolver_dsygv_batched_(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_dsygv_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsygv_batched_full_rank,&
      
rocsolver_dsygv_batched_rank_0,&
      
rocsolver_dsygv_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEGV_BATCHED computes the eigenvalues and (optionally)
  !>     eigenvectors of a batch of complex generalized hermitian-definite eigenproblems.
  !> 
  !>     \details
  !>     For each instance in the batch, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l X_l = \lambda B_l X_l & \: \text{1st form,}\\
  !>         A_l B_l X_l = \lambda X_l & \: \text{2nd form, or}\\
  !>         B_l A_l X_l = \lambda X_l & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype. The eigenvectors are computed depending on the
  !>     value of evect.
  !> 
  !>     When computed, the matrix \f$Z_l\f$ of eigenvectors is normalized as follows:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Z_l^H B_l^{} Z_l^{}=I & \: \text{if 1st or 2nd form, or}\\
  !>         Z_l^H B_l^{-1} Z_l^{}=I & \: \text{if 3rd form.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblems.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower parts of the matrices
  !>                 A_l and B_l are stored. If uplo indicates lower (or upper),
  !>                 then the upper (or lower) parts of A_l and B_l are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the hermitian matrices A_l. On exit, if evect is original,
  !>                 the normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular
  !>                 part of the matrices A_l (including the diagonal) are destroyed,
  !>                 depending on the value of uplo.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A_l.
  !>     @param[out]
  !>     B           array of pointers to type. Each pointer points to an array on the GPU of dimension ldbn.
  !>                 On entry, the hermitian positive definite matrices B_l. On exit, the
  !>                 triangular factor of B_l as returned by \ref rocsolver_spotrf_batched "POTRF_BATCHED".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B_l.
  !>     @param[out]
  !>     D           pointer to real type. Array on the GPU (the size depends on the value of strideD).
  !>                 On exit, the eigenvalues in increasing order.
  !>     @param[in]
  !>     strideD     rocblas_stride.
  !>                 Stride from the start of one vector D_l to the next one D_(l+1).
  !>                 There is no restriction for the value of strideD. Normal use is strideD >= n.
  !>     @param[out]
  !>     E           pointer to real type. Array on the GPU (the size depends on the value of strideE).
  !>                 This array is used to work internally with the tridiagonal matrix T_l associated with
  !>                 the l-th reduced eigenvalue problem.
  !>                 On exit, if 0 < info[l] <= n, it contains the unconverged off-diagonal elements of T_l
  !>                 (or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements
  !>                 of this matrix are in D_l; those that converged correspond to a subset of the
  !>                 eigenvalues (not necessarily ordered).
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use is strideE >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit of batch l.
  !>                 If info[l] = i <= n, i off-diagonal elements of an intermediate
  !>                 tridiagonal form did not converge to zero.
  !>                 If info[l] = n + i, the leading minor of order i of B_l is not
  !>                 positive definite.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_chegv_batched
    function rocsolver_chegv_batched_(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_chegv_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_chegv_batched_full_rank,&
      
rocsolver_chegv_batched_rank_0,&
      
rocsolver_chegv_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zhegv_batched
    function rocsolver_zhegv_batched_(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_zhegv_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegv_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zhegv_batched_full_rank,&
      
rocsolver_zhegv_batched_rank_0,&
      
rocsolver_zhegv_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYGV_STRIDED_BATCHED computes the eigenvalues and (optionally)
  !>     eigenvectors of a batch of real generalized symmetric-definite eigenproblems.
  !> 
  !>     \details
  !>     For each instance in the batch, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l X_l = \lambda B_l X_l & \: \text{1st form,}\\
  !>         A_l B_l X_l = \lambda X_l & \: \text{2nd form, or}\\
  !>         B_l A_l X_l = \lambda X_l & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype. The eigenvectors are computed depending on the
  !>     value of evect.
  !> 
  !>     When computed, the matrix \f$Z_l\f$ of eigenvectors is normalized as follows:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Z_l^T B_l^{} Z_l^{}=I & \: \text{if 1st or 2nd form, or}\\
  !>         Z_l^T B_l^{-1} Z_l^{}=I & \: \text{if 3rd form.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblems.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower parts of the matrices
  !>                 A_l and B_l are stored. If uplo indicates lower (or upper),
  !>                 then the upper (or lower) parts of A_l and B_l are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the symmetric matrices A_l. On exit, if evect is original,
  !>                 the normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular
  !>                 part of the matrices A_l (including the diagonal) are destroyed,
  !>                 depending on the value of uplo.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use is strideA >= ldan.
  !>     @param[out]
  !>     B           pointer to type. Array on the GPU (the size depends on the value of strideB).
  !>                 On entry, the symmetric positive definite matrices B_l. On exit, the
  !>                 triangular factor of B_l as returned by \ref rocsolver_spotrf_strided_batched "POTRF_STRIDED_BATCHED".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B_l.
  !>     @param[in]
  !>     strideB     rocblas_stride.
  !>                 Stride from the start of one matrix B_l to the next one B_(l+1).
  !>                 There is no restriction for the value of strideB. Normal use is strideB >= ldbn.
  !>     @param[out]
  !>     D           pointer to type. Array on the GPU (the size depends on the value of strideD).
  !>                 On exit, the eigenvalues in increasing order.
  !>     @param[in]
  !>     strideD     rocblas_stride.
  !>                 Stride from the start of one vector D_l to the next one D_(l+1).
  !>                 There is no restriction for the value of strideD. Normal use is strideD >= n.
  !>     @param[out]
  !>     E           pointer to type. Array on the GPU (the size depends on the value of strideE).
  !>                 This array is used to work internally with the tridiagonal matrix T_l associated with
  !>                 the l-th reduced eigenvalue problem.
  !>                 On exit, if 0 < info[l] <= n, it contains the unconverged off-diagonal elements of T_l
  !>                 (or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements
  !>                 of this matrix are in D_l; those that converged correspond to a subset of the
  !>                 eigenvalues (not necessarily ordered).
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use is strideE >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit of batch j.
  !>                 If info[l] = i <= n, i off-diagonal elements of an intermediate
  !>                 tridiagonal form did not converge to zero.
  !>                 If info[l] = n + i, the leading minor of order i of B_l is not
  !>                 positive definite.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_ssygv_strided_batched
    function rocsolver_ssygv_strided_batched_(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_ssygv_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssygv_strided_batched_full_rank,&
      
rocsolver_ssygv_strided_batched_rank_0,&
      
rocsolver_ssygv_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dsygv_strided_batched
    function rocsolver_dsygv_strided_batched_(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_dsygv_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsygv_strided_batched_full_rank,&
      
rocsolver_dsygv_strided_batched_rank_0,&
      
rocsolver_dsygv_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEGV_STRIDED_BATCHED computes the eigenvalues and (optionally)
  !>     eigenvectors of a batch of complex generalized hermitian-definite eigenproblems.
  !> 
  !>     \details
  !>     For each instance in the batch, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l X_l = \lambda B_l X_l & \: \text{1st form,}\\
  !>         A_l B_l X_l = \lambda X_l & \: \text{2nd form, or}\\
  !>         B_l A_l X_l = \lambda X_l & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype. The eigenvectors are computed depending on the
  !>     value of evect.
  !> 
  !>     When computed, the matrix \f$Z_l\f$ of eigenvectors is normalized as follows:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Z_l^H B_l^{} Z_l^{}=I & \: \text{if 1st or 2nd form, or}\\
  !>         Z_l^H B_l^{-1} Z_l^{}=I & \: \text{if 3rd form.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblems.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower parts of the matrices
  !>                 A_l and B_l are stored. If uplo indicates lower (or upper),
  !>                 then the upper (or lower) parts of A_l and B_l are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the hermitian matrices A_l. On exit, if evect is original,
  !>                 the normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular
  !>                 part of the matrices A_l (including the diagonal) are destroyed,
  !>                 depending on the value of uplo.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use is strideA >= ldan.
  !>     @param[out]
  !>     B           pointer to type. Array on the GPU (the size depends on the value of strideB).
  !>                 On entry, the hermitian positive definite matrices B_l. On exit, the
  !>                 triangular factor of B_l as returned by \ref rocsolver_spotrf_strided_batched "POTRF_STRIDED_BATCHED".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B_l.
  !>     @param[in]
  !>     strideB     rocblas_stride.
  !>                 Stride from the start of one matrix B_l to the next one B_(l+1).
  !>                 There is no restriction for the value of strideB. Normal use is strideB >= ldbn.
  !>     @param[out]
  !>     D           pointer to real type. Array on the GPU (the size depends on the value of strideD).
  !>                 On exit, the eigenvalues in increasing order.
  !>     @param[in]
  !>     strideD     rocblas_stride.
  !>                 Stride from the start of one vector D_l to the next one D_(l+1).
  !>                 There is no restriction for the value of strideD. Normal use is strideD >= n.
  !>     @param[out]
  !>     E           pointer to real type. Array on the GPU (the size depends on the value of strideE).
  !>                 This array is used to work internally with the tridiagonal matrix T_l associated with
  !>                 the l-th reduced eigenvalue problem.
  !>                 On exit, if 0 < info[l] <= n, it contains the unconverged off-diagonal elements of T_l
  !>                 (or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements
  !>                 of this matrix are in D_l; those that converged correspond to a subset of the
  !>                 eigenvalues (not necessarily ordered).
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use is strideE >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit of batch l.
  !>                 If info[l] = i <= n, i off-diagonal elements of an intermediate
  !>                 tridiagonal form did not converge to zero.
  !>                 If info[l] = n + i, the leading minor of order i of B_l is not
  !>                 positive definite.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_chegv_strided_batched
    function rocsolver_chegv_strided_batched_(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_chegv_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_chegv_strided_batched_full_rank,&
      
rocsolver_chegv_strided_batched_rank_0,&
      
rocsolver_chegv_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zhegv_strided_batched
    function rocsolver_zhegv_strided_batched_(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_zhegv_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegv_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zhegv_strided_batched_full_rank,&
      
rocsolver_zhegv_strided_batched_rank_0,&
      
rocsolver_zhegv_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYGVD computes the eigenvalues and (optionally) eigenvectors of
  !>     a real generalized symmetric-definite eigenproblem.
  !> 
  !>     \details
  !>     The problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A X = \lambda B X & \: \text{1st form,}\\
  !>         A B X = \lambda X & \: \text{2nd form, or}\\
  !>         B A X = \lambda X & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype. The eigenvectors are computed using a divide-and-conquer algorithm, depending on the
  !>     value of evect.
  !> 
  !>     When computed, the matrix Z of eigenvectors is normalized as follows:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Z^T B Z=I & \: \text{if 1st or 2nd form, or}\\
  !>         Z^T B^{-1} Z=I & \: \text{if 3rd form.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblem.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower parts of the matrices
  !>                 A and B are stored. If uplo indicates lower (or upper),
  !>                 then the upper (or lower) parts of A and B are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the symmetric matrix A. On exit, if evect is original,
  !>                 the normalized matrix Z of eigenvectors. If evect is none, then the upper or lower triangular
  !>                 part of the matrix A (including the diagonal) is destroyed,
  !>                 depending on the value of uplo.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     B           pointer to type. Array on the GPU of dimension ldbn.
  !>                 On entry, the symmetric positive definite matrix B. On exit, the
  !>                 triangular factor of B as returned by \ref rocsolver_spotrf "POTRF".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B.
  !>     @param[out]
  !>     D           pointer to type. Array on the GPU of dimension n.
  !>                 On exit, the eigenvalues in increasing order.
  !>     @param[out]
  !>     E           pointer to type. Array on the GPU of dimension n.
  !>                 This array is used to work internally with the tridiagonal matrix T associated with
  !>                 the reduced eigenvalue problem.
  !>                 On exit, if 0 < info <= n, it contains the unconverged off-diagonal elements of T
  !>                 (or properly speaking, a tridiagonal matrix equivalent to T). The diagonal elements
  !>                 of this matrix are in D; those that converged correspond to a subset of the
  !>                 eigenvalues (not necessarily ordered).
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i <= n and evect is rocblas_evect_none, i off-diagonal elements of an
  !>                 intermediate tridiagonal form did not converge to zero.
  !>                 If info = i <= n and evect is rocblas_evect_original, the algorithm failed to
  !>                 compute an eigenvalue in the submatrix from [i(n+1), i(n+1)] to [i%(n+1), i%(n+1)].
  !>                 If info = n + i, the leading minor of order i of B is not
  !>                 positive definite.
  !>     
  interface rocsolver_ssygvd
    function rocsolver_ssygvd_(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo) bind(c, name="rocsolver_ssygvd")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvd_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssygvd_full_rank,&
      
rocsolver_ssygvd_rank_0,&
      
rocsolver_ssygvd_rank_1
#endif

  end interface
  
  interface rocsolver_dsygvd
    function rocsolver_dsygvd_(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo) bind(c, name="rocsolver_dsygvd")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvd_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsygvd_full_rank,&
      
rocsolver_dsygvd_rank_0,&
      
rocsolver_dsygvd_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEGVD computes the eigenvalues and (optionally) eigenvectors of
  !>     a complex generalized hermitian-definite eigenproblem.
  !> 
  !>     \details
  !>     The problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A X = \lambda B X & \: \text{1st form,}\\
  !>         A B X = \lambda X & \: \text{2nd form, or}\\
  !>         B A X = \lambda X & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype. The eigenvectors are computed using a divide-and-conquer algorithm, depending on the
  !>     value of evect.
  !> 
  !>     When computed, the matrix Z of eigenvectors is normalized as follows:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Z^H B Z=I & \: \text{if 1st or 2nd form, or}\\
  !>         Z^H B^{-1} Z=I & \: \text{if 3rd form.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblem.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower parts of the matrices
  !>                 A and B are stored. If uplo indicates lower (or upper),
  !>                 then the upper (or lower) parts of A and B are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the hermitian matrix A. On exit, if evect is original,
  !>                 the normalized matrix Z of eigenvectors. If evect is none, then the upper or lower triangular
  !>                 part of the matrix A (including the diagonal) is destroyed,
  !>                 depending on the value of uplo.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     B           pointer to type. Array on the GPU of dimension ldbn.
  !>                 On entry, the hermitian positive definite matrix B. On exit, the
  !>                 triangular factor of B as returned by \ref rocsolver_spotrf "POTRF".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B.
  !>     @param[out]
  !>     D           pointer to real type. Array on the GPU of dimension n.
  !>                 On exit, the eigenvalues in increasing order.
  !>     @param[out]
  !>     E           pointer to real type. Array on the GPU of dimension n.
  !>                 This array is used to work internally with the tridiagonal matrix T associated with
  !>                 the reduced eigenvalue problem.
  !>                 On exit, if 0 < info <= n, it contains the unconverged off-diagonal elements of T
  !>                 (or properly speaking, a tridiagonal matrix equivalent to T). The diagonal elements
  !>                 of this matrix are in D; those that converged correspond to a subset of the
  !>                 eigenvalues (not necessarily ordered).
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i <= n and evect is rocblas_evect_none, i off-diagonal elements of an
  !>                 intermediate tridiagonal form did not converge to zero.
  !>                 If info = i <= n and evect is rocblas_evect_original, the algorithm failed to
  !>                 compute an eigenvalue in the submatrix from [i(n+1), i(n+1)] to [i%(n+1), i%(n+1)].
  !>                 If info = n + i, the leading minor of order i of B is not
  !>                 positive definite.
  !>     
  interface rocsolver_chegvd
    function rocsolver_chegvd_(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo) bind(c, name="rocsolver_chegvd")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvd_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_chegvd_full_rank,&
      
rocsolver_chegvd_rank_0,&
      
rocsolver_chegvd_rank_1
#endif

  end interface
  
  interface rocsolver_zhegvd
    function rocsolver_zhegvd_(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo) bind(c, name="rocsolver_zhegvd")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvd_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: D
      type(c_ptr),value :: E
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zhegvd_full_rank,&
      
rocsolver_zhegvd_rank_0,&
      
rocsolver_zhegvd_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYGVD_BATCHED computes the eigenvalues and (optionally)
  !>     eigenvectors of a batch of real generalized symmetric-definite eigenproblems.
  !> 
  !>     \details
  !>     For each instance in the batch, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l X_l = \lambda B_l X_l & \: \text{1st form,}\\
  !>         A_l B_l X_l = \lambda X_l & \: \text{2nd form, or}\\
  !>         B_l A_l X_l = \lambda X_l & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype. The eigenvectors are computed using a divide-and-conquer algorithm, depending on the
  !>     value of evect.
  !> 
  !>     When computed, the matrix \f$Z_l\f$ of eigenvectors is normalized as follows:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Z_l^T B_l^{} Z_l^{}=I & \: \text{if 1st or 2nd form, or}\\
  !>         Z_l^T B_l^{-1} Z_l^{}=I & \: \text{if 3rd form.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblems.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower parts of the matrices
  !>                 A_l and B_l are stored. If uplo indicates lower (or upper),
  !>                 then the upper (or lower) parts of A_l and B_l are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the symmetric matrices A_l. On exit, if evect is original,
  !>                 the normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular
  !>                 part of the matrices A_l (including the diagonal) are destroyed,
  !>                 depending on the value of uplo.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A_l.
  !>     @param[out]
  !>     B           array of pointers to type. Each pointer points to an array on the GPU of dimension ldbn.
  !>                 On entry, the symmetric positive definite matrices B_l. On exit, the
  !>                 triangular factor of B_l as returned by \ref rocsolver_spotrf_batched "POTRF_BATCHED".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B_l.
  !>     @param[out]
  !>     D           pointer to type. Array on the GPU (the size depends on the value of strideD).
  !>                 On exit, the eigenvalues in increasing order.
  !>     @param[in]
  !>     strideD     rocblas_stride.
  !>                 Stride from the start of one vector D_l to the next one D_(l+1).
  !>                 There is no restriction for the value of strideD. Normal use is strideD >= n.
  !>     @param[out]
  !>     E           pointer to type. Array on the GPU (the size depends on the value of strideE).
  !>                 This array is used to work internally with the tridiagonal matrix T_l associated with
  !>                 the l-th reduced eigenvalue problem.
  !>                 On exit, if 0 < info[l] <= n, it contains the unconverged off-diagonal elements of T_l
  !>                 (or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements
  !>                 of this matrix are in D_l; those that converged correspond to a subset of the
  !>                 eigenvalues (not necessarily ordered).
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use is strideE >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit of batch l.
  !>                 If info[l] = i <= n and evect is rocblas_evect_none, i off-diagonal elements of an
  !>                 intermediate tridiagonal form did not converge to zero.
  !>                 If info[l] = i <= n and evect is rocblas_evect_original, the algorithm failed to
  !>                 compute an eigenvalue in the submatrix from [i(n+1), i(n+1)] to [i%(n+1), i%(n+1)].
  !>                 If info[l] = n + i, the leading minor of order i of B_l is not
  !>                 positive definite.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_ssygvd_batched
    function rocsolver_ssygvd_batched_(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_ssygvd_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvd_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssygvd_batched_full_rank,&
      
rocsolver_ssygvd_batched_rank_0,&
      
rocsolver_ssygvd_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dsygvd_batched
    function rocsolver_dsygvd_batched_(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_dsygvd_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvd_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsygvd_batched_full_rank,&
      
rocsolver_dsygvd_batched_rank_0,&
      
rocsolver_dsygvd_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEGVD_BATCHED computes the eigenvalues and (optionally)
  !>     eigenvectors of a batch of complex generalized hermitian-definite eigenproblems.
  !> 
  !>     \details
  !>     For each instance in the batch, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l X_l = \lambda B_l X_l & \: \text{1st form,}\\
  !>         A_l B_l X_l = \lambda X_l & \: \text{2nd form, or}\\
  !>         B_l A_l X_l = \lambda X_l & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype. The eigenvectors are computed using a divide-and-conquer algorithm, depending on the
  !>     value of evect.
  !> 
  !>     When computed, the matrix \f$Z_l\f$ of eigenvectors is normalized as follows:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Z_l^H B_l^{} Z_l^{}=I & \: \text{if 1st or 2nd form, or}\\
  !>         Z_l^H B_l^{-1} Z_l^{}=I & \: \text{if 3rd form.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblems.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower parts of the matrices
  !>                 A_l and B_l are stored. If uplo indicates lower (or upper),
  !>                 then the upper (or lower) parts of A_l and B_l are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the hermitian matrices A_l. On exit, if evect is original,
  !>                 the normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular
  !>                 part of the matrices A_l (including the diagonal) are destroyed,
  !>                 depending on the value of uplo.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A_l.
  !>     @param[out]
  !>     B           array of pointers to type. Each pointer points to an array on the GPU of dimension ldbn.
  !>                 On entry, the hermitian positive definite matrices B_l. On exit, the
  !>                 triangular factor of B_l as returned by \ref rocsolver_spotrf_batched "POTRF_BATCHED".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B_l.
  !>     @param[out]
  !>     D           pointer to real type. Array on the GPU (the size depends on the value of strideD).
  !>                 On exit, the eigenvalues in increasing order.
  !>     @param[in]
  !>     strideD     rocblas_stride.
  !>                 Stride from the start of one vector D_l to the next one D_(l+1).
  !>                 There is no restriction for the value of strideD. Normal use is strideD >= n.
  !>     @param[out]
  !>     E           pointer to real type. Array on the GPU (the size depends on the value of strideE).
  !>                 This array is used to work internally with the tridiagonal matrix T_l associated with
  !>                 the l-th reduced eigenvalue problem.
  !>                 On exit, if 0 < info[l] <= n, it contains the unconverged off-diagonal elements of T_l
  !>                 (or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements
  !>                 of this matrix are in D_l; those that converged correspond to a subset of the
  !>                 eigenvalues (not necessarily ordered).
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use is strideE >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit of batch l.
  !>                 If info[l] = i <= n and evect is rocblas_evect_none, i off-diagonal elements of an
  !>                 intermediate tridiagonal form did not converge to zero.
  !>                 If info[l] = i <= n and evect is rocblas_evect_original, the algorithm failed to
  !>                 compute an eigenvalue in the submatrix from [i(n+1), i(n+1)] to [i%(n+1), i%(n+1)].
  !>                 If info[l] = n + i, the leading minor of order i of B_l is not
  !>                 positive definite.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_chegvd_batched
    function rocsolver_chegvd_batched_(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_chegvd_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvd_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_chegvd_batched_full_rank,&
      
rocsolver_chegvd_batched_rank_0,&
      
rocsolver_chegvd_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zhegvd_batched
    function rocsolver_zhegvd_batched_(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_zhegvd_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvd_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zhegvd_batched_full_rank,&
      
rocsolver_zhegvd_batched_rank_0,&
      
rocsolver_zhegvd_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYGVD_STRIDED_BATCHED computes the eigenvalues and (optionally)
  !>     eigenvectors of a batch of real generalized symmetric-definite eigenproblems.
  !> 
  !>     \details
  !>     For each instance in the batch, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l X_l = \lambda B_l X_l & \: \text{1st form,}\\
  !>         A_l B_l X_l = \lambda X_l & \: \text{2nd form, or}\\
  !>         B_l A_l X_l = \lambda X_l & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype. The eigenvectors are computed using a divide-and-conquer algorithm, depending on the
  !>     value of evect.
  !> 
  !>     When computed, the matrix \f$Z_l\f$ of eigenvectors is normalized as follows:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Z_l^T B_l^{} Z_l^{}=I & \: \text{if 1st or 2nd form, or}\\
  !>         Z_l^T B_l^{-1} Z_l^{}=I & \: \text{if 3rd form.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblems.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower parts of the matrices
  !>                 A_l and B_l are stored. If uplo indicates lower (or upper),
  !>                 then the upper (or lower) parts of A_l and B_l are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the symmetric matrices A_l. On exit, if evect is original,
  !>                 the normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular
  !>                 part of the matrices A_l (including the diagonal) are destroyed,
  !>                 depending on the value of uplo.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use is strideA >= ldan.
  !>     @param[out]
  !>     B           pointer to type. Array on the GPU (the size depends on the value of strideB).
  !>                 On entry, the symmetric positive definite matrices B_l. On exit, the
  !>                 triangular factor of B_l as returned by \ref rocsolver_spotrf_strided_batched "POTRF_STRIDED_BATCHED".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B_l.
  !>     @param[in]
  !>     strideB     rocblas_stride.
  !>                 Stride from the start of one matrix B_l to the next one B_(l+1).
  !>                 There is no restriction for the value of strideB. Normal use is strideB >= ldbn.
  !>     @param[out]
  !>     D           pointer to type. Array on the GPU (the size depends on the value of strideD).
  !>                 On exit, the eigenvalues in increasing order.
  !>     @param[in]
  !>     strideD     rocblas_stride.
  !>                 Stride from the start of one vector D_l to the next one D_(l+1).
  !>                 There is no restriction for the value of strideD. Normal use is strideD >= n.
  !>     @param[out]
  !>     E           pointer to type. Array on the GPU (the size depends on the value of strideE).
  !>                 This array is used to work internally with the tridiagonal matrix T_l associated with
  !>                 the l-th reduced eigenvalue problem.
  !>                 On exit, if 0 < info[l] <= n, it contains the unconverged off-diagonal elements of T_l
  !>                 (or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements
  !>                 of this matrix are in D_l; those that converged correspond to a subset of the
  !>                 eigenvalues (not necessarily ordered).
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use is strideE >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit of batch l.
  !>                 If info[l] = i <= n and evect is rocblas_evect_none, i off-diagonal elements of an
  !>                 intermediate tridiagonal form did not converge to zero.
  !>                 If info[l] = i <= n and evect is rocblas_evect_original, the algorithm failed to
  !>                 compute an eigenvalue in the submatrix from [i(n+1), i(n+1)] to [i%(n+1), i%(n+1)].
  !>                 If info[l] = n + i, the leading minor of order i of B_l is not
  !>                 positive definite.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_ssygvd_strided_batched
    function rocsolver_ssygvd_strided_batched_(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_ssygvd_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvd_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssygvd_strided_batched_full_rank,&
      
rocsolver_ssygvd_strided_batched_rank_0,&
      
rocsolver_ssygvd_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dsygvd_strided_batched
    function rocsolver_dsygvd_strided_batched_(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_dsygvd_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvd_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsygvd_strided_batched_full_rank,&
      
rocsolver_dsygvd_strided_batched_rank_0,&
      
rocsolver_dsygvd_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEGVD_STRIDED_BATCHED computes the eigenvalues and (optionally)
  !>     eigenvectors of a batch of complex generalized hermitian-definite eigenproblems.
  !> 
  !>     \details
  !>     For each instance in the batch, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l X_l = \lambda B_l X_l & \: \text{1st form,}\\
  !>         A_l B_l X_l = \lambda X_l & \: \text{2nd form, or}\\
  !>         B_l A_l X_l = \lambda X_l & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype. The eigenvectors are computed using a divide-and-conquer algorithm, depending on the
  !>     value of evect.
  !> 
  !>     When computed, the matrix \f$Z_l\f$ of eigenvectors is normalized as follows:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Z_l^H B_l^{} Z_l^{}=I & \: \text{if 1st or 2nd form, or}\\
  !>         Z_l^H B_l^{-1} Z_l^{}=I & \: \text{if 3rd form.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblems.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower parts of the matrices
  !>                 A_l and B_l are stored. If uplo indicates lower (or upper),
  !>                 then the upper (or lower) parts of A_l and B_l are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the hermitian matrices A_l. On exit, if evect is original,
  !>                 the normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular
  !>                 part of the matrices A_l (including the diagonal) are destroyed,
  !>                 depending on the value of uplo.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use is strideA >= ldan.
  !>     @param[out]
  !>     B           pointer to type. Array on the GPU (the size depends on the value of strideB).
  !>                 On entry, the hermitian positive definite matrices B_l. On exit, the
  !>                 triangular factor of B_l as returned by \ref rocsolver_spotrf_strided_batched "POTRF_STRIDED_BATCHED".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B_l.
  !>     @param[in]
  !>     strideB     rocblas_stride.
  !>                 Stride from the start of one matrix B_l to the next one B_(l+1).
  !>                 There is no restriction for the value of strideB. Normal use is strideB >= ldbn.
  !>     @param[out]
  !>     D           pointer to real type. Array on the GPU (the size depends on the value of strideD).
  !>                 On exit, the eigenvalues in increasing order.
  !>     @param[in]
  !>     strideD     rocblas_stride.
  !>                 Stride from the start of one vector D_l to the next one D_(l+1).
  !>                 There is no restriction for the value of strideD. Normal use is strideD >= n.
  !>     @param[out]
  !>     E           pointer to real type. Array on the GPU (the size depends on the value of strideE).
  !>                 This array is used to work internally with the tridiagonal matrix T_l associated with
  !>                 the l-th reduced eigenvalue problem.
  !>                 On exit, if 0 < info[l] <= n, it contains the unconverged off-diagonal elements of T_l
  !>                 (or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements
  !>                 of this matrix are in D_l; those that converged correspond to a subset of the
  !>                 eigenvalues (not necessarily ordered).
  !>     @param[in]
  !>     strideE     rocblas_stride.
  !>                 Stride from the start of one vector E_l to the next one E_(l+1).
  !>                 There is no restriction for the value of strideE. Normal use is strideE >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit of batch l.
  !>                 If info[l] = i <= n and evect is rocblas_evect_none, i off-diagonal elements of an
  !>                 intermediate tridiagonal form did not converge to zero.
  !>                 If info[l] = i <= n and evect is rocblas_evect_original, the algorithm failed to
  !>                 compute an eigenvalue in the submatrix from [i(n+1), i(n+1)] to [i%(n+1), i%(n+1)].
  !>                 If info[l] = n + i, the leading minor of order i of B_l is not
  !>                 positive definite.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_chegvd_strided_batched
    function rocsolver_chegvd_strided_batched_(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_chegvd_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvd_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_chegvd_strided_batched_full_rank,&
      
rocsolver_chegvd_strided_batched_rank_0,&
      
rocsolver_chegvd_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zhegvd_strided_batched
    function rocsolver_zhegvd_strided_batched_(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count) bind(c, name="rocsolver_zhegvd_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvd_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: D
      integer(c_int64_t),value :: strideD
      type(c_ptr),value :: E
      integer(c_int64_t),value :: strideE
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zhegvd_strided_batched_full_rank,&
      
rocsolver_zhegvd_strided_batched_rank_0,&
      
rocsolver_zhegvd_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYGVJ computes the eigenvalues and (optionally) eigenvectors of
  !>     a real generalized symmetric-definite eigenproblem.
  !> 
  !>     \details
  !>     The problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A X = \lambda B X & \: \text{1st form,}\\
  !>         A B X = \lambda X & \: \text{2nd form, or}\\
  !>         B A X = \lambda X & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype. The eigenvalues are found using the iterative
  !>     Jacobi algorithm, and are returned in ascending order. The eigenvectors are computed
  !>     depending on the value of evect.
  !> 
  !>     When computed, the matrix Z of eigenvectors is normalized as follows:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Z^T B Z=I & \: \text{if 1st or 2nd form, or}\\
  !>         Z^T B^{-1} Z=I & \: \text{if 3rd form.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblem.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower parts of the matrices
  !>                 A and B are stored. If uplo indicates lower (or upper),
  !>                 then the upper (or lower) parts of A and B are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the symmetric matrix A. On exit, if evect is original,
  !>                 the normalized matrix Z of eigenvectors. If evect is none, then the upper or lower triangular
  !>                 part of the matrix A (including the diagonal) is destroyed,
  !>                 depending on the value of uplo.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     B           pointer to type. Array on the GPU of dimension ldbn.
  !>                 On entry, the symmetric positive definite matrix B. On exit, the
  !>                 triangular factor of B as returned by \ref rocsolver_spotrf "POTRF".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B.
  !>     @param[in]
  !>     abstol      type.
  !>                 The absolute tolerance. The algorithm is considered to have converged once the residual
  !>                 is <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.
  !>     @param[out]
  !>     residual    pointer to type on the GPU.
  !>                 The Frobenius norm of the off-diagonal elements at the final iteration.
  !>     @param[in]
  !>     max_sweeps  rocblas_int. max_sweeps > 0.
  !>                 Maximum number of sweeps (iterations) to be used by the algorithm.
  !>     @param[out]
  !>     n_sweeps    pointer to a rocblas_int on the GPU.
  !>                 The actual number of sweeps (iterations) used by the algorithm.
  !>     @param[out]
  !>     W           pointer to type. Array on the GPU of dimension n.
  !>                 On exit, the eigenvalues in increasing order.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = 1, the algorithm did not converge.
  !>                 If info = n + i, the leading minor of order i of B is not
  !>                 positive definite.
  !>     
  interface rocsolver_ssygvj
    function rocsolver_ssygvj_(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,myInfo) bind(c, name="rocsolver_ssygvj")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvj_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_float),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: W
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssygvj_full_rank,&
      
rocsolver_ssygvj_rank_0,&
      
rocsolver_ssygvj_rank_1
#endif

  end interface
  
  interface rocsolver_dsygvj
    function rocsolver_dsygvj_(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,myInfo) bind(c, name="rocsolver_dsygvj")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvj_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_double),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: W
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsygvj_full_rank,&
      
rocsolver_dsygvj_rank_0,&
      
rocsolver_dsygvj_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEGVJ computes the eigenvalues and (optionally) eigenvectors of
  !>     a complex generalized hermitian-definite eigenproblem.
  !> 
  !>     \details
  !>     The problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A X = \lambda B X & \: \text{1st form,}\\
  !>         A B X = \lambda X & \: \text{2nd form, or}\\
  !>         B A X = \lambda X & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype. The eigenvalues are found using the iterative
  !>     Jacobi algorithm, and are returned in ascending order. The eigenvectors are computed
  !>     depending on the value of evect.
  !> 
  !>     When computed, the matrix Z of eigenvectors is normalized as follows:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Z^H B Z=I & \: \text{if 1st or 2nd form, or}\\
  !>         Z^H B^{-1} Z=I & \: \text{if 3rd form.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblem.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower parts of the matrices
  !>                 A and B are stored. If uplo indicates lower (or upper),
  !>                 then the upper (or lower) parts of A and B are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the hermitian matrix A. On exit, if evect is original,
  !>                 the normalized matrix Z of eigenvectors. If evect is none, then the upper or lower triangular
  !>                 part of the matrix A (including the diagonal) is destroyed,
  !>                 depending on the value of uplo.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     B           pointer to type. Array on the GPU of dimension ldbn.
  !>                 On entry, the hermitian positive definite matrix B. On exit, the
  !>                 triangular factor of B as returned by \ref rocsolver_spotrf "POTRF".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B.
  !>     @param[in]
  !>     abstol      real type.
  !>                 The absolute tolerance. The algorithm is considered to have converged once the residual
  !>                 is <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.
  !>     @param[out]
  !>     residual    pointer to real type on the GPU.
  !>                 The Frobenius norm of the off-diagonal elements at the final iteration.
  !>     @param[in]
  !>     max_sweeps  rocblas_int. max_sweeps > 0.
  !>                 Maximum number of sweeps (iterations) to be used by the algorithm.
  !>     @param[out]
  !>     n_sweeps    pointer to a rocblas_int on the GPU.
  !>                 The actual number of sweeps (iterations) used by the algorithm.
  !>     @param[out]
  !>     W           pointer to real type. Array on the GPU of dimension n.
  !>                 On exit, the eigenvalues in increasing order.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = 1, the algorithm did not converge.
  !>                 If info = n + i, the leading minor of order i of B is not
  !>                 positive definite.
  !>     
  interface rocsolver_chegvj
    function rocsolver_chegvj_(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,myInfo) bind(c, name="rocsolver_chegvj")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvj_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_float),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: W
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_chegvj_full_rank,&
      
rocsolver_chegvj_rank_0,&
      
rocsolver_chegvj_rank_1
#endif

  end interface
  
  interface rocsolver_zhegvj
    function rocsolver_zhegvj_(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,myInfo) bind(c, name="rocsolver_zhegvj")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvj_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_double),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: W
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zhegvj_full_rank,&
      
rocsolver_zhegvj_rank_0,&
      
rocsolver_zhegvj_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYGVJ_BATCHED computes the eigenvalues and (optionally)
  !>     eigenvectors of a batch of real generalized symmetric-definite eigenproblems.
  !> 
  !>     \details
  !>     For each instance in the batch, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l X_l = \lambda B_l X_l & \: \text{1st form,}\\
  !>         A_l B_l X_l = \lambda X_l & \: \text{2nd form, or}\\
  !>         B_l A_l X_l = \lambda X_l & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype. The eigenvalues are found using the iterative
  !>     Jacobi algorithm, and are returned in ascending order. The eigenvectors are computed
  !>     depending on the value of evect.
  !> 
  !>     When computed, the matrix \f$Z_l\f$ of eigenvectors is normalized as follows:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Z_l^T B_l^{} Z_l^{}=I & \: \text{if 1st or 2nd form, or}\\
  !>         Z_l^T B_l^{-1} Z_l^{}=I & \: \text{if 3rd form.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblems.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower parts of the matrices
  !>                 A_l and B_l are stored. If uplo indicates lower (or upper),
  !>                 then the upper (or lower) parts of A_l and B_l are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the symmetric matrices A_l. On exit, if evect is original,
  !>                 the normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular
  !>                 part of the matrices A_l (including the diagonal) are destroyed,
  !>                 depending on the value of uplo.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A_l.
  !>     @param[out]
  !>     B           array of pointers to type. Each pointer points to an array on the GPU of dimension ldbn.
  !>                 On entry, the symmetric positive definite matrices B_l. On exit, the
  !>                 triangular factor of B_l as returned by \ref rocsolver_spotrf_batched "POTRF_BATCHED".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B_l.
  !>     @param[in]
  !>     abstol      type.
  !>                 The absolute tolerance. The algorithm is considered to have converged once the residual
  !>                 is <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.
  !>     @param[out]
  !>     residual    pointer to type. Array of batch_count scalars on the GPU.
  !>                 The Frobenius norm of the off-diagonal elements at the final iteration for each batch instance.
  !>     @param[in]
  !>     max_sweeps  rocblas_int. max_sweeps > 0.
  !>                 Maximum number of sweeps (iterations) to be used by the algorithm.
  !>     @param[out]
  !>     n_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 The actual number of sweeps (iterations) used by the algorithm for each batch instance.
  !>     @param[out]
  !>     W           pointer to type. Array on the GPU (the size depends on the value of strideW).
  !>                 On exit, the eigenvalues in increasing order.
  !>     @param[in]
  !>     strideW     rocblas_stride.
  !>                 Stride from the start of one vector W_l to the next one W_(l+1).
  !>                 There is no restriction for the value of strideW. Normal use is strideW >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit of batch instance l.
  !>                 If info[l] = 1, the algorithm did not converge.
  !>                 If info[l] = n + i, the leading minor of order i of B_l is not
  !>                 positive definite.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_ssygvj_batched
    function rocsolver_ssygvj_batched_(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count) bind(c, name="rocsolver_ssygvj_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvj_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_float),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssygvj_batched_full_rank,&
      
rocsolver_ssygvj_batched_rank_0,&
      
rocsolver_ssygvj_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dsygvj_batched
    function rocsolver_dsygvj_batched_(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count) bind(c, name="rocsolver_dsygvj_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvj_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_double),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsygvj_batched_full_rank,&
      
rocsolver_dsygvj_batched_rank_0,&
      
rocsolver_dsygvj_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEGVJ_BATCHED computes the eigenvalues and (optionally)
  !>     eigenvectors of a batch of complex generalized hermitian-definite eigenproblems.
  !> 
  !>     \details
  !>     For each instance in the batch, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l X_l = \lambda B_l X_l & \: \text{1st form,}\\
  !>         A_l B_l X_l = \lambda X_l & \: \text{2nd form, or}\\
  !>         B_l A_l X_l = \lambda X_l & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype. The eigenvalues are found using the iterative
  !>     Jacobi algorithm, and are returned in ascending order. The eigenvectors are computed
  !>     depending on the value of evect.
  !> 
  !>     When computed, the matrix \f$Z_l\f$ of eigenvectors is normalized as follows:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Z_l^H B_l^{} Z_l^{}=I & \: \text{if 1st or 2nd form, or}\\
  !>         Z_l^H B_l^{-1} Z_l^{}=I & \: \text{if 3rd form.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblems.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower parts of the matrices
  !>                 A_l and B_l are stored. If uplo indicates lower (or upper),
  !>                 then the upper (or lower) parts of A_l and B_l are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the hermitian matrices A_l. On exit, if evect is original,
  !>                 the normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular
  !>                 part of the matrices A_l (including the diagonal) are destroyed,
  !>                 depending on the value of uplo.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A_l.
  !>     @param[out]
  !>     B           array of pointers to type. Each pointer points to an array on the GPU of dimension ldbn.
  !>                 On entry, the hermitian positive definite matrices B_l. On exit, the
  !>                 triangular factor of B_l as returned by \ref rocsolver_spotrf_batched "POTRF_BATCHED".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B_l.
  !>     @param[in]
  !>     abstol      real type.
  !>                 The absolute tolerance. The algorithm is considered to have converged once the residual
  !>                 is <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.
  !>     @param[out]
  !>     residual    pointer to real type. Array of batch_count scalars on the GPU.
  !>                 The Frobenius norm of the off-diagonal elements at the final iteration for each batch instance.
  !>     @param[in]
  !>     max_sweeps  rocblas_int. max_sweeps > 0.
  !>                 Maximum number of sweeps (iterations) to be used by the algorithm.
  !>     @param[out]
  !>     n_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 The actual number of sweeps (iterations) used by the algorithm for each batch instance.
  !>     @param[out]
  !>     W           pointer to real type. Array on the GPU (the size depends on the value of strideW).
  !>                 On exit, the eigenvalues in increasing order.
  !>     @param[in]
  !>     strideW     rocblas_stride.
  !>                 Stride from the start of one vector W_l to the next one W_(l+1).
  !>                 There is no restriction for the value of strideW. Normal use is strideW >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit of batch l.
  !>                 If info[l] = 1, the algorithm did not converge.
  !>                 If info[l] = n + i, the leading minor of order i of B_l is not
  !>                 positive definite.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_chegvj_batched
    function rocsolver_chegvj_batched_(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count) bind(c, name="rocsolver_chegvj_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvj_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_float),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_chegvj_batched_full_rank,&
      
rocsolver_chegvj_batched_rank_0,&
      
rocsolver_chegvj_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zhegvj_batched
    function rocsolver_zhegvj_batched_(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count) bind(c, name="rocsolver_zhegvj_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvj_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_double),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zhegvj_batched_full_rank,&
      
rocsolver_zhegvj_batched_rank_0,&
      
rocsolver_zhegvj_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYGVJ_STRIDED_BATCHED computes the eigenvalues and (optionally)
  !>     eigenvectors of a batch of real generalized symmetric-definite eigenproblems.
  !> 
  !>     \details
  !>     For each instance in the batch, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l X_l = \lambda B_l X_l & \: \text{1st form,}\\
  !>         A_l B_l X_l = \lambda X_l & \: \text{2nd form, or}\\
  !>         B_l A_l X_l = \lambda X_l & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype. The eigenvalues are found using the iterative
  !>     Jacobi algorithm, and are returned in ascending order. The eigenvectors are computed
  !>     depending on the value of evect.
  !> 
  !>     When computed, the matrix \f$Z_l\f$ of eigenvectors is normalized as follows:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Z_l^T B_l^{} Z_l^{}=I & \: \text{if 1st or 2nd form, or}\\
  !>         Z_l^T B_l^{-1} Z_l^{}=I & \: \text{if 3rd form.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblems.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower parts of the matrices
  !>                 A_l and B_l are stored. If uplo indicates lower (or upper),
  !>                 then the upper (or lower) parts of A_l and B_l are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the symmetric matrices A_l. On exit, if evect is original,
  !>                 the normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular
  !>                 part of the matrices A_l (including the diagonal) are destroyed,
  !>                 depending on the value of uplo.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use is strideA >= ldan.
  !>     @param[out]
  !>     B           pointer to type. Array on the GPU (the size depends on the value of strideB).
  !>                 On entry, the symmetric positive definite matrices B_l. On exit, the
  !>                 triangular factor of B_l as returned by \ref rocsolver_spotrf_strided_batched "POTRF_STRIDED_BATCHED".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B_l.
  !>     @param[in]
  !>     strideB     rocblas_stride.
  !>                 Stride from the start of one matrix B_l to the next one B_(l+1).
  !>                 There is no restriction for the value of strideB. Normal use is strideB >= ldbn.
  !>     @param[in]
  !>     abstol      type.
  !>                 The absolute tolerance. The algorithm is considered to have converged once the residual
  !>                 is <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.
  !>     @param[out]
  !>     residual    pointer to type. Array of batch_count scalars on the GPU.
  !>                 The Frobenius norm of the off-diagonal elements at the final iteration for each batch instance.
  !>     @param[in]
  !>     max_sweeps  rocblas_int. max_sweeps > 0.
  !>                 Maximum number of sweeps (iterations) to be used by the algorithm.
  !>     @param[out]
  !>     n_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 The actual number of sweeps (iterations) used by the algorithm for each batch instance.
  !>     @param[out]
  !>     W           pointer to type. Array on the GPU (the size depends on the value of strideW).
  !>                 On exit, the eigenvalues in increasing order.
  !>     @param[in]
  !>     strideW     rocblas_stride.
  !>                 Stride from the start of one vector W_l to the next one W_(l+1).
  !>                 There is no restriction for the value of strideW. Normal use is strideW >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit of batch l.
  !>                 If info[l] = 1, the algorithm did not converge.
  !>                 If info[l] = n + i, the leading minor of order i of B_l is not
  !>                 positive definite.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_ssygvj_strided_batched
    function rocsolver_ssygvj_strided_batched_(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count) bind(c, name="rocsolver_ssygvj_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvj_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_float),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssygvj_strided_batched_full_rank,&
      
rocsolver_ssygvj_strided_batched_rank_0,&
      
rocsolver_ssygvj_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dsygvj_strided_batched
    function rocsolver_dsygvj_strided_batched_(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count) bind(c, name="rocsolver_dsygvj_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvj_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_double),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsygvj_strided_batched_full_rank,&
      
rocsolver_dsygvj_strided_batched_rank_0,&
      
rocsolver_dsygvj_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEGVJ_STRIDED_BATCHED computes the eigenvalues and (optionally)
  !>     eigenvectors of a batch of complex generalized hermitian-definite eigenproblems.
  !> 
  !>     \details
  !>     For each instance in the batch, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l X_l = \lambda B_l X_l & \: \text{1st form,}\\
  !>         A_l B_l X_l = \lambda X_l & \: \text{2nd form, or}\\
  !>         B_l A_l X_l = \lambda X_l & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype. The eigenvalues are found using the iterative
  !>     Jacobi algorithm, and are returned in ascending order. The eigenvectors are computed
  !>     depending on the value of evect.
  !> 
  !>     When computed, the matrix \f$Z_l\f$ of eigenvectors is normalized as follows:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Z_l^H B_l^{} Z_l^{}=I & \: \text{if 1st or 2nd form, or}\\
  !>         Z_l^H B_l^{-1} Z_l^{}=I & \: \text{if 3rd form.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblems.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower parts of the matrices
  !>                 A_l and B_l are stored. If uplo indicates lower (or upper),
  !>                 then the upper (or lower) parts of A_l and B_l are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the hermitian matrices A_l. On exit, if evect is original,
  !>                 the normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular
  !>                 part of the matrices A_l (including the diagonal) are destroyed,
  !>                 depending on the value of uplo.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use is strideA >= ldan.
  !>     @param[out]
  !>     B           pointer to type. Array on the GPU (the size depends on the value of strideB).
  !>                 On entry, the hermitian positive definite matrices B_l. On exit, the
  !>                 triangular factor of B_l as returned by \ref rocsolver_spotrf_strided_batched "POTRF_STRIDED_BATCHED".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B_l.
  !>     @param[in]
  !>     strideB     rocblas_stride.
  !>                 Stride from the start of one matrix B_l to the next one B_(l+1).
  !>                 There is no restriction for the value of strideB. Normal use is strideB >= ldbn.
  !>     @param[in]
  !>     abstol      real type.
  !>                 The absolute tolerance. The algorithm is considered to have converged once the residual
  !>                 is <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.
  !>     @param[out]
  !>     residual    pointer to real type. Array of batch_count scalars on the GPU.
  !>                 The Frobenius norm of the off-diagonal elements at the final iteration for each batch instance.
  !>     @param[in]
  !>     max_sweeps  rocblas_int. max_sweeps > 0.
  !>                 Maximum number of sweeps (iterations) to be used by the algorithm.
  !>     @param[out]
  !>     n_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 The actual number of sweeps (iterations) used by the algorithm for each batch instance.
  !>     @param[out]
  !>     W           pointer to real type. Array on the GPU (the size depends on the value of strideW).
  !>                 On exit, the eigenvalues in increasing order.
  !>     @param[in]
  !>     strideW     rocblas_stride.
  !>                 Stride from the start of one vector W_l to the next one W_(l+1).
  !>                 There is no restriction for the value of strideW. Normal use is strideW >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit of batch l.
  !>                 If info[l] = 1, the algorithm did not converge.
  !>                 If info[l] = n + i, the leading minor of order i of B_l is not
  !>                 positive definite.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_chegvj_strided_batched
    function rocsolver_chegvj_strided_batched_(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count) bind(c, name="rocsolver_chegvj_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvj_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_float),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_chegvj_strided_batched_full_rank,&
      
rocsolver_chegvj_strided_batched_rank_0,&
      
rocsolver_chegvj_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zhegvj_strided_batched
    function rocsolver_zhegvj_strided_batched_(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count) bind(c, name="rocsolver_zhegvj_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvj_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_double),value :: abstol
      type(c_ptr),value :: residual
      integer(c_int),value :: max_sweeps
      type(c_ptr),value :: n_sweeps
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zhegvj_strided_batched_full_rank,&
      
rocsolver_zhegvj_strided_batched_rank_0,&
      
rocsolver_zhegvj_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYGVX computes a set of the eigenvalues and optionally the corresponding eigenvectors of
  !>     a real generalized symmetric-definite eigenproblem.
  !> 
  !>     \details
  !>     The problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A X = \lambda B X & \: \text{1st form,}\\
  !>         A B X = \lambda X & \: \text{2nd form, or}\\
  !>         B A X = \lambda X & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype. The eigenvectors are computed depending on the
  !>     value of evect.
  !> 
  !>     When computed, the matrix Z of eigenvectors is normalized as follows:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Z^T B Z=I & \: \text{if 1st or 2nd form, or}\\
  !>         Z^T B^{-1} Z=I & \: \text{if 3rd form.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     This function computes all the eigenvalues, all the eigenvalues in the half-open interval \f$(vl, vu]\f$,
  !>     or the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,
  !>     the eigenvectors for these eigenvalues will be computed as well.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblem.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     erange      #rocblas_erange.
  !>                 Specifies the type of range or interval of the eigenvalues to be computed.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower parts of the matrices
  !>                 A and B are stored. If uplo indicates lower (or upper),
  !>                 then the upper (or lower) parts of A and B are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A. On exit, the contents of A are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrix A.
  !>     @param[out]
  !>     B           pointer to type. Array on the GPU of dimension ldbn.
  !>                 On entry, the symmetric positive definite matrix B. On exit, the
  !>                 triangular factor of B as returned by \ref rocsolver_spotrf "POTRF".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B.
  !>     @param[in]
  !>     vl          type. vl < vu.
  !>                 The lower bound of the search interval (vl, vu]. Ignored if range indicates to look
  !>                 for all the eigenvalues of A or the eigenvalues within a set of indices.
  !>     @param[in]
  !>     vu          type. vl < vu.
  !>                 The upper bound of the search interval (vl, vu]. Ignored if range indicates to look
  !>                 for all the eigenvalues of A or the eigenvalues within a set of indices.
  !>     @param[in]
  !>     il          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.
  !>                 The index of the smallest eigenvalue to be computed. Ignored if range indicates to look
  !>                 for all the eigenvalues of A or the eigenvalues in a half-open interval.
  !>     @param[in]
  !>     iu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..
  !>                 The index of the largest eigenvalue to be computed. Ignored if range indicates to look
  !>                 for all the eigenvalues of A or the eigenvalues in a half-open interval.
  !>     @param[in]
  !>     abstol      type.
  !>                 The absolute tolerance. An eigenvalue is considered to be located if it lies
  !>                 in an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times
  !>                 the 1-norm of the tridiagonal form of A will be used as tolerance. If abstol=0, then the tolerance will be set
  !>                 to twice the underflow threshold; this is the tolerance that could get the most accurate results.
  !>     @param[out]
  !>     nev         pointer to a rocblas_int on the GPU.
  !>                 The total number of eigenvalues found. If erange is rocblas_erange_all, nev = n.
  !>                 If erange is rocblas_erange_index, nev = iu - il + 1. Otherwise, 0 <= nev <= n.
  !>     @param[out]
  !>     W           pointer to type. Array on the GPU of dimension n.
  !>                 The first nev elements contain the computed eigenvalues. (The remaining elements
  !>                 can be used as workspace for internal computations).
  !>     @param[out]
  !>     Z           pointer to type. Array on the GPU of dimension ldznev.
  !>                 On exit, if evect is not rocblas_evect_none and info = 0, the first nev columns contain
  !>                 the eigenvectors of A corresponding to the output eigenvalues. Not referenced if
  !>                 evect is rocblas_evect_none.
  !>                 Note: If erange is rocblas_range_value, then the values of nev are not known in advance.
  !>                 The user should ensure that Z is large enough to hold n columns, as all n columns
  !>                 can be used as workspace for internal computations.
  !>     @param[in]
  !>     ldz         rocblas_int. ldz >= n.
  !>                 Specifies the leading dimension of matrix Z.
  !>     @param[out]
  !>     ifail       pointer to rocblas_int. Array on the GPU of dimension n.
  !>                 If info = 0, the first nev elements of ifail are zero.
  !>                 If info = i <= n, ifail contains the indices of the i eigenvectors that failed
  !>                 to converge.
  !>                 Not referenced if evect is rocblas_evect_none.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i <= n, i columns of Z did not converge.
  !>                 If info = n + i, the leading minor of order i of B is not
  !>                 positive definite.
  !>     
  interface rocsolver_ssygvx
    function rocsolver_ssygvx_(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo) bind(c, name="rocsolver_ssygvx")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvx_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_erange_all)),value :: erange
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_float),value :: vl
      real(c_float),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      real(c_float),value :: abstol
      type(c_ptr),value :: nev
      type(c_ptr),value :: W
      type(c_ptr),value :: Z
      integer(c_int),value :: ldz
      type(c_ptr),value :: ifail
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssygvx_full_rank,&
      
rocsolver_ssygvx_rank_0,&
      
rocsolver_ssygvx_rank_1
#endif

  end interface
  
  interface rocsolver_dsygvx
    function rocsolver_dsygvx_(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo) bind(c, name="rocsolver_dsygvx")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvx_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_erange_all)),value :: erange
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_double),value :: vl
      real(c_double),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      real(c_double),value :: abstol
      type(c_ptr),value :: nev
      type(c_ptr),value :: W
      type(c_ptr),value :: Z
      integer(c_int),value :: ldz
      type(c_ptr),value :: ifail
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsygvx_full_rank,&
      
rocsolver_dsygvx_rank_0,&
      
rocsolver_dsygvx_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEGVX computes a set of the eigenvalues and optionally the corresponding eigenvectors of
  !>     a complex generalized hermitian-definite eigenproblem.
  !> 
  !>     \details
  !>     The problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A X = \lambda B X & \: \text{1st form,}\\
  !>         A B X = \lambda X & \: \text{2nd form, or}\\
  !>         B A X = \lambda X & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype. The eigenvectors are computed depending on the
  !>     value of evect.
  !> 
  !>     When computed, the matrix Z of eigenvectors is normalized as follows:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Z^H B Z=I & \: \text{if 1st or 2nd form, or}\\
  !>         Z^H B^{-1} Z=I & \: \text{if 3rd form.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     This function computes all the eigenvalues, all the eigenvalues in the half-open interval \f$(vl, vu]\f$,
  !>     or the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,
  !>     the eigenvectors for these eigenvalues will be computed as well.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblem.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     erange      #rocblas_erange.
  !>                 Specifies the type of range or interval of the eigenvalues to be computed.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower parts of the matrices
  !>                 A and B are stored. If uplo indicates lower (or upper),
  !>                 then the upper (or lower) parts of A and B are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the matrix A. On exit, the contents of A are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrix A.
  !>     @param[out]
  !>     B           pointer to type. Array on the GPU of dimension ldbn.
  !>                 On entry, the hermitian positive definite matrix B. On exit, the
  !>                 triangular factor of B as returned by \ref rocsolver_spotrf "POTRF".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B.
  !>     @param[in]
  !>     vl          real type. vl < vu.
  !>                 The lower bound of the search interval (vl, vu]. Ignored if range indicates to look
  !>                 for all the eigenvalues of A or the eigenvalues within a set of indices.
  !>     @param[in]
  !>     vu          real type. vl < vu.
  !>                 The upper bound of the search interval (vl, vu]. Ignored if range indicates to look
  !>                 for all the eigenvalues of A or the eigenvalues within a set of indices.
  !>     @param[in]
  !>     il          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.
  !>                 The index of the smallest eigenvalue to be computed. Ignored if range indicates to look
  !>                 for all the eigenvalues of A or the eigenvalues in a half-open interval.
  !>     @param[in]
  !>     iu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..
  !>                 The index of the largest eigenvalue to be computed. Ignored if range indicates to look
  !>                 for all the eigenvalues of A or the eigenvalues in a half-open interval.
  !>     @param[in]
  !>     abstol      real type.
  !>                 The absolute tolerance. An eigenvalue is considered to be located if it lies
  !>                 in an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times
  !>                 the 1-norm of the tridiagonal form of A will be used as tolerance. If abstol=0, then the tolerance will be set
  !>                 to twice the underflow threshold; this is the tolerance that could get the most accurate results.
  !>     @param[out]
  !>     nev         pointer to a rocblas_int on the GPU.
  !>                 The total number of eigenvalues found. If erange is rocblas_erange_all, nev = n.
  !>                 If erange is rocblas_erange_index, nev = iu - il + 1. Otherwise, 0 <= nev <= n.
  !>     @param[out]
  !>     W           pointer to real type. Array on the GPU of dimension n.
  !>                 The first nev elements contain the computed eigenvalues. (The remaining elements
  !>                 can be used as workspace for internal computations).
  !>     @param[out]
  !>     Z           pointer to type. Array on the GPU of dimension ldznev.
  !>                 On exit, if evect is not rocblas_evect_none and info = 0, the first nev columns contain
  !>                 the eigenvectors of A corresponding to the output eigenvalues. Not referenced if
  !>                 evect is rocblas_evect_none.
  !>                 Note: If erange is rocblas_range_value, then the values of nev are not known in advance.
  !>                 The user should ensure that Z is large enough to hold n columns, as all n columns
  !>                 can be used as workspace for internal computations.
  !>     @param[in]
  !>     ldz         rocblas_int. ldz >= n.
  !>                 Specifies the leading dimension of matrix Z.
  !>     @param[out]
  !>     ifail       pointer to rocblas_int. Array on the GPU of dimension n.
  !>                 If info = 0, the first nev elements of ifail are zero.
  !>                 If info = i <= n, ifail contains the indices of the i eigenvectors that failed
  !>                 to converge.
  !>                 Not referenced if evect is rocblas_evect_none.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i <= n, i columns of Z did not converge.
  !>                 If info = n + i, the leading minor of order i of B is not
  !>                 positive definite.
  !>     
  interface rocsolver_chegvx
    function rocsolver_chegvx_(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo) bind(c, name="rocsolver_chegvx")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvx_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_erange_all)),value :: erange
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_float),value :: vl
      real(c_float),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      real(c_float),value :: abstol
      type(c_ptr),value :: nev
      type(c_ptr),value :: W
      type(c_ptr),value :: Z
      integer(c_int),value :: ldz
      type(c_ptr),value :: ifail
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_chegvx_full_rank,&
      
rocsolver_chegvx_rank_0,&
      
rocsolver_chegvx_rank_1
#endif

  end interface
  
  interface rocsolver_zhegvx
    function rocsolver_zhegvx_(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo) bind(c, name="rocsolver_zhegvx")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvx_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_erange_all)),value :: erange
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      real(c_double),value :: vl
      real(c_double),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      real(c_double),value :: abstol
      type(c_ptr),value :: nev
      type(c_ptr),value :: W
      type(c_ptr),value :: Z
      integer(c_int),value :: ldz
      type(c_ptr),value :: ifail
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zhegvx_full_rank,&
      
rocsolver_zhegvx_rank_0,&
      
rocsolver_zhegvx_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYGVX_BATCHED computes a set of the eigenvalues and optionally
  !>     the corresponding eigenvectors of a batch of real generalized symmetric-definite eigenproblems.
  !> 
  !>     \details
  !>     For each instance in the batch, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l X_l = \lambda B_l X_l & \: \text{1st form,}\\
  !>         A_l B_l X_l = \lambda X_l & \: \text{2nd form, or}\\
  !>         B_l A_l X_l = \lambda X_l & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype. The eigenvectors are computed depending on the
  !>     value of evect.
  !> 
  !>     When computed, the matrix \f$Z_l\f$ of eigenvectors is normalized as follows:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Z_l^T B_l^{} Z_l^{}=I & \: \text{if 1st or 2nd form, or}\\
  !>         Z_l^T B_l^{-1} Z_l^{}=I & \: \text{if 3rd form.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     This function computes all the eigenvalues, all the eigenvalues in the half-open interval \f$(vl, vu]\f$,
  !>     or the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,
  !>     the eigenvectors for these eigenvalues will be computed as well.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblems.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     erange      #rocblas_erange.
  !>                 Specifies the type of range or interval of the eigenvalues to be computed.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower parts of the matrices
  !>                 A_l and B_l are stored. If uplo indicates lower (or upper),
  !>                 then the upper (or lower) parts of A_l and B_l are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the matrices A_l. On exit, the contents of A_l are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[out]
  !>     B           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldbn.
  !>                 On entry, the symmetric positive definite matrices B_l. On exit, the
  !>                 triangular factor of B_l as returned by \ref rocsolver_spotrf_batched "POTRF_BATCHED".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B_l.
  !>     @param[in]
  !>     vl          type. vl < vu.
  !>                 The lower bound of the search interval (vl, vu]. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues within a set of indices.
  !>     @param[in]
  !>     vu          type. vl < vu.
  !>                 The upper bound of the search interval (vl, vu]. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues within a set of indices.
  !>     @param[in]
  !>     il          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.
  !>                 The index of the smallest eigenvalue to be computed. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues in a half-open interval.
  !>     @param[in]
  !>     iu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..
  !>                 The index of the largest eigenvalue to be computed. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues in a half-open interval.
  !>     @param[in]
  !>     abstol      type.
  !>                 The absolute tolerance. An eigenvalue is considered to be located if it lies
  !>                 in an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times
  !>                 the 1-norm of the tridiagonal form of A_l will be used as tolerance. If abstol=0, then the tolerance will be set
  !>                 to twice the underflow threshold; this is the tolerance that could get the most accurate results.
  !>     @param[out]
  !>     nev         pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 The total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.
  !>                 If erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.
  !>     @param[out]
  !>     W           pointer to type. Array on the GPU (the size depends on the value of strideW).
  !>                 The first nev[l] elements contain the computed eigenvalues. (The remaining elements
  !>                 can be used as workspace for internal computations).
  !>     @param[in]
  !>     strideW     rocblas_stride.
  !>                 Stride from the start of one vector W_l to the next one W_(l+1).
  !>                 There is no restriction for the value of strideW. Normal use case is strideW >= n.
  !>     @param[out]
  !>     Z           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldznev[l].
  !>                 On exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain
  !>                 the eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if
  !>                 evect is rocblas_evect_none.
  !>                 Note: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.
  !>                 The user should ensure that Z_l is large enough to hold n columns, as all n columns
  !>                 can be used as workspace for internal computations.
  !>     @param[in]
  !>     ldz         rocblas_int. ldz >= n.
  !>                 Specifies the leading dimension of matrices Z_l.
  !>     @param[out]
  !>     ifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).
  !>                 If info[l] = 0, the first nev[l] elements of ifail_l are zero.
  !>                 If info[l] = i <= n, ifail_l contains the indices of the i eigenvectors that failed
  !>                 to converge.
  !>                 Not referenced if evect is rocblas_evect_none.
  !>     @param[in]
  !>     strideF     rocblas_stride.
  !>                 Stride from the start of one vector ifail_l to the next one ifail_(l+1).
  !>                 There is no restriction for the value of strideF. Normal use case is strideF >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit of batch instance l.
  !>                 If info[l] = i <= n, i columns of Z_l did not converge.
  !>                 If info[l] = n + i, the leading minor of order i of B_l is not
  !>                 positive definite.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_ssygvx_batched
    function rocsolver_ssygvx_batched_(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count) bind(c, name="rocsolver_ssygvx_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvx_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_erange_all)),value :: erange
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_float),value :: vl
      real(c_float),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      real(c_float),value :: abstol
      type(c_ptr),value :: nev
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr) :: Z
      integer(c_int),value :: ldz
      type(c_ptr),value :: ifail
      integer(c_int64_t),value :: strideF
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssygvx_batched_full_rank,&
      
rocsolver_ssygvx_batched_rank_0,&
      
rocsolver_ssygvx_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dsygvx_batched
    function rocsolver_dsygvx_batched_(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count) bind(c, name="rocsolver_dsygvx_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvx_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_erange_all)),value :: erange
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_double),value :: vl
      real(c_double),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      real(c_double),value :: abstol
      type(c_ptr),value :: nev
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr) :: Z
      integer(c_int),value :: ldz
      type(c_ptr),value :: ifail
      integer(c_int64_t),value :: strideF
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsygvx_batched_full_rank,&
      
rocsolver_dsygvx_batched_rank_0,&
      
rocsolver_dsygvx_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEGVX_BATCHED computes a set of the eigenvalues and optionally
  !>     the corresponding eigenvectors of a batch of complex generalized hermitian-definite eigenproblems.
  !> 
  !>     \details
  !>     For each instance in the batch, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l X_l = \lambda B_l X_l & \: \text{1st form,}\\
  !>         A_l B_l X_l = \lambda X_l & \: \text{2nd form, or}\\
  !>         B_l A_l X_l = \lambda X_l & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype. The eigenvectors are computed depending on the
  !>     value of evect.
  !> 
  !>     When computed, the matrix \f$Z_l\f$ of eigenvectors is normalized as follows:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Z_l^H B_l^{} Z_l^{}=I & \: \text{if 1st or 2nd form, or}\\
  !>         Z_l^H B_l^{-1} Z_l^{}=I & \: \text{if 3rd form.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     This function computes all the eigenvalues, all the eigenvalues in the half-open interval \f$(vl, vu]\f$,
  !>     or the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,
  !>     the eigenvectors for these eigenvalues will be computed as well.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblems.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     erange      #rocblas_erange.
  !>                 Specifies the type of range or interval of the eigenvalues to be computed.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower parts of the matrices
  !>                 A_l and B_l are stored. If uplo indicates lower (or upper),
  !>                 then the upper (or lower) parts of A_l and B_l are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the matrices A_l. On exit, the contents of A_l are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[out]
  !>     B           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldbn.
  !>                 On entry, the hermitian positive definite matrices B_l. On exit, the
  !>                 triangular factor of B_l as returned by \ref rocsolver_spotrf_batched "POTRF_BATCHED".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B_l.
  !>     @param[in]
  !>     vl          real type. vl < vu.
  !>                 The lower bound of the search interval (vl, vu]. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues within a set of indices.
  !>     @param[in]
  !>     vu          real type. vl < vu.
  !>                 The upper bound of the search interval (vl, vu]. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues within a set of indices.
  !>     @param[in]
  !>     il          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.
  !>                 The index of the smallest eigenvalue to be computed. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues in a half-open interval.
  !>     @param[in]
  !>     iu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..
  !>                 The index of the largest eigenvalue to be computed. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues in a half-open interval.
  !>     @param[in]
  !>     abstol      real type.
  !>                 The absolute tolerance. An eigenvalue is considered to be located if it lies
  !>                 in an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times
  !>                 the 1-norm of the tridiagonal form of A_l will be used as tolerance. If abstol=0, then the tolerance will be set
  !>                 to twice the underflow threshold; this is the tolerance that could get the most accurate results.
  !>     @param[out]
  !>     nev         pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 The total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.
  !>                 If erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.
  !>     @param[out]
  !>     W           pointer to real type. Array on the GPU (the size depends on the value of strideW).
  !>                 The first nev[l] elements contain the computed eigenvalues. (The remaining elements
  !>                 can be used as workspace for internal computations).
  !>     @param[in]
  !>     strideW     rocblas_stride.
  !>                 Stride from the start of one vector W_l to the next one W_(l+1).
  !>                 There is no restriction for the value of strideW. Normal use case is strideW >= n.
  !>     @param[out]
  !>     Z           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldznev[l].
  !>                 On exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain
  !>                 the eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if
  !>                 evect is rocblas_evect_none.
  !>                 Note: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.
  !>                 The user should ensure that Z_l is large enough to hold n columns, as all n columns
  !>                 can be used as workspace for internal computations.
  !>     @param[in]
  !>     ldz         rocblas_int. ldz >= n.
  !>                 Specifies the leading dimension of matrices Z_l.
  !>     @param[out]
  !>     ifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).
  !>                 If info[l] = 0, the first nev[l] elements of ifail_l are zero.
  !>                 If info[l] = i <= n, ifail_l contains the indices of the i eigenvectors that failed
  !>                 to converge.
  !>                 Not referenced if evect is rocblas_evect_none.
  !>     @param[in]
  !>     strideF     rocblas_stride.
  !>                 Stride from the start of one vector ifail_l to the next one ifail_(l+1).
  !>                 There is no restriction for the value of strideF. Normal use case is strideF >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit of batch instance l.
  !>                 If info[l] = i <= n, i columns of Z_l did not converge.
  !>                 If info[l] = n + i, the leading minor of order i of B_l is not
  !>                 positive definite.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_chegvx_batched
    function rocsolver_chegvx_batched_(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count) bind(c, name="rocsolver_chegvx_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvx_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_erange_all)),value :: erange
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_float),value :: vl
      real(c_float),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      real(c_float),value :: abstol
      type(c_ptr),value :: nev
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr) :: Z
      integer(c_int),value :: ldz
      type(c_ptr),value :: ifail
      integer(c_int64_t),value :: strideF
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_chegvx_batched_full_rank,&
      
rocsolver_chegvx_batched_rank_0,&
      
rocsolver_chegvx_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zhegvx_batched
    function rocsolver_zhegvx_batched_(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count) bind(c, name="rocsolver_zhegvx_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvx_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_erange_all)),value :: erange
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      real(c_double),value :: vl
      real(c_double),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      real(c_double),value :: abstol
      type(c_ptr),value :: nev
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr) :: Z
      integer(c_int),value :: ldz
      type(c_ptr),value :: ifail
      integer(c_int64_t),value :: strideF
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zhegvx_batched_full_rank,&
      
rocsolver_zhegvx_batched_rank_0,&
      
rocsolver_zhegvx_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYGVX_STRIDED_BATCHED computes a set of the eigenvalues and optionally
  !>     the corresponding eigenvectors of a batch of real generalized symmetric-definite eigenproblems.
  !> 
  !>     \details
  !>     For each instance in the batch, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l X_l = \lambda B_l X_l & \: \text{1st form,}\\
  !>         A_l B_l X_l = \lambda X_l & \: \text{2nd form, or}\\
  !>         B_l A_l X_l = \lambda X_l & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype. The eigenvectors are computed depending on the
  !>     value of evect.
  !> 
  !>     When computed, the matrix \f$Z_l\f$ of eigenvectors is normalized as follows:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Z_l^T B_l^{} Z_l^{}=I & \: \text{if 1st or 2nd form, or}\\
  !>         Z_l^T B_l^{-1} Z_l^{}=I & \: \text{if 3rd form.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     This function computes all the eigenvalues, all the eigenvalues in the half-open interval \f$(vl, vu]\f$,
  !>     or the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,
  !>     the eigenvectors for these eigenvalues will be computed as well.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblems.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     erange      #rocblas_erange.
  !>                 Specifies the type of range or interval of the eigenvalues to be computed.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower parts of the matrices
  !>                 A_l and B_l are stored. If uplo indicates lower (or upper),
  !>                 then the upper (or lower) parts of A_l and B_l are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the matrices A_l. On exit, the contents of A_l are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     B           pointer to type. Array on the GPU (the size depends on the value of strideB).
  !>                 On entry, the symmetric positive definite matrices B_l. On exit, the
  !>                 triangular factor of B_l as returned by \ref rocsolver_spotrf_strided_batched "POTRF_STRIDED_BATCHED".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B_l.
  !>     @param[in]
  !>     strideB     rocblas_stride.
  !>                 Stride from the start of one matrix B_l to the next one B_(l+1).
  !>                 There is no restriction for the value of strideB. Normal use is strideB >= ldbn.
  !>     @param[in]
  !>     vl          type. vl < vu.
  !>                 The lower bound of the search interval (vl, vu]. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues within a set of indices.
  !>     @param[in]
  !>     vu          type. vl < vu.
  !>                 The upper bound of the search interval (vl, vu]. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues within a set of indices.
  !>     @param[in]
  !>     il          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.
  !>                 The index of the smallest eigenvalue to be computed. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues in a half-open interval.
  !>     @param[in]
  !>     iu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..
  !>                 The index of the largest eigenvalue to be computed. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues in a half-open interval.
  !>     @param[in]
  !>     abstol      type.
  !>                 The absolute tolerance. An eigenvalue is considered to be located if it lies
  !>                 in an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times
  !>                 the 1-norm of the tridiagonal form of A_l will be used as tolerance. If abstol=0, then the tolerance will be set
  !>                 to twice the underflow threshold; this is the tolerance that could get the most accurate results.
  !>     @param[out]
  !>     nev         pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 The total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.
  !>                 If erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.
  !>     @param[out]
  !>     W           pointer to type. Array on the GPU (the size depends on the value of strideW).
  !>                 The first nev[l] elements contain the computed eigenvalues. (The remaining elements
  !>                 can be used as workspace for internal computations).
  !>     @param[in]
  !>     strideW     rocblas_stride.
  !>                 Stride from the start of one vector W_l to the next one W_(l+1).
  !>                 There is no restriction for the value of strideW. Normal use case is strideW >= n.
  !>     @param[out]
  !>     Z           pointer to type. Array on the GPU (the size depends on the value of strideZ).
  !>                 On exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain
  !>                 the eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if
  !>                 evect is rocblas_evect_none.
  !>     @param[in]
  !>     ldz         rocblas_int. ldz >= n.
  !>                 Specifies the leading dimension of matrices Z_l.
  !>     @param[in]
  !>     strideZ     rocblas_stride.
  !>                 Stride from the start of one matrix Z_l to the next one Z_(l+1).
  !>                 There is no restriction for the value of strideZ. Normal use case is strideZ >= ldznev[l].
  !>                 Note: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.
  !>                 The user should ensure that Z_l is large enough to hold n columns, as all n columns
  !>                 can be used as workspace for internal computations.
  !>     @param[out]
  !>     ifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).
  !>                 If info[l] = 0, the first nev[l] elements of ifail_l are zero.
  !>                 If info[l] = i <= n, ifail_l contains the indices of the i eigenvectors that failed
  !>                 to converge.
  !>                 Not referenced if evect is rocblas_evect_none.
  !>     @param[in]
  !>     strideF     rocblas_stride.
  !>                 Stride from the start of one vector ifail_l to the next one ifail_(l+1).
  !>                 There is no restriction for the value of strideF. Normal use case is strideF >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit of batch l.
  !>                 If info[l] = i <= n, i columns of Z_l did not converge.
  !>                 If info[l] = n + i, the leading minor of order i of B_l is not
  !>                 positive definite.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_ssygvx_strided_batched
    function rocsolver_ssygvx_strided_batched_(handle,itype,evect,erange,uplo,n,A,lda,strideA,B,ldb,strideB,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count) bind(c, name="rocsolver_ssygvx_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvx_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_erange_all)),value :: erange
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_float),value :: vl
      real(c_float),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      real(c_float),value :: abstol
      type(c_ptr),value :: nev
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr),value :: Z
      integer(c_int),value :: ldz
      integer(c_int64_t),value :: strideZ
      type(c_ptr),value :: ifail
      integer(c_int64_t),value :: strideF
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssygvx_strided_batched_full_rank,&
      
rocsolver_ssygvx_strided_batched_rank_0,&
      
rocsolver_ssygvx_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dsygvx_strided_batched
    function rocsolver_dsygvx_strided_batched_(handle,itype,evect,erange,uplo,n,A,lda,strideA,B,ldb,strideB,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count) bind(c, name="rocsolver_dsygvx_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvx_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_erange_all)),value :: erange
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_double),value :: vl
      real(c_double),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      real(c_double),value :: abstol
      type(c_ptr),value :: nev
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr),value :: Z
      integer(c_int),value :: ldz
      integer(c_int64_t),value :: strideZ
      type(c_ptr),value :: ifail
      integer(c_int64_t),value :: strideF
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsygvx_strided_batched_full_rank,&
      
rocsolver_dsygvx_strided_batched_rank_0,&
      
rocsolver_dsygvx_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief HEGVX_STRIDED_BATCHED computes a set of the eigenvalues and optionally
  !>     the corresponding eigenvectors of a batch of complex generalized hermitian-definite eigenproblems.
  !> 
  !>     \details
  !>     For each instance in the batch, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l X_l = \lambda B_l X_l & \: \text{1st form,}\\
  !>         A_l B_l X_l = \lambda X_l & \: \text{2nd form, or}\\
  !>         B_l A_l X_l = \lambda X_l & \: \text{3rd form,}
  !>         \end{array}
  !>     \f]
  !> 
  !>     depending on the value of itype. The eigenvectors are computed depending on the
  !>     value of evect.
  !> 
  !>     When computed, the matrix \f$Z_l\f$ of eigenvectors is normalized as follows:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         Z_l^H B_l^{} Z_l^{}=I & \: \text{if 1st or 2nd form, or}\\
  !>         Z_l^H B_l^{-1} Z_l^{}=I & \: \text{if 3rd form.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     This function computes all the eigenvalues, all the eigenvalues in the half-open interval \f$(vl, vu]\f$,
  !>     or the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,
  !>     the eigenvectors for these eigenvalues will be computed as well.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     itype       #rocblas_eform.
  !>                 Specifies the form of the generalized eigenproblems.
  !>     @param[in]
  !>     evect       #rocblas_evect.
  !>                 Specifies whether the eigenvectors are to be computed.
  !>                 If evect is rocblas_evect_original, then the eigenvectors are computed.
  !>                 rocblas_evect_tridiagonal is not supported.
  !>     @param[in]
  !>     erange      #rocblas_erange.
  !>                 Specifies the type of range or interval of the eigenvalues to be computed.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower parts of the matrices
  !>                 A_l and B_l are stored. If uplo indicates lower (or upper),
  !>                 then the upper (or lower) parts of A_l and B_l are not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The matrix dimensions.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the matrices A_l. On exit, the contents of A_l are destroyed.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     B           pointer to type. Array on the GPU (the size depends on the value of strideB).
  !>                 On entry, the hermitian positive definite matrices B_l. On exit, the
  !>                 triangular factor of B_l as returned by \ref rocsolver_spotrf_strided_batched "POTRF_STRIDED_BATCHED".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 Specifies the leading dimension of B_l.
  !>     @param[in]
  !>     strideB     rocblas_stride.
  !>                 Stride from the start of one matrix B_l to the next one B_(l+1).
  !>                 There is no restriction for the value of strideB. Normal use is strideB >= ldbn.
  !>     @param[in]
  !>     vl          real type. vl < vu.
  !>                 The lower bound of the search interval (vl, vu]. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues within a set of indices.
  !>     @param[in]
  !>     vu          real type. vl < vu.
  !>                 The upper bound of the search interval (vl, vu]. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues within a set of indices.
  !>     @param[in]
  !>     il          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.
  !>                 The index of the smallest eigenvalue to be computed. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues in a half-open interval.
  !>     @param[in]
  !>     iu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..
  !>                 The index of the largest eigenvalue to be computed. Ignored if range indicates to look
  !>                 for all the eigenvalues of A_l or the eigenvalues in a half-open interval.
  !>     @param[in]
  !>     abstol      real type.
  !>                 The absolute tolerance. An eigenvalue is considered to be located if it lies
  !>                 in an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times
  !>                 the 1-norm of the tridiagonal form of A_l will be used as tolerance. If abstol=0, then the tolerance will be set
  !>                 to twice the underflow threshold; this is the tolerance that could get the most accurate results.
  !>     @param[out]
  !>     nev         pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 The total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.
  !>                 If erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.
  !>     @param[out]
  !>     W           pointer to real type. Array on the GPU (the size depends on the value of strideW).
  !>                 The first nev[l] elements contain the computed eigenvalues. (The remaining elements
  !>                 can be used as workspace for internal computations).
  !>     @param[in]
  !>     strideW     rocblas_stride.
  !>                 Stride from the start of one vector W_l to the next one W_(l+1).
  !>                 There is no restriction for the value of strideW. Normal use case is strideW >= n.
  !>     @param[out]
  !>     Z           pointer to type. Array on the GPU (the size depends on the value of strideZ).
  !>                 On exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain
  !>                 the eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if
  !>                 evect is rocblas_evect_none.
  !>     @param[in]
  !>     ldz         rocblas_int. ldz >= n.
  !>                 Specifies the leading dimension of matrices Z_l.
  !>     @param[in]
  !>     strideZ     rocblas_stride.
  !>                 Stride from the start of one matrix Z_l to the next one Z_(l+1).
  !>                 There is no restriction for the value of strideZ. Normal use case is strideZ >= ldznev[l].
  !>                 Note: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.
  !>                 The user should ensure that Z_l is large enough to hold n columns, as all n columns
  !>                 can be used as workspace for internal computations.
  !>     @param[out]
  !>     ifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).
  !>                 If info[l] = 0, the first nev[l] elements of ifail_l are zero.
  !>                 If info[l] = i <= n, ifail_l contains the indices of the i eigenvectors that failed
  !>                 to converge.
  !>                 Not referenced if evect is rocblas_evect_none.
  !>     @param[in]
  !>     strideF     rocblas_stride.
  !>                 Stride from the start of one vector ifail_l to the next one ifail_(l+1).
  !>                 There is no restriction for the value of strideF. Normal use case is strideF >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit of batch l.
  !>                 If info[l] = i <= n, i columns of Z_l did not converge.
  !>                 If info[l] = n + i, the leading minor of order i of B_l is not
  !>                 positive definite.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_chegvx_strided_batched
    function rocsolver_chegvx_strided_batched_(handle,itype,evect,erange,uplo,n,A,lda,strideA,B,ldb,strideB,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count) bind(c, name="rocsolver_chegvx_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvx_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_erange_all)),value :: erange
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_float),value :: vl
      real(c_float),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      real(c_float),value :: abstol
      type(c_ptr),value :: nev
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr),value :: Z
      integer(c_int),value :: ldz
      integer(c_int64_t),value :: strideZ
      type(c_ptr),value :: ifail
      integer(c_int64_t),value :: strideF
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_chegvx_strided_batched_full_rank,&
      
rocsolver_chegvx_strided_batched_rank_0,&
      
rocsolver_chegvx_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zhegvx_strided_batched
    function rocsolver_zhegvx_strided_batched_(handle,itype,evect,erange,uplo,n,A,lda,strideA,B,ldb,strideB,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count) bind(c, name="rocsolver_zhegvx_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvx_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_eform_ax)),value :: itype
      integer(kind(rocblas_evect_original)),value :: evect
      integer(kind(rocblas_erange_all)),value :: erange
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_double),value :: vl
      real(c_double),value :: vu
      integer(c_int),value :: il
      integer(c_int),value :: iu
      real(c_double),value :: abstol
      type(c_ptr),value :: nev
      type(c_ptr),value :: W
      integer(c_int64_t),value :: strideW
      type(c_ptr),value :: Z
      integer(c_int),value :: ldz
      integer(c_int64_t),value :: strideZ
      type(c_ptr),value :: ifail
      integer(c_int64_t),value :: strideF
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zhegvx_strided_batched_full_rank,&
      
rocsolver_zhegvx_strided_batched_rank_0,&
      
rocsolver_zhegvx_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GETRI_OUTOFPLACE computes the inverse \f$C = A^{-1}\f$ of a general n-by-n matrix A.
  !> 
  !>     \details
  !>     The inverse is computed by solving the linear system
  !> 
  !>     \f[
  !>         AC = I
  !>     \f]
  !> 
  !>     where I is the identity matrix, and A is factorized as \f$A = PLU\f$ as given by \ref rocsolver_sgetrf "GETRF".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of the matrix A.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 The factors L and U of the factorization A = PLU returned by \ref rocsolver_sgetrf "GETRF".
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to rocblas_int. Array on the GPU of dimension n.
  !>                 The pivot indices returned by \ref rocsolver_sgetrf "GETRF".
  !>     @param[out]
  !>     C           pointer to type. Array on the GPU of dimension ldcn.
  !>                 If info = 0, the inverse of A. Otherwise, undefined.
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= n.
  !>                 Specifies the leading dimension of C.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0, U is singular. U[i,i] is the first zero pivot.
  !>     
  interface rocsolver_sgetri_outofplace
    function rocsolver_sgetri_outofplace_(handle,n,A,lda,ipiv,C,ldc,myInfo) bind(c, name="rocsolver_sgetri_outofplace")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_outofplace_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgetri_outofplace_full_rank,&
      
rocsolver_sgetri_outofplace_rank_0,&
      
rocsolver_sgetri_outofplace_rank_1
#endif

  end interface
  
  interface rocsolver_dgetri_outofplace
    function rocsolver_dgetri_outofplace_(handle,n,A,lda,ipiv,C,ldc,myInfo) bind(c, name="rocsolver_dgetri_outofplace")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_outofplace_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgetri_outofplace_full_rank,&
      
rocsolver_dgetri_outofplace_rank_0,&
      
rocsolver_dgetri_outofplace_rank_1
#endif

  end interface
  
  interface rocsolver_cgetri_outofplace
    function rocsolver_cgetri_outofplace_(handle,n,A,lda,ipiv,C,ldc,myInfo) bind(c, name="rocsolver_cgetri_outofplace")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_outofplace_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgetri_outofplace_full_rank,&
      
rocsolver_cgetri_outofplace_rank_0,&
      
rocsolver_cgetri_outofplace_rank_1
#endif

  end interface
  
  interface rocsolver_zgetri_outofplace
    function rocsolver_zgetri_outofplace_(handle,n,A,lda,ipiv,C,ldc,myInfo) bind(c, name="rocsolver_zgetri_outofplace")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_outofplace_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgetri_outofplace_full_rank,&
      
rocsolver_zgetri_outofplace_rank_0,&
      
rocsolver_zgetri_outofplace_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GETRI_OUTOFPLACE_BATCHED computes the inverse \f$C_l = A_l^{-1}\f$ of a batch of general n-by-n matrices \f$A_l\f$.
  !> 
  !>     \details
  !>     The inverse is computed by solving the linear system
  !> 
  !>     \f[
  !>         A_l C_l = I
  !>     \f]
  !> 
  !>     where I is the identity matrix, and \f$A_l\f$ is factorized as \f$A_l = P_l  L_l  U_l\f$ as given by \ref rocsolver_sgetrf_batched "GETRF_BATCHED".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of all matrices A_l in the batch.
  !>     @param[in]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 The factors L_l and U_l of the factorization A_l = P_lL_lU_l returned by \ref rocsolver_sgetrf_batched "GETRF_BATCHED".
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     ipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).
  !>                 The pivot indices returned by \ref rocsolver_sgetrf_batched "GETRF_BATCHED".
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value of strideP. Normal use case is strideP >= n.
  !>     @param[out]
  !>     C           array of pointers to type. Each pointer points to an array on the GPU of dimension ldcn.
  !>                 If info[l] = 0, the inverse of matrices A_l. Otherwise, undefined.
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= n.
  !>                 Specifies the leading dimension of C_l.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for inversion of A_l.
  !>                 If info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgetri_outofplace_batched
    function rocsolver_sgetri_outofplace_batched_(handle,n,A,lda,ipiv,strideP,C,ldc,myInfo,batch_count) bind(c, name="rocsolver_sgetri_outofplace_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_outofplace_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgetri_outofplace_batched_full_rank,&
      
rocsolver_sgetri_outofplace_batched_rank_0,&
      
rocsolver_sgetri_outofplace_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgetri_outofplace_batched
    function rocsolver_dgetri_outofplace_batched_(handle,n,A,lda,ipiv,strideP,C,ldc,myInfo,batch_count) bind(c, name="rocsolver_dgetri_outofplace_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_outofplace_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgetri_outofplace_batched_full_rank,&
      
rocsolver_dgetri_outofplace_batched_rank_0,&
      
rocsolver_dgetri_outofplace_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgetri_outofplace_batched
    function rocsolver_cgetri_outofplace_batched_(handle,n,A,lda,ipiv,strideP,C,ldc,myInfo,batch_count) bind(c, name="rocsolver_cgetri_outofplace_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_outofplace_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgetri_outofplace_batched_full_rank,&
      
rocsolver_cgetri_outofplace_batched_rank_0,&
      
rocsolver_cgetri_outofplace_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgetri_outofplace_batched
    function rocsolver_zgetri_outofplace_batched_(handle,n,A,lda,ipiv,strideP,C,ldc,myInfo,batch_count) bind(c, name="rocsolver_zgetri_outofplace_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_outofplace_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgetri_outofplace_batched_full_rank,&
      
rocsolver_zgetri_outofplace_batched_rank_0,&
      
rocsolver_zgetri_outofplace_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GETRI_OUTOFPLACE_STRIDED_BATCHED computes the inverse \f$C_l = A_l^{-1}\f$ of a batch of general n-by-n matrices \f$A_l\f$.
  !> 
  !>     \details
  !>     The inverse is computed by solving the linear system
  !> 
  !>     \f[
  !>         A_l C_l = I
  !>     \f]
  !> 
  !>     where I is the identity matrix, and \f$A_l\f$ is factorized as \f$A_l = P_l L_l U_l\f$ as given by \ref rocsolver_sgetrf_strided_batched "GETRF_STRIDED_BATCHED".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of all matrices A_l in the batch.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 The factors L_l and U_l of the factorization A_l = P_lL_lU_l returned by
  !>                 \ref rocsolver_sgetrf_strided_batched "GETRF_STRIDED_BATCHED".
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan
  !>     @param[in]
  !>     ipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).
  !>                 The pivot indices returned by \ref rocsolver_sgetrf_strided_batched "GETRF_STRIDED_BATCHED".
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value of strideP. Normal use case is strideP >= n.
  !>     @param[out]
  !>     C           pointer to type. Array on the GPU (the size depends on the value of strideC).
  !>                 If info[l] = 0, the inverse of matrices A_l. Otherwise, undefined.
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= n.
  !>                 Specifies the leading dimension of C_l.
  !>     @param[in]
  !>     strideC     rocblas_stride.
  !>                 Stride from the start of one matrix C_l to the next one C_(l+1).
  !>                 There is no restriction for the value of strideC. Normal use case is strideC >= ldcn
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for inversion of A_l.
  !>                 If info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgetri_outofplace_strided_batched
    function rocsolver_sgetri_outofplace_strided_batched_(handle,n,A,lda,strideA,ipiv,strideP,C,ldc,strideC,myInfo,batch_count) bind(c, name="rocsolver_sgetri_outofplace_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_outofplace_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgetri_outofplace_strided_batched_full_rank,&
      
rocsolver_sgetri_outofplace_strided_batched_rank_0,&
      
rocsolver_sgetri_outofplace_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgetri_outofplace_strided_batched
    function rocsolver_dgetri_outofplace_strided_batched_(handle,n,A,lda,strideA,ipiv,strideP,C,ldc,strideC,myInfo,batch_count) bind(c, name="rocsolver_dgetri_outofplace_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_outofplace_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgetri_outofplace_strided_batched_full_rank,&
      
rocsolver_dgetri_outofplace_strided_batched_rank_0,&
      
rocsolver_dgetri_outofplace_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgetri_outofplace_strided_batched
    function rocsolver_cgetri_outofplace_strided_batched_(handle,n,A,lda,strideA,ipiv,strideP,C,ldc,strideC,myInfo,batch_count) bind(c, name="rocsolver_cgetri_outofplace_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_outofplace_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgetri_outofplace_strided_batched_full_rank,&
      
rocsolver_cgetri_outofplace_strided_batched_rank_0,&
      
rocsolver_cgetri_outofplace_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgetri_outofplace_strided_batched
    function rocsolver_zgetri_outofplace_strided_batched_(handle,n,A,lda,strideA,ipiv,strideP,C,ldc,strideC,myInfo,batch_count) bind(c, name="rocsolver_zgetri_outofplace_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_outofplace_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgetri_outofplace_strided_batched_full_rank,&
      
rocsolver_zgetri_outofplace_strided_batched_rank_0,&
      
rocsolver_zgetri_outofplace_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GETRI_NPVT_OUTOFPLACE computes the inverse \f$C = A^{-1}\f$ of a general n-by-n matrix A without partial pivoting.
  !> 
  !>     \details
  !>     The inverse is computed by solving the linear system
  !> 
  !>     \f[
  !>         AC = I
  !>     \f]
  !> 
  !>     where I is the identity matrix, and A is factorized as \f$A = LU\f$ as given by \ref rocsolver_sgetrf_npvt "GETRF_NPVT".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of the matrix A.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 The factors L and U of the factorization A = LU returned by \ref rocsolver_sgetrf_npvt "GETRF_NPVT".
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     C           pointer to type. Array on the GPU of dimension ldcn.
  !>                 If info = 0, the inverse of A. Otherwise, undefined.
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= n.
  !>                 Specifies the leading dimension of C.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0, U is singular. U[i,i] is the first zero pivot.
  !>     
  interface rocsolver_sgetri_npvt_outofplace
    function rocsolver_sgetri_npvt_outofplace_(handle,n,A,lda,C,ldc,myInfo) bind(c, name="rocsolver_sgetri_npvt_outofplace")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_npvt_outofplace_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgetri_npvt_outofplace_full_rank,&
      
rocsolver_sgetri_npvt_outofplace_rank_0,&
      
rocsolver_sgetri_npvt_outofplace_rank_1
#endif

  end interface
  
  interface rocsolver_dgetri_npvt_outofplace
    function rocsolver_dgetri_npvt_outofplace_(handle,n,A,lda,C,ldc,myInfo) bind(c, name="rocsolver_dgetri_npvt_outofplace")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_npvt_outofplace_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgetri_npvt_outofplace_full_rank,&
      
rocsolver_dgetri_npvt_outofplace_rank_0,&
      
rocsolver_dgetri_npvt_outofplace_rank_1
#endif

  end interface
  
  interface rocsolver_cgetri_npvt_outofplace
    function rocsolver_cgetri_npvt_outofplace_(handle,n,A,lda,C,ldc,myInfo) bind(c, name="rocsolver_cgetri_npvt_outofplace")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_npvt_outofplace_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgetri_npvt_outofplace_full_rank,&
      
rocsolver_cgetri_npvt_outofplace_rank_0,&
      
rocsolver_cgetri_npvt_outofplace_rank_1
#endif

  end interface
  
  interface rocsolver_zgetri_npvt_outofplace
    function rocsolver_zgetri_npvt_outofplace_(handle,n,A,lda,C,ldc,myInfo) bind(c, name="rocsolver_zgetri_npvt_outofplace")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_npvt_outofplace_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgetri_npvt_outofplace_full_rank,&
      
rocsolver_zgetri_npvt_outofplace_rank_0,&
      
rocsolver_zgetri_npvt_outofplace_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GETRI_NPVT_OUTOFPLACE_BATCHED computes the inverse \f$C_l^{} = A_l^{-1}\f$ of a batch of general n-by-n matrices \f$A_l\f$
  !>     without partial pivoting.
  !> 
  !>     \details
  !>     The inverse is computed by solving the linear system
  !> 
  !>     \f[
  !>         A_l C_l = I
  !>     \f]
  !> 
  !>     where I is the identity matrix, and \f$A_l\f$ is factorized as \f$A_l = L_l  U_l\f$ as given by \ref rocsolver_sgetrf_npvt_batched "GETRF_NPVT_BATCHED".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of all matrices A_l in the batch.
  !>     @param[in]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 The factors L_l and U_l of the factorization A_l = L_lU_l returned by \ref rocsolver_sgetrf_npvt_batched "GETRF_NPVT_BATCHED".
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[out]
  !>     C           array of pointers to type. Each pointer points to an array on the GPU of dimension ldcn.
  !>                 If info[l] = 0, the inverse of matrices A_l. Otherwise, undefined.
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= n.
  !>                 Specifies the leading dimension of C_l.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for inversion of A_l.
  !>                 If info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgetri_npvt_outofplace_batched
    function rocsolver_sgetri_npvt_outofplace_batched_(handle,n,A,lda,C,ldc,myInfo,batch_count) bind(c, name="rocsolver_sgetri_npvt_outofplace_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_npvt_outofplace_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgetri_npvt_outofplace_batched_full_rank,&
      
rocsolver_sgetri_npvt_outofplace_batched_rank_0,&
      
rocsolver_sgetri_npvt_outofplace_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgetri_npvt_outofplace_batched
    function rocsolver_dgetri_npvt_outofplace_batched_(handle,n,A,lda,C,ldc,myInfo,batch_count) bind(c, name="rocsolver_dgetri_npvt_outofplace_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_npvt_outofplace_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgetri_npvt_outofplace_batched_full_rank,&
      
rocsolver_dgetri_npvt_outofplace_batched_rank_0,&
      
rocsolver_dgetri_npvt_outofplace_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgetri_npvt_outofplace_batched
    function rocsolver_cgetri_npvt_outofplace_batched_(handle,n,A,lda,C,ldc,myInfo,batch_count) bind(c, name="rocsolver_cgetri_npvt_outofplace_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_npvt_outofplace_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgetri_npvt_outofplace_batched_full_rank,&
      
rocsolver_cgetri_npvt_outofplace_batched_rank_0,&
      
rocsolver_cgetri_npvt_outofplace_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgetri_npvt_outofplace_batched
    function rocsolver_zgetri_npvt_outofplace_batched_(handle,n,A,lda,C,ldc,myInfo,batch_count) bind(c, name="rocsolver_zgetri_npvt_outofplace_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_npvt_outofplace_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgetri_npvt_outofplace_batched_full_rank,&
      
rocsolver_zgetri_npvt_outofplace_batched_rank_0,&
      
rocsolver_zgetri_npvt_outofplace_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GETRI_NPVT_OUTOFPLACE_STRIDED_BATCHED computes the inverse \f$C_l^{} = A_l^{-1}\f$ of a batch of general n-by-n matrices \f$A_l\f$
  !>     without partial pivoting.
  !> 
  !>     \details
  !>     The inverse is computed by solving the linear system
  !> 
  !>     \f[
  !>         A_l C_l = I
  !>     \f]
  !> 
  !>     where I is the identity matrix, and \f$A_l\f$ is factorized as \f$A_l = L_l  U_l\f$ as given by \ref rocsolver_sgetrf_npvt_strided_batched "GETRF_NPVT_STRIDED_BATCHED".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of all matrices A_l in the batch.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 The factors L_l and U_l of the factorization A_l = L_lU_l returned by
  !>                 \ref rocsolver_sgetrf_npvt_strided_batched "GETRF_NPVT_STRIDED_BATCHED".
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan
  !>     @param[out]
  !>     C           pointer to type. Array on the GPU (the size depends on the value of strideC).
  !>                 If info[l] = 0, the inverse of matrices A_l. Otherwise, undefined.
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= n.
  !>                 Specifies the leading dimension of C_l.
  !>     @param[in]
  !>     strideC     rocblas_stride.
  !>                 Stride from the start of one matrix C_l to the next one C_(l+1).
  !>                 There is no restriction for the value of strideC. Normal use case is strideC >= ldcn
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for inversion of A_l.
  !>                 If info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgetri_npvt_outofplace_strided_batched
    function rocsolver_sgetri_npvt_outofplace_strided_batched_(handle,n,A,lda,strideA,C,ldc,strideC,myInfo,batch_count) bind(c, name="rocsolver_sgetri_npvt_outofplace_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_npvt_outofplace_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgetri_npvt_outofplace_strided_batched_full_rank,&
      
rocsolver_sgetri_npvt_outofplace_strided_batched_rank_0,&
      
rocsolver_sgetri_npvt_outofplace_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgetri_npvt_outofplace_strided_batched
    function rocsolver_dgetri_npvt_outofplace_strided_batched_(handle,n,A,lda,strideA,C,ldc,strideC,myInfo,batch_count) bind(c, name="rocsolver_dgetri_npvt_outofplace_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_npvt_outofplace_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgetri_npvt_outofplace_strided_batched_full_rank,&
      
rocsolver_dgetri_npvt_outofplace_strided_batched_rank_0,&
      
rocsolver_dgetri_npvt_outofplace_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgetri_npvt_outofplace_strided_batched
    function rocsolver_cgetri_npvt_outofplace_strided_batched_(handle,n,A,lda,strideA,C,ldc,strideC,myInfo,batch_count) bind(c, name="rocsolver_cgetri_npvt_outofplace_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_npvt_outofplace_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgetri_npvt_outofplace_strided_batched_full_rank,&
      
rocsolver_cgetri_npvt_outofplace_strided_batched_rank_0,&
      
rocsolver_cgetri_npvt_outofplace_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgetri_npvt_outofplace_strided_batched
    function rocsolver_zgetri_npvt_outofplace_strided_batched_(handle,n,A,lda,strideA,C,ldc,strideC,myInfo,batch_count) bind(c, name="rocsolver_zgetri_npvt_outofplace_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_npvt_outofplace_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgetri_npvt_outofplace_strided_batched_full_rank,&
      
rocsolver_zgetri_npvt_outofplace_strided_batched_rank_0,&
      
rocsolver_zgetri_npvt_outofplace_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief TRTRI inverts a triangular n-by-n matrix A.
  !> 
  !>     \details
  !>     A can be upper or lower triangular, depending on the value of uplo, and unit or non-unit
  !>     triangular, depending on the value of diag.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the matrix A is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower)
  !>                 part of A is not used.
  !>     @param[in]
  !>     diag        rocblas_diagonal.
  !>                 If diag indicates unit, then the diagonal elements of A are not referenced and
  !>                 assumed to be one.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of the matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the triangular matrix.
  !>                 On exit, the inverse of A if info = 0.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0, A is singular. A[i,i] is the first zero element in the diagonal.
  !>     
  interface rocsolver_strtri
    function rocsolver_strtri_(handle,uplo,diag,n,A,lda,myInfo) bind(c, name="rocsolver_strtri")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_strtri_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_strtri_full_rank,&
      
rocsolver_strtri_rank_0,&
      
rocsolver_strtri_rank_1
#endif

  end interface
  
  interface rocsolver_dtrtri
    function rocsolver_dtrtri_(handle,uplo,diag,n,A,lda,myInfo) bind(c, name="rocsolver_dtrtri")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dtrtri_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dtrtri_full_rank,&
      
rocsolver_dtrtri_rank_0,&
      
rocsolver_dtrtri_rank_1
#endif

  end interface
  
  interface rocsolver_ctrtri
    function rocsolver_ctrtri_(handle,uplo,diag,n,A,lda,myInfo) bind(c, name="rocsolver_ctrtri")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ctrtri_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ctrtri_full_rank,&
      
rocsolver_ctrtri_rank_0,&
      
rocsolver_ctrtri_rank_1
#endif

  end interface
  
  interface rocsolver_ztrtri
    function rocsolver_ztrtri_(handle,uplo,diag,n,A,lda,myInfo) bind(c, name="rocsolver_ztrtri")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ztrtri_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ztrtri_full_rank,&
      
rocsolver_ztrtri_rank_0,&
      
rocsolver_ztrtri_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief TRTRI_BATCHED inverts a batch of triangular n-by-n matrices \f$A_l\f$.
  !> 
  !>     \details
  !>     \f$A_l\f$ can be upper or lower triangular, depending on the value of uplo, and unit or non-unit
  !>     triangular, depending on the value of diag.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the matrices A_l are stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower)
  !>                 part of A_l is not used.
  !>     @param[in]
  !>     diag        rocblas_diagonal.
  !>                 If diag indicates unit, then the diagonal elements of matrices A_l are not referenced and
  !>                 assumed to be one.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of all matrices A_l in the batch.
  !>     @param[inout]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the triangular matrices A_l.
  !>                 On exit, the inverses of A_l if info[l] = 0.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for inversion of A_l.
  !>                 If info[l] = i > 0, A_l is singular. A_l[i,i] is the first zero element in the diagonal.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_strtri_batched
    function rocsolver_strtri_batched_(handle,uplo,diag,n,A,lda,myInfo,batch_count) bind(c, name="rocsolver_strtri_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_strtri_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_strtri_batched_full_rank,&
      
rocsolver_strtri_batched_rank_0,&
      
rocsolver_strtri_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dtrtri_batched
    function rocsolver_dtrtri_batched_(handle,uplo,diag,n,A,lda,myInfo,batch_count) bind(c, name="rocsolver_dtrtri_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dtrtri_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dtrtri_batched_full_rank,&
      
rocsolver_dtrtri_batched_rank_0,&
      
rocsolver_dtrtri_batched_rank_1
#endif

  end interface
  
  interface rocsolver_ctrtri_batched
    function rocsolver_ctrtri_batched_(handle,uplo,diag,n,A,lda,myInfo,batch_count) bind(c, name="rocsolver_ctrtri_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ctrtri_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ctrtri_batched_full_rank,&
      
rocsolver_ctrtri_batched_rank_0,&
      
rocsolver_ctrtri_batched_rank_1
#endif

  end interface
  
  interface rocsolver_ztrtri_batched
    function rocsolver_ztrtri_batched_(handle,uplo,diag,n,A,lda,myInfo,batch_count) bind(c, name="rocsolver_ztrtri_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ztrtri_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ztrtri_batched_full_rank,&
      
rocsolver_ztrtri_batched_rank_0,&
      
rocsolver_ztrtri_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief TRTRI_STRIDED_BATCHED inverts a batch of triangular n-by-n matrices \f$A_l\f$.
  !> 
  !>     \details
  !>     \f$A_l\f$ can be upper or lower triangular, depending on the value of uplo, and unit or non-unit
  !>     triangular, depending on the value of diag.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the matrices A_l are stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower)
  !>                 part of A_l is not used.
  !>     @param[in]
  !>     diag        rocblas_diagonal.
  !>                 If diag indicates unit, then the diagonal elements of matrices A_l are not referenced and
  !>                 assumed to be one.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of all matrices A_l in the batch.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the triangular matrices A_l.
  !>                 On exit, the inverses of A_l if info[l] = 0.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for inversion of A_l.
  !>                 If info[l] = i > 0, A_l is singular. A_l[i,i] is the first zero element in the diagonal.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_strtri_strided_batched
    function rocsolver_strtri_strided_batched_(handle,uplo,diag,n,A,lda,strideA,myInfo,batch_count) bind(c, name="rocsolver_strtri_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_strtri_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_strtri_strided_batched_full_rank,&
      
rocsolver_strtri_strided_batched_rank_0,&
      
rocsolver_strtri_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dtrtri_strided_batched
    function rocsolver_dtrtri_strided_batched_(handle,uplo,diag,n,A,lda,strideA,myInfo,batch_count) bind(c, name="rocsolver_dtrtri_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dtrtri_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dtrtri_strided_batched_full_rank,&
      
rocsolver_dtrtri_strided_batched_rank_0,&
      
rocsolver_dtrtri_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_ctrtri_strided_batched
    function rocsolver_ctrtri_strided_batched_(handle,uplo,diag,n,A,lda,strideA,myInfo,batch_count) bind(c, name="rocsolver_ctrtri_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ctrtri_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ctrtri_strided_batched_full_rank,&
      
rocsolver_ctrtri_strided_batched_rank_0,&
      
rocsolver_ctrtri_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_ztrtri_strided_batched
    function rocsolver_ztrtri_strided_batched_(handle,uplo,diag,n,A,lda,strideA,myInfo,batch_count) bind(c, name="rocsolver_ztrtri_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ztrtri_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(kind(rocblas_diagonal_non_unit)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ztrtri_strided_batched_full_rank,&
      
rocsolver_ztrtri_strided_batched_rank_0,&
      
rocsolver_ztrtri_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYTF2 computes the factorization of a symmetric indefinite matrix \f$A\f$
  !>     using Bunch-Kaufman diagonal pivoting.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The factorization has the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A = U D U^T & \: \text{or}\\
  !>         A = L D L^T &
  !>         \end{array}
  !>     \f]
  !> 
  !>     where \f$U\f$ or \f$L\f$ is a product of permutation and unit upperlower
  !>     triangular matrices (depending on the value of uplo), and \f$D\f$ is a symmetric
  !>     block diagonal matrix with 1-by-1 and 2-by-2 diagonal blocks \f$D_k\f$.
  !> 
  !>     Specifically, \f$U\f$ and \f$L\f$ are computed as
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U = P(n) U(n) \cdots P(k) U(k) \cdots & \: \text{and}\\
  !>         L = P(1) L(1) \cdots P(k) L(k) \cdots &
  !>         \end{array}
  !>     \f]
  !> 
  !>     where \f$k\f$ decreases from \f$n\f$ to 1 (increases from 1 to \f$n\f$) in steps of 1 or 2,
  !>     depending on the order of block \f$D_k\f$, and \f$P(k)\f$ is a permutation matrix defined by
  !>     \f$ipiv[k]\f$. If we let \f$s\f$ denote the order of block \f$D_k\f$, then \f$U(k)\f$
  !>     and \f$L(k)\f$ are unit upperlower triangular matrices defined as
  !> 
  !>     \f[
  !>         U(k) = \left[ \begin{array}{ccc}
  !>         I_{k-s} & v & 0 \\
  !>         0 & I_s & 0 \\
  !>         0 & 0 & I_{n-k}
  !>         \end{array} \right]
  !>     \f]
  !> 
  !>     and
  !> 
  !>     \f[
  !>         L(k) = \left[ \begin{array}{ccc}
  !>         I_{k-1} & 0 & 0 \\
  !>         0 & I_s & 0 \\
  !>         0 & v & I_{n-k-s+1}
  !>         \end{array} \right].
  !>     \f]
  !> 
  !>     If \f$s = 1\f$, then \f$D_k\f$ is stored in \f$A[k,k]\f$ and \f$v\f$ is stored in the upperlower
  !>     part of column \f$k\f$ of \f$A\f$.
  !>     If \f$s = 2\f$ and uplo is upper, then \f$D_k\f$ is stored in \f$A[k-1,k-1]\f$, \f$A[k-1,k]\f$,
  !>     and \f$A[k,k]\f$, and \f$v\f$ is stored in the upper parts of columns \f$k-1\f$ and \f$k\f$ of \f$A\f$.
  !>     If \f$s = 2\f$ and uplo is lower, then \f$D_k\f$ is stored in \f$A[k,k]\f$, \f$A[k+1,k]\f$,
  !>     and \f$A[k+1,k+1]\f$, and \f$v\f$ is stored in the lower parts of columns \f$k\f$ and \f$k+1\f$ of \f$A\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the matrix A is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower)
  !>                 part of A is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of the matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the symmetric matrix A to be factored.
  !>                 On exit, the block diagonal matrix D and the multipliers needed to
  !>                 compute U or L.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     ipiv        pointer to rocblas_int. Array on the GPU of dimension n.
  !>                 The vector of pivot indices. Elements of ipiv are 1-based indices.
  !>                 For 1 <= k <= n, if ipiv[k] > 0 then rows and columns k and ipiv[k]
  !>                 were interchanged and D[k,k] is a 1-by-1 diagonal block.
  !>                 If, instead, ipiv[k] = ipiv[k-1] < 0 and uplo is upper (or ipiv[k]
  !>                 = ipiv[k+1] < 0 and uplo is lower), then rows and columns k-1 and
  !>                 -ipiv[k] (or rows and columns k+1 and -ipiv[k]) were interchanged
  !>                 and D[k-1,k-1] to D[k,k] (or D[k,k] to D[k+1,k+1]) is a 2-by-2
  !>                 diagonal block.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0, D is singular. D[i,i] is the first diagonal zero.
  !>     
  interface rocsolver_ssytf2
    function rocsolver_ssytf2_(handle,uplo,n,A,lda,ipiv,myInfo) bind(c, name="rocsolver_ssytf2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytf2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssytf2_full_rank,&
      
rocsolver_ssytf2_rank_0,&
      
rocsolver_ssytf2_rank_1
#endif

  end interface
  
  interface rocsolver_dsytf2
    function rocsolver_dsytf2_(handle,uplo,n,A,lda,ipiv,myInfo) bind(c, name="rocsolver_dsytf2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytf2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsytf2_full_rank,&
      
rocsolver_dsytf2_rank_0,&
      
rocsolver_dsytf2_rank_1
#endif

  end interface
  
  interface rocsolver_csytf2
    function rocsolver_csytf2_(handle,uplo,n,A,lda,ipiv,myInfo) bind(c, name="rocsolver_csytf2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_csytf2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_csytf2_full_rank,&
      
rocsolver_csytf2_rank_0,&
      
rocsolver_csytf2_rank_1
#endif

  end interface
  
  interface rocsolver_zsytf2
    function rocsolver_zsytf2_(handle,uplo,n,A,lda,ipiv,myInfo) bind(c, name="rocsolver_zsytf2")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zsytf2_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zsytf2_full_rank,&
      
rocsolver_zsytf2_rank_0,&
      
rocsolver_zsytf2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYTF2_BATCHED computes the factorization of a batch of symmetric indefinite
  !>     matrices using Bunch-Kaufman diagonal pivoting.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The factorization has the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l^{} = U_l^{} D_l^{} U_l^T & \: \text{or}\\
  !>         A_l^{} = L_l^{} D_l^{} L_l^T &
  !>         \end{array}
  !>     \f]
  !> 
  !>     where \f$U_l\f$ or \f$L_l\f$ is a product of permutation and unit upperlower
  !>     triangular matrices (depending on the value of uplo), and \f$D_l\f$ is a symmetric
  !>     block diagonal matrix with 1-by-1 and 2-by-2 diagonal blocks \f$D_{kl}\f$.
  !> 
  !>     Specifically, \f$U_l\f$ and \f$L_l\f$ are computed as
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U_l = P_l(n) U_l(n) \cdots P_l(k) U_l(k) \cdots & \: \text{and}\\
  !>         L_l = P_l(1) L_l(1) \cdots P_l(k) L_l(k) \cdots &
  !>         \end{array}
  !>     \f]
  !> 
  !>     where \f$k\f$ decreases from \f$n\f$ to 1 (increases from 1 to \f$n\f$) in steps of 1 or 2,
  !>     depending on the order of block \f$D_{kl}\f$, and \f$P_l(k)\f$ is a permutation matrix defined by
  !>     \f$ipiv_l[k]\f$. If we let \f$s\f$ denote the order of block \f$D_{kl}\f$, then \f$U_l(k)\f$
  !>     and \f$L_l(k)\f$ are unit upperlower triangular matrices defined as
  !> 
  !>     \f[
  !>         U_l(k) = \left[ \begin{array}{ccc}
  !>         I_{k-s} & v & 0 \\
  !>         0 & I_s & 0 \\
  !>         0 & 0 & I_{n-k}
  !>         \end{array} \right]
  !>     \f]
  !> 
  !>     and
  !> 
  !>     \f[
  !>         L_l(k) = \left[ \begin{array}{ccc}
  !>         I_{k-1} & 0 & 0 \\
  !>         0 & I_s & 0 \\
  !>         0 & v & I_{n-k-s+1}
  !>         \end{array} \right].
  !>     \f]
  !> 
  !>     If \f$s = 1\f$, then \f$D_{kl}\f$ is stored in \f$A_l[k,k]\f$ and \f$v\f$ is stored in the upperlower
  !>     part of column \f$k\f$ of \f$A_l\f$.
  !>     If \f$s = 2\f$ and uplo is upper, then \f$D_{kl}\f$ is stored in \f$A_l[k-1,k-1]\f$, \f$A_l[k-1,k]\f$,
  !>     and \f$A_l[k,k]\f$, and \f$v\f$ is stored in the upper parts of columns \f$k-1\f$ and \f$k\f$ of \f$A_l\f$.
  !>     If \f$s = 2\f$ and uplo is lower, then \f$D_{kl}\f$ is stored in \f$A_l[k,k]\f$, \f$A_l[k+1,k]\f$,
  !>     and \f$A_l[k+1,k+1]\f$, and \f$v\f$ is stored in the lower parts of columns \f$k\f$ and \f$k+1\f$ of \f$A_l\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the matrices A_l are stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower)
  !>                 part of A_l is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of all matrices A_l in the batch.
  !>     @param[inout]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the symmetric matrices A_l to be factored.
  !>                 On exit, the block diagonal matrices D_l and the multipliers needed to
  !>                 compute U_l or L_l.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[out]
  !>     ipiv        pointer to rocblas_int. Array on the GPU of dimension n.
  !>                 The vector of pivot indices. Elements of ipiv are 1-based indices.
  !>                 For 1 <= k <= n, if ipiv_l[k] > 0 then rows and columns k and ipiv_l[k]
  !>                 were interchanged and D_l[k,k] is a 1-by-1 diagonal block.
  !>                 If, instead, ipiv_l[k] = ipiv_l[k-1] < 0 and uplo is upper (or ipiv_l[k]
  !>                 = ipiv_l[k+1] < 0 and uplo is lower), then rows and columns k-1 and
  !>                 -ipiv_l[k] (or rows and columns k+1 and -ipiv_l[k]) were interchanged
  !>                 and D_l[k-1,k-1] to D_l[k,k] (or D_l[k,k] to D_l[k+1,k+1]) is a 2-by-2
  !>                 diagonal block.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value of strideP. Normal use case is strideP >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for factorization of A_l.
  !>                 If info[l] = i > 0, D_l is singular. D_l[i,i] is the first diagonal zero.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_ssytf2_batched
    function rocsolver_ssytf2_batched_(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_ssytf2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytf2_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssytf2_batched_full_rank,&
      
rocsolver_ssytf2_batched_rank_0,&
      
rocsolver_ssytf2_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dsytf2_batched
    function rocsolver_dsytf2_batched_(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_dsytf2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytf2_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsytf2_batched_full_rank,&
      
rocsolver_dsytf2_batched_rank_0,&
      
rocsolver_dsytf2_batched_rank_1
#endif

  end interface
  
  interface rocsolver_csytf2_batched
    function rocsolver_csytf2_batched_(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_csytf2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_csytf2_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_csytf2_batched_full_rank,&
      
rocsolver_csytf2_batched_rank_0,&
      
rocsolver_csytf2_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zsytf2_batched
    function rocsolver_zsytf2_batched_(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_zsytf2_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zsytf2_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zsytf2_batched_full_rank,&
      
rocsolver_zsytf2_batched_rank_0,&
      
rocsolver_zsytf2_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYTF2_STRIDED_BATCHED computes the factorization of a batch of symmetric indefinite
  !>     matrices using Bunch-Kaufman diagonal pivoting.
  !> 
  !>     \details
  !>     (This is the unblocked version of the algorithm).
  !> 
  !>     The factorization has the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l^{} = U_l^{} D_l^{} U_l^T & \: \text{or}\\
  !>         A_l^{} = L_l^{} D_l^{} L_l^T &
  !>         \end{array}
  !>     \f]
  !> 
  !>     where \f$U_l\f$ or \f$L_l\f$ is a product of permutation and unit upperlower
  !>     triangular matrices (depending on the value of uplo), and \f$D_l\f$ is a symmetric
  !>     block diagonal matrix with 1-by-1 and 2-by-2 diagonal blocks \f$D_{kl}\f$.
  !> 
  !>     Specifically, \f$U_l\f$ and \f$L_l\f$ are computed as
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U_l = P_l(n) U_l(n) \cdots P_l(k) U_l(k) \cdots & \: \text{and}\\
  !>         L_l = P_l(1) L_l(1) \cdots P_l(k) L_l(k) \cdots &
  !>         \end{array}
  !>     \f]
  !> 
  !>     where \f$k\f$ decreases from \f$n\f$ to 1 (increases from 1 to \f$n\f$) in steps of 1 or 2,
  !>     depending on the order of block \f$D_{kl}\f$, and \f$P_l(k)\f$ is a permutation matrix defined by
  !>     \f$ipiv_l[k]\f$. If we let \f$s\f$ denote the order of block \f$D_{kl}\f$, then \f$U_l(k)\f$
  !>     and \f$L_l(k)\f$ are unit upperlower triangular matrices defined as
  !> 
  !>     \f[
  !>         U_l(k) = \left[ \begin{array}{ccc}
  !>         I_{k-s} & v & 0 \\
  !>         0 & I_s & 0 \\
  !>         0 & 0 & I_{n-k}
  !>         \end{array} \right]
  !>     \f]
  !> 
  !>     and
  !> 
  !>     \f[
  !>         L_l(k) = \left[ \begin{array}{ccc}
  !>         I_{k-1} & 0 & 0 \\
  !>         0 & I_s & 0 \\
  !>         0 & v & I_{n-k-s+1}
  !>         \end{array} \right].
  !>     \f]
  !> 
  !>     If \f$s = 1\f$, then \f$D_{kl}\f$ is stored in \f$A_l[k,k]\f$ and \f$v\f$ is stored in the upperlower
  !>     part of column \f$k\f$ of \f$A_l\f$.
  !>     If \f$s = 2\f$ and uplo is upper, then \f$D_{kl}\f$ is stored in \f$A_l[k-1,k-1]\f$, \f$A_l[k-1,k]\f$,
  !>     and \f$A_l[k,k]\f$, and \f$v\f$ is stored in the upper parts of columns \f$k-1\f$ and \f$k\f$ of \f$A_l\f$.
  !>     If \f$s = 2\f$ and uplo is lower, then \f$D_{kl}\f$ is stored in \f$A_l[k,k]\f$, \f$A_l[k+1,k]\f$,
  !>     and \f$A_l[k+1,k+1]\f$, and \f$v\f$ is stored in the lower parts of columns \f$k\f$ and \f$k+1\f$ of \f$A_l\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the matrices A_l are stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower)
  !>                 part of A_l is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of all matrices A_l in the batch.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the symmetric matrices A_l to be factored.
  !>                 On exit, the block diagonal matrices D_l and the multipliers needed to
  !>                 compute U_l or L_l.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan
  !>     @param[out]
  !>     ipiv        pointer to rocblas_int. Array on the GPU of dimension n.
  !>                 The vector of pivot indices. Elements of ipiv are 1-based indices.
  !>                 For 1 <= k <= n, if ipiv_l[k] > 0 then rows and columns k and ipiv_l[k]
  !>                 were interchanged and D_l[k,k] is a 1-by-1 diagonal block.
  !>                 If, instead, ipiv_l[k] = ipiv_l[k-1] < 0 and uplo is upper (or ipiv_l[k]
  !>                 = ipiv_l[k+1] < 0 and uplo is lower), then rows and columns k-1 and
  !>                 -ipiv_l[k] (or rows and columns k+1 and -ipiv_l[k]) were interchanged
  !>                 and D_l[k-1,k-1] to D_l[k,k] (or D_l[k,k] to D_l[k+1,k+1]) is a 2-by-2
  !>                 diagonal block.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value of strideP. Normal use case is strideP >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for factorization of A_l.
  !>                 If info[l] = i > 0, D_l is singular. D_l[i,i] is the first diagonal zero.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_ssytf2_strided_batched
    function rocsolver_ssytf2_strided_batched_(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_ssytf2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytf2_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssytf2_strided_batched_full_rank,&
      
rocsolver_ssytf2_strided_batched_rank_0,&
      
rocsolver_ssytf2_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dsytf2_strided_batched
    function rocsolver_dsytf2_strided_batched_(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_dsytf2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytf2_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsytf2_strided_batched_full_rank,&
      
rocsolver_dsytf2_strided_batched_rank_0,&
      
rocsolver_dsytf2_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_csytf2_strided_batched
    function rocsolver_csytf2_strided_batched_(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_csytf2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_csytf2_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_csytf2_strided_batched_full_rank,&
      
rocsolver_csytf2_strided_batched_rank_0,&
      
rocsolver_csytf2_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zsytf2_strided_batched
    function rocsolver_zsytf2_strided_batched_(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_zsytf2_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zsytf2_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zsytf2_strided_batched_full_rank,&
      
rocsolver_zsytf2_strided_batched_rank_0,&
      
rocsolver_zsytf2_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYTRF computes the factorization of a symmetric indefinite matrix \f$A\f$
  !>     using Bunch-Kaufman diagonal pivoting.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The factorization has the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A = U D U^T & \: \text{or}\\
  !>         A = L D L^T &
  !>         \end{array}
  !>     \f]
  !> 
  !>     where \f$U\f$ or \f$L\f$ is a product of permutation and unit upperlower
  !>     triangular matrices (depending on the value of uplo), and \f$D\f$ is a symmetric
  !>     block diagonal matrix with 1-by-1 and 2-by-2 diagonal blocks \f$D_k\f$.
  !> 
  !>     Specifically, \f$U\f$ and \f$L\f$ are computed as
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U = P(n) U(n) \cdots P(k) U(k) \cdots & \: \text{and}\\
  !>         L = P(1) L(1) \cdots P(k) L(k) \cdots &
  !>         \end{array}
  !>     \f]
  !> 
  !>     where \f$k\f$ decreases from \f$n\f$ to 1 (increases from 1 to \f$n\f$) in steps of 1 or 2,
  !>     depending on the order of block \f$D_k\f$, and \f$P(k)\f$ is a permutation matrix defined by
  !>     \f$ipiv[k]\f$. If we let \f$s\f$ denote the order of block \f$D_k\f$, then \f$U(k)\f$
  !>     and \f$L(k)\f$ are unit upperlower triangular matrices defined as
  !> 
  !>     \f[
  !>         U(k) = \left[ \begin{array}{ccc}
  !>         I_{k-s} & v & 0 \\
  !>         0 & I_s & 0 \\
  !>         0 & 0 & I_{n-k}
  !>         \end{array} \right]
  !>     \f]
  !> 
  !>     and
  !> 
  !>     \f[
  !>         L(k) = \left[ \begin{array}{ccc}
  !>         I_{k-1} & 0 & 0 \\
  !>         0 & I_s & 0 \\
  !>         0 & v & I_{n-k-s+1}
  !>         \end{array} \right].
  !>     \f]
  !> 
  !>     If \f$s = 1\f$, then \f$D_k\f$ is stored in \f$A[k,k]\f$ and \f$v\f$ is stored in the upperlower
  !>     part of column \f$k\f$ of \f$A\f$.
  !>     If \f$s = 2\f$ and uplo is upper, then \f$D_k\f$ is stored in \f$A[k-1,k-1]\f$, \f$A[k-1,k]\f$,
  !>     and \f$A[k,k]\f$, and \f$v\f$ is stored in the upper parts of columns \f$k-1\f$ and \f$k\f$ of \f$A\f$.
  !>     If \f$s = 2\f$ and uplo is lower, then \f$D_k\f$ is stored in \f$A[k,k]\f$, \f$A[k+1,k]\f$,
  !>     and \f$A[k+1,k+1]\f$, and \f$v\f$ is stored in the lower parts of columns \f$k\f$ and \f$k+1\f$ of \f$A\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the matrix A is stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower)
  !>                 part of A is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of the matrix A.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.
  !>                 On entry, the symmetric matrix A to be factored.
  !>                 On exit, the block diagonal matrix D and the multipliers needed to
  !>                 compute U or L.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of A.
  !>     @param[out]
  !>     ipiv        pointer to rocblas_int. Array on the GPU of dimension n.
  !>                 The vector of pivot indices. Elements of ipiv are 1-based indices.
  !>                 For 1 <= k <= n, if ipiv[k] > 0 then rows and columns k and ipiv[k]
  !>                 were interchanged and D[k,k] is a 1-by-1 diagonal block.
  !>                 If, instead, ipiv[k] = ipiv[k-1] < 0 and uplo is upper (or ipiv[k]
  !>                 = ipiv[k+1] < 0 and uplo is lower), then rows and columns k-1 and
  !>                 -ipiv[k] (or rows and columns k+1 and -ipiv[k]) were interchanged
  !>                 and D[k-1,k-1] to D[k,k] (or D[k,k] to D[k+1,k+1]) is a 2-by-2
  !>                 diagonal block.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0, D is singular. D[i,i] is the first diagonal zero.
  !>     
  interface rocsolver_ssytrf
    function rocsolver_ssytrf_(handle,uplo,n,A,lda,ipiv,myInfo) bind(c, name="rocsolver_ssytrf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytrf_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssytrf_full_rank,&
      
rocsolver_ssytrf_rank_0,&
      
rocsolver_ssytrf_rank_1
#endif

  end interface
  
  interface rocsolver_dsytrf
    function rocsolver_dsytrf_(handle,uplo,n,A,lda,ipiv,myInfo) bind(c, name="rocsolver_dsytrf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytrf_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsytrf_full_rank,&
      
rocsolver_dsytrf_rank_0,&
      
rocsolver_dsytrf_rank_1
#endif

  end interface
  
  interface rocsolver_csytrf
    function rocsolver_csytrf_(handle,uplo,n,A,lda,ipiv,myInfo) bind(c, name="rocsolver_csytrf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_csytrf_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_csytrf_full_rank,&
      
rocsolver_csytrf_rank_0,&
      
rocsolver_csytrf_rank_1
#endif

  end interface
  
  interface rocsolver_zsytrf
    function rocsolver_zsytrf_(handle,uplo,n,A,lda,ipiv,myInfo) bind(c, name="rocsolver_zsytrf")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zsytrf_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zsytrf_full_rank,&
      
rocsolver_zsytrf_rank_0,&
      
rocsolver_zsytrf_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYTRF_BATCHED computes the factorization of a batch of symmetric indefinite
  !>     matrices using Bunch-Kaufman diagonal pivoting.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The factorization has the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l^{} = U_l^{} D_l^{} U_l^T & \: \text{or}\\
  !>         A_l^{} = L_l^{} D_l^{} L_l^T &
  !>         \end{array}
  !>     \f]
  !> 
  !>     where \f$U_l\f$ or \f$L_l\f$ is a product of permutation and unit upperlower
  !>     triangular matrices (depending on the value of uplo), and \f$D_l\f$ is a symmetric
  !>     block diagonal matrix with 1-by-1 and 2-by-2 diagonal blocks \f$D_{kl}\f$.
  !> 
  !>     Specifically, \f$U_l\f$ and \f$L_l\f$ are computed as
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U_l = P_l(n) U_l(n) \cdots P_l(k) U_l(k) \cdots & \: \text{and}\\
  !>         L_l = P_l(1) L_l(1) \cdots P_l(k) L_l(k) \cdots &
  !>         \end{array}
  !>     \f]
  !> 
  !>     where \f$k\f$ decreases from \f$n\f$ to 1 (increases from 1 to \f$n\f$) in steps of 1 or 2,
  !>     depending on the order of block \f$D_{kl}\f$, and \f$P_l(k)\f$ is a permutation matrix defined by
  !>     \f$ipiv_l[k]\f$. If we let \f$s\f$ denote the order of block \f$D_{kl}\f$, then \f$U_l(k)\f$
  !>     and \f$L_l(k)\f$ are unit upperlower triangular matrices defined as
  !> 
  !>     \f[
  !>         U_l(k) = \left[ \begin{array}{ccc}
  !>         I_{k-s} & v & 0 \\
  !>         0 & I_s & 0 \\
  !>         0 & 0 & I_{n-k}
  !>         \end{array} \right]
  !>     \f]
  !> 
  !>     and
  !> 
  !>     \f[
  !>         L_l(k) = \left[ \begin{array}{ccc}
  !>         I_{k-1} & 0 & 0 \\
  !>         0 & I_s & 0 \\
  !>         0 & v & I_{n-k-s+1}
  !>         \end{array} \right].
  !>     \f]
  !> 
  !>     If \f$s = 1\f$, then \f$D_{kl}\f$ is stored in \f$A_l[k,k]\f$ and \f$v\f$ is stored in the upperlower
  !>     part of column \f$k\f$ of \f$A_l\f$.
  !>     If \f$s = 2\f$ and uplo is upper, then \f$D_{kl}\f$ is stored in \f$A_l[k-1,k-1]\f$, \f$A_l[k-1,k]\f$,
  !>     and \f$A_l[k,k]\f$, and \f$v\f$ is stored in the upper parts of columns \f$k-1\f$ and \f$k\f$ of \f$A_l\f$.
  !>     If \f$s = 2\f$ and uplo is lower, then \f$D_{kl}\f$ is stored in \f$A_l[k,k]\f$, \f$A_l[k+1,k]\f$,
  !>     and \f$A_l[k+1,k+1]\f$, and \f$v\f$ is stored in the lower parts of columns \f$k\f$ and \f$k+1\f$ of \f$A_l\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the matrices A_l are stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower)
  !>                 part of A_l is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of all matrices A_l in the batch.
  !>     @param[inout]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.
  !>                 On entry, the symmetric matrices A_l to be factored.
  !>                 On exit, the block diagonal matrices D_l and the multipliers needed to
  !>                 compute U_l or L_l.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[out]
  !>     ipiv        pointer to rocblas_int. Array on the GPU of dimension n.
  !>                 The vector of pivot indices. Elements of ipiv are 1-based indices.
  !>                 For 1 <= k <= n, if ipiv_l[k] > 0 then rows and columns k and ipiv_l[k]
  !>                 were interchanged and D_l[k,k] is a 1-by-1 diagonal block.
  !>                 If, instead, ipiv_l[k] = ipiv_l[k-1] < 0 and uplo is upper (or ipiv_l[k]
  !>                 = ipiv_l[k+1] < 0 and uplo is lower), then rows and columns k-1 and
  !>                 -ipiv_l[k] (or rows and columns k+1 and -ipiv_l[k]) were interchanged
  !>                 and D_l[k-1,k-1] to D_l[k,k] (or D_l[k,k] to D_l[k+1,k+1]) is a 2-by-2
  !>                 diagonal block.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value of strideP. Normal use case is strideP >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for factorization of A_l.
  !>                 If info[l] = i > 0, D_l is singular. D_l[i,i] is the first diagonal zero.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_ssytrf_batched
    function rocsolver_ssytrf_batched_(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_ssytrf_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytrf_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssytrf_batched_full_rank,&
      
rocsolver_ssytrf_batched_rank_0,&
      
rocsolver_ssytrf_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dsytrf_batched
    function rocsolver_dsytrf_batched_(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_dsytrf_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytrf_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsytrf_batched_full_rank,&
      
rocsolver_dsytrf_batched_rank_0,&
      
rocsolver_dsytrf_batched_rank_1
#endif

  end interface
  
  interface rocsolver_csytrf_batched
    function rocsolver_csytrf_batched_(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_csytrf_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_csytrf_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_csytrf_batched_full_rank,&
      
rocsolver_csytrf_batched_rank_0,&
      
rocsolver_csytrf_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zsytrf_batched
    function rocsolver_zsytrf_batched_(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_zsytrf_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zsytrf_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zsytrf_batched_full_rank,&
      
rocsolver_zsytrf_batched_rank_0,&
      
rocsolver_zsytrf_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SYTRF_STRIDED_BATCHED computes the factorization of a batch of symmetric indefinite
  !>     matrices using Bunch-Kaufman diagonal pivoting.
  !> 
  !>     \details
  !>     (This is the blocked version of the algorithm).
  !> 
  !>     The factorization has the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_l^{} = U_l^{} D_l^{} U_l^T & \: \text{or}\\
  !>         A_l^{} = L_l^{} D_l^{} L_l^T &
  !>         \end{array}
  !>     \f]
  !> 
  !>     where \f$U_l\f$ or \f$L_l\f$ is a product of permutation and unit upperlower
  !>     triangular matrices (depending on the value of uplo), and \f$D_l\f$ is a symmetric
  !>     block diagonal matrix with 1-by-1 and 2-by-2 diagonal blocks \f$D_{kl}\f$.
  !> 
  !>     Specifically, \f$U_l\f$ and \f$L_l\f$ are computed as
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         U_l = P_l(n) U_l(n) \cdots P_l(k) U_l(k) \cdots & \: \text{and}\\
  !>         L_l = P_l(1) L_l(1) \cdots P_l(k) L_l(k) \cdots &
  !>         \end{array}
  !>     \f]
  !> 
  !>     where \f$k\f$ decreases from \f$n\f$ to 1 (increases from 1 to \f$n\f$) in steps of 1 or 2,
  !>     depending on the order of block \f$D_{kl}\f$, and \f$P_l(k)\f$ is a permutation matrix defined by
  !>     \f$ipiv_l[k]\f$. If we let \f$s\f$ denote the order of block \f$D_{kl}\f$, then \f$U_l(k)\f$
  !>     and \f$L_l(k)\f$ are unit upperlower triangular matrices defined as
  !> 
  !>     \f[
  !>         U_l(k) = \left[ \begin{array}{ccc}
  !>         I_{k-s} & v & 0 \\
  !>         0 & I_s & 0 \\
  !>         0 & 0 & I_{n-k}
  !>         \end{array} \right]
  !>     \f]
  !> 
  !>     and
  !> 
  !>     \f[
  !>         L_l(k) = \left[ \begin{array}{ccc}
  !>         I_{k-1} & 0 & 0 \\
  !>         0 & I_s & 0 \\
  !>         0 & v & I_{n-k-s+1}
  !>         \end{array} \right].
  !>     \f]
  !> 
  !>     If \f$s = 1\f$, then \f$D_{kl}\f$ is stored in \f$A_l[k,k]\f$ and \f$v\f$ is stored in the upperlower
  !>     part of column \f$k\f$ of \f$A_l\f$.
  !>     If \f$s = 2\f$ and uplo is upper, then \f$D_{kl}\f$ is stored in \f$A_l[k-1,k-1]\f$, \f$A_l[k-1,k]\f$,
  !>     and \f$A_l[k,k]\f$, and \f$v\f$ is stored in the upper parts of columns \f$k-1\f$ and \f$k\f$ of \f$A_l\f$.
  !>     If \f$s = 2\f$ and uplo is lower, then \f$D_l(k)\f$ is stored in \f$A_l[k,k]\f$, \f$A_l[k+1,k]\f$,
  !>     and \f$A_l[k+1,k+1]\f$, and \f$v\f$ is stored in the lower parts of columns \f$k\f$ and \f$k+1\f$ of \f$A_l\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     uplo        rocblas_fill.
  !>                 Specifies whether the upper or lower part of the matrices A_l are stored.
  !>                 If uplo indicates lower (or upper), then the upper (or lower)
  !>                 part of A_l is not used.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows and columns of all matrices A_l in the batch.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 On entry, the symmetric matrices A_l to be factored.
  !>                 On exit, the block diagonal matrices D_l and the multipliers needed to
  !>                 compute U_l or L_l.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= n.
  !>                 Specifies the leading dimension of matrices A_l.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one matrix A_l to the next one A_(l+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan
  !>     @param[out]
  !>     ipiv        pointer to rocblas_int. Array on the GPU of dimension n.
  !>                 The vector of pivot indices. Elements of ipiv are 1-based indices.
  !>                 For 1 <= k <= n, if ipiv_l[k] > 0 then rows and columns k and ipiv_l[k]
  !>                 were interchanged and D_l[k,k] is a 1-by-1 diagonal block.
  !>                 If, instead, ipiv_l[k] = ipiv_l[k-1] < 0 and uplo is upper (or ipiv_l[k]
  !>                 = ipiv_l[k+1] < 0 and uplo is lower), then rows and columns k-1 and
  !>                 -ipiv_l[k] (or rows and columns k+1 and -ipiv_l[k]) were interchanged
  !>                 and D_l[k-1,k-1] to D_l[k,k] (or D_l[k,k] to D_l[k+1,k+1]) is a 2-by-2
  !>                 diagonal block.
  !>     @param[in]
  !>     strideP     rocblas_stride.
  !>                 Stride from the start of one vector ipiv_l to the next one ipiv_(l+1).
  !>                 There is no restriction for the value of strideP. Normal use case is strideP >= n.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for factorization of A_l.
  !>                 If info[l] = i > 0, D_l is singular. D_l[i,i] is the first diagonal zero.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_ssytrf_strided_batched
    function rocsolver_ssytrf_strided_batched_(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_ssytrf_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytrf_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_ssytrf_strided_batched_full_rank,&
      
rocsolver_ssytrf_strided_batched_rank_0,&
      
rocsolver_ssytrf_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dsytrf_strided_batched
    function rocsolver_dsytrf_strided_batched_(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_dsytrf_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytrf_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dsytrf_strided_batched_full_rank,&
      
rocsolver_dsytrf_strided_batched_rank_0,&
      
rocsolver_dsytrf_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_csytrf_strided_batched
    function rocsolver_csytrf_strided_batched_(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_csytrf_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_csytrf_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_csytrf_strided_batched_full_rank,&
      
rocsolver_csytrf_strided_batched_rank_0,&
      
rocsolver_csytrf_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zsytrf_strided_batched
    function rocsolver_zsytrf_strided_batched_(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count) bind(c, name="rocsolver_zsytrf_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zsytrf_strided_batched_
      type(c_ptr),value :: handle
      integer(kind(rocblas_fill_upper)),value :: uplo
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zsytrf_strided_batched_full_rank,&
      
rocsolver_zsytrf_strided_batched_rank_0,&
      
rocsolver_zsytrf_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GEBLTTRF_NPVT computes the LU factorization of a block tridiagonal matrix without partial pivoting.
  !> 
  !>     \details The LU factorization of a block tridiagonal matrix
  !> 
  !>     \f[
  !>         M = \left[\begin{array}{ccccc}
  !>         B_1 & C_1\\
  !>         A_1 & B_2 & C_2\\
  !>          & \ddots & \ddots & \ddots \\
  !>          &  & A_{n-2} & B_{n-1} & C_{n-1}\\
  !>          &  &  & A_{n-1} & B_n
  !>         \end{array}\right]
  !>     \f]
  !> 
  !>     with \f$n = \mathrm{nblocks}\f$ diagonal blocks of size nb, can be represented as
  !> 
  !>     \f[
  !>         M = \left[\begin{array}{cccc}
  !>         L_1 \\
  !>         A_1 & L_2\\
  !>          & \ddots & \ddots \\
  !>          &  & A_{n-1} & L_n
  !>         \end{array}\right] \left[\begin{array}{cccc}
  !>         I & U_1 \\
  !>          & \ddots & \ddots \\
  !>          &  & I & U_{n-1}\\
  !>          &  &  & I
  !>         \end{array}\right] = LU
  !>     \f]
  !> 
  !>     where the blocks \f$L_i\f$ and \f$U_i\f$ are also general blocks of size nb.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     nb          rocblas_int. nb >= 0.
  !>                 The number of rows and columns of each block.
  !>     @param[in]
  !>     nblocks     rocblas_int. nblocks >= 0.
  !>                 The number of blocks along the diagonal of the matrix.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU of dimension ldanb(nblocks-1).
  !>                 Contains the blocks A_i arranged one after the other.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= nb.
  !>                 Specifies the leading dimension of blocks A_i.
  !>     @param[inout]
  !>     B           pointer to type. Array on the GPU of dimension ldbnbnblocks.
  !>                 On entry, contains the blocks B_i arranged one after the other.
  !>                 On exit it is overwritten by blocks L_i in factorized form as returned by
  !>                 \ref rocsolver_sgetrf_npvt "GETRF_NPVT"
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= nb.
  !>                 Specifies the leading dimension of blocks B_i.
  !>     @param[inout]
  !>     C           pointer to type. Array on the GPU of dimension ldcnb(nblocks-1).
  !>                 On entry, contains the blocks C_i arranged one after the other.
  !>                 On exit it is overwritten by blocks U_i.
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= nb.
  !>                 Specifies the leading dimension of blocks C_i.
  !>     @param[out]
  !>     info        pointer to a rocblas_int on the GPU.
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0, the matrix is singular.
  !>     
  interface rocsolver_sgeblttrf_npvt
    function rocsolver_sgeblttrf_npvt_(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo) bind(c, name="rocsolver_sgeblttrf_npvt")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrf_npvt_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgeblttrf_npvt_full_rank,&
      
rocsolver_sgeblttrf_npvt_rank_0,&
      
rocsolver_sgeblttrf_npvt_rank_1
#endif

  end interface
  
  interface rocsolver_dgeblttrf_npvt
    function rocsolver_dgeblttrf_npvt_(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo) bind(c, name="rocsolver_dgeblttrf_npvt")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrf_npvt_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgeblttrf_npvt_full_rank,&
      
rocsolver_dgeblttrf_npvt_rank_0,&
      
rocsolver_dgeblttrf_npvt_rank_1
#endif

  end interface
  
  interface rocsolver_cgeblttrf_npvt
    function rocsolver_cgeblttrf_npvt_(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo) bind(c, name="rocsolver_cgeblttrf_npvt")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrf_npvt_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgeblttrf_npvt_full_rank,&
      
rocsolver_cgeblttrf_npvt_rank_0,&
      
rocsolver_cgeblttrf_npvt_rank_1
#endif

  end interface
  
  interface rocsolver_zgeblttrf_npvt
    function rocsolver_zgeblttrf_npvt_(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo) bind(c, name="rocsolver_zgeblttrf_npvt")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrf_npvt_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgeblttrf_npvt_full_rank,&
      
rocsolver_zgeblttrf_npvt_rank_0,&
      
rocsolver_zgeblttrf_npvt_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GEBLTTRF_NPVT_BATCHED computes the LU factorization of a batch of block tridiagonal matrices without
  !>     partial pivoting.
  !> 
  !>     \details The LU factorization of a block tridiagonal matrix \f$M_l\f$ in the batch
  !> 
  !>     \f[
  !>         M_l = \left[\begin{array}{ccccc}
  !>         B_{l1} & C_{l1}\\
  !>         A_{l1} & B_{l2} & C_{l2}\\
  !>          & \ddots & \ddots & \ddots \\
  !>          &  & A_{l(n-2)} & B_{l(n-1)} & C_{l(l-1)}\\
  !>          &  &  & A_{l(n-1)} & B_{ln}
  !>         \end{array}\right]
  !>     \f]
  !> 
  !>     with \f$n = \mathrm{nblocks}\f$ diagonal blocks of size nb, can be represented as
  !> 
  !>     \f[
  !>         M_l = \left[\begin{array}{cccc}
  !>         L_{l1} \\
  !>         A_{l1} & L_{l2}\\
  !>          & \ddots & \ddots \\
  !>          &  & A_{l(n-1)} & L_{ln}
  !>         \end{array}\right] \left[\begin{array}{cccc}
  !>         I & U_{l1} \\
  !>          & \ddots & \ddots \\
  !>          &  & I & U_{l(n-1)}\\
  !>          &  &  & I
  !>         \end{array}\right] = L_lU_l
  !>     \f]
  !> 
  !>     where the blocks \f$L_{li}\f$ and \f$U_{li}\f$ are also general blocks of size nb.
  !> 
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     nb          rocblas_int. nb >= 0.
  !>                 The number of rows and columns of each block.
  !>     @param[in]
  !>     nblocks     rocblas_int. nblocks >= 0.
  !>                 The number of blocks along the diagonal of each matrix in the batch.
  !>     @param[in]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension
  !>                 ldanb(nblocks-1).
  !>                 Contains the blocks A_{li} arranged one after the other.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= nb.
  !>                 Specifies the leading dimension of blocks A_{li}.
  !>     @param[inout]
  !>     B           array of pointers to type. Each pointer points to an array on the GPU of dimension
  !>                 ldbnbnblocks.
  !>                 On entry, contains the blocks B_{li} arranged one after the other.
  !>                 On exit it is overwritten by blocks L_{li} in factorized form as returned by
  !>                 \ref rocsolver_sgetrf_npvt "GETRF_NPVT"
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= nb.
  !>                 Specifies the leading dimension of blocks B_{li}.
  !>     @param[inout]
  !>     C           array of pointers to type. Each pointer points to an array on the GPU of dimension
  !>                 ldcnb(nblocks-1).
  !>                 On entry, contains the blocks C_{li} arranged one after the other.
  !>                 On exit it is overwritten by blocks U_{li}.
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= nb.
  !>                 Specifies the leading dimension of blocks C_{li}.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for factorization of l-th batch instance.
  !>                 If info[l] = i > 0, the l-th batch instance is singular.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgeblttrf_npvt_batched
    function rocsolver_sgeblttrf_npvt_batched_(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo,batch_count) bind(c, name="rocsolver_sgeblttrf_npvt_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrf_npvt_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgeblttrf_npvt_batched_full_rank,&
      
rocsolver_sgeblttrf_npvt_batched_rank_0,&
      
rocsolver_sgeblttrf_npvt_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgeblttrf_npvt_batched
    function rocsolver_dgeblttrf_npvt_batched_(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo,batch_count) bind(c, name="rocsolver_dgeblttrf_npvt_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrf_npvt_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgeblttrf_npvt_batched_full_rank,&
      
rocsolver_dgeblttrf_npvt_batched_rank_0,&
      
rocsolver_dgeblttrf_npvt_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgeblttrf_npvt_batched
    function rocsolver_cgeblttrf_npvt_batched_(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo,batch_count) bind(c, name="rocsolver_cgeblttrf_npvt_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrf_npvt_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgeblttrf_npvt_batched_full_rank,&
      
rocsolver_cgeblttrf_npvt_batched_rank_0,&
      
rocsolver_cgeblttrf_npvt_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgeblttrf_npvt_batched
    function rocsolver_zgeblttrf_npvt_batched_(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo,batch_count) bind(c, name="rocsolver_zgeblttrf_npvt_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrf_npvt_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgeblttrf_npvt_batched_full_rank,&
      
rocsolver_zgeblttrf_npvt_batched_rank_0,&
      
rocsolver_zgeblttrf_npvt_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GEBLTTRF_NPVT_STRIDED_BATCHED computes the LU factorization of a batch of block tridiagonal
  !>     matrices without partial pivoting.
  !> 
  !>     \details The LU factorization of a block tridiagonal matrix \f$M_l\f$ in the batch
  !> 
  !>     \f[
  !>         M_l = \left[\begin{array}{ccccc}
  !>         B_{l1} & C_{l1}\\
  !>         A_{l1} & B_{l2} & C_{l2}\\
  !>          & \ddots & \ddots & \ddots \\
  !>          &  & A_{l(n-2)} & B_{l(n-1)} & C_{l(n-1)}\\
  !>          &  &  & A_{l(n-1)} & B_{ln}
  !>         \end{array}\right]
  !>     \f]
  !> 
  !>     with \f$n = \mathrm{nblocks}\f$ diagonal blocks of size nb, can be represented as
  !> 
  !>     \f[
  !>         M_l = \left[\begin{array}{cccc}
  !>         L_{l1} \\
  !>         A_{l1} & L_{l2}\\
  !>          & \ddots & \ddots \\
  !>          &  & A_{l(n-1)} & L_{ln}
  !>         \end{array}\right] \left[\begin{array}{cccc}
  !>         I & U_{l1} \\
  !>          & \ddots & \ddots \\
  !>          &  & I & U_{l(n-1)}\\
  !>          &  &  & I
  !>         \end{array}\right] = L_lU_l
  !>     \f]
  !> 
  !>     where the blocks \f$L_{li}\f$ and \f$U_{li}\f$ are also general blocks of size nb.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     nb          rocblas_int. nb >= 0.
  !>                 The number of rows and columns of each block.
  !>     @param[in]
  !>     nblocks     rocblas_int. nblocks >= 0.
  !>                 The number of blocks along the diagonal of each matrix in the batch.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 Contains the blocks A_{li} arranged one after the other.
  !>     @param[in]
  !>     lda         rocblas_int. lda >= nb.
  !>                 Specifies the leading dimension of blocks A_{li}.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one block A_{li} to the same block in the next batch
  !>                 instance A_{(l+1)i}.
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >=
  !>                 ldanbnblocks.
  !>     @param[inout]
  !>     B           pointer to type. Array on the GPU (the size depends on the value of strideB).
  !>                 On entry, contains the blocks B_{li} arranged one after the other.
  !>                 On exit it is overwritten by blocks L_{li} in factorized form as returned by
  !>                 \ref rocsolver_sgetrf_npvt "GETRF_NPVT"
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= nb.
  !>                 Specifies the leading dimension of matrix blocks B_{li}.
  !>     @param[in]
  !>     strideB     rocblas_stride.
  !>                 Stride from the start of one block B_{li} to the same block in the next batch
  !>                 instance B_{(l+1)i}.
  !>                 There is no restriction for the value of strideB. Normal use case is strideB >=
  !>                 ldbnbnblocks.
  !>     @param[inout]
  !>     C           pointer to type. Array on the GPU (the size depends on the value of strideC).
  !>                 On entry, contains the blocks C_{li} arranged one after the other.
  !>                 On exit it is overwritten by blocks U_{li}.
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= nb.
  !>                 Specifies the leading dimension of matrix blocks C_{li}.
  !>     @param[in]
  !>     strideC     rocblas_stride.
  !>                 Stride from the start of one block B_{li} to the same block in the next batch
  !>                 instance B_{(l+1)i}.
  !>                 There is no restriction for the value of strideC. Normal use case is strideC >=
  !>                 ldcnbnblocks.
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for factorization of l-th batch instance.
  !>                 If info[l] = i > 0, the l-th batch instance is singular.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgeblttrf_npvt_strided_batched
    function rocsolver_sgeblttrf_npvt_strided_batched_(handle,nb,nblocks,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,myInfo,batch_count) bind(c, name="rocsolver_sgeblttrf_npvt_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrf_npvt_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgeblttrf_npvt_strided_batched_full_rank,&
      
rocsolver_sgeblttrf_npvt_strided_batched_rank_0,&
      
rocsolver_sgeblttrf_npvt_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgeblttrf_npvt_strided_batched
    function rocsolver_dgeblttrf_npvt_strided_batched_(handle,nb,nblocks,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,myInfo,batch_count) bind(c, name="rocsolver_dgeblttrf_npvt_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrf_npvt_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgeblttrf_npvt_strided_batched_full_rank,&
      
rocsolver_dgeblttrf_npvt_strided_batched_rank_0,&
      
rocsolver_dgeblttrf_npvt_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgeblttrf_npvt_strided_batched
    function rocsolver_cgeblttrf_npvt_strided_batched_(handle,nb,nblocks,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,myInfo,batch_count) bind(c, name="rocsolver_cgeblttrf_npvt_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrf_npvt_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgeblttrf_npvt_strided_batched_full_rank,&
      
rocsolver_cgeblttrf_npvt_strided_batched_rank_0,&
      
rocsolver_cgeblttrf_npvt_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgeblttrf_npvt_strided_batched
    function rocsolver_zgeblttrf_npvt_strided_batched_(handle,nb,nblocks,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,myInfo,batch_count) bind(c, name="rocsolver_zgeblttrf_npvt_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrf_npvt_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgeblttrf_npvt_strided_batched_full_rank,&
      
rocsolver_zgeblttrf_npvt_strided_batched_rank_0,&
      
rocsolver_zgeblttrf_npvt_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GEBLTTRF_NPVT_INTERLEAVED_BATCHED computes the LU factorization of a batch of block tridiagonal
  !>     matrices without partial pivoting.
  !> 
  !>     \details The LU factorization of a block tridiagonal matrix \f$M_l\f$ in the batch
  !> 
  !>     \f[
  !>         M_l = \left[\begin{array}{ccccc}
  !>         B_{l1} & C_{l1}\\
  !>         A_{l1} & B_{l2} & C_{l2}\\
  !>          & \ddots & \ddots & \ddots \\
  !>          &  & A_{l(n-2)} & B_{l(n-1)} & C_{l(n-1)}\\
  !>          &  &  & A_{l(n-1)} & B_{ln}
  !>         \end{array}\right]
  !>     \f]
  !> 
  !>     with \f$n = \mathrm{nblocks}\f$ diagonal blocks of size nb, can be represented as
  !> 
  !>     \f[
  !>         M_l = \left[\begin{array}{cccc}
  !>         L_{l1} \\
  !>         A_{l1} & L_{l2}\\
  !>          & \ddots & \ddots \\
  !>          &  & A_{l(n-1)} & L_{ln}
  !>         \end{array}\right] \left[\begin{array}{cccc}
  !>         I & U_{l1} \\
  !>          & \ddots & \ddots \\
  !>          &  & I & U_{l(n-1)}\\
  !>          &  &  & I
  !>         \end{array}\right] = L_lU_l
  !>     \f]
  !> 
  !>     where the blocks \f$L_{li}\f$ and \f$U_{li}\f$ are also general blocks of size nb.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     nb          rocblas_int. nb >= 0.
  !>                 The number of rows and columns of each block.
  !>     @param[in]
  !>     nblocks     rocblas_int. nblocks >= 0.
  !>                 The number of blocks along the diagonal of each matrix in the batch.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 Contains the blocks A_{li} arranged one after the other.
  !>     @param[in]
  !>     inca        rocblas_int. inca > 0.
  !>                 Stride from the start of one row of A_{li} to the next. Normal use cases are
  !>                 inca = 1 (strided batched case) or inca = batch_count (interleaved batched case).
  !>     @param[in]
  !>     lda         rocblas_int. lda >= inca  nb.
  !>                 Specifies the leading dimension of blocks A_{li}, i.e. the stride from the start
  !>                 of one column of A_{li} to the next.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one block A_{li} to the same block in the next batch
  !>                 instance A_{(l+1)i}.
  !>                 There is no restriction for the value of strideA. Normal use cases are strideA >=
  !>                 ldanbnblocks (strided batched case) or strideA = 1 (interleaved batched case).
  !>     @param[inout]
  !>     B           pointer to type. Array on the GPU (the size depends on the value of strideB).
  !>                 On entry, contains the blocks B_{li} arranged one after the other.
  !>                 On exit it is overwritten by blocks L_{li} in factorized form as returned by
  !>                 \ref rocsolver_sgetrf_npvt "GETRF_NPVT"
  !>     @param[in]
  !>     incb        rocblas_int. incb > 0.
  !>                 Stride from the start of one row of B_{li} to the next. Normal use cases are
  !>                 incb = 1 (strided batched case) or incb = batch_count (interleaved batched case).
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= incb  nb.
  !>                 Specifies the leading dimension of blocks B_{li}, i.e. the stride from the start
  !>                 of one column of B_{li} to the next.
  !>     @param[in]
  !>     strideB     rocblas_stride.
  !>                 Stride from the start of one block B_{li} to the same block in the next batch
  !>                 instance B_{(l+1)i}.
  !>                 There is no restriction for the value of strideB. Normal use cases are strideB >=
  !>                 ldbnbnblocks (strided batched case) or strideB = 1 (interleaved batched case).
  !>     @param[inout]
  !>     C           pointer to type. Array on the GPU (the size depends on the value of strideC).
  !>                 On entry, contains the blocks C_{li} arranged one after the other.
  !>                 On exit it is overwritten by blocks U_{li}.
  !>     @param[in]
  !>     incc        rocblas_int. incc > 0.
  !>                 Stride from the start of one row of C_{li} to the next. Normal use cases are
  !>                 incc = 1 (strided batched case) or incc = batch_count (interleaved batched case).
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= incc  nb.
  !>                 Specifies the leading dimension of blocks C_{li}, i.e. the stride from the start
  !>                 of one column of C_{li} to the next.
  !>     @param[in]
  !>     strideC     rocblas_stride.
  !>                 Stride from the start of one block B_{li} to the same block in the next batch
  !>                 instance B_{(l+1)i}.
  !>                 There is no restriction for the value of strideC. Normal use cases are strideC >=
  !>                 ldcnbnblocks (strided batched case) or strideC = 1 (interleaved batched case).
  !>     @param[out]
  !>     info        pointer to rocblas_int. Array of batch_count integers on the GPU.
  !>                 If info[l] = 0, successful exit for factorization of l-th batch instance.
  !>                 If info[l] = i > 0, the l-th batch instance is singular.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgeblttrf_npvt_interleaved_batched
    function rocsolver_sgeblttrf_npvt_interleaved_batched_(handle,nb,nblocks,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,myInfo,batch_count) bind(c, name="rocsolver_sgeblttrf_npvt_interleaved_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrf_npvt_interleaved_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      type(c_ptr),value :: A
      integer(c_int),value :: inca
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: incb
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: C
      integer(c_int),value :: incc
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgeblttrf_npvt_interleaved_batched_full_rank,&
      
rocsolver_sgeblttrf_npvt_interleaved_batched_rank_0,&
      
rocsolver_sgeblttrf_npvt_interleaved_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgeblttrf_npvt_interleaved_batched
    function rocsolver_dgeblttrf_npvt_interleaved_batched_(handle,nb,nblocks,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,myInfo,batch_count) bind(c, name="rocsolver_dgeblttrf_npvt_interleaved_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrf_npvt_interleaved_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      type(c_ptr),value :: A
      integer(c_int),value :: inca
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: incb
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: C
      integer(c_int),value :: incc
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgeblttrf_npvt_interleaved_batched_full_rank,&
      
rocsolver_dgeblttrf_npvt_interleaved_batched_rank_0,&
      
rocsolver_dgeblttrf_npvt_interleaved_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgeblttrf_npvt_interleaved_batched
    function rocsolver_cgeblttrf_npvt_interleaved_batched_(handle,nb,nblocks,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,myInfo,batch_count) bind(c, name="rocsolver_cgeblttrf_npvt_interleaved_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrf_npvt_interleaved_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      type(c_ptr),value :: A
      integer(c_int),value :: inca
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: incb
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: C
      integer(c_int),value :: incc
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgeblttrf_npvt_interleaved_batched_full_rank,&
      
rocsolver_cgeblttrf_npvt_interleaved_batched_rank_0,&
      
rocsolver_cgeblttrf_npvt_interleaved_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgeblttrf_npvt_interleaved_batched
    function rocsolver_zgeblttrf_npvt_interleaved_batched_(handle,nb,nblocks,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,myInfo,batch_count) bind(c, name="rocsolver_zgeblttrf_npvt_interleaved_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrf_npvt_interleaved_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      type(c_ptr),value :: A
      integer(c_int),value :: inca
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: incb
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: C
      integer(c_int),value :: incc
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgeblttrf_npvt_interleaved_batched_full_rank,&
      
rocsolver_zgeblttrf_npvt_interleaved_batched_rank_0,&
      
rocsolver_zgeblttrf_npvt_interleaved_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GEBLTTRS_NPVT solves a system of linear equations given by a block tridiagonal matrix
  !>     in its factorized form (without partial pivoting).
  !> 
  !>     \details The linear system has the form
  !> 
  !>     \f[
  !>         MX = \left[\begin{array}{ccccc}
  !>         B_1 & C_1\\
  !>         A_1 & B_2 & C_2\\
  !>          & \ddots & \ddots & \ddots \\
  !>          &  & A_{n-2} & B_{n-1} & C_{n-1}\\
  !>          &  &  & A_{n-1} & B_n
  !>         \end{array}\right]\left[\begin{array}{c}
  !>         X_1\\
  !>         X_2\\
  !>         X_3\\
  !>         \vdots\\
  !>         X_n
  !>         \end{array}\right]=\left[\begin{array}{c}
  !>         R_1\\
  !>         R_2\\
  !>         R_3\\
  !>         \vdots\\
  !>         R_n
  !>         \end{array}\right]=R
  !>     \f]
  !> 
  !>     where matrix M has \f$n = \mathrm{nblocks}\f$ diagonal blocks of size nb, and the right-hand-side
  !>     blocks \f$R_i\f$ are general blocks of size nb-by-nrhs. The blocks of matrix M should be in
  !>     the factorized form as returned by \ref rocsolver_sgeblttrf_npvt "GEBLTTRF_NPVT".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     nb          rocblas_int. nb >= 0.
  !>                 The number of rows and columns of each block.
  !>     @param[in]
  !>     nblocks     rocblas_int. nblocks >= 0.
  !>                 The number of blocks along the diagonal of the matrix.
  !>     @param[in]
  !>     nrhs        rocblas_int. nrhs >= 0.
  !>                 The number of right hand sides, i.e., the number of columns of blocks R_i.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU of dimension ldanb(nblocks-1).
  !>                 Contains the blocks A_i as returned by \ref rocsolver_sgeblttrf_npvt "GEBLTTRF_NPVT".
  !>     @param[in]
  !>     lda         rocblas_int. lda >= nb.
  !>                 Specifies the leading dimension of blocks A_i.
  !>     @param[in]
  !>     B           pointer to type. Array on the GPU of dimension ldbnbnblocks.
  !>                 Contains the blocks B_i as returned by \ref rocsolver_sgeblttrf_npvt "GEBLTTRF_NPVT".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= nb.
  !>                 Specifies the leading dimension of blocks B_i.
  !>     @param[in]
  !>     C           pointer to type. Array on the GPU of dimension ldcnb(nblocks-1).
  !>                 Contains the blocks C_i as returned by \ref rocsolver_sgeblttrf_npvt "GEBLTTRF_NPVT".
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= nb.
  !>                 Specifies the leading dimension of blocks C_i.
  !>     @param[inout]
  !>     X           pointer to type. Array on the GPU of dimension ldxnblocksnrhs.
  !>                 On entry, X contains the right-hand-side blocks R_i. It is overwritten by solution
  !>                 vectors X_i on exit.
  !>     @param[in]
  !>     ldx         rocblas_int. ldx >= nb.
  !>                 Specifies the leading dimension of blocks X_i.
  !>     
  interface rocsolver_sgeblttrs_npvt
    function rocsolver_sgeblttrs_npvt_(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx) bind(c, name="rocsolver_sgeblttrs_npvt")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrs_npvt_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: X
      integer(c_int),value :: ldx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgeblttrs_npvt_full_rank,&
      
rocsolver_sgeblttrs_npvt_rank_0,&
      
rocsolver_sgeblttrs_npvt_rank_1
#endif

  end interface
  
  interface rocsolver_dgeblttrs_npvt
    function rocsolver_dgeblttrs_npvt_(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx) bind(c, name="rocsolver_dgeblttrs_npvt")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrs_npvt_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: X
      integer(c_int),value :: ldx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgeblttrs_npvt_full_rank,&
      
rocsolver_dgeblttrs_npvt_rank_0,&
      
rocsolver_dgeblttrs_npvt_rank_1
#endif

  end interface
  
  interface rocsolver_cgeblttrs_npvt
    function rocsolver_cgeblttrs_npvt_(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx) bind(c, name="rocsolver_cgeblttrs_npvt")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrs_npvt_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: X
      integer(c_int),value :: ldx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgeblttrs_npvt_full_rank,&
      
rocsolver_cgeblttrs_npvt_rank_0,&
      
rocsolver_cgeblttrs_npvt_rank_1
#endif

  end interface
  
  interface rocsolver_zgeblttrs_npvt
    function rocsolver_zgeblttrs_npvt_(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx) bind(c, name="rocsolver_zgeblttrs_npvt")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrs_npvt_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: X
      integer(c_int),value :: ldx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgeblttrs_npvt_full_rank,&
      
rocsolver_zgeblttrs_npvt_rank_0,&
      
rocsolver_zgeblttrs_npvt_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GEBLTTRS_NPVT_BATCHED solves a batch of system of linear equations given by block tridiagonal
  !>     matrices in its factorized form (without partial pivoting).
  !> 
  !>     \details Each linear system has the form
  !> 
  !>     \f[
  !>         M_lX_l = \left[\begin{array}{ccccc}
  !>         B_{l1} & C_{l1}\\
  !>         A_{l1} & B_{l2} & C_{l2}\\
  !>          & \ddots & \ddots & \ddots \\
  !>          &  & A_{l(n-2)} & B_{l(n-1)} & C_{l(n-1)}\\
  !>          &  &  & A_{l(n-1)} & B_{ln}
  !>         \end{array}\right]\left[\begin{array}{c}
  !>         X_{l1}\\
  !>         X_{l2}\\
  !>         X_{l3}\\
  !>         \vdots\\
  !>         X_{ln}
  !>         \end{array}\right]=\left[\begin{array}{c}
  !>         R_{l1}\\
  !>         R_{l2}\\
  !>         R_{l3}\\
  !>         \vdots\\
  !>         R_{ln}
  !>         \end{array}\right]=R_l
  !>     \f]
  !> 
  !>     where matrix \f$M_l\f$ has \f$n = \mathrm{nblocks}\f$ diagonal blocks of size nb, and the right-hand-side
  !>     blocks \f$R_{li}\f$ are general blocks of size nb-by-nrhs. The blocks of matrix \f$M_l\f$ should be in
  !>     the factorized form as returned by \ref rocsolver_sgeblttrf_npvt_batched "GEBLTTRF_NPVT_BATCHED".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     nb          rocblas_int. nb >= 0.
  !>                 The number of rows and columns of each block.
  !>     @param[in]
  !>     nblocks     rocblas_int. nblocks >= 0.
  !>                 The number of blocks along the diagonal of each matrix in the batch.
  !>     @param[in]
  !>     nrhs        rocblas_int. nrhs >= 0.
  !>                 The number of right hand sides, i.e., the number of columns of blocks R_{li}.
  !>     @param[in]
  !>     A           array of pointers to type. Each pointer points to an array on the GPU of dimension
  !>                 ldanb(nblocks-1).
  !>                 Contains the blocks A_{li} as returned by \ref rocsolver_sgeblttrf_npvt_batched "GEBLTTRF_NPVT_BATCHED".
  !>     @param[in]
  !>     lda         rocblas_int. lda >= nb.
  !>                 Specifies the leading dimension of blocks A_{li}.
  !>     @param[in]
  !>     B           array of pointers to type. Each pointer points to an array on the GPU of dimension
  !>                 ldanbnblocks.
  !>                 Contains the blocks B_{li} as returned by \ref rocsolver_sgeblttrf_npvt_batched "GEBLTTRF_NPVT_BATCHED".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= nb.
  !>                 Specifies the leading dimension of blocks B_{li}.
  !>     @param[in]
  !>     C           array of pointers to type. Each pointer points to an array on the GPU of dimension
  !>                 ldcnb(nblocks-1).
  !>                 Contains the blocks C_{li} as returned by \ref rocsolver_sgeblttrf_npvt_batched "GEBLTTRF_NPVT_BATCHED".
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= nb.
  !>                 Specifies the leading dimension of blocks C_{li}.
  !>     @param[inout]
  !>     X           array of pointers to type. Each pointer points to an array on the GPU of dimension
  !>                 ldxnblocksnrhs.
  !>                 On entry, X contains the right-hand-side blocks R_{li}. It is overwritten by solution
  !>                 vectors X_{li} on exit.
  !>     @param[in]
  !>     ldx         rocblas_int. ldx >= nb.
  !>                 Specifies the leading dimension of blocks X_{li}.
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgeblttrs_npvt_batched
    function rocsolver_sgeblttrs_npvt_batched_(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx,batch_count) bind(c, name="rocsolver_sgeblttrs_npvt_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrs_npvt_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      type(c_ptr) :: X
      integer(c_int),value :: ldx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgeblttrs_npvt_batched_full_rank,&
      
rocsolver_sgeblttrs_npvt_batched_rank_0,&
      
rocsolver_sgeblttrs_npvt_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgeblttrs_npvt_batched
    function rocsolver_dgeblttrs_npvt_batched_(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx,batch_count) bind(c, name="rocsolver_dgeblttrs_npvt_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrs_npvt_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      type(c_ptr) :: X
      integer(c_int),value :: ldx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgeblttrs_npvt_batched_full_rank,&
      
rocsolver_dgeblttrs_npvt_batched_rank_0,&
      
rocsolver_dgeblttrs_npvt_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgeblttrs_npvt_batched
    function rocsolver_cgeblttrs_npvt_batched_(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx,batch_count) bind(c, name="rocsolver_cgeblttrs_npvt_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrs_npvt_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      type(c_ptr) :: X
      integer(c_int),value :: ldx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgeblttrs_npvt_batched_full_rank,&
      
rocsolver_cgeblttrs_npvt_batched_rank_0,&
      
rocsolver_cgeblttrs_npvt_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgeblttrs_npvt_batched
    function rocsolver_zgeblttrs_npvt_batched_(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx,batch_count) bind(c, name="rocsolver_zgeblttrs_npvt_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrs_npvt_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      type(c_ptr) :: X
      integer(c_int),value :: ldx
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgeblttrs_npvt_batched_full_rank,&
      
rocsolver_zgeblttrs_npvt_batched_rank_0,&
      
rocsolver_zgeblttrs_npvt_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GEBLTTRS_NPVT_STRIDED_BATCHED solves a batch of system of linear equations given by block
  !>     tridiagonal matrices in its factorized form (without partial pivoting).
  !> 
  !>     \details Each linear system has the form
  !> 
  !>     \f[
  !>         M_lX_l = \left[\begin{array}{ccccc}
  !>         B_{l1} & C_{l1}\\
  !>         A_{l1} & B_{l2} & C_{l2}\\
  !>          & \ddots & \ddots & \ddots \\
  !>          &  & A_{l(n-2)} & B_{l(n-1)} & C_{l(n-1)}\\
  !>          &  &  & A_{l(n-1)} & B_{ln}
  !>         \end{array}\right]\left[\begin{array}{c}
  !>         X_{l1}\\
  !>         X_{l2}\\
  !>         X_{l3}\\
  !>         \vdots\\
  !>         X_{ln}
  !>         \end{array}\right]=\left[\begin{array}{c}
  !>         R_{l1}\\
  !>         R_{l2}\\
  !>         R_{l3}\\
  !>         \vdots\\
  !>         R_{ln}
  !>         \end{array}\right]=R_l
  !>     \f]
  !> 
  !>     where matrix \f$M_l\f$ has \f$n = \mathrm{nblocks}\f$ diagonal blocks of size nb, and the right-hand-side
  !>     blocks \f$R_{li}\f$ are general blocks of size nb-by-nrhs. The blocks of matrix \f$M_l\f$ should be in
  !>     the factorized form as returned by \ref rocsolver_sgeblttrf_npvt_strided_batched "GEBLTTRF_NPVT_STRIDED_BATCHED".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     nb          rocblas_int. nb >= 0.
  !>                 The number of rows and columns of each block.
  !>     @param[in]
  !>     nblocks     rocblas_int. nblocks >= 0.
  !>                 The number of blocks along the diagonal of each matrix in the batch.
  !>     @param[in]
  !>     nrhs        rocblas_int. nrhs >= 0.
  !>                 The number of right hand sides, i.e., the number of columns of blocks R_{li}.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 Contains the blocks A_{li} as returned by \ref rocsolver_sgeblttrf_npvt_strided_batched "GEBLTTRF_NPVT_STRIDED_BATCHED".
  !>     @param[in]
  !>     lda         rocblas_int. lda >= nb.
  !>                 Specifies the leading dimension of blocks A_{li}.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one block A_{li} to the same block in the next batch
  !>                 instance A_{(l+1)i}.
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >=
  !>                 ldanbnblocks
  !>     @param[in]
  !>     B           pointer to type. Array on the GPU (the size depends on the value of strideB).
  !>                 Contains the blocks B_{li} as returned by \ref rocsolver_sgeblttrf_npvt_strided_batched "GEBLTTRF_NPVT_STRIDED_BATCHED".
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= nb.
  !>                 Specifies the leading dimension of blocks B_{li}.
  !>     @param[in]
  !>     strideB     rocblas_stride.
  !>                 Stride from the start of one block B_{li} to the same block in the next batch
  !>                 instance B_{(l+1)i}.
  !>                 There is no restriction for the value of strideB. Normal use case is strideB >=
  !>                 ldbnbnblocks
  !>     @param[in]
  !>     C           pointer to type. Array on the GPU (the size depends on the value of strideC).
  !>                 Contains the blocks C_{li} as returned by \ref rocsolver_sgeblttrf_npvt_strided_batched "GEBLTTRF_NPVT_STRIDED_BATCHED".
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= nb.
  !>                 Specifies the leading dimension of blocks C_{li}.
  !>     @param[in]
  !>     strideC     rocblas_stride.
  !>                 Stride from the start of one block C_{li} to the same block in the next batch
  !>                 instance C_{(l+1)i}.
  !>                 There is no restriction for the value of strideC. Normal use case is strideC >=
  !>                 ldcnbnblocks
  !>     @param[inout]
  !>     X           pointer to type. Array on the GPU (the size depends on the value of strideX).
  !>                 On entry, X contains the right-hand-side blocks R_{li}. It is overwritten by solution
  !>                 vectors X_{li} on exit.
  !>     @param[in]
  !>     ldx         rocblas_int. ldx >= nb.
  !>                 Specifies the leading dimension of blocks X_{li}.
  !>     @param[in]
  !>     strideX     rocblas_stride.
  !>                 Stride from the start of one block X_{li} to the same block in the next batch
  !>                 instance X_{(l+1)i}.
  !>                 There is no restriction for the value of strideX. Normal use case is strideX >=
  !>                 ldxnblocksnrhs
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgeblttrs_npvt_strided_batched
    function rocsolver_sgeblttrs_npvt_strided_batched_(handle,nb,nblocks,nrhs,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,X,ldx,strideX,batch_count) bind(c, name="rocsolver_sgeblttrs_npvt_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrs_npvt_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      type(c_ptr),value :: X
      integer(c_int),value :: ldx
      integer(c_int64_t),value :: strideX
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgeblttrs_npvt_strided_batched_full_rank,&
      
rocsolver_sgeblttrs_npvt_strided_batched_rank_0,&
      
rocsolver_sgeblttrs_npvt_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgeblttrs_npvt_strided_batched
    function rocsolver_dgeblttrs_npvt_strided_batched_(handle,nb,nblocks,nrhs,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,X,ldx,strideX,batch_count) bind(c, name="rocsolver_dgeblttrs_npvt_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrs_npvt_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      type(c_ptr),value :: X
      integer(c_int),value :: ldx
      integer(c_int64_t),value :: strideX
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgeblttrs_npvt_strided_batched_full_rank,&
      
rocsolver_dgeblttrs_npvt_strided_batched_rank_0,&
      
rocsolver_dgeblttrs_npvt_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgeblttrs_npvt_strided_batched
    function rocsolver_cgeblttrs_npvt_strided_batched_(handle,nb,nblocks,nrhs,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,X,ldx,strideX,batch_count) bind(c, name="rocsolver_cgeblttrs_npvt_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrs_npvt_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      type(c_ptr),value :: X
      integer(c_int),value :: ldx
      integer(c_int64_t),value :: strideX
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgeblttrs_npvt_strided_batched_full_rank,&
      
rocsolver_cgeblttrs_npvt_strided_batched_rank_0,&
      
rocsolver_cgeblttrs_npvt_strided_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgeblttrs_npvt_strided_batched
    function rocsolver_zgeblttrs_npvt_strided_batched_(handle,nb,nblocks,nrhs,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,X,ldx,strideX,batch_count) bind(c, name="rocsolver_zgeblttrs_npvt_strided_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrs_npvt_strided_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      type(c_ptr),value :: X
      integer(c_int),value :: ldx
      integer(c_int64_t),value :: strideX
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgeblttrs_npvt_strided_batched_full_rank,&
      
rocsolver_zgeblttrs_npvt_strided_batched_rank_0,&
      
rocsolver_zgeblttrs_npvt_strided_batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GEBLTTRS_NPVT_INTERLEAVED_BATCHED solves a batch of system of linear equations given by block
  !>     tridiagonal matrices in its factorized form (without partial pivoting).
  !> 
  !>     \details Each linear system has the form
  !> 
  !>     \f[
  !>         M_lX_l = \left[\begin{array}{ccccc}
  !>         B_{l1} & C_{ll}\\
  !>         A_{l1} & B_{ll} & C_{ll}\\
  !>          & \ddots & \ddots & \ddots \\
  !>          &  & A_{l(n-2)} & B_{l(n-1)} & C_{l(n-1)}\\
  !>          &  &  & A_{l(n-1)} & B_{ln}
  !>         \end{array}\right]\left[\begin{array}{c}
  !>         X_{l1}\\
  !>         X_{l2}\\
  !>         X_{l3}\\
  !>         \vdots\\
  !>         X_{ln}
  !>         \end{array}\right]=\left[\begin{array}{c}
  !>         R_{l1}\\
  !>         R_{l2}\\
  !>         R_{l3}\\
  !>         \vdots\\
  !>         R_{ln}
  !>         \end{array}\right]=R_l
  !>     \f]
  !> 
  !>     where matrix \f$M_l\f$ has \f$n = \mathrm{nblocks}\f$ diagonal blocks of size nb, and the right-hand-side
  !>     blocks \f$R_{li}\f$ are general blocks of size nb-by-nrhs. The blocks of matrix \f$M_l\f$ should be in
  !>     the factorized form as returned by \ref rocsolver_sgeblttrf_npvt_interleaved_batched "GEBLTTRF_NPVT_INTERLEAVED_BATCHED".
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     nb          rocblas_int. nb >= 0.
  !>                 The number of rows and columns of each block.
  !>     @param[in]
  !>     nblocks     rocblas_int. nblocks >= 0.
  !>                 The number of blocks along the diagonal of each matrix in the batch.
  !>     @param[in]
  !>     nrhs        rocblas_int. nrhs >= 0.
  !>                 The number of right hand sides, i.e., the number of columns of blocks R_{li}.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).
  !>                 Contains the blocks A_{li} as returned by \ref rocsolver_sgeblttrf_npvt_interleaved_batched "GEBLTTRF_NPVT_INTERLEAVED_BATCHED".
  !>     @param[in]
  !>     inca        rocblas_int. inca > 0.
  !>                 Stride from the start of one row of A_{li} to the next. Normal use cases are
  !>                 inca = 1 (strided batched case) or inca = batch_count (interleaved batched case).
  !>     @param[in]
  !>     lda         rocblas_int. lda >= inca  nb.
  !>                 Specifies the leading dimension of blocks A_{li}, i.e. the stride from the start
  !>                 of one column of A_{li} to the next.
  !>     @param[in]
  !>     strideA     rocblas_stride.
  !>                 Stride from the start of one block A_{li} to the same block in the next batch
  !>                 instance A_{(l+1)i}.
  !>                 There is no restriction for the value of strideA. Normal use cases are strideA >=
  !>                 ldanbnblocks (strided batched case) or strideA = 1 (interleaved batched case).
  !>     @param[in]
  !>     B           pointer to type. Array on the GPU (the size depends on the value of strideB).
  !>                 Contains the blocks B_{li} as returned by \ref rocsolver_sgeblttrf_npvt_interleaved_batched "GEBLTTRF_NPVT_INTERLEAVED_BATCHED".
  !>     @param[in]
  !>     incb        rocblas_int. incb > 0.
  !>                 Stride from the start of one row of B_{li} to the next. Normal use cases are
  !>                 incb = 1 (strided batched case) or incb = batch_count (interleaved batched case).
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= incb  nb.
  !>                 Specifies the leading dimension of blocks B_{li}, i.e. the stride from the start
  !>                 of one column of B_{li} to the next.
  !>     @param[in]
  !>     strideB     rocblas_stride.
  !>                 Stride from the start of one block B_{li} to the same block in the next batch
  !>                 instance B_{(l+1)i}.
  !>                 There is no restriction for the value of strideB. Normal use cases are strideB >=
  !>                 ldbnbnblocks (strided batched case) or strideB = 1 (interleaved batched case).
  !>     @param[in]
  !>     C           pointer to type. Array on the GPU (the size depends on the value of strideC).
  !>                 Contains the blocks C_{li} as returned by \ref rocsolver_sgeblttrf_npvt_interleaved_batched "GEBLTTRF_NPVT_INTERLEAVED_BATCHED".
  !>     @param[in]
  !>     incc        rocblas_int. incc > 0.
  !>                 Stride from the start of one row of C_{li} to the next. Normal use cases are
  !>                 incc = 1 (strided batched case) or incc = batch_count (interleaved batched case).
  !>     @param[in]
  !>     ldc         rocblas_int. ldc >= incc  nb.
  !>                 Specifies the leading dimension of blocks C_{li}, i.e. the stride from the start
  !>                 of one column of C_{li} to the next.
  !>     @param[in]
  !>     strideC     rocblas_stride.
  !>                 Stride from the start of one block C_{li} to the same block in the next batch
  !>                 instance C_{(l+1)i}.
  !>                 There is no restriction for the value of strideC. Normal use cases are strideC >=
  !>                 ldcnbnblocks (strided batched case) or strideC = 1 (interleaved batched case).
  !>     @param[inout]
  !>     X           pointer to type. Array on the GPU (the size depends on the value of strideX).
  !>                 On entry, X contains the right-hand-side blocks R_{li}. It is overwritten by solution
  !>                 vectors X_{li} on exit.
  !>     @param[in]
  !>     incx        rocblas_int. incx > 0.
  !>                 Stride from the start of one row of X_{li} to the next. Normal use cases are
  !>                 incx = 1 (strided batched case) or incx = batch_count (interleaved batched case).
  !>     @param[in]
  !>     ldx         rocblas_int. ldx >= incx  nb.
  !>                 Specifies the leading dimension of blocks X_{li}, i.e. the stride from the start
  !>                 of one column of X_{li} to the next.
  !>     @param[in]
  !>     strideX     rocblas_stride.
  !>                 Stride from the start of one block X_{li} to the same block in the next batch
  !>                 instance X_{(l+1)i}.
  !>                 There is no restriction for the value of strideX. Normal use cases are strideX >=
  !>                 ldxnrhsnblocks (strided batched case) or strideX = 1 (interleaved batched case).
  !>     @param[in]
  !>     batch_count rocblas_int. batch_count >= 0.
  !>                 Number of matrices in the batch.
  !>     
  interface rocsolver_sgeblttrs_npvt_interleaved_batched
    function rocsolver_sgeblttrs_npvt_interleaved_batched_(handle,nb,nblocks,nrhs,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,X,incx,ldx,strideX,batch_count) bind(c, name="rocsolver_sgeblttrs_npvt_interleaved_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrs_npvt_interleaved_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: inca
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: incb
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: C
      integer(c_int),value :: incc
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      type(c_ptr),value :: X
      integer(c_int),value :: incx
      integer(c_int),value :: ldx
      integer(c_int64_t),value :: strideX
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_sgeblttrs_npvt_interleaved_batched_full_rank,&
      
rocsolver_sgeblttrs_npvt_interleaved_batched_rank_0,&
      
rocsolver_sgeblttrs_npvt_interleaved_batched_rank_1
#endif

  end interface
  
  interface rocsolver_dgeblttrs_npvt_interleaved_batched
    function rocsolver_dgeblttrs_npvt_interleaved_batched_(handle,nb,nblocks,nrhs,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,X,incx,ldx,strideX,batch_count) bind(c, name="rocsolver_dgeblttrs_npvt_interleaved_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrs_npvt_interleaved_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: inca
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: incb
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: C
      integer(c_int),value :: incc
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      type(c_ptr),value :: X
      integer(c_int),value :: incx
      integer(c_int),value :: ldx
      integer(c_int64_t),value :: strideX
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dgeblttrs_npvt_interleaved_batched_full_rank,&
      
rocsolver_dgeblttrs_npvt_interleaved_batched_rank_0,&
      
rocsolver_dgeblttrs_npvt_interleaved_batched_rank_1
#endif

  end interface
  
  interface rocsolver_cgeblttrs_npvt_interleaved_batched
    function rocsolver_cgeblttrs_npvt_interleaved_batched_(handle,nb,nblocks,nrhs,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,X,incx,ldx,strideX,batch_count) bind(c, name="rocsolver_cgeblttrs_npvt_interleaved_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrs_npvt_interleaved_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: inca
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: incb
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: C
      integer(c_int),value :: incc
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      type(c_ptr),value :: X
      integer(c_int),value :: incx
      integer(c_int),value :: ldx
      integer(c_int64_t),value :: strideX
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_cgeblttrs_npvt_interleaved_batched_full_rank,&
      
rocsolver_cgeblttrs_npvt_interleaved_batched_rank_0,&
      
rocsolver_cgeblttrs_npvt_interleaved_batched_rank_1
#endif

  end interface
  
  interface rocsolver_zgeblttrs_npvt_interleaved_batched
    function rocsolver_zgeblttrs_npvt_interleaved_batched_(handle,nb,nblocks,nrhs,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,X,incx,ldx,strideX,batch_count) bind(c, name="rocsolver_zgeblttrs_npvt_interleaved_batched")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrs_npvt_interleaved_batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: nb
      integer(c_int),value :: nblocks
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: inca
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: incb
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: C
      integer(c_int),value :: incc
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      type(c_ptr),value :: X
      integer(c_int),value :: incx
      integer(c_int),value :: ldx
      integer(c_int64_t),value :: strideX
      integer(c_int),value :: batch_count
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_zgeblttrs_npvt_interleaved_batched_full_rank,&
      
rocsolver_zgeblttrs_npvt_interleaved_batched_rank_0,&
      
rocsolver_zgeblttrs_npvt_interleaved_batched_rank_1
#endif

  end interface
  !> ! \brief CREATE_RFINFO initializes the structure rfinfo that contains the meta data and descriptors of the involved matrices
  !>         required by the re-factorization functions
  !>     \ref rocsolver_scsrrf_refactlu "CSRRF_REFACTLU" and \ref rocsolver_scsrrf_refactchol "CSRRF_REFACTCHOL", and
  !>         by the direct solver \ref rocsolver_scsrrf_solve "CSRRF_SOLVE".
  !> 
  !>     \details
  !>     @param[out]
  !>     rfinfo      #rocsolver_rfinfo.
  !>                 The pointer to the rfinfo struct to be initialized.
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     
  interface rocsolver_create_rfinfo
    function rocsolver_create_rfinfo_(rfinfo,handle) bind(c, name="rocsolver_create_rfinfo")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_create_rfinfo_
      type(c_ptr) :: rfinfo
      type(c_ptr),value :: handle
    end function


  end interface
  !> ! \brief DESTROY_RFINFO destroys the structure rfinfo used by the re-factorization functions
  !>         \ref rocsolver_scsrrf_refactlu "CSRRF_REFACTLU" and \ref rocsolver_scsrrf_refactchol "CSRRF_REFACTCHOL", and
  !>     by the direct solver \ref rocsolver_scsrrf_solve "CSRRF_SOLVE".
  !> 
  !>     \details
  !>     @param[in]
  !>     rfinfo      #rocsolver_rfinfo.
  !>                 The rfinfo struct to be destroyed.
  !>     
  interface rocsolver_destroy_rfinfo
    function rocsolver_destroy_rfinfo_(rfinfo) bind(c, name="rocsolver_destroy_rfinfo")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_destroy_rfinfo_
      type(c_ptr),value :: rfinfo
    end function


  end interface
  !> ! \brief SET_RFINFO_MODE sets the mode of the structure rfinfo required by the re-factorization functions
  !>     \ref rocsolver_scsrrf_refactlu "CSRRF_REFACTLU" and \ref rocsolver_scsrrf_refactchol "CSRRF_REFACTCHOL", and
  !>         by the direct solver \ref rocsolver_scsrrf_solve "CSRRF_SOLVE".
  !> 
  !>     \details
  !>     @param[in]
  !>     rfinfo      #rocsolver_rfinfo.
  !>                 The rfinfo struct to be set up.
  !>     @param[in]
  !>     mode        #rocsolver_rfinfo_mode.
  !>                                 Use rocsolver_rfinfo_mode_cholesky when the Cholesky factorization is required.
  !>     
  interface rocsolver_set_rfinfo_mode
    function rocsolver_set_rfinfo_mode_(rfinfo,mode) bind(c, name="rocsolver_set_rfinfo_mode")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_set_rfinfo_mode_
      type(c_ptr),value :: rfinfo
      integer(kind(rocsolver_rfinfo_mode_lu)),value :: mode
    end function


  end interface
  !> ! \brief GET_RFINFO_MODE gets the mode of the structure rfinfo required by the re-factorization functions
  !>     \ref rocsolver_scsrrf_refactlu "CSRRF_REFACTLU" and \ref rocsolver_scsrrf_refactchol "CSRRF_REFACTCHOL", and
  !>         by the direct solver \ref rocsolver_scsrrf_solve "CSRRF_SOLVE".
  !> 
  !>     \details
  !>     @param[in]
  !>     rfinfo      #rocsolver_rfinfo.
  !>                 The referenced rfinfo struct.
  !>     @param[out]
  !>     mode        #rocsolver_rfinfo_mode.
  !>                                 The queried mode.
  !>     
  interface rocsolver_get_rfinfo_mode
    function rocsolver_get_rfinfo_mode_(rfinfo,mode) bind(c, name="rocsolver_get_rfinfo_mode")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_get_rfinfo_mode_
      type(c_ptr),value :: rfinfo
      type(c_ptr),value :: mode
    end function


  end interface
  !> ! @{
  !>     \brief CSRRF_SUMLU bundles the factors \f$L\f$ and \f$U\f$, associated with the LU factorization
  !>      of a sparse matrix \f$A\f$, into a single sparse matrix \f$T=(L-I)+U\f$.
  !> 
  !>     \details Factor \f$L\f$ is a sparse lower triangular matrix with unit diagonal elements, and
  !>     \f$U\f$ is a sparse upper triangular matrix. The resulting sparse matrix \f$T\f$ combines both
  !>     sparse factors without storing the unit diagonal; in other words, the number of non-zero
  !>     elements of T, nnzT, is given by nnzT = nnzL - n + nnzU.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows (and columns) of matrix A.
  !>     @param[in]
  !>     nnzL        rocblas_int. nnzL >= n.
  !>                 The number of non-zero elements in L.
  !>     @param[in]
  !>     ptrL        pointer to rocblas_int. Array on the GPU of dimension n+1.
  !>                 It contains the positions of the beginning of each row in indL and valL.
  !>                 The last element of ptrL is equal to nnzL.
  !>     @param[in]
  !>     indL        pointer to rocblas_int. Array on the GPU of dimension nnzL.
  !>                 It contains the column indices of the non-zero elements of L. Indices are
  !>                 sorted by row and by column within each row.
  !>     @param[in]
  !>     valL        pointer to type. Array on the GPU of dimension nnzL.
  !>                 The values of the non-zero elements of L.
  !>     @param[in]
  !>     nnzU        rocblas_int. nnzU >= 0.
  !>                 The number of non-zero elements in U.
  !>     @param[in]
  !>     ptrU        pointer to rocblas_int. Array on the GPU of dimension n+1.
  !>                 It contains the positions of the beginning of each row in indU and valU.
  !>                 The last element of ptrU is equal to nnzU.
  !>     @param[in]
  !>     indU        pointer to rocblas_int. Array on the GPU of dimension nnzU.
  !>                 It contains the column indices of the non-zero elements of U. Indices are
  !>                 sorted by row and by column within each row.
  !>     @param[in]
  !>     valU        pointer to type. Array on the GPU of dimension nnzU.
  !>                 The values of the non-zero elements of U.
  !>     @param[out]
  !>     ptrT        pointer to rocblas_int. Array on the GPU of dimension n+1.
  !>                 It contains the positions of the beginning of each row in indT and valT.
  !>                 The last element of ptrT is equal to nnzT.
  !>     @param[out]
  !>     indT        pointer to rocblas_int. Array on the GPU of dimension nnzT.
  !>                 It contains the column indices of the non-zero elements of T. Indices are
  !>                 sorted by row and by column within each row.
  !>     @param[out]
  !>     valT        pointer to type. Array on the GPU of dimension nnzT.
  !>                 The values of the non-zero elements of T.
  !>     
  interface rocsolver_scsrrf_sumlu
    function rocsolver_scsrrf_sumlu_(handle,n,nnzL,ptrL,indL,valL,nnzU,ptrU,indU,valU,ptrT,indT,valT) bind(c, name="rocsolver_scsrrf_sumlu")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_scsrrf_sumlu_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      integer(c_int),value :: nnzL
      type(c_ptr),value :: ptrL
      type(c_ptr),value :: indL
      type(c_ptr),value :: valL
      integer(c_int),value :: nnzU
      type(c_ptr),value :: ptrU
      type(c_ptr),value :: indU
      type(c_ptr),value :: valU
      type(c_ptr),value :: ptrT
      type(c_ptr),value :: indT
      type(c_ptr),value :: valT
    end function


  end interface
  
  interface rocsolver_dcsrrf_sumlu
    function rocsolver_dcsrrf_sumlu_(handle,n,nnzL,ptrL,indL,valL,nnzU,ptrU,indU,valU,ptrT,indT,valT) bind(c, name="rocsolver_dcsrrf_sumlu")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dcsrrf_sumlu_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      integer(c_int),value :: nnzL
      type(c_ptr),value :: ptrL
      type(c_ptr),value :: indL
      type(c_ptr),value :: valL
      integer(c_int),value :: nnzU
      type(c_ptr),value :: ptrU
      type(c_ptr),value :: indU
      type(c_ptr),value :: valU
      type(c_ptr),value :: ptrT
      type(c_ptr),value :: indT
      type(c_ptr),value :: valT
    end function


  end interface
  !> ! @{
  !>     \brief CSRRF_SPLITLU splits the factors \f$L\f$ and \f$U\f$, associated with the LU factorization
  !>      of a sparse matrix \f$A\f$, from a bundled matrix \f$T=(L-I)+U\f$.
  !> 
  !>     \details Factor \f$L\f$ is a sparse lower triangular matrix with unit diagonal elements, and
  !>     \f$U\f$ is a sparse upper triangular matrix. Conceptually, on input, U is stored on the diagonal
  !>     and upper part of \f$T\f$, while the non diagonal elements of \f$L\f$ are stored on the strictly
  !>     lower part of \f$T\f$.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows (and columns) of matrix A.
  !>     @param[in]
  !>     nnzT        rocblas_int. nnzT >= 0.
  !>                 The number of non-zero elements in T.
  !>     @param[in]
  !>     ptrT        pointer to rocblas_int. Array on the GPU of dimension n+1.
  !>                 It contains the positions of the beginning of each row in indT and valT.
  !>                 The last element of ptrT is equal to nnzT.
  !>     @param[in]
  !>     indT        pointer to rocblas_int. Array on the GPU of dimension nnzT.
  !>                 It contains the column indices of the non-zero elements of T. Indices are
  !>                 sorted by row and by column within each row.
  !>     @param[in]
  !>     valT        pointer to type. Array on the GPU of dimension nnzT.
  !>                 The values of the non-zero elements of T.
  !>     @param[out]
  !>     ptrL        pointer to rocblas_int. Array on the GPU of dimension n+1.
  !>                 It contains the positions of the beginning of each row in indL and valL.
  !>                 The last element of ptrL is equal to nnzL.
  !>     @param[out]
  !>     indL        pointer to rocblas_int. Array on the GPU of dimension nnzL.
  !>                 It contains the column indices of the non-zero elements of L. Indices are
  !>                 sorted by row and by column within each row. (If nnzL is not known in advance,
  !>                 the size of this array could be set to nnzT + n as an upper bound).
  !>     @param[out]
  !>     valL        pointer to type. Array on the GPU of dimension nnzL.
  !>                 The values of the non-zero elements of L. (If nnzL is not known in advance,
  !>                 the size of this array could be set to nnzT + n as an upper bound).
  !>     @param[out]
  !>     ptrU        pointer to rocblas_int. Array on the GPU of dimension n+1.
  !>                 It contains the positions of the beginning of each row in indU and valU.
  !>                 The last element of ptrU is equal to nnzU.
  !>     @param[out]
  !>     indU        pointer to rocblas_int. Array on the GPU of dimension nnzU.
  !>                 It contains the column indices of the non-zero elements of U. Indices are
  !>                 sorted by row and by column within each row. (If nnzU is not known in advance,
  !>                 the size of this array could be set to nnzT as an upper bound).
  !>     @param[out]
  !>     valU        pointer to type. Array on the GPU of dimension nnzU.
  !>                 The values of the non-zero elements of U. (If nnzU is not known in advance,
  !>                 the size of this array could be set to nnzT as an upper bound).
  !>     
  interface rocsolver_scsrrf_splitlu
    function rocsolver_scsrrf_splitlu_(handle,n,nnzT,ptrT,indT,valT,ptrL,indL,valL,ptrU,indU,valU) bind(c, name="rocsolver_scsrrf_splitlu")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_scsrrf_splitlu_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      integer(c_int),value :: nnzT
      type(c_ptr),value :: ptrT
      type(c_ptr),value :: indT
      type(c_ptr),value :: valT
      type(c_ptr),value :: ptrL
      type(c_ptr),value :: indL
      type(c_ptr),value :: valL
      type(c_ptr),value :: ptrU
      type(c_ptr),value :: indU
      type(c_ptr),value :: valU
    end function


  end interface
  
  interface rocsolver_dcsrrf_splitlu
    function rocsolver_dcsrrf_splitlu_(handle,n,nnzT,ptrT,indT,valT,ptrL,indL,valL,ptrU,indU,valU) bind(c, name="rocsolver_dcsrrf_splitlu")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dcsrrf_splitlu_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      integer(c_int),value :: nnzT
      type(c_ptr),value :: ptrT
      type(c_ptr),value :: indT
      type(c_ptr),value :: valT
      type(c_ptr),value :: ptrL
      type(c_ptr),value :: indL
      type(c_ptr),value :: valL
      type(c_ptr),value :: ptrU
      type(c_ptr),value :: indU
      type(c_ptr),value :: valU
    end function


  end interface
  !> ! @{
  !>     \brief CSRRF_ANALYSIS performs the analysis phase required by the re-factorization functions
  !>         \ref rocsolver_scsrrf_refactlu "CSRRF_REFACTLU" and \ref rocsolver_scsrrf_refactchol "CSRRF_REFACTCHOL", and
  !>     by the direct solver \ref rocsolver_scsrrf_solve "CSRRF_SOLVE".
  !> 
  !>     \details Consider a sparse matrix \f$M\f$ previously factorized as
  !> 
  !>     \f[
  !>         Q^TMQ = L_ML_M^T
  !>     \f]
  !> 
  !>         (Cholesky factorization for the symmetric positive definite case), or
  !> 
  !>         \f[
  !>         PMQ = L_MU_M
  !>     \f]
  !> 
  !>         (LU factorization for the general case)
  !> 
  !>     where \f$L_M\f$ is lower triangular (with unit diagonal in the general case), \f$U_M\f$ is upper triangular, and \f$P\f$
  !>     and \f$Q\f$ are permutation matrices associated with pivoting and re-ordering (to minimize
  !>     fill-in), respectively. The meta data generated by this routine is collected in the output parameter
  !>     rfinfo. This information will allow the fast re-factorization of another sparse matrix \f$A\f$ as
  !> 
  !>         \f[
  !>         Q^TAQ = L_AL_A^T, \quad \text{or}
  !>     \f]
  !> 
  !>     \f[
  !>         PAQ = L_AU_A,
  !>     \f]
  !> 
  !>     and, eventually, the computation of the solution vector \f$X\f$ of any linear system of the form
  !> 
  !>     \f[
  !>         AX = B
  !>     \f]
  !> 
  !>     as long as \f$A\f$ has the same sparsity pattern as the previous matrix \f$M\f$.
  !> 
  !>         This function supposes that the rfinfo struct has been initialized by \ref rocsolver_create_rfinfo "RFINFO_CREATE".
  !>         By default, rfinfo is set up to work with the LU factorization (general matrices). If the matrix is symmetric positive definite,
  !>         and the Cholesky factorization is
  !>         desired, then the corresponding mode must be manually set up by \ref rocsolver_set_rfinfo_mode "SET_RFINFO_MODE". This function
  !>         does not automatically detect symmetry.
  !> 
  !>     For the LU factorization mode, the LU factors \f$L_M\f$ and \f$U_M\f$ must be passed in a bundle
  !>     matrix \f$T=(L_M-I)+U_M\f$ as returned by \ref rocsolver_scsrrf_sumlu "CSRRF_SUMLU". For the Cholesky mode,
  !>     the lower triangular part of \f$T\f$ must contain the Cholesky factor \f$L_M\f$; the strictly upper triangular
  !>         part of \f$T\f$ will be ignored. Similarly, the strictly upper triangular part of \f$M\f$ is ignored when working
  !>         in Cholesky mode.
  !> 
  !>     \note
  !>     If only a re-factorization will be executed (i.e. no solver phase), then nrhs can be set to zero
  !>     and B can be null.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows (and columns) of matrix M.
  !>     @param[in]
  !>     nrhs        rocblas_int. nrhs >= 0.
  !>                 The number of right-hand-sides (columns of matrix B). Set nrhs to zero when only the
  !>                 re-factorization is needed.
  !>     @param[in]
  !>     nnzM        rocblas_int. nnzM >= 0.
  !>                 The number of non-zero elements in M.
  !>     @param[in]
  !>     ptrM        pointer to rocblas_int. Array on the GPU of dimension n+1.
  !>                 It contains the positions of the beginning of each row in indM and valM.
  !>                 The last element of ptrM is equal to nnzM.
  !>     @param[in]
  !>     indM        pointer to rocblas_int. Array on the GPU of dimension nnzM.
  !>                 It contains the column indices of the non-zero elements of M. Indices are
  !>                 sorted by row and by column within each row.
  !>     @param[in]
  !>     valM        pointer to type. Array on the GPU of dimension nnzM.
  !>                 The values of the non-zero elements of M. The strictly upper triangular entries are
  !>                                 not referenced when working in Cholesky mode.
  !>     @param[in]
  !>     nnzT        rocblas_int. nnzT >= 0.
  !>                 The number of non-zero elements in T.
  !>     @param[in]
  !>     ptrT        pointer to rocblas_int. Array on the GPU of dimension n+1.
  !>                 It contains the positions of the beginning of each row in indT and valT.
  !>                 The last element of ptrT is equal to nnzT.
  !>     @param[in]
  !>     indT        pointer to rocblas_int. Array on the GPU of dimension nnzT.
  !>                 It contains the column indices of the non-zero elements of T. Indices are
  !>                 sorted by row and by column within each row.
  !>     @param[in]
  !>     valT        pointer to type. Array on the GPU of dimension nnzT.
  !>                 The values of the non-zero elements of T. The strictly upper triangular entries are
  !>                 not referenced when working in Cholesky mode.
  !>     @param[in]
  !>     pivP        pointer to rocblas_int. Array on the GPU of dimension n.
  !>                 Contains the pivot indices representing the permutation matrix P, i.e. the
  !>                 order in which the rows of matrix M were re-arranged. When working in Cholesky mode,
  !>                                 this array is not referenced and can be null.
  !>     @param[in]
  !>     pivQ        pointer to rocblas_int. Array on the GPU of dimension n.
  !>                 Contains the pivot indices representing the permutation matrix Q, i.e. the
  !>                 order in which the columns of matrix M were re-arranged.
  !>     @param[in]
  !>     B           pointer to type. Array on the GPU of dimension ldbnrhs.
  !>                 The right hand side matrix B. It can be null if only the re-factorization is needed.
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 The leading dimension of B.
  !>     @param[out]
  !>     rfinfo      rocsolver_rfinfo.
  !>                 Structure that holds the meta data generated in the analysis phase.
  !>     
  interface rocsolver_scsrrf_analysis
    function rocsolver_scsrrf_analysis_(handle,n,nrhs,nnzM,ptrM,indM,valM,nnzT,ptrT,indT,valT,pivP,pivQ,B,ldb,rfinfo) bind(c, name="rocsolver_scsrrf_analysis")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_scsrrf_analysis_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      integer(c_int),value :: nnzM
      type(c_ptr),value :: ptrM
      type(c_ptr),value :: indM
      type(c_ptr),value :: valM
      integer(c_int),value :: nnzT
      type(c_ptr),value :: ptrT
      type(c_ptr),value :: indT
      type(c_ptr),value :: valT
      type(c_ptr),value :: pivP
      type(c_ptr),value :: pivQ
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: rfinfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_scsrrf_analysis_full_rank,&
      
rocsolver_scsrrf_analysis_rank_0,&
      
rocsolver_scsrrf_analysis_rank_1
#endif

  end interface
  
  interface rocsolver_dcsrrf_analysis
    function rocsolver_dcsrrf_analysis_(handle,n,nrhs,nnzM,ptrM,indM,valM,nnzT,ptrT,indT,valT,pivP,pivQ,B,ldb,rfinfo) bind(c, name="rocsolver_dcsrrf_analysis")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dcsrrf_analysis_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      integer(c_int),value :: nnzM
      type(c_ptr),value :: ptrM
      type(c_ptr),value :: indM
      type(c_ptr),value :: valM
      integer(c_int),value :: nnzT
      type(c_ptr),value :: ptrT
      type(c_ptr),value :: indT
      type(c_ptr),value :: valT
      type(c_ptr),value :: pivP
      type(c_ptr),value :: pivQ
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: rfinfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dcsrrf_analysis_full_rank,&
      
rocsolver_dcsrrf_analysis_rank_0,&
      
rocsolver_dcsrrf_analysis_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief CSRRF_REFACTLU performs a fast LU factorization of a sparse matrix \f$A\f$ based on the
  !>     information from the factorization of a previous matrix \f$M\f$ with the same sparsity pattern
  !>     (re-factorization).
  !> 
  !>     \details Consider a sparse matrix \f$M\f$ previously factorized as
  !> 
  !>     \f[
  !>         PMQ = L_MU_M
  !>     \f]
  !> 
  !>     where \f$L_M\f$ is lower triangular with unit diagonal, \f$U_M\f$ is upper triangular, and \f$P\f$
  !>     and \f$Q\f$ are permutation matrices associated with pivoting and re-ordering (to minimize
  !>     fill-in), respectively. If \f$A\f$ has the same sparsity pattern as \f$M\f$, then the re-factorization
  !> 
  !>     \f[
  !>         PAQ = L_AU_A
  !>     \f]
  !> 
  !>     can be computed numerically without a symbolic analysis phase.
  !> 
  !>     This function supposes that rfinfo has been updated, by function \ref rocsolver_scsrrf_analysis "CSRRF_ANALYSIS",
  !>     after the analysis phase of the previous matrix M and its initial factorization. Both functions, CSRRF_ANALYSIS and
  !>         CSRRF_REFACTLU must be run with the same rfinfo mode (LU factorization, the default mode), otherwise the workflow will
  !>         result in an error.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows (and columns) of matrix A.
  !>     @param[in]
  !>     nnzA        rocblas_int. nnzA >= 0.
  !>                 The number of non-zero elements in A.
  !>     @param[in]
  !>     ptrA        pointer to rocblas_int. Array on the GPU of dimension n+1.
  !>                 It contains the positions of the beginning of each row in indA and valA.
  !>                 The last element of ptrM is equal to nnzA.
  !>     @param[in]
  !>     indA        pointer to rocblas_int. Array on the GPU of dimension nnzA.
  !>                 It contains the column indices of the non-zero elements of M. Indices are
  !>                 sorted by row and by column within each row.
  !>     @param[in]
  !>     valA        pointer to type. Array on the GPU of dimension nnzA.
  !>                 The values of the non-zero elements of A.
  !>     @param[in]
  !>     nnzT        rocblas_int. nnzT >= 0.
  !>                 The number of non-zero elements in T.
  !>     @param[in]
  !>     ptrT        pointer to rocblas_int. Array on the GPU of dimension n+1.
  !>                 It contains the positions of the beginning of each row in indT and valT.
  !>                 The last element of ptrT is equal to nnzT.
  !>     @param[in]
  !>     indT        pointer to rocblas_int. Array on the GPU of dimension nnzT.
  !>                 It contains the column indices of the non-zero elements of T. Indices are
  !>                 sorted by row and by column within each row.
  !>     @param[out]
  !>     valT        pointer to type. Array on the GPU of dimension nnzT.
  !>                 The values of the non-zero elements of the new bundle matrix (L_A - I) + U_A.
  !>     @param[in]
  !>     pivP        pointer to rocblas_int. Array on the GPU of dimension n.
  !>                 Contains the pivot indices representing the permutation matrix P, i.e. the
  !>                 order in which the rows of matrix M were re-arranged.
  !>     @param[in]
  !>     pivQ        pointer to rocblas_int. Array on the GPU of dimension n.
  !>                 Contains the pivot indices representing the permutation matrix Q, i.e. the
  !>                 order in which the columns of matrix M were re-arranged.
  !>     @param[in]
  !>     rfinfo      rocsolver_rfinfo.
  !>                 Structure that holds the meta data generated in the analysis phase.
  !>     
  interface rocsolver_scsrrf_refactlu
    function rocsolver_scsrrf_refactlu_(handle,n,nnzA,ptrA,indA,valA,nnzT,ptrT,indT,valT,pivP,pivQ,rfinfo) bind(c, name="rocsolver_scsrrf_refactlu")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_scsrrf_refactlu_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      integer(c_int),value :: nnzA
      type(c_ptr),value :: ptrA
      type(c_ptr),value :: indA
      type(c_ptr),value :: valA
      integer(c_int),value :: nnzT
      type(c_ptr),value :: ptrT
      type(c_ptr),value :: indT
      type(c_ptr),value :: valT
      type(c_ptr),value :: pivP
      type(c_ptr),value :: pivQ
      type(c_ptr),value :: rfinfo
    end function


  end interface
  
  interface rocsolver_dcsrrf_refactlu
    function rocsolver_dcsrrf_refactlu_(handle,n,nnzA,ptrA,indA,valA,nnzT,ptrT,indT,valT,pivP,pivQ,rfinfo) bind(c, name="rocsolver_dcsrrf_refactlu")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dcsrrf_refactlu_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      integer(c_int),value :: nnzA
      type(c_ptr),value :: ptrA
      type(c_ptr),value :: indA
      type(c_ptr),value :: valA
      integer(c_int),value :: nnzT
      type(c_ptr),value :: ptrT
      type(c_ptr),value :: indT
      type(c_ptr),value :: valT
      type(c_ptr),value :: pivP
      type(c_ptr),value :: pivQ
      type(c_ptr),value :: rfinfo
    end function


  end interface
  !> ! @{
  !>     \brief CSRRF_REFACTCHOL performs a fast Cholesky factorization of a sparse symmetric positive definite matrix \f$A\f$
  !>         based on the information from the factorization of a previous matrix \f$M\f$ with the same sparsity pattern
  !>     (re-factorization).
  !> 
  !>     \details Consider a sparse matrix \f$M\f$ previously factorized as
  !> 
  !>     \f[
  !>         Q^TMQ = L_ML_M^T
  !>     \f]
  !> 
  !>     where \f$L_M\f$ is lower triangular, and \f$Q\f$ is a permutation matrices associated with re-ordering to minimize
  !>     fill-in. If \f$A\f$ has the same sparsity pattern as \f$M\f$, then the re-factorization
  !> 
  !>     \f[
  !>         Q^TAQ = L_AL_A^T
  !>     \f]
  !> 
  !>     can be computed numerically without a symbolic analysis phase.
  !> 
  !>     This function supposes that rfinfo has been updated by function \ref rocsolver_scsrrf_analysis "CSRRF_ANALYSIS",
  !>     after the analysis phase of the previous matrix M and its initial factorization. Both functions, CSRRF_ANALYSIS and
  !>     CSRRF_REFACTCHOL must be run with the same rfinfo mode (Cholesky factorization), otherwise the workflow will
  !>     result in an error.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows (and columns) of matrix A.
  !>     @param[in]
  !>     nnzA        rocblas_int. nnzA >= 0.
  !>                 The number of non-zero elements in A.
  !>     @param[in]
  !>     ptrA        pointer to rocblas_int. Array on the GPU of dimension n+1.
  !>                 It contains the positions of the beginning of each row in indA and valA.
  !>                 The last element of ptrM is equal to nnzA.
  !>     @param[in]
  !>     indA        pointer to rocblas_int. Array on the GPU of dimension nnzA.
  !>                 It contains the column indices of the non-zero elements of M. Indices are
  !>                 sorted by row and by column within each row.
  !>     @param[in]
  !>     valA        pointer to type. Array on the GPU of dimension nnzA.
  !>                 The values of the non-zero elements of A. The strictly upper triangular entries are
  !>                 not referenced.
  !>     @param[in]
  !>     nnzT        rocblas_int. nnzT >= 0.
  !>                 The number of non-zero elements in T.
  !>     @param[in]
  !>     ptrT        pointer to rocblas_int. Array on the GPU of dimension n+1.
  !>                 It contains the positions of the beginning of each row in indT and valT.
  !>                 The last element of ptrT is equal to nnzT.
  !>     @param[in]
  !>     indT        pointer to rocblas_int. Array on the GPU of dimension nnzT.
  !>                 It contains the column indices of the non-zero elements of T. Indices are
  !>                 sorted by row and by column within each row.
  !>     @param[out]
  !>     valT        pointer to type. Array on the GPU of dimension nnzT.
  !>                 The values of the non-zero elements of the new Cholesky factor L_A.
  !>                                 The strictly upper triangular entries of this array are not referenced.
  !>     @param[in]
  !>     pivQ        pointer to rocblas_int. Array on the GPU of dimension n.
  !>                 Contains the pivot indices representing the permutation matrix Q, i.e. the
  !>                 order in which the columns of matrix M were re-arranged.
  !>     @param[in]
  !>     rfinfo      #rocsolver_rfinfo.
  !>                 Structure that holds the meta data generated in the analysis phase.
  !>     
  interface rocsolver_scsrrf_refactchol
    function rocsolver_scsrrf_refactchol_(handle,n,nnzA,ptrA,indA,valA,nnzT,ptrT,indT,valT,pivQ,rfinfo) bind(c, name="rocsolver_scsrrf_refactchol")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_scsrrf_refactchol_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      integer(c_int),value :: nnzA
      type(c_ptr),value :: ptrA
      type(c_ptr),value :: indA
      type(c_ptr),value :: valA
      integer(c_int),value :: nnzT
      type(c_ptr),value :: ptrT
      type(c_ptr),value :: indT
      type(c_ptr),value :: valT
      type(c_ptr),value :: pivQ
      type(c_ptr),value :: rfinfo
    end function


  end interface
  
  interface rocsolver_dcsrrf_refactchol
    function rocsolver_dcsrrf_refactchol_(handle,n,nnzA,ptrA,indA,valA,nnzT,ptrT,indT,valT,pivQ,rfinfo) bind(c, name="rocsolver_dcsrrf_refactchol")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dcsrrf_refactchol_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      integer(c_int),value :: nnzA
      type(c_ptr),value :: ptrA
      type(c_ptr),value :: indA
      type(c_ptr),value :: valA
      integer(c_int),value :: nnzT
      type(c_ptr),value :: ptrT
      type(c_ptr),value :: indT
      type(c_ptr),value :: valT
      type(c_ptr),value :: pivQ
      type(c_ptr),value :: rfinfo
    end function


  end interface
  !> ! @{
  !>     \brief CSRRF_SOLVE solves a linear system with sparse coefficient matrix \f$A\f$ in its
  !>     factorized form.
  !> 
  !>     \details The linear system is of the form
  !> 
  !>     \f[
  !>         AX = B
  !>     \f]
  !> 
  !>     where the sparse matrix \f$A\f$ is factorized as
  !> 
  !>     \f[
  !>         Q^TAQ = L_AL_A^T
  !>     \f]
  !> 
  !>         (Cholesky factorization for the symmetric positive definite case), or
  !> 
  !>         \f[
  !>         PAQ = L_AU_A
  !>     \f]
  !> 
  !>         (LU factorization for the general case),
  !> 
  !>     and \f$B\f$ is a dense matrix of right hand sides.
  !> 
  !>         This function supposes that rfinfo has been updated by function \ref rocsolver_scsrrf_analysis "CSRRF_ANALYSIS",
  !>     after the analysis phase. Both functions, CSRRF_ANALYSIS and
  !>     CSRRF_SOLVE must be run with the same rfinfo mode (LU or Cholesky factorization), otherwise the workflow will
  !>     result in an error.
  !> 
  !>     For the LU factorization mode, the LU factors \f$L_A\f$ and \f$U_A\f$ must be passed in a bundle matrix \f$T=(L_A-I)+U_A\f$
  !>         as returned by \ref rocsolver_scsrrf_refactlu "CSRRF_REFACTLU" or \ref rocsolver_scsrrf_sumlu "CSRRF_SUMLU". For the Cholesky mode,
  !>     the lower triangular part of \f$T\f$ must contain the Cholesky factor \f$L_A\f$; the strictly upper triangular
  !>     part of \f$T\f$ will be ignored.
  !> 
  !>     @param[in]
  !>     handle      rocblas_handle.
  !>     @param[in]
  !>     n           rocblas_int. n >= 0.
  !>                 The number of rows (and columns) of matrix A.
  !>     @param[in]
  !>     nrhs        rocblas_int. nrhs >= 0.
  !>                 The number of right hand sides, i.e. the number of columns of matrix B.
  !>     @param[in]
  !>     nnzT        rocblas_int. nnzT >= 0.
  !>                 The number of non-zero elements in T.
  !>     @param[in]
  !>     ptrT        pointer to rocblas_int. Array on the GPU of dimension n+1.
  !>                 It contains the positions of the beginning of each row in indT and valT.
  !>                 The last element of ptrT is equal to nnzT.
  !>     @param[in]
  !>     indT        pointer to rocblas_int. Array on the GPU of dimension nnzT.
  !>                 It contains the column indices of the non-zero elements of T. Indices are
  !>                 sorted by row and by column within each row.
  !>     @param[in]
  !>     valT        pointer to type. Array on the GPU of dimension nnzT.
  !>                 The values of the non-zero elements of T. The strictly upper triangular entries are
  !>                 not referenced when working in Cholesky mode.
  !>     @param[in]
  !>     pivP        pointer to rocblas_int. Array on the GPU of dimension n.
  !>                 Contains the pivot indices representing the permutation matrix P, i.e. the
  !>                 order in which the rows of matrix A were re-arranged. When working in Cholesky mode,
  !>                 this array is not referenced and can be null.
  !>     @param[in]
  !>     pivQ        pointer to rocblas_int. Array on the GPU of dimension n.
  !>                 Contains the pivot indices representing the permutation matrix Q, i.e. the
  !>                 order in which the columns of matrix A were re-arranged.
  !>     @param[inout]
  !>     B           pointer to type. Array on the GPU of dimension ldbnrhs.
  !>                 On entry the right hand side matrix B. On exit, the solution matrix X.
  !>     @param[in]
  !>     ldb         rocblas_int. ldb >= n.
  !>                 The leading dimension of B.
  !>     @param[in]
  !>     rfinfo      rocsolver_rfinfo.
  !>                 Structure that holds the meta data generated in the analysis phase.
  !>     
  interface rocsolver_scsrrf_solve
    function rocsolver_scsrrf_solve_(handle,n,nrhs,nnzT,ptrT,indT,valT,pivP,pivQ,B,ldb,rfinfo) bind(c, name="rocsolver_scsrrf_solve")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_scsrrf_solve_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      integer(c_int),value :: nnzT
      type(c_ptr),value :: ptrT
      type(c_ptr),value :: indT
      type(c_ptr),value :: valT
      type(c_ptr),value :: pivP
      type(c_ptr),value :: pivQ
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: rfinfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_scsrrf_solve_full_rank,&
      
rocsolver_scsrrf_solve_rank_0,&
      
rocsolver_scsrrf_solve_rank_1
#endif

  end interface
  
  interface rocsolver_dcsrrf_solve
    function rocsolver_dcsrrf_solve_(handle,n,nrhs,nnzT,ptrT,indT,valT,pivP,pivQ,B,ldb,rfinfo) bind(c, name="rocsolver_dcsrrf_solve")
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dcsrrf_solve_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      integer(c_int),value :: nnzT
      type(c_ptr),value :: ptrT
      type(c_ptr),value :: indT
      type(c_ptr),value :: valT
      type(c_ptr),value :: pivP
      type(c_ptr),value :: pivQ
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: rfinfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure rocsolver_dcsrrf_solve_full_rank,&
      
rocsolver_dcsrrf_solve_rank_0,&
      
rocsolver_dcsrrf_solve_rank_1
#endif

  end interface

#ifdef USE_FPOINTER_INTERFACES
  contains
    function rocsolver_clacgv_rank_0(handle,n,x,incx)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clacgv_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      rocsolver_clacgv_rank_0 = rocsolver_clacgv_(handle,n,c_loc(x),incx)
    end function

    function rocsolver_clacgv_rank_1(handle,n,x,incx)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clacgv_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocsolver_clacgv_rank_1 = rocsolver_clacgv_(handle,n,c_loc(x),incx)
    end function

    function rocsolver_zlacgv_rank_0(handle,n,x,incx)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlacgv_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      rocsolver_zlacgv_rank_0 = rocsolver_zlacgv_(handle,n,c_loc(x),incx)
    end function

    function rocsolver_zlacgv_rank_1(handle,n,x,incx)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlacgv_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      rocsolver_zlacgv_rank_1 = rocsolver_zlacgv_(handle,n,c_loc(x),incx)
    end function

    function rocsolver_slaswp_full_rank(handle,n,A,lda,k1,k2,ipiv,incx)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slaswp_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: k1
      integer(c_int) :: k2
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int) :: incx
      !
      rocsolver_slaswp_full_rank = rocsolver_slaswp_(handle,n,c_loc(A),lda,k1,k2,c_loc(ipiv),incx)
    end function

    function rocsolver_slaswp_rank_0(handle,n,A,lda,k1,k2,ipiv,incx)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slaswp_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int) :: k1
      integer(c_int) :: k2
      integer(c_int),target :: ipiv
      integer(c_int) :: incx
      !
      rocsolver_slaswp_rank_0 = rocsolver_slaswp_(handle,n,c_loc(A),lda,k1,k2,c_loc(ipiv),incx)
    end function

    function rocsolver_slaswp_rank_1(handle,n,A,lda,k1,k2,ipiv,incx)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slaswp_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: k1
      integer(c_int) :: k2
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int) :: incx
      !
      rocsolver_slaswp_rank_1 = rocsolver_slaswp_(handle,n,c_loc(A),lda,k1,k2,c_loc(ipiv),incx)
    end function

    function rocsolver_dlaswp_full_rank(handle,n,A,lda,k1,k2,ipiv,incx)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlaswp_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: k1
      integer(c_int) :: k2
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int) :: incx
      !
      rocsolver_dlaswp_full_rank = rocsolver_dlaswp_(handle,n,c_loc(A),lda,k1,k2,c_loc(ipiv),incx)
    end function

    function rocsolver_dlaswp_rank_0(handle,n,A,lda,k1,k2,ipiv,incx)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlaswp_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int) :: k1
      integer(c_int) :: k2
      integer(c_int),target :: ipiv
      integer(c_int) :: incx
      !
      rocsolver_dlaswp_rank_0 = rocsolver_dlaswp_(handle,n,c_loc(A),lda,k1,k2,c_loc(ipiv),incx)
    end function

    function rocsolver_dlaswp_rank_1(handle,n,A,lda,k1,k2,ipiv,incx)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlaswp_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: k1
      integer(c_int) :: k2
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int) :: incx
      !
      rocsolver_dlaswp_rank_1 = rocsolver_dlaswp_(handle,n,c_loc(A),lda,k1,k2,c_loc(ipiv),incx)
    end function

    function rocsolver_claswp_full_rank(handle,n,A,lda,k1,k2,ipiv,incx)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_claswp_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: k1
      integer(c_int) :: k2
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int) :: incx
      !
      rocsolver_claswp_full_rank = rocsolver_claswp_(handle,n,c_loc(A),lda,k1,k2,c_loc(ipiv),incx)
    end function

    function rocsolver_claswp_rank_0(handle,n,A,lda,k1,k2,ipiv,incx)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_claswp_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int) :: k1
      integer(c_int) :: k2
      integer(c_int),target :: ipiv
      integer(c_int) :: incx
      !
      rocsolver_claswp_rank_0 = rocsolver_claswp_(handle,n,c_loc(A),lda,k1,k2,c_loc(ipiv),incx)
    end function

    function rocsolver_claswp_rank_1(handle,n,A,lda,k1,k2,ipiv,incx)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_claswp_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: k1
      integer(c_int) :: k2
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int) :: incx
      !
      rocsolver_claswp_rank_1 = rocsolver_claswp_(handle,n,c_loc(A),lda,k1,k2,c_loc(ipiv),incx)
    end function

    function rocsolver_zlaswp_full_rank(handle,n,A,lda,k1,k2,ipiv,incx)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlaswp_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int) :: k1
      integer(c_int) :: k2
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int) :: incx
      !
      rocsolver_zlaswp_full_rank = rocsolver_zlaswp_(handle,n,c_loc(A),lda,k1,k2,c_loc(ipiv),incx)
    end function

    function rocsolver_zlaswp_rank_0(handle,n,A,lda,k1,k2,ipiv,incx)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlaswp_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int) :: k1
      integer(c_int) :: k2
      integer(c_int),target :: ipiv
      integer(c_int) :: incx
      !
      rocsolver_zlaswp_rank_0 = rocsolver_zlaswp_(handle,n,c_loc(A),lda,k1,k2,c_loc(ipiv),incx)
    end function

    function rocsolver_zlaswp_rank_1(handle,n,A,lda,k1,k2,ipiv,incx)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlaswp_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int) :: k1
      integer(c_int) :: k2
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int) :: incx
      !
      rocsolver_zlaswp_rank_1 = rocsolver_zlaswp_(handle,n,c_loc(A),lda,k1,k2,c_loc(ipiv),incx)
    end function

    function rocsolver_slarfg_rank_0(handle,n,alpha,x,incx,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slarfg_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: tau
      !
      rocsolver_slarfg_rank_0 = rocsolver_slarfg_(handle,n,alpha,c_loc(x),incx,tau)
    end function

    function rocsolver_slarfg_rank_1(handle,n,alpha,x,incx,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slarfg_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: tau
      !
      rocsolver_slarfg_rank_1 = rocsolver_slarfg_(handle,n,alpha,c_loc(x),incx,tau)
    end function

    function rocsolver_dlarfg_rank_0(handle,n,alpha,x,incx,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlarfg_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: tau
      !
      rocsolver_dlarfg_rank_0 = rocsolver_dlarfg_(handle,n,alpha,c_loc(x),incx,tau)
    end function

    function rocsolver_dlarfg_rank_1(handle,n,alpha,x,incx,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlarfg_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: tau
      !
      rocsolver_dlarfg_rank_1 = rocsolver_dlarfg_(handle,n,alpha,c_loc(x),incx,tau)
    end function

    function rocsolver_clarfg_rank_0(handle,n,alpha,x,incx,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clarfg_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: tau
      !
      rocsolver_clarfg_rank_0 = rocsolver_clarfg_(handle,n,alpha,c_loc(x),incx,tau)
    end function

    function rocsolver_clarfg_rank_1(handle,n,alpha,x,incx,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clarfg_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: tau
      !
      rocsolver_clarfg_rank_1 = rocsolver_clarfg_(handle,n,alpha,c_loc(x),incx,tau)
    end function

    function rocsolver_zlarfg_rank_0(handle,n,alpha,x,incx,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlarfg_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: tau
      !
      rocsolver_zlarfg_rank_0 = rocsolver_zlarfg_(handle,n,alpha,c_loc(x),incx,tau)
    end function

    function rocsolver_zlarfg_rank_1(handle,n,alpha,x,incx,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlarfg_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: tau
      !
      rocsolver_zlarfg_rank_1 = rocsolver_zlarfg_(handle,n,alpha,c_loc(x),incx,tau)
    end function

    function rocsolver_slarft_full_rank(handle,myDirect,storev,n,k,V,ldv,tau,T,ldt)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slarft_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_forward_direction)) :: myDirect
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      real(c_float) :: tau
      real(c_float),target,dimension(:,:) :: T
      integer(c_int) :: ldt
      !
      rocsolver_slarft_full_rank = rocsolver_slarft_(handle,myDirect,storev,n,k,c_loc(V),ldv,tau,c_loc(T),ldt)
    end function

    function rocsolver_slarft_rank_0(handle,myDirect,storev,n,k,V,ldv,tau,T,ldt)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slarft_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_forward_direction)) :: myDirect
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target :: V
      integer(c_int) :: ldv
      real(c_float) :: tau
      real(c_float),target :: T
      integer(c_int) :: ldt
      !
      rocsolver_slarft_rank_0 = rocsolver_slarft_(handle,myDirect,storev,n,k,c_loc(V),ldv,tau,c_loc(T),ldt)
    end function

    function rocsolver_slarft_rank_1(handle,myDirect,storev,n,k,V,ldv,tau,T,ldt)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slarft_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_forward_direction)) :: myDirect
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: V
      integer(c_int) :: ldv
      real(c_float) :: tau
      real(c_float),target,dimension(:) :: T
      integer(c_int) :: ldt
      !
      rocsolver_slarft_rank_1 = rocsolver_slarft_(handle,myDirect,storev,n,k,c_loc(V),ldv,tau,c_loc(T),ldt)
    end function

    function rocsolver_dlarft_full_rank(handle,myDirect,storev,n,k,V,ldv,tau,T,ldt)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlarft_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_forward_direction)) :: myDirect
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      real(c_double) :: tau
      real(c_double),target,dimension(:,:) :: T
      integer(c_int) :: ldt
      !
      rocsolver_dlarft_full_rank = rocsolver_dlarft_(handle,myDirect,storev,n,k,c_loc(V),ldv,tau,c_loc(T),ldt)
    end function

    function rocsolver_dlarft_rank_0(handle,myDirect,storev,n,k,V,ldv,tau,T,ldt)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlarft_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_forward_direction)) :: myDirect
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target :: V
      integer(c_int) :: ldv
      real(c_double) :: tau
      real(c_double),target :: T
      integer(c_int) :: ldt
      !
      rocsolver_dlarft_rank_0 = rocsolver_dlarft_(handle,myDirect,storev,n,k,c_loc(V),ldv,tau,c_loc(T),ldt)
    end function

    function rocsolver_dlarft_rank_1(handle,myDirect,storev,n,k,V,ldv,tau,T,ldt)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlarft_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_forward_direction)) :: myDirect
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: V
      integer(c_int) :: ldv
      real(c_double) :: tau
      real(c_double),target,dimension(:) :: T
      integer(c_int) :: ldt
      !
      rocsolver_dlarft_rank_1 = rocsolver_dlarft_(handle,myDirect,storev,n,k,c_loc(V),ldv,tau,c_loc(T),ldt)
    end function

    function rocsolver_clarft_full_rank(handle,myDirect,storev,n,k,V,ldv,tau,T,ldt)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clarft_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_forward_direction)) :: myDirect
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      complex(c_float_complex) :: tau
      complex(c_float_complex),target,dimension(:,:) :: T
      integer(c_int) :: ldt
      !
      rocsolver_clarft_full_rank = rocsolver_clarft_(handle,myDirect,storev,n,k,c_loc(V),ldv,tau,c_loc(T),ldt)
    end function

    function rocsolver_clarft_rank_0(handle,myDirect,storev,n,k,V,ldv,tau,T,ldt)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clarft_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_forward_direction)) :: myDirect
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target :: V
      integer(c_int) :: ldv
      complex(c_float_complex) :: tau
      complex(c_float_complex),target :: T
      integer(c_int) :: ldt
      !
      rocsolver_clarft_rank_0 = rocsolver_clarft_(handle,myDirect,storev,n,k,c_loc(V),ldv,tau,c_loc(T),ldt)
    end function

    function rocsolver_clarft_rank_1(handle,myDirect,storev,n,k,V,ldv,tau,T,ldt)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clarft_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_forward_direction)) :: myDirect
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: V
      integer(c_int) :: ldv
      complex(c_float_complex) :: tau
      complex(c_float_complex),target,dimension(:) :: T
      integer(c_int) :: ldt
      !
      rocsolver_clarft_rank_1 = rocsolver_clarft_(handle,myDirect,storev,n,k,c_loc(V),ldv,tau,c_loc(T),ldt)
    end function

    function rocsolver_zlarft_full_rank(handle,myDirect,storev,n,k,V,ldv,tau,T,ldt)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlarft_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_forward_direction)) :: myDirect
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      complex(c_double_complex) :: tau
      complex(c_double_complex),target,dimension(:,:) :: T
      integer(c_int) :: ldt
      !
      rocsolver_zlarft_full_rank = rocsolver_zlarft_(handle,myDirect,storev,n,k,c_loc(V),ldv,tau,c_loc(T),ldt)
    end function

    function rocsolver_zlarft_rank_0(handle,myDirect,storev,n,k,V,ldv,tau,T,ldt)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlarft_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_forward_direction)) :: myDirect
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target :: V
      integer(c_int) :: ldv
      complex(c_double_complex) :: tau
      complex(c_double_complex),target :: T
      integer(c_int) :: ldt
      !
      rocsolver_zlarft_rank_0 = rocsolver_zlarft_(handle,myDirect,storev,n,k,c_loc(V),ldv,tau,c_loc(T),ldt)
    end function

    function rocsolver_zlarft_rank_1(handle,myDirect,storev,n,k,V,ldv,tau,T,ldt)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlarft_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_forward_direction)) :: myDirect
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: V
      integer(c_int) :: ldv
      complex(c_double_complex) :: tau
      complex(c_double_complex),target,dimension(:) :: T
      integer(c_int) :: ldt
      !
      rocsolver_zlarft_rank_1 = rocsolver_zlarft_(handle,myDirect,storev,n,k,c_loc(V),ldv,tau,c_loc(T),ldt)
    end function

    function rocsolver_slarf_full_rank(handle,side,m,n,x,incx,alpha,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slarf_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocsolver_slarf_full_rank = rocsolver_slarf_(handle,side,m,n,c_loc(x),incx,alpha,c_loc(A),lda)
    end function

    function rocsolver_slarf_rank_0(handle,side,m,n,x,incx,alpha,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slarf_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      !
      rocsolver_slarf_rank_0 = rocsolver_slarf_(handle,side,m,n,c_loc(x),incx,alpha,c_loc(A),lda)
    end function

    function rocsolver_slarf_rank_1(handle,side,m,n,x,incx,alpha,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slarf_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocsolver_slarf_rank_1 = rocsolver_slarf_(handle,side,m,n,c_loc(x),incx,alpha,c_loc(A),lda)
    end function

    function rocsolver_dlarf_full_rank(handle,side,m,n,x,incx,alpha,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlarf_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocsolver_dlarf_full_rank = rocsolver_dlarf_(handle,side,m,n,c_loc(x),incx,alpha,c_loc(A),lda)
    end function

    function rocsolver_dlarf_rank_0(handle,side,m,n,x,incx,alpha,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlarf_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      !
      rocsolver_dlarf_rank_0 = rocsolver_dlarf_(handle,side,m,n,c_loc(x),incx,alpha,c_loc(A),lda)
    end function

    function rocsolver_dlarf_rank_1(handle,side,m,n,x,incx,alpha,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlarf_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocsolver_dlarf_rank_1 = rocsolver_dlarf_(handle,side,m,n,c_loc(x),incx,alpha,c_loc(A),lda)
    end function

    function rocsolver_clarf_full_rank(handle,side,m,n,x,incx,alpha,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clarf_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocsolver_clarf_full_rank = rocsolver_clarf_(handle,side,m,n,c_loc(x),incx,alpha,c_loc(A),lda)
    end function

    function rocsolver_clarf_rank_0(handle,side,m,n,x,incx,alpha,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clarf_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      !
      rocsolver_clarf_rank_0 = rocsolver_clarf_(handle,side,m,n,c_loc(x),incx,alpha,c_loc(A),lda)
    end function

    function rocsolver_clarf_rank_1(handle,side,m,n,x,incx,alpha,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clarf_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocsolver_clarf_rank_1 = rocsolver_clarf_(handle,side,m,n,c_loc(x),incx,alpha,c_loc(A),lda)
    end function

    function rocsolver_zlarf_full_rank(handle,side,m,n,x,incx,alpha,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlarf_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocsolver_zlarf_full_rank = rocsolver_zlarf_(handle,side,m,n,c_loc(x),incx,alpha,c_loc(A),lda)
    end function

    function rocsolver_zlarf_rank_0(handle,side,m,n,x,incx,alpha,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlarf_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      !
      rocsolver_zlarf_rank_0 = rocsolver_zlarf_(handle,side,m,n,c_loc(x),incx,alpha,c_loc(A),lda)
    end function

    function rocsolver_zlarf_rank_1(handle,side,m,n,x,incx,alpha,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlarf_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocsolver_zlarf_rank_1 = rocsolver_zlarf_(handle,side,m,n,c_loc(x),incx,alpha,c_loc(A),lda)
    end function

    function rocsolver_slarfb_full_rank(handle,side,trans,myDirect,storev,m,n,k,V,ldv,T,ldt,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slarfb_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_forward_direction)) :: myDirect
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      real(c_float),target,dimension(:,:) :: T
      integer(c_int) :: ldt
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocsolver_slarfb_full_rank = rocsolver_slarfb_(handle,side,trans,myDirect,storev,m,n,k,c_loc(V),ldv,c_loc(T),ldt,c_loc(A),lda)
    end function

    function rocsolver_slarfb_rank_0(handle,side,trans,myDirect,storev,m,n,k,V,ldv,T,ldt,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slarfb_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_forward_direction)) :: myDirect
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target :: V
      integer(c_int) :: ldv
      real(c_float),target :: T
      integer(c_int) :: ldt
      real(c_float),target :: A
      integer(c_int) :: lda
      !
      rocsolver_slarfb_rank_0 = rocsolver_slarfb_(handle,side,trans,myDirect,storev,m,n,k,c_loc(V),ldv,c_loc(T),ldt,c_loc(A),lda)
    end function

    function rocsolver_slarfb_rank_1(handle,side,trans,myDirect,storev,m,n,k,V,ldv,T,ldt,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slarfb_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_forward_direction)) :: myDirect
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: V
      integer(c_int) :: ldv
      real(c_float),target,dimension(:) :: T
      integer(c_int) :: ldt
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocsolver_slarfb_rank_1 = rocsolver_slarfb_(handle,side,trans,myDirect,storev,m,n,k,c_loc(V),ldv,c_loc(T),ldt,c_loc(A),lda)
    end function

    function rocsolver_dlarfb_full_rank(handle,side,trans,myDirect,storev,m,n,k,V,ldv,T,ldt,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlarfb_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_forward_direction)) :: myDirect
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      real(c_double),target,dimension(:,:) :: T
      integer(c_int) :: ldt
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocsolver_dlarfb_full_rank = rocsolver_dlarfb_(handle,side,trans,myDirect,storev,m,n,k,c_loc(V),ldv,c_loc(T),ldt,c_loc(A),lda)
    end function

    function rocsolver_dlarfb_rank_0(handle,side,trans,myDirect,storev,m,n,k,V,ldv,T,ldt,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlarfb_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_forward_direction)) :: myDirect
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target :: V
      integer(c_int) :: ldv
      real(c_double),target :: T
      integer(c_int) :: ldt
      real(c_double),target :: A
      integer(c_int) :: lda
      !
      rocsolver_dlarfb_rank_0 = rocsolver_dlarfb_(handle,side,trans,myDirect,storev,m,n,k,c_loc(V),ldv,c_loc(T),ldt,c_loc(A),lda)
    end function

    function rocsolver_dlarfb_rank_1(handle,side,trans,myDirect,storev,m,n,k,V,ldv,T,ldt,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlarfb_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_forward_direction)) :: myDirect
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: V
      integer(c_int) :: ldv
      real(c_double),target,dimension(:) :: T
      integer(c_int) :: ldt
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocsolver_dlarfb_rank_1 = rocsolver_dlarfb_(handle,side,trans,myDirect,storev,m,n,k,c_loc(V),ldv,c_loc(T),ldt,c_loc(A),lda)
    end function

    function rocsolver_clarfb_full_rank(handle,side,trans,myDirect,storev,m,n,k,V,ldv,T,ldt,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clarfb_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_forward_direction)) :: myDirect
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      complex(c_float_complex),target,dimension(:,:) :: T
      integer(c_int) :: ldt
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocsolver_clarfb_full_rank = rocsolver_clarfb_(handle,side,trans,myDirect,storev,m,n,k,c_loc(V),ldv,c_loc(T),ldt,c_loc(A),lda)
    end function

    function rocsolver_clarfb_rank_0(handle,side,trans,myDirect,storev,m,n,k,V,ldv,T,ldt,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clarfb_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_forward_direction)) :: myDirect
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target :: V
      integer(c_int) :: ldv
      complex(c_float_complex),target :: T
      integer(c_int) :: ldt
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      !
      rocsolver_clarfb_rank_0 = rocsolver_clarfb_(handle,side,trans,myDirect,storev,m,n,k,c_loc(V),ldv,c_loc(T),ldt,c_loc(A),lda)
    end function

    function rocsolver_clarfb_rank_1(handle,side,trans,myDirect,storev,m,n,k,V,ldv,T,ldt,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clarfb_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_forward_direction)) :: myDirect
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: V
      integer(c_int) :: ldv
      complex(c_float_complex),target,dimension(:) :: T
      integer(c_int) :: ldt
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocsolver_clarfb_rank_1 = rocsolver_clarfb_(handle,side,trans,myDirect,storev,m,n,k,c_loc(V),ldv,c_loc(T),ldt,c_loc(A),lda)
    end function

    function rocsolver_zlarfb_full_rank(handle,side,trans,myDirect,storev,m,n,k,V,ldv,T,ldt,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlarfb_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_forward_direction)) :: myDirect
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      complex(c_double_complex),target,dimension(:,:) :: T
      integer(c_int) :: ldt
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocsolver_zlarfb_full_rank = rocsolver_zlarfb_(handle,side,trans,myDirect,storev,m,n,k,c_loc(V),ldv,c_loc(T),ldt,c_loc(A),lda)
    end function

    function rocsolver_zlarfb_rank_0(handle,side,trans,myDirect,storev,m,n,k,V,ldv,T,ldt,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlarfb_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_forward_direction)) :: myDirect
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target :: V
      integer(c_int) :: ldv
      complex(c_double_complex),target :: T
      integer(c_int) :: ldt
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      !
      rocsolver_zlarfb_rank_0 = rocsolver_zlarfb_(handle,side,trans,myDirect,storev,m,n,k,c_loc(V),ldv,c_loc(T),ldt,c_loc(A),lda)
    end function

    function rocsolver_zlarfb_rank_1(handle,side,trans,myDirect,storev,m,n,k,V,ldv,T,ldt,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlarfb_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(kind(rocblas_forward_direction)) :: myDirect
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: V
      integer(c_int) :: ldv
      complex(c_double_complex),target,dimension(:) :: T
      integer(c_int) :: ldt
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocsolver_zlarfb_rank_1 = rocsolver_zlarfb_(handle,side,trans,myDirect,storev,m,n,k,c_loc(V),ldv,c_loc(T),ldt,c_loc(A),lda)
    end function

    function rocsolver_slabrd_full_rank(handle,m,n,k,A,lda,D,E,tauq,taup,X,ldx,Y,ldy)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slabrd_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      real(c_float),target,dimension(:) :: tauq
      real(c_float),target,dimension(:) :: taup
      real(c_float),target,dimension(:,:) :: X
      integer(c_int) :: ldx
      real(c_float),target,dimension(:,:) :: Y
      integer(c_int) :: ldy
      !
      rocsolver_slabrd_full_rank = rocsolver_slabrd_(handle,m,n,k,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup),c_loc(X),ldx,c_loc(Y),ldy)
    end function

    function rocsolver_slabrd_rank_0(handle,m,n,k,A,lda,D,E,tauq,taup,X,ldx,Y,ldy)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slabrd_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: D
      real(c_float),target :: E
      real(c_float),target :: tauq
      real(c_float),target :: taup
      real(c_float),target :: X
      integer(c_int) :: ldx
      real(c_float),target :: Y
      integer(c_int) :: ldy
      !
      rocsolver_slabrd_rank_0 = rocsolver_slabrd_(handle,m,n,k,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup),c_loc(X),ldx,c_loc(Y),ldy)
    end function

    function rocsolver_slabrd_rank_1(handle,m,n,k,A,lda,D,E,tauq,taup,X,ldx,Y,ldy)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slabrd_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      real(c_float),target,dimension(:) :: tauq
      real(c_float),target,dimension(:) :: taup
      real(c_float),target,dimension(:) :: X
      integer(c_int) :: ldx
      real(c_float),target,dimension(:) :: Y
      integer(c_int) :: ldy
      !
      rocsolver_slabrd_rank_1 = rocsolver_slabrd_(handle,m,n,k,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup),c_loc(X),ldx,c_loc(Y),ldy)
    end function

    function rocsolver_dlabrd_full_rank(handle,m,n,k,A,lda,D,E,tauq,taup,X,ldx,Y,ldy)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlabrd_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      real(c_double),target,dimension(:) :: tauq
      real(c_double),target,dimension(:) :: taup
      real(c_double),target,dimension(:,:) :: X
      integer(c_int) :: ldx
      real(c_double),target,dimension(:,:) :: Y
      integer(c_int) :: ldy
      !
      rocsolver_dlabrd_full_rank = rocsolver_dlabrd_(handle,m,n,k,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup),c_loc(X),ldx,c_loc(Y),ldy)
    end function

    function rocsolver_dlabrd_rank_0(handle,m,n,k,A,lda,D,E,tauq,taup,X,ldx,Y,ldy)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlabrd_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: D
      real(c_double),target :: E
      real(c_double),target :: tauq
      real(c_double),target :: taup
      real(c_double),target :: X
      integer(c_int) :: ldx
      real(c_double),target :: Y
      integer(c_int) :: ldy
      !
      rocsolver_dlabrd_rank_0 = rocsolver_dlabrd_(handle,m,n,k,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup),c_loc(X),ldx,c_loc(Y),ldy)
    end function

    function rocsolver_dlabrd_rank_1(handle,m,n,k,A,lda,D,E,tauq,taup,X,ldx,Y,ldy)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlabrd_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      real(c_double),target,dimension(:) :: tauq
      real(c_double),target,dimension(:) :: taup
      real(c_double),target,dimension(:) :: X
      integer(c_int) :: ldx
      real(c_double),target,dimension(:) :: Y
      integer(c_int) :: ldy
      !
      rocsolver_dlabrd_rank_1 = rocsolver_dlabrd_(handle,m,n,k,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup),c_loc(X),ldx,c_loc(Y),ldy)
    end function

    function rocsolver_clabrd_full_rank(handle,m,n,k,A,lda,D,E,tauq,taup,X,ldx,Y,ldy)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clabrd_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      complex(c_float_complex),target,dimension(:) :: tauq
      complex(c_float_complex),target,dimension(:) :: taup
      complex(c_float_complex),target,dimension(:,:) :: X
      integer(c_int) :: ldx
      complex(c_float_complex),target,dimension(:,:) :: Y
      integer(c_int) :: ldy
      !
      rocsolver_clabrd_full_rank = rocsolver_clabrd_(handle,m,n,k,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup),c_loc(X),ldx,c_loc(Y),ldy)
    end function

    function rocsolver_clabrd_rank_0(handle,m,n,k,A,lda,D,E,tauq,taup,X,ldx,Y,ldy)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clabrd_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      real(c_float),target :: D
      real(c_float),target :: E
      complex(c_float_complex),target :: tauq
      complex(c_float_complex),target :: taup
      complex(c_float_complex),target :: X
      integer(c_int) :: ldx
      complex(c_float_complex),target :: Y
      integer(c_int) :: ldy
      !
      rocsolver_clabrd_rank_0 = rocsolver_clabrd_(handle,m,n,k,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup),c_loc(X),ldx,c_loc(Y),ldy)
    end function

    function rocsolver_clabrd_rank_1(handle,m,n,k,A,lda,D,E,tauq,taup,X,ldx,Y,ldy)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clabrd_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      complex(c_float_complex),target,dimension(:) :: tauq
      complex(c_float_complex),target,dimension(:) :: taup
      complex(c_float_complex),target,dimension(:) :: X
      integer(c_int) :: ldx
      complex(c_float_complex),target,dimension(:) :: Y
      integer(c_int) :: ldy
      !
      rocsolver_clabrd_rank_1 = rocsolver_clabrd_(handle,m,n,k,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup),c_loc(X),ldx,c_loc(Y),ldy)
    end function

    function rocsolver_zlabrd_full_rank(handle,m,n,k,A,lda,D,E,tauq,taup,X,ldx,Y,ldy)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlabrd_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      complex(c_double_complex),target,dimension(:) :: tauq
      complex(c_double_complex),target,dimension(:) :: taup
      complex(c_double_complex),target,dimension(:,:) :: X
      integer(c_int) :: ldx
      complex(c_double_complex),target,dimension(:,:) :: Y
      integer(c_int) :: ldy
      !
      rocsolver_zlabrd_full_rank = rocsolver_zlabrd_(handle,m,n,k,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup),c_loc(X),ldx,c_loc(Y),ldy)
    end function

    function rocsolver_zlabrd_rank_0(handle,m,n,k,A,lda,D,E,tauq,taup,X,ldx,Y,ldy)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlabrd_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      real(c_double),target :: D
      real(c_double),target :: E
      complex(c_double_complex),target :: tauq
      complex(c_double_complex),target :: taup
      complex(c_double_complex),target :: X
      integer(c_int) :: ldx
      complex(c_double_complex),target :: Y
      integer(c_int) :: ldy
      !
      rocsolver_zlabrd_rank_0 = rocsolver_zlabrd_(handle,m,n,k,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup),c_loc(X),ldx,c_loc(Y),ldy)
    end function

    function rocsolver_zlabrd_rank_1(handle,m,n,k,A,lda,D,E,tauq,taup,X,ldx,Y,ldy)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlabrd_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      complex(c_double_complex),target,dimension(:) :: tauq
      complex(c_double_complex),target,dimension(:) :: taup
      complex(c_double_complex),target,dimension(:) :: X
      integer(c_int) :: ldx
      complex(c_double_complex),target,dimension(:) :: Y
      integer(c_int) :: ldy
      !
      rocsolver_zlabrd_rank_1 = rocsolver_zlabrd_(handle,m,n,k,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup),c_loc(X),ldx,c_loc(Y),ldy)
    end function

    function rocsolver_slatrd_full_rank(handle,uplo,n,k,A,lda,E,tau,W,ldw)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slatrd_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: E
      real(c_float) :: tau
      type(c_ptr) :: W
      integer(c_int) :: ldw
      !
      rocsolver_slatrd_full_rank = rocsolver_slatrd_(handle,uplo,n,k,c_loc(A),lda,c_loc(E),tau,W,ldw)
    end function

    function rocsolver_slatrd_rank_0(handle,uplo,n,k,A,lda,E,tau,W,ldw)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slatrd_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: E
      real(c_float) :: tau
      type(c_ptr) :: W
      integer(c_int) :: ldw
      !
      rocsolver_slatrd_rank_0 = rocsolver_slatrd_(handle,uplo,n,k,c_loc(A),lda,c_loc(E),tau,W,ldw)
    end function

    function rocsolver_slatrd_rank_1(handle,uplo,n,k,A,lda,E,tau,W,ldw)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slatrd_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: E
      real(c_float) :: tau
      type(c_ptr) :: W
      integer(c_int) :: ldw
      !
      rocsolver_slatrd_rank_1 = rocsolver_slatrd_(handle,uplo,n,k,c_loc(A),lda,c_loc(E),tau,W,ldw)
    end function

    function rocsolver_dlatrd_full_rank(handle,uplo,n,k,A,lda,E,tau,W,ldw)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlatrd_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: E
      real(c_double) :: tau
      type(c_ptr) :: W
      integer(c_int) :: ldw
      !
      rocsolver_dlatrd_full_rank = rocsolver_dlatrd_(handle,uplo,n,k,c_loc(A),lda,c_loc(E),tau,W,ldw)
    end function

    function rocsolver_dlatrd_rank_0(handle,uplo,n,k,A,lda,E,tau,W,ldw)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlatrd_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: E
      real(c_double) :: tau
      type(c_ptr) :: W
      integer(c_int) :: ldw
      !
      rocsolver_dlatrd_rank_0 = rocsolver_dlatrd_(handle,uplo,n,k,c_loc(A),lda,c_loc(E),tau,W,ldw)
    end function

    function rocsolver_dlatrd_rank_1(handle,uplo,n,k,A,lda,E,tau,W,ldw)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlatrd_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: E
      real(c_double) :: tau
      type(c_ptr) :: W
      integer(c_int) :: ldw
      !
      rocsolver_dlatrd_rank_1 = rocsolver_dlatrd_(handle,uplo,n,k,c_loc(A),lda,c_loc(E),tau,W,ldw)
    end function

    function rocsolver_clatrd_full_rank(handle,uplo,n,k,A,lda,E,tau,W,ldw)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clatrd_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: E
      complex(c_float_complex) :: tau
      type(c_ptr) :: W
      integer(c_int) :: ldw
      !
      rocsolver_clatrd_full_rank = rocsolver_clatrd_(handle,uplo,n,k,c_loc(A),lda,c_loc(E),tau,W,ldw)
    end function

    function rocsolver_clatrd_rank_0(handle,uplo,n,k,A,lda,E,tau,W,ldw)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clatrd_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      real(c_float),target :: E
      complex(c_float_complex) :: tau
      type(c_ptr) :: W
      integer(c_int) :: ldw
      !
      rocsolver_clatrd_rank_0 = rocsolver_clatrd_(handle,uplo,n,k,c_loc(A),lda,c_loc(E),tau,W,ldw)
    end function

    function rocsolver_clatrd_rank_1(handle,uplo,n,k,A,lda,E,tau,W,ldw)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clatrd_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: E
      complex(c_float_complex) :: tau
      type(c_ptr) :: W
      integer(c_int) :: ldw
      !
      rocsolver_clatrd_rank_1 = rocsolver_clatrd_(handle,uplo,n,k,c_loc(A),lda,c_loc(E),tau,W,ldw)
    end function

    function rocsolver_zlatrd_full_rank(handle,uplo,n,k,A,lda,E,tau,W,ldw)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlatrd_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: E
      complex(c_double_complex) :: tau
      type(c_ptr) :: W
      integer(c_int) :: ldw
      !
      rocsolver_zlatrd_full_rank = rocsolver_zlatrd_(handle,uplo,n,k,c_loc(A),lda,c_loc(E),tau,W,ldw)
    end function

    function rocsolver_zlatrd_rank_0(handle,uplo,n,k,A,lda,E,tau,W,ldw)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlatrd_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      real(c_double),target :: E
      complex(c_double_complex) :: tau
      type(c_ptr) :: W
      integer(c_int) :: ldw
      !
      rocsolver_zlatrd_rank_0 = rocsolver_zlatrd_(handle,uplo,n,k,c_loc(A),lda,c_loc(E),tau,W,ldw)
    end function

    function rocsolver_zlatrd_rank_1(handle,uplo,n,k,A,lda,E,tau,W,ldw)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlatrd_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: E
      complex(c_double_complex) :: tau
      type(c_ptr) :: W
      integer(c_int) :: ldw
      !
      rocsolver_zlatrd_rank_1 = rocsolver_zlatrd_(handle,uplo,n,k,c_loc(A),lda,c_loc(E),tau,W,ldw)
    end function

    function rocsolver_slasyf_full_rank(handle,uplo,n,nb,kb,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slasyf_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nb
      type(c_ptr) :: kb
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_slasyf_full_rank = rocsolver_slasyf_(handle,uplo,n,nb,kb,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_slasyf_rank_0(handle,uplo,n,nb,kb,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slasyf_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nb
      type(c_ptr) :: kb
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_slasyf_rank_0 = rocsolver_slasyf_(handle,uplo,n,nb,kb,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_slasyf_rank_1(handle,uplo,n,nb,kb,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slasyf_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nb
      type(c_ptr) :: kb
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_slasyf_rank_1 = rocsolver_slasyf_(handle,uplo,n,nb,kb,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_dlasyf_full_rank(handle,uplo,n,nb,kb,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlasyf_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nb
      type(c_ptr) :: kb
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_dlasyf_full_rank = rocsolver_dlasyf_(handle,uplo,n,nb,kb,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_dlasyf_rank_0(handle,uplo,n,nb,kb,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlasyf_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nb
      type(c_ptr) :: kb
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_dlasyf_rank_0 = rocsolver_dlasyf_(handle,uplo,n,nb,kb,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_dlasyf_rank_1(handle,uplo,n,nb,kb,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlasyf_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nb
      type(c_ptr) :: kb
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_dlasyf_rank_1 = rocsolver_dlasyf_(handle,uplo,n,nb,kb,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_clasyf_full_rank(handle,uplo,n,nb,kb,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clasyf_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nb
      type(c_ptr) :: kb
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_clasyf_full_rank = rocsolver_clasyf_(handle,uplo,n,nb,kb,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_clasyf_rank_0(handle,uplo,n,nb,kb,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clasyf_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nb
      type(c_ptr) :: kb
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_clasyf_rank_0 = rocsolver_clasyf_(handle,uplo,n,nb,kb,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_clasyf_rank_1(handle,uplo,n,nb,kb,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clasyf_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nb
      type(c_ptr) :: kb
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_clasyf_rank_1 = rocsolver_clasyf_(handle,uplo,n,nb,kb,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_zlasyf_full_rank(handle,uplo,n,nb,kb,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlasyf_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nb
      type(c_ptr) :: kb
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_zlasyf_full_rank = rocsolver_zlasyf_(handle,uplo,n,nb,kb,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_zlasyf_rank_0(handle,uplo,n,nb,kb,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlasyf_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nb
      type(c_ptr) :: kb
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_zlasyf_rank_0 = rocsolver_zlasyf_(handle,uplo,n,nb,kb,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_zlasyf_rank_1(handle,uplo,n,nb,kb,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlasyf_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nb
      type(c_ptr) :: kb
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_zlasyf_rank_1 = rocsolver_zlasyf_(handle,uplo,n,nb,kb,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_slauum_full_rank(handle,uplo,n,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slauum_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocsolver_slauum_full_rank = rocsolver_slauum_(handle,uplo,n,c_loc(A),lda)
    end function

    function rocsolver_slauum_rank_0(handle,uplo,n,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slauum_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      !
      rocsolver_slauum_rank_0 = rocsolver_slauum_(handle,uplo,n,c_loc(A),lda)
    end function

    function rocsolver_slauum_rank_1(handle,uplo,n,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_slauum_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocsolver_slauum_rank_1 = rocsolver_slauum_(handle,uplo,n,c_loc(A),lda)
    end function

    function rocsolver_dlauum_full_rank(handle,uplo,n,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlauum_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocsolver_dlauum_full_rank = rocsolver_dlauum_(handle,uplo,n,c_loc(A),lda)
    end function

    function rocsolver_dlauum_rank_0(handle,uplo,n,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlauum_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      !
      rocsolver_dlauum_rank_0 = rocsolver_dlauum_(handle,uplo,n,c_loc(A),lda)
    end function

    function rocsolver_dlauum_rank_1(handle,uplo,n,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dlauum_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocsolver_dlauum_rank_1 = rocsolver_dlauum_(handle,uplo,n,c_loc(A),lda)
    end function

    function rocsolver_clauum_full_rank(handle,uplo,n,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clauum_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocsolver_clauum_full_rank = rocsolver_clauum_(handle,uplo,n,c_loc(A),lda)
    end function

    function rocsolver_clauum_rank_0(handle,uplo,n,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clauum_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      !
      rocsolver_clauum_rank_0 = rocsolver_clauum_(handle,uplo,n,c_loc(A),lda)
    end function

    function rocsolver_clauum_rank_1(handle,uplo,n,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_clauum_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocsolver_clauum_rank_1 = rocsolver_clauum_(handle,uplo,n,c_loc(A),lda)
    end function

    function rocsolver_zlauum_full_rank(handle,uplo,n,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlauum_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      !
      rocsolver_zlauum_full_rank = rocsolver_zlauum_(handle,uplo,n,c_loc(A),lda)
    end function

    function rocsolver_zlauum_rank_0(handle,uplo,n,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlauum_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      !
      rocsolver_zlauum_rank_0 = rocsolver_zlauum_(handle,uplo,n,c_loc(A),lda)
    end function

    function rocsolver_zlauum_rank_1(handle,uplo,n,A,lda)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zlauum_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      !
      rocsolver_zlauum_rank_1 = rocsolver_zlauum_(handle,uplo,n,c_loc(A),lda)
    end function

    function rocsolver_sorg2r_full_rank(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorg2r_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sorg2r_full_rank = rocsolver_sorg2r_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sorg2r_rank_0(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorg2r_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      !
      rocsolver_sorg2r_rank_0 = rocsolver_sorg2r_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sorg2r_rank_1(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorg2r_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sorg2r_rank_1 = rocsolver_sorg2r_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dorg2r_full_rank(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorg2r_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dorg2r_full_rank = rocsolver_dorg2r_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dorg2r_rank_0(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorg2r_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      !
      rocsolver_dorg2r_rank_0 = rocsolver_dorg2r_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dorg2r_rank_1(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorg2r_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dorg2r_rank_1 = rocsolver_dorg2r_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cung2r_full_rank(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cung2r_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cung2r_full_rank = rocsolver_cung2r_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cung2r_rank_0(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cung2r_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      !
      rocsolver_cung2r_rank_0 = rocsolver_cung2r_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cung2r_rank_1(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cung2r_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cung2r_rank_1 = rocsolver_cung2r_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zung2r_full_rank(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zung2r_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zung2r_full_rank = rocsolver_zung2r_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zung2r_rank_0(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zung2r_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      !
      rocsolver_zung2r_rank_0 = rocsolver_zung2r_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zung2r_rank_1(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zung2r_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zung2r_rank_1 = rocsolver_zung2r_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sorgqr_full_rank(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorgqr_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sorgqr_full_rank = rocsolver_sorgqr_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sorgqr_rank_0(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorgqr_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      !
      rocsolver_sorgqr_rank_0 = rocsolver_sorgqr_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sorgqr_rank_1(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorgqr_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sorgqr_rank_1 = rocsolver_sorgqr_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dorgqr_full_rank(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorgqr_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dorgqr_full_rank = rocsolver_dorgqr_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dorgqr_rank_0(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorgqr_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      !
      rocsolver_dorgqr_rank_0 = rocsolver_dorgqr_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dorgqr_rank_1(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorgqr_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dorgqr_rank_1 = rocsolver_dorgqr_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cungqr_full_rank(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cungqr_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cungqr_full_rank = rocsolver_cungqr_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cungqr_rank_0(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cungqr_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      !
      rocsolver_cungqr_rank_0 = rocsolver_cungqr_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cungqr_rank_1(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cungqr_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cungqr_rank_1 = rocsolver_cungqr_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zungqr_full_rank(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zungqr_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zungqr_full_rank = rocsolver_zungqr_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zungqr_rank_0(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zungqr_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      !
      rocsolver_zungqr_rank_0 = rocsolver_zungqr_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zungqr_rank_1(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zungqr_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zungqr_rank_1 = rocsolver_zungqr_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sorgl2_full_rank(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorgl2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sorgl2_full_rank = rocsolver_sorgl2_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sorgl2_rank_0(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorgl2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      !
      rocsolver_sorgl2_rank_0 = rocsolver_sorgl2_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sorgl2_rank_1(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorgl2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sorgl2_rank_1 = rocsolver_sorgl2_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dorgl2_full_rank(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorgl2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dorgl2_full_rank = rocsolver_dorgl2_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dorgl2_rank_0(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorgl2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      !
      rocsolver_dorgl2_rank_0 = rocsolver_dorgl2_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dorgl2_rank_1(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorgl2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dorgl2_rank_1 = rocsolver_dorgl2_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cungl2_full_rank(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cungl2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cungl2_full_rank = rocsolver_cungl2_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cungl2_rank_0(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cungl2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      !
      rocsolver_cungl2_rank_0 = rocsolver_cungl2_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cungl2_rank_1(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cungl2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cungl2_rank_1 = rocsolver_cungl2_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zungl2_full_rank(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zungl2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zungl2_full_rank = rocsolver_zungl2_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zungl2_rank_0(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zungl2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      !
      rocsolver_zungl2_rank_0 = rocsolver_zungl2_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zungl2_rank_1(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zungl2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zungl2_rank_1 = rocsolver_zungl2_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sorglq_full_rank(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorglq_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sorglq_full_rank = rocsolver_sorglq_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sorglq_rank_0(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorglq_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      !
      rocsolver_sorglq_rank_0 = rocsolver_sorglq_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sorglq_rank_1(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorglq_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sorglq_rank_1 = rocsolver_sorglq_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dorglq_full_rank(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorglq_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dorglq_full_rank = rocsolver_dorglq_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dorglq_rank_0(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorglq_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      !
      rocsolver_dorglq_rank_0 = rocsolver_dorglq_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dorglq_rank_1(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorglq_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dorglq_rank_1 = rocsolver_dorglq_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cunglq_full_rank(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunglq_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cunglq_full_rank = rocsolver_cunglq_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cunglq_rank_0(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunglq_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      !
      rocsolver_cunglq_rank_0 = rocsolver_cunglq_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cunglq_rank_1(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunglq_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cunglq_rank_1 = rocsolver_cunglq_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zunglq_full_rank(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunglq_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zunglq_full_rank = rocsolver_zunglq_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zunglq_rank_0(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunglq_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      !
      rocsolver_zunglq_rank_0 = rocsolver_zunglq_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zunglq_rank_1(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunglq_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zunglq_rank_1 = rocsolver_zunglq_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sorg2l_full_rank(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorg2l_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sorg2l_full_rank = rocsolver_sorg2l_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sorg2l_rank_0(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorg2l_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      !
      rocsolver_sorg2l_rank_0 = rocsolver_sorg2l_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sorg2l_rank_1(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorg2l_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sorg2l_rank_1 = rocsolver_sorg2l_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dorg2l_full_rank(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorg2l_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dorg2l_full_rank = rocsolver_dorg2l_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dorg2l_rank_0(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorg2l_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      !
      rocsolver_dorg2l_rank_0 = rocsolver_dorg2l_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dorg2l_rank_1(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorg2l_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dorg2l_rank_1 = rocsolver_dorg2l_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cung2l_full_rank(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cung2l_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cung2l_full_rank = rocsolver_cung2l_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cung2l_rank_0(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cung2l_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      !
      rocsolver_cung2l_rank_0 = rocsolver_cung2l_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cung2l_rank_1(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cung2l_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cung2l_rank_1 = rocsolver_cung2l_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zung2l_full_rank(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zung2l_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zung2l_full_rank = rocsolver_zung2l_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zung2l_rank_0(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zung2l_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      !
      rocsolver_zung2l_rank_0 = rocsolver_zung2l_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zung2l_rank_1(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zung2l_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zung2l_rank_1 = rocsolver_zung2l_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sorgql_full_rank(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorgql_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sorgql_full_rank = rocsolver_sorgql_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sorgql_rank_0(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorgql_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      !
      rocsolver_sorgql_rank_0 = rocsolver_sorgql_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sorgql_rank_1(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorgql_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sorgql_rank_1 = rocsolver_sorgql_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dorgql_full_rank(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorgql_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dorgql_full_rank = rocsolver_dorgql_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dorgql_rank_0(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorgql_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      !
      rocsolver_dorgql_rank_0 = rocsolver_dorgql_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dorgql_rank_1(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorgql_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dorgql_rank_1 = rocsolver_dorgql_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cungql_full_rank(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cungql_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cungql_full_rank = rocsolver_cungql_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cungql_rank_0(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cungql_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      !
      rocsolver_cungql_rank_0 = rocsolver_cungql_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cungql_rank_1(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cungql_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cungql_rank_1 = rocsolver_cungql_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zungql_full_rank(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zungql_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zungql_full_rank = rocsolver_zungql_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zungql_rank_0(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zungql_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      !
      rocsolver_zungql_rank_0 = rocsolver_zungql_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zungql_rank_1(handle,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zungql_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zungql_rank_1 = rocsolver_zungql_(handle,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sorgbr_full_rank(handle,storev,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorgbr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sorgbr_full_rank = rocsolver_sorgbr_(handle,storev,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sorgbr_rank_0(handle,storev,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorgbr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      !
      rocsolver_sorgbr_rank_0 = rocsolver_sorgbr_(handle,storev,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sorgbr_rank_1(handle,storev,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorgbr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sorgbr_rank_1 = rocsolver_sorgbr_(handle,storev,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dorgbr_full_rank(handle,storev,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorgbr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dorgbr_full_rank = rocsolver_dorgbr_(handle,storev,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dorgbr_rank_0(handle,storev,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorgbr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      !
      rocsolver_dorgbr_rank_0 = rocsolver_dorgbr_(handle,storev,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dorgbr_rank_1(handle,storev,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorgbr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dorgbr_rank_1 = rocsolver_dorgbr_(handle,storev,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cungbr_full_rank(handle,storev,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cungbr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cungbr_full_rank = rocsolver_cungbr_(handle,storev,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cungbr_rank_0(handle,storev,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cungbr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      !
      rocsolver_cungbr_rank_0 = rocsolver_cungbr_(handle,storev,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cungbr_rank_1(handle,storev,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cungbr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cungbr_rank_1 = rocsolver_cungbr_(handle,storev,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zungbr_full_rank(handle,storev,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zungbr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zungbr_full_rank = rocsolver_zungbr_(handle,storev,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zungbr_rank_0(handle,storev,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zungbr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      !
      rocsolver_zungbr_rank_0 = rocsolver_zungbr_(handle,storev,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zungbr_rank_1(handle,storev,m,n,k,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zungbr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_column_wise)) :: storev
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zungbr_rank_1 = rocsolver_zungbr_(handle,storev,m,n,k,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sorgtr_full_rank(handle,uplo,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorgtr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sorgtr_full_rank = rocsolver_sorgtr_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sorgtr_rank_0(handle,uplo,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorgtr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      !
      rocsolver_sorgtr_rank_0 = rocsolver_sorgtr_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sorgtr_rank_1(handle,uplo,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorgtr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sorgtr_rank_1 = rocsolver_sorgtr_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dorgtr_full_rank(handle,uplo,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorgtr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dorgtr_full_rank = rocsolver_dorgtr_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dorgtr_rank_0(handle,uplo,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorgtr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      !
      rocsolver_dorgtr_rank_0 = rocsolver_dorgtr_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dorgtr_rank_1(handle,uplo,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorgtr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dorgtr_rank_1 = rocsolver_dorgtr_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cungtr_full_rank(handle,uplo,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cungtr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cungtr_full_rank = rocsolver_cungtr_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cungtr_rank_0(handle,uplo,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cungtr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      !
      rocsolver_cungtr_rank_0 = rocsolver_cungtr_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cungtr_rank_1(handle,uplo,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cungtr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cungtr_rank_1 = rocsolver_cungtr_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zungtr_full_rank(handle,uplo,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zungtr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zungtr_full_rank = rocsolver_zungtr_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zungtr_rank_0(handle,uplo,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zungtr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      !
      rocsolver_zungtr_rank_0 = rocsolver_zungtr_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zungtr_rank_1(handle,uplo,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zungtr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zungtr_rank_1 = rocsolver_zungtr_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sorm2r_full_rank(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorm2r_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_sorm2r_full_rank = rocsolver_sorm2r_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_sorm2r_rank_0(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorm2r_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      real(c_float),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_sorm2r_rank_0 = rocsolver_sorm2r_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_sorm2r_rank_1(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorm2r_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_sorm2r_rank_1 = rocsolver_sorm2r_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_dorm2r_full_rank(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorm2r_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_dorm2r_full_rank = rocsolver_dorm2r_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_dorm2r_rank_0(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorm2r_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      real(c_double),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_dorm2r_rank_0 = rocsolver_dorm2r_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_dorm2r_rank_1(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorm2r_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_dorm2r_rank_1 = rocsolver_dorm2r_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_cunm2r_full_rank(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunm2r_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_cunm2r_full_rank = rocsolver_cunm2r_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_cunm2r_rank_0(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunm2r_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_cunm2r_rank_0 = rocsolver_cunm2r_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_cunm2r_rank_1(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunm2r_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_cunm2r_rank_1 = rocsolver_cunm2r_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_zunm2r_full_rank(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunm2r_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_zunm2r_full_rank = rocsolver_zunm2r_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_zunm2r_rank_0(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunm2r_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_zunm2r_rank_0 = rocsolver_zunm2r_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_zunm2r_rank_1(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunm2r_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_zunm2r_rank_1 = rocsolver_zunm2r_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_sormqr_full_rank(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sormqr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_sormqr_full_rank = rocsolver_sormqr_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_sormqr_rank_0(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sormqr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      real(c_float),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_sormqr_rank_0 = rocsolver_sormqr_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_sormqr_rank_1(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sormqr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_sormqr_rank_1 = rocsolver_sormqr_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_dormqr_full_rank(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dormqr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_dormqr_full_rank = rocsolver_dormqr_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_dormqr_rank_0(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dormqr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      real(c_double),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_dormqr_rank_0 = rocsolver_dormqr_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_dormqr_rank_1(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dormqr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_dormqr_rank_1 = rocsolver_dormqr_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_cunmqr_full_rank(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunmqr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_cunmqr_full_rank = rocsolver_cunmqr_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_cunmqr_rank_0(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunmqr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_cunmqr_rank_0 = rocsolver_cunmqr_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_cunmqr_rank_1(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunmqr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_cunmqr_rank_1 = rocsolver_cunmqr_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_zunmqr_full_rank(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunmqr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_zunmqr_full_rank = rocsolver_zunmqr_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_zunmqr_rank_0(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunmqr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_zunmqr_rank_0 = rocsolver_zunmqr_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_zunmqr_rank_1(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunmqr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_zunmqr_rank_1 = rocsolver_zunmqr_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_sorml2_full_rank(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorml2_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_sorml2_full_rank = rocsolver_sorml2_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_sorml2_rank_0(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorml2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      real(c_float),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_sorml2_rank_0 = rocsolver_sorml2_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_sorml2_rank_1(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorml2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_sorml2_rank_1 = rocsolver_sorml2_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_dorml2_full_rank(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorml2_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_dorml2_full_rank = rocsolver_dorml2_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_dorml2_rank_0(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorml2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      real(c_double),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_dorml2_rank_0 = rocsolver_dorml2_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_dorml2_rank_1(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorml2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_dorml2_rank_1 = rocsolver_dorml2_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_cunml2_full_rank(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunml2_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_cunml2_full_rank = rocsolver_cunml2_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_cunml2_rank_0(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunml2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_cunml2_rank_0 = rocsolver_cunml2_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_cunml2_rank_1(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunml2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_cunml2_rank_1 = rocsolver_cunml2_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_zunml2_full_rank(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunml2_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_zunml2_full_rank = rocsolver_zunml2_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_zunml2_rank_0(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunml2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_zunml2_rank_0 = rocsolver_zunml2_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_zunml2_rank_1(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunml2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_zunml2_rank_1 = rocsolver_zunml2_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_sormlq_full_rank(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sormlq_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_sormlq_full_rank = rocsolver_sormlq_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_sormlq_rank_0(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sormlq_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      real(c_float),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_sormlq_rank_0 = rocsolver_sormlq_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_sormlq_rank_1(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sormlq_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_sormlq_rank_1 = rocsolver_sormlq_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_dormlq_full_rank(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dormlq_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_dormlq_full_rank = rocsolver_dormlq_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_dormlq_rank_0(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dormlq_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      real(c_double),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_dormlq_rank_0 = rocsolver_dormlq_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_dormlq_rank_1(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dormlq_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_dormlq_rank_1 = rocsolver_dormlq_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_cunmlq_full_rank(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunmlq_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_cunmlq_full_rank = rocsolver_cunmlq_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_cunmlq_rank_0(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunmlq_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_cunmlq_rank_0 = rocsolver_cunmlq_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_cunmlq_rank_1(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunmlq_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_cunmlq_rank_1 = rocsolver_cunmlq_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_zunmlq_full_rank(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunmlq_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_zunmlq_full_rank = rocsolver_zunmlq_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_zunmlq_rank_0(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunmlq_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_zunmlq_rank_0 = rocsolver_zunmlq_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_zunmlq_rank_1(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunmlq_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_zunmlq_rank_1 = rocsolver_zunmlq_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_sorm2l_full_rank(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorm2l_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_sorm2l_full_rank = rocsolver_sorm2l_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_sorm2l_rank_0(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorm2l_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      real(c_float),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_sorm2l_rank_0 = rocsolver_sorm2l_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_sorm2l_rank_1(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sorm2l_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_sorm2l_rank_1 = rocsolver_sorm2l_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_dorm2l_full_rank(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorm2l_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_dorm2l_full_rank = rocsolver_dorm2l_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_dorm2l_rank_0(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorm2l_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      real(c_double),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_dorm2l_rank_0 = rocsolver_dorm2l_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_dorm2l_rank_1(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dorm2l_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_dorm2l_rank_1 = rocsolver_dorm2l_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_cunm2l_full_rank(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunm2l_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_cunm2l_full_rank = rocsolver_cunm2l_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_cunm2l_rank_0(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunm2l_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_cunm2l_rank_0 = rocsolver_cunm2l_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_cunm2l_rank_1(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunm2l_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_cunm2l_rank_1 = rocsolver_cunm2l_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_zunm2l_full_rank(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunm2l_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_zunm2l_full_rank = rocsolver_zunm2l_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_zunm2l_rank_0(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunm2l_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_zunm2l_rank_0 = rocsolver_zunm2l_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_zunm2l_rank_1(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunm2l_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_zunm2l_rank_1 = rocsolver_zunm2l_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_sormql_full_rank(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sormql_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_sormql_full_rank = rocsolver_sormql_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_sormql_rank_0(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sormql_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      real(c_float),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_sormql_rank_0 = rocsolver_sormql_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_sormql_rank_1(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sormql_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_sormql_rank_1 = rocsolver_sormql_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_dormql_full_rank(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dormql_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_dormql_full_rank = rocsolver_dormql_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_dormql_rank_0(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dormql_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      real(c_double),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_dormql_rank_0 = rocsolver_dormql_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_dormql_rank_1(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dormql_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_dormql_rank_1 = rocsolver_dormql_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_cunmql_full_rank(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunmql_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_cunmql_full_rank = rocsolver_cunmql_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_cunmql_rank_0(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunmql_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_cunmql_rank_0 = rocsolver_cunmql_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_cunmql_rank_1(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunmql_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_cunmql_rank_1 = rocsolver_cunmql_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_zunmql_full_rank(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunmql_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_zunmql_full_rank = rocsolver_zunmql_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_zunmql_rank_0(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunmql_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_zunmql_rank_0 = rocsolver_zunmql_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_zunmql_rank_1(handle,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunmql_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_zunmql_rank_1 = rocsolver_zunmql_(handle,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_sormbr_full_rank(handle,storev,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sormbr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_column_wise)) :: storev
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_sormbr_full_rank = rocsolver_sormbr_(handle,storev,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_sormbr_rank_0(handle,storev,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sormbr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_column_wise)) :: storev
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      real(c_float),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_sormbr_rank_0 = rocsolver_sormbr_(handle,storev,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_sormbr_rank_1(handle,storev,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sormbr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_column_wise)) :: storev
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_sormbr_rank_1 = rocsolver_sormbr_(handle,storev,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_dormbr_full_rank(handle,storev,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dormbr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_column_wise)) :: storev
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_dormbr_full_rank = rocsolver_dormbr_(handle,storev,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_dormbr_rank_0(handle,storev,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dormbr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_column_wise)) :: storev
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      real(c_double),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_dormbr_rank_0 = rocsolver_dormbr_(handle,storev,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_dormbr_rank_1(handle,storev,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dormbr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_column_wise)) :: storev
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_dormbr_rank_1 = rocsolver_dormbr_(handle,storev,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_cunmbr_full_rank(handle,storev,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunmbr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_column_wise)) :: storev
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_cunmbr_full_rank = rocsolver_cunmbr_(handle,storev,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_cunmbr_rank_0(handle,storev,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunmbr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_column_wise)) :: storev
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_cunmbr_rank_0 = rocsolver_cunmbr_(handle,storev,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_cunmbr_rank_1(handle,storev,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunmbr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_column_wise)) :: storev
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_cunmbr_rank_1 = rocsolver_cunmbr_(handle,storev,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_zunmbr_full_rank(handle,storev,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunmbr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_column_wise)) :: storev
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_zunmbr_full_rank = rocsolver_zunmbr_(handle,storev,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_zunmbr_rank_0(handle,storev,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunmbr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_column_wise)) :: storev
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_zunmbr_rank_0 = rocsolver_zunmbr_(handle,storev,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_zunmbr_rank_1(handle,storev,side,trans,m,n,k,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunmbr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_column_wise)) :: storev
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_zunmbr_rank_1 = rocsolver_zunmbr_(handle,storev,side,trans,m,n,k,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_sormtr_full_rank(handle,side,uplo,trans,m,n,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sormtr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_sormtr_full_rank = rocsolver_sormtr_(handle,side,uplo,trans,m,n,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_sormtr_rank_0(handle,side,uplo,trans,m,n,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sormtr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      real(c_float),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_sormtr_rank_0 = rocsolver_sormtr_(handle,side,uplo,trans,m,n,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_sormtr_rank_1(handle,side,uplo,trans,m,n,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sormtr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_sormtr_rank_1 = rocsolver_sormtr_(handle,side,uplo,trans,m,n,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_dormtr_full_rank(handle,side,uplo,trans,m,n,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dormtr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_dormtr_full_rank = rocsolver_dormtr_(handle,side,uplo,trans,m,n,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_dormtr_rank_0(handle,side,uplo,trans,m,n,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dormtr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      real(c_double),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_dormtr_rank_0 = rocsolver_dormtr_(handle,side,uplo,trans,m,n,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_dormtr_rank_1(handle,side,uplo,trans,m,n,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dormtr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_dormtr_rank_1 = rocsolver_dormtr_(handle,side,uplo,trans,m,n,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_cunmtr_full_rank(handle,side,uplo,trans,m,n,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunmtr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_cunmtr_full_rank = rocsolver_cunmtr_(handle,side,uplo,trans,m,n,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_cunmtr_rank_0(handle,side,uplo,trans,m,n,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunmtr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_cunmtr_rank_0 = rocsolver_cunmtr_(handle,side,uplo,trans,m,n,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_cunmtr_rank_1(handle,side,uplo,trans,m,n,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cunmtr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_cunmtr_rank_1 = rocsolver_cunmtr_(handle,side,uplo,trans,m,n,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_zunmtr_full_rank(handle,side,uplo,trans,m,n,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunmtr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_zunmtr_full_rank = rocsolver_zunmtr_(handle,side,uplo,trans,m,n,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_zunmtr_rank_0(handle,side,uplo,trans,m,n,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunmtr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      rocsolver_zunmtr_rank_0 = rocsolver_zunmtr_(handle,side,uplo,trans,m,n,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_zunmtr_rank_1(handle,side,uplo,trans,m,n,A,lda,ipiv,C,ldc)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zunmtr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_side_left)) :: side
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      rocsolver_zunmtr_rank_1 = rocsolver_zunmtr_(handle,side,uplo,trans,m,n,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc)
    end function

    function rocsolver_sbdsqr_full_rank(handle,uplo,n,nv,nu,nc,D,E,V,ldv,U,ldu,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sbdsqr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nv
      integer(c_int) :: nu
      integer(c_int) :: nc
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      real(c_float),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      real(c_float),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_sbdsqr_full_rank = rocsolver_sbdsqr_(handle,uplo,n,nv,nu,nc,c_loc(D),c_loc(E),c_loc(V),ldv,c_loc(U),ldu,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_sbdsqr_rank_0(handle,uplo,n,nv,nu,nc,D,E,V,ldv,U,ldu,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sbdsqr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nv
      integer(c_int) :: nu
      integer(c_int) :: nc
      real(c_float),target :: D
      real(c_float),target :: E
      real(c_float),target :: V
      integer(c_int) :: ldv
      real(c_float),target :: U
      integer(c_int) :: ldu
      real(c_float),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_sbdsqr_rank_0 = rocsolver_sbdsqr_(handle,uplo,n,nv,nu,nc,c_loc(D),c_loc(E),c_loc(V),ldv,c_loc(U),ldu,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_sbdsqr_rank_1(handle,uplo,n,nv,nu,nc,D,E,V,ldv,U,ldu,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sbdsqr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nv
      integer(c_int) :: nu
      integer(c_int) :: nc
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      real(c_float),target,dimension(:) :: V
      integer(c_int) :: ldv
      real(c_float),target,dimension(:) :: U
      integer(c_int) :: ldu
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_sbdsqr_rank_1 = rocsolver_sbdsqr_(handle,uplo,n,nv,nu,nc,c_loc(D),c_loc(E),c_loc(V),ldv,c_loc(U),ldu,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_dbdsqr_full_rank(handle,uplo,n,nv,nu,nc,D,E,V,ldv,U,ldu,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dbdsqr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nv
      integer(c_int) :: nu
      integer(c_int) :: nc
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      real(c_double),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      real(c_double),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_dbdsqr_full_rank = rocsolver_dbdsqr_(handle,uplo,n,nv,nu,nc,c_loc(D),c_loc(E),c_loc(V),ldv,c_loc(U),ldu,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_dbdsqr_rank_0(handle,uplo,n,nv,nu,nc,D,E,V,ldv,U,ldu,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dbdsqr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nv
      integer(c_int) :: nu
      integer(c_int) :: nc
      real(c_double),target :: D
      real(c_double),target :: E
      real(c_double),target :: V
      integer(c_int) :: ldv
      real(c_double),target :: U
      integer(c_int) :: ldu
      real(c_double),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_dbdsqr_rank_0 = rocsolver_dbdsqr_(handle,uplo,n,nv,nu,nc,c_loc(D),c_loc(E),c_loc(V),ldv,c_loc(U),ldu,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_dbdsqr_rank_1(handle,uplo,n,nv,nu,nc,D,E,V,ldv,U,ldu,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dbdsqr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nv
      integer(c_int) :: nu
      integer(c_int) :: nc
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      real(c_double),target,dimension(:) :: V
      integer(c_int) :: ldv
      real(c_double),target,dimension(:) :: U
      integer(c_int) :: ldu
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_dbdsqr_rank_1 = rocsolver_dbdsqr_(handle,uplo,n,nv,nu,nc,c_loc(D),c_loc(E),c_loc(V),ldv,c_loc(U),ldu,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_cbdsqr_full_rank(handle,uplo,n,nv,nu,nc,D,E,V,ldv,U,ldu,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cbdsqr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nv
      integer(c_int) :: nu
      integer(c_int) :: nc
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      complex(c_float_complex),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      complex(c_float_complex),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_cbdsqr_full_rank = rocsolver_cbdsqr_(handle,uplo,n,nv,nu,nc,c_loc(D),c_loc(E),c_loc(V),ldv,c_loc(U),ldu,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_cbdsqr_rank_0(handle,uplo,n,nv,nu,nc,D,E,V,ldv,U,ldu,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cbdsqr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nv
      integer(c_int) :: nu
      integer(c_int) :: nc
      real(c_float),target :: D
      real(c_float),target :: E
      complex(c_float_complex),target :: V
      integer(c_int) :: ldv
      complex(c_float_complex),target :: U
      integer(c_int) :: ldu
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_cbdsqr_rank_0 = rocsolver_cbdsqr_(handle,uplo,n,nv,nu,nc,c_loc(D),c_loc(E),c_loc(V),ldv,c_loc(U),ldu,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_cbdsqr_rank_1(handle,uplo,n,nv,nu,nc,D,E,V,ldv,U,ldu,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cbdsqr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nv
      integer(c_int) :: nu
      integer(c_int) :: nc
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      complex(c_float_complex),target,dimension(:) :: V
      integer(c_int) :: ldv
      complex(c_float_complex),target,dimension(:) :: U
      integer(c_int) :: ldu
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_cbdsqr_rank_1 = rocsolver_cbdsqr_(handle,uplo,n,nv,nu,nc,c_loc(D),c_loc(E),c_loc(V),ldv,c_loc(U),ldu,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_zbdsqr_full_rank(handle,uplo,n,nv,nu,nc,D,E,V,ldv,U,ldu,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zbdsqr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nv
      integer(c_int) :: nu
      integer(c_int) :: nc
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      complex(c_double_complex),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      complex(c_double_complex),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_zbdsqr_full_rank = rocsolver_zbdsqr_(handle,uplo,n,nv,nu,nc,c_loc(D),c_loc(E),c_loc(V),ldv,c_loc(U),ldu,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_zbdsqr_rank_0(handle,uplo,n,nv,nu,nc,D,E,V,ldv,U,ldu,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zbdsqr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nv
      integer(c_int) :: nu
      integer(c_int) :: nc
      real(c_double),target :: D
      real(c_double),target :: E
      complex(c_double_complex),target :: V
      integer(c_int) :: ldv
      complex(c_double_complex),target :: U
      integer(c_int) :: ldu
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_zbdsqr_rank_0 = rocsolver_zbdsqr_(handle,uplo,n,nv,nu,nc,c_loc(D),c_loc(E),c_loc(V),ldv,c_loc(U),ldu,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_zbdsqr_rank_1(handle,uplo,n,nv,nu,nc,D,E,V,ldv,U,ldu,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zbdsqr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nv
      integer(c_int) :: nu
      integer(c_int) :: nc
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      complex(c_double_complex),target,dimension(:) :: V
      integer(c_int) :: ldv
      complex(c_double_complex),target,dimension(:) :: U
      integer(c_int) :: ldu
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_zbdsqr_rank_1 = rocsolver_zbdsqr_(handle,uplo,n,nv,nu,nc,c_loc(D),c_loc(E),c_loc(V),ldv,c_loc(U),ldu,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_ssterf_rank_0(handle,n,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssterf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: D
      real(c_float),target :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_ssterf_rank_0 = rocsolver_ssterf_(handle,n,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_ssterf_rank_1(handle,n,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssterf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_ssterf_rank_1 = rocsolver_ssterf_(handle,n,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_dsterf_rank_0(handle,n,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsterf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: D
      real(c_double),target :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_dsterf_rank_0 = rocsolver_dsterf_(handle,n,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_dsterf_rank_1(handle,n,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsterf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_dsterf_rank_1 = rocsolver_dsterf_(handle,n,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_ssteqr_full_rank(handle,evect,n,D,E,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssteqr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_ssteqr_full_rank = rocsolver_ssteqr_(handle,evect,n,c_loc(D),c_loc(E),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_ssteqr_rank_0(handle,evect,n,D,E,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssteqr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(c_int) :: n
      real(c_float),target :: D
      real(c_float),target :: E
      real(c_float),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_ssteqr_rank_0 = rocsolver_ssteqr_(handle,evect,n,c_loc(D),c_loc(E),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_ssteqr_rank_1(handle,evect,n,D,E,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssteqr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_ssteqr_rank_1 = rocsolver_ssteqr_(handle,evect,n,c_loc(D),c_loc(E),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_dsteqr_full_rank(handle,evect,n,D,E,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsteqr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_dsteqr_full_rank = rocsolver_dsteqr_(handle,evect,n,c_loc(D),c_loc(E),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_dsteqr_rank_0(handle,evect,n,D,E,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsteqr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(c_int) :: n
      real(c_double),target :: D
      real(c_double),target :: E
      real(c_double),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_dsteqr_rank_0 = rocsolver_dsteqr_(handle,evect,n,c_loc(D),c_loc(E),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_dsteqr_rank_1(handle,evect,n,D,E,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsteqr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_dsteqr_rank_1 = rocsolver_dsteqr_(handle,evect,n,c_loc(D),c_loc(E),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_csteqr_full_rank(handle,evect,n,D,E,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_csteqr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_csteqr_full_rank = rocsolver_csteqr_(handle,evect,n,c_loc(D),c_loc(E),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_csteqr_rank_0(handle,evect,n,D,E,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_csteqr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(c_int) :: n
      real(c_float),target :: D
      real(c_float),target :: E
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_csteqr_rank_0 = rocsolver_csteqr_(handle,evect,n,c_loc(D),c_loc(E),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_csteqr_rank_1(handle,evect,n,D,E,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_csteqr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_csteqr_rank_1 = rocsolver_csteqr_(handle,evect,n,c_loc(D),c_loc(E),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_zsteqr_full_rank(handle,evect,n,D,E,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zsteqr_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_zsteqr_full_rank = rocsolver_zsteqr_(handle,evect,n,c_loc(D),c_loc(E),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_zsteqr_rank_0(handle,evect,n,D,E,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zsteqr_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(c_int) :: n
      real(c_double),target :: D
      real(c_double),target :: E
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_zsteqr_rank_0 = rocsolver_zsteqr_(handle,evect,n,c_loc(D),c_loc(E),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_zsteqr_rank_1(handle,evect,n,D,E,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zsteqr_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_zsteqr_rank_1 = rocsolver_zsteqr_(handle,evect,n,c_loc(D),c_loc(E),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_sstedc_full_rank(handle,evect,n,D,E,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sstedc_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_sstedc_full_rank = rocsolver_sstedc_(handle,evect,n,c_loc(D),c_loc(E),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_sstedc_rank_0(handle,evect,n,D,E,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sstedc_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(c_int) :: n
      real(c_float),target :: D
      real(c_float),target :: E
      real(c_float),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_sstedc_rank_0 = rocsolver_sstedc_(handle,evect,n,c_loc(D),c_loc(E),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_sstedc_rank_1(handle,evect,n,D,E,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sstedc_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_sstedc_rank_1 = rocsolver_sstedc_(handle,evect,n,c_loc(D),c_loc(E),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_dstedc_full_rank(handle,evect,n,D,E,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dstedc_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_dstedc_full_rank = rocsolver_dstedc_(handle,evect,n,c_loc(D),c_loc(E),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_dstedc_rank_0(handle,evect,n,D,E,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dstedc_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(c_int) :: n
      real(c_double),target :: D
      real(c_double),target :: E
      real(c_double),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_dstedc_rank_0 = rocsolver_dstedc_(handle,evect,n,c_loc(D),c_loc(E),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_dstedc_rank_1(handle,evect,n,D,E,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dstedc_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_dstedc_rank_1 = rocsolver_dstedc_(handle,evect,n,c_loc(D),c_loc(E),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_cstedc_full_rank(handle,evect,n,D,E,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cstedc_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_cstedc_full_rank = rocsolver_cstedc_(handle,evect,n,c_loc(D),c_loc(E),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_cstedc_rank_0(handle,evect,n,D,E,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cstedc_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(c_int) :: n
      real(c_float),target :: D
      real(c_float),target :: E
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_cstedc_rank_0 = rocsolver_cstedc_(handle,evect,n,c_loc(D),c_loc(E),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_cstedc_rank_1(handle,evect,n,D,E,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cstedc_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_cstedc_rank_1 = rocsolver_cstedc_(handle,evect,n,c_loc(D),c_loc(E),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_zstedc_full_rank(handle,evect,n,D,E,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zstedc_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_zstedc_full_rank = rocsolver_zstedc_(handle,evect,n,c_loc(D),c_loc(E),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_zstedc_rank_0(handle,evect,n,D,E,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zstedc_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(c_int) :: n
      real(c_double),target :: D
      real(c_double),target :: E
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_zstedc_rank_0 = rocsolver_zstedc_(handle,evect,n,c_loc(D),c_loc(E),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_zstedc_rank_1(handle,evect,n,D,E,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zstedc_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_zstedc_rank_1 = rocsolver_zstedc_(handle,evect,n,c_loc(D),c_loc(E),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_sstebz_rank_0(handle,erange,eorder,n,vl,vu,il,iu,abstol,D,E,nev,nsplit,W,iblock,isplit,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sstebz_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_eorder_blocks)) :: eorder
      integer(c_int) :: n
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      real(c_float),target :: D
      real(c_float),target :: E
      type(c_ptr) :: nev
      type(c_ptr) :: nsplit
      type(c_ptr) :: W
      type(c_ptr) :: iblock
      type(c_ptr) :: isplit
      type(c_ptr) :: myInfo
      !
      rocsolver_sstebz_rank_0 = rocsolver_sstebz_(handle,erange,eorder,n,vl,vu,il,iu,abstol,c_loc(D),c_loc(E),nev,nsplit,W,iblock,isplit,myInfo)
    end function

    function rocsolver_sstebz_rank_1(handle,erange,eorder,n,vl,vu,il,iu,abstol,D,E,nev,nsplit,W,iblock,isplit,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sstebz_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_eorder_blocks)) :: eorder
      integer(c_int) :: n
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      type(c_ptr) :: nev
      type(c_ptr) :: nsplit
      type(c_ptr) :: W
      type(c_ptr) :: iblock
      type(c_ptr) :: isplit
      type(c_ptr) :: myInfo
      !
      rocsolver_sstebz_rank_1 = rocsolver_sstebz_(handle,erange,eorder,n,vl,vu,il,iu,abstol,c_loc(D),c_loc(E),nev,nsplit,W,iblock,isplit,myInfo)
    end function

    function rocsolver_dstebz_rank_0(handle,erange,eorder,n,vl,vu,il,iu,abstol,D,E,nev,nsplit,W,iblock,isplit,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dstebz_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_eorder_blocks)) :: eorder
      integer(c_int) :: n
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      real(c_double),target :: D
      real(c_double),target :: E
      type(c_ptr) :: nev
      type(c_ptr) :: nsplit
      type(c_ptr) :: W
      type(c_ptr) :: iblock
      type(c_ptr) :: isplit
      type(c_ptr) :: myInfo
      !
      rocsolver_dstebz_rank_0 = rocsolver_dstebz_(handle,erange,eorder,n,vl,vu,il,iu,abstol,c_loc(D),c_loc(E),nev,nsplit,W,iblock,isplit,myInfo)
    end function

    function rocsolver_dstebz_rank_1(handle,erange,eorder,n,vl,vu,il,iu,abstol,D,E,nev,nsplit,W,iblock,isplit,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dstebz_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_eorder_blocks)) :: eorder
      integer(c_int) :: n
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      type(c_ptr) :: nev
      type(c_ptr) :: nsplit
      type(c_ptr) :: W
      type(c_ptr) :: iblock
      type(c_ptr) :: isplit
      type(c_ptr) :: myInfo
      !
      rocsolver_dstebz_rank_1 = rocsolver_dstebz_(handle,erange,eorder,n,vl,vu,il,iu,abstol,c_loc(D),c_loc(E),nev,nsplit,W,iblock,isplit,myInfo)
    end function

    function rocsolver_sstein_rank_0(handle,n,D,E,nev,W,iblock,isplit,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sstein_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: D
      real(c_float),target :: E
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: iblock
      type(c_ptr) :: isplit
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_sstein_rank_0 = rocsolver_sstein_(handle,n,c_loc(D),c_loc(E),nev,W,iblock,isplit,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_sstein_rank_1(handle,n,D,E,nev,W,iblock,isplit,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sstein_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: iblock
      type(c_ptr) :: isplit
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_sstein_rank_1 = rocsolver_sstein_(handle,n,c_loc(D),c_loc(E),nev,W,iblock,isplit,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_dstein_rank_0(handle,n,D,E,nev,W,iblock,isplit,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dstein_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: D
      real(c_double),target :: E
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: iblock
      type(c_ptr) :: isplit
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_dstein_rank_0 = rocsolver_dstein_(handle,n,c_loc(D),c_loc(E),nev,W,iblock,isplit,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_dstein_rank_1(handle,n,D,E,nev,W,iblock,isplit,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dstein_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: iblock
      type(c_ptr) :: isplit
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_dstein_rank_1 = rocsolver_dstein_(handle,n,c_loc(D),c_loc(E),nev,W,iblock,isplit,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_cstein_rank_0(handle,n,D,E,nev,W,iblock,isplit,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cstein_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: D
      real(c_float),target :: E
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: iblock
      type(c_ptr) :: isplit
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_cstein_rank_0 = rocsolver_cstein_(handle,n,c_loc(D),c_loc(E),nev,W,iblock,isplit,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_cstein_rank_1(handle,n,D,E,nev,W,iblock,isplit,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cstein_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: iblock
      type(c_ptr) :: isplit
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_cstein_rank_1 = rocsolver_cstein_(handle,n,c_loc(D),c_loc(E),nev,W,iblock,isplit,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_zstein_rank_0(handle,n,D,E,nev,W,iblock,isplit,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zstein_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: D
      real(c_double),target :: E
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: iblock
      type(c_ptr) :: isplit
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_zstein_rank_0 = rocsolver_zstein_(handle,n,c_loc(D),c_loc(E),nev,W,iblock,isplit,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_zstein_rank_1(handle,n,D,E,nev,W,iblock,isplit,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zstein_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: iblock
      type(c_ptr) :: isplit
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_zstein_rank_1 = rocsolver_zstein_(handle,n,c_loc(D),c_loc(E),nev,W,iblock,isplit,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_sbdsvdx_rank_0(handle,uplo,svect,srange,n,D,E,vl,vu,il,iu,nsv,S,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sbdsvdx_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_svect_all)) :: svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: n
      real(c_float),target :: D
      real(c_float),target :: E
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_float),target :: S
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_sbdsvdx_rank_0 = rocsolver_sbdsvdx_(handle,uplo,svect,srange,n,c_loc(D),c_loc(E),vl,vu,il,iu,nsv,c_loc(S),Z,ldz,ifail,myInfo)
    end function

    function rocsolver_sbdsvdx_rank_1(handle,uplo,svect,srange,n,D,E,vl,vu,il,iu,nsv,S,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sbdsvdx_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_svect_all)) :: svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_float),target,dimension(:) :: S
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_sbdsvdx_rank_1 = rocsolver_sbdsvdx_(handle,uplo,svect,srange,n,c_loc(D),c_loc(E),vl,vu,il,iu,nsv,c_loc(S),Z,ldz,ifail,myInfo)
    end function

    function rocsolver_dbdsvdx_rank_0(handle,uplo,svect,srange,n,D,E,vl,vu,il,iu,nsv,S,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dbdsvdx_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_svect_all)) :: svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: n
      real(c_double),target :: D
      real(c_double),target :: E
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_double),target :: S
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_dbdsvdx_rank_0 = rocsolver_dbdsvdx_(handle,uplo,svect,srange,n,c_loc(D),c_loc(E),vl,vu,il,iu,nsv,c_loc(S),Z,ldz,ifail,myInfo)
    end function

    function rocsolver_dbdsvdx_rank_1(handle,uplo,svect,srange,n,D,E,vl,vu,il,iu,nsv,S,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dbdsvdx_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_svect_all)) :: svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_double),target,dimension(:) :: S
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_dbdsvdx_rank_1 = rocsolver_dbdsvdx_(handle,uplo,svect,srange,n,c_loc(D),c_loc(E),vl,vu,il,iu,nsv,c_loc(S),Z,ldz,ifail,myInfo)
    end function

    function rocsolver_sgetf2_npvt_full_rank(handle,m,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetf2_npvt_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_sgetf2_npvt_full_rank = rocsolver_sgetf2_npvt_(handle,m,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_sgetf2_npvt_rank_0(handle,m,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetf2_npvt_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_sgetf2_npvt_rank_0 = rocsolver_sgetf2_npvt_(handle,m,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_sgetf2_npvt_rank_1(handle,m,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetf2_npvt_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_sgetf2_npvt_rank_1 = rocsolver_sgetf2_npvt_(handle,m,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_dgetf2_npvt_full_rank(handle,m,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetf2_npvt_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_dgetf2_npvt_full_rank = rocsolver_dgetf2_npvt_(handle,m,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_dgetf2_npvt_rank_0(handle,m,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetf2_npvt_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_dgetf2_npvt_rank_0 = rocsolver_dgetf2_npvt_(handle,m,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_dgetf2_npvt_rank_1(handle,m,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetf2_npvt_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_dgetf2_npvt_rank_1 = rocsolver_dgetf2_npvt_(handle,m,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_cgetf2_npvt_full_rank(handle,m,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetf2_npvt_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_cgetf2_npvt_full_rank = rocsolver_cgetf2_npvt_(handle,m,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_cgetf2_npvt_rank_0(handle,m,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetf2_npvt_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_cgetf2_npvt_rank_0 = rocsolver_cgetf2_npvt_(handle,m,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_cgetf2_npvt_rank_1(handle,m,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetf2_npvt_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_cgetf2_npvt_rank_1 = rocsolver_cgetf2_npvt_(handle,m,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_zgetf2_npvt_full_rank(handle,m,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetf2_npvt_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_zgetf2_npvt_full_rank = rocsolver_zgetf2_npvt_(handle,m,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_zgetf2_npvt_rank_0(handle,m,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetf2_npvt_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_zgetf2_npvt_rank_0 = rocsolver_zgetf2_npvt_(handle,m,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_zgetf2_npvt_rank_1(handle,m,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetf2_npvt_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_zgetf2_npvt_rank_1 = rocsolver_zgetf2_npvt_(handle,m,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_sgetf2_npvt_batched_full_rank(handle,m,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetf2_npvt_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetf2_npvt_batched_full_rank = rocsolver_sgetf2_npvt_batched_(handle,m,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_sgetf2_npvt_batched_rank_0(handle,m,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetf2_npvt_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetf2_npvt_batched_rank_0 = rocsolver_sgetf2_npvt_batched_(handle,m,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_sgetf2_npvt_batched_rank_1(handle,m,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetf2_npvt_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetf2_npvt_batched_rank_1 = rocsolver_sgetf2_npvt_batched_(handle,m,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_dgetf2_npvt_batched_full_rank(handle,m,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetf2_npvt_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetf2_npvt_batched_full_rank = rocsolver_dgetf2_npvt_batched_(handle,m,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_dgetf2_npvt_batched_rank_0(handle,m,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetf2_npvt_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetf2_npvt_batched_rank_0 = rocsolver_dgetf2_npvt_batched_(handle,m,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_dgetf2_npvt_batched_rank_1(handle,m,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetf2_npvt_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetf2_npvt_batched_rank_1 = rocsolver_dgetf2_npvt_batched_(handle,m,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_cgetf2_npvt_batched_full_rank(handle,m,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetf2_npvt_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetf2_npvt_batched_full_rank = rocsolver_cgetf2_npvt_batched_(handle,m,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_cgetf2_npvt_batched_rank_0(handle,m,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetf2_npvt_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetf2_npvt_batched_rank_0 = rocsolver_cgetf2_npvt_batched_(handle,m,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_cgetf2_npvt_batched_rank_1(handle,m,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetf2_npvt_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetf2_npvt_batched_rank_1 = rocsolver_cgetf2_npvt_batched_(handle,m,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_zgetf2_npvt_batched_full_rank(handle,m,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetf2_npvt_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetf2_npvt_batched_full_rank = rocsolver_zgetf2_npvt_batched_(handle,m,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_zgetf2_npvt_batched_rank_0(handle,m,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetf2_npvt_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetf2_npvt_batched_rank_0 = rocsolver_zgetf2_npvt_batched_(handle,m,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_zgetf2_npvt_batched_rank_1(handle,m,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetf2_npvt_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetf2_npvt_batched_rank_1 = rocsolver_zgetf2_npvt_batched_(handle,m,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_sgetf2_npvt_strided_batched_full_rank(handle,m,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetf2_npvt_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetf2_npvt_strided_batched_full_rank = rocsolver_sgetf2_npvt_strided_batched_(handle,m,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_sgetf2_npvt_strided_batched_rank_0(handle,m,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetf2_npvt_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetf2_npvt_strided_batched_rank_0 = rocsolver_sgetf2_npvt_strided_batched_(handle,m,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_sgetf2_npvt_strided_batched_rank_1(handle,m,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetf2_npvt_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetf2_npvt_strided_batched_rank_1 = rocsolver_sgetf2_npvt_strided_batched_(handle,m,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_dgetf2_npvt_strided_batched_full_rank(handle,m,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetf2_npvt_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetf2_npvt_strided_batched_full_rank = rocsolver_dgetf2_npvt_strided_batched_(handle,m,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_dgetf2_npvt_strided_batched_rank_0(handle,m,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetf2_npvt_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetf2_npvt_strided_batched_rank_0 = rocsolver_dgetf2_npvt_strided_batched_(handle,m,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_dgetf2_npvt_strided_batched_rank_1(handle,m,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetf2_npvt_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetf2_npvt_strided_batched_rank_1 = rocsolver_dgetf2_npvt_strided_batched_(handle,m,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_cgetf2_npvt_strided_batched_full_rank(handle,m,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetf2_npvt_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetf2_npvt_strided_batched_full_rank = rocsolver_cgetf2_npvt_strided_batched_(handle,m,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_cgetf2_npvt_strided_batched_rank_0(handle,m,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetf2_npvt_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetf2_npvt_strided_batched_rank_0 = rocsolver_cgetf2_npvt_strided_batched_(handle,m,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_cgetf2_npvt_strided_batched_rank_1(handle,m,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetf2_npvt_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetf2_npvt_strided_batched_rank_1 = rocsolver_cgetf2_npvt_strided_batched_(handle,m,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_zgetf2_npvt_strided_batched_full_rank(handle,m,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetf2_npvt_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetf2_npvt_strided_batched_full_rank = rocsolver_zgetf2_npvt_strided_batched_(handle,m,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_zgetf2_npvt_strided_batched_rank_0(handle,m,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetf2_npvt_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetf2_npvt_strided_batched_rank_0 = rocsolver_zgetf2_npvt_strided_batched_(handle,m,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_zgetf2_npvt_strided_batched_rank_1(handle,m,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetf2_npvt_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetf2_npvt_strided_batched_rank_1 = rocsolver_zgetf2_npvt_strided_batched_(handle,m,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_sgetrf_npvt_full_rank(handle,m,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrf_npvt_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_sgetrf_npvt_full_rank = rocsolver_sgetrf_npvt_(handle,m,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_sgetrf_npvt_rank_0(handle,m,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrf_npvt_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_sgetrf_npvt_rank_0 = rocsolver_sgetrf_npvt_(handle,m,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_sgetrf_npvt_rank_1(handle,m,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrf_npvt_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_sgetrf_npvt_rank_1 = rocsolver_sgetrf_npvt_(handle,m,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_dgetrf_npvt_full_rank(handle,m,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrf_npvt_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_dgetrf_npvt_full_rank = rocsolver_dgetrf_npvt_(handle,m,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_dgetrf_npvt_rank_0(handle,m,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrf_npvt_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_dgetrf_npvt_rank_0 = rocsolver_dgetrf_npvt_(handle,m,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_dgetrf_npvt_rank_1(handle,m,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrf_npvt_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_dgetrf_npvt_rank_1 = rocsolver_dgetrf_npvt_(handle,m,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_cgetrf_npvt_full_rank(handle,m,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrf_npvt_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_cgetrf_npvt_full_rank = rocsolver_cgetrf_npvt_(handle,m,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_cgetrf_npvt_rank_0(handle,m,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrf_npvt_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_cgetrf_npvt_rank_0 = rocsolver_cgetrf_npvt_(handle,m,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_cgetrf_npvt_rank_1(handle,m,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrf_npvt_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_cgetrf_npvt_rank_1 = rocsolver_cgetrf_npvt_(handle,m,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_zgetrf_npvt_full_rank(handle,m,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrf_npvt_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_zgetrf_npvt_full_rank = rocsolver_zgetrf_npvt_(handle,m,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_zgetrf_npvt_rank_0(handle,m,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrf_npvt_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_zgetrf_npvt_rank_0 = rocsolver_zgetrf_npvt_(handle,m,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_zgetrf_npvt_rank_1(handle,m,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrf_npvt_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_zgetrf_npvt_rank_1 = rocsolver_zgetrf_npvt_(handle,m,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_sgetrf_npvt_batched_full_rank(handle,m,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrf_npvt_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetrf_npvt_batched_full_rank = rocsolver_sgetrf_npvt_batched_(handle,m,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_sgetrf_npvt_batched_rank_0(handle,m,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrf_npvt_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetrf_npvt_batched_rank_0 = rocsolver_sgetrf_npvt_batched_(handle,m,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_sgetrf_npvt_batched_rank_1(handle,m,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrf_npvt_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetrf_npvt_batched_rank_1 = rocsolver_sgetrf_npvt_batched_(handle,m,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_dgetrf_npvt_batched_full_rank(handle,m,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrf_npvt_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetrf_npvt_batched_full_rank = rocsolver_dgetrf_npvt_batched_(handle,m,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_dgetrf_npvt_batched_rank_0(handle,m,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrf_npvt_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetrf_npvt_batched_rank_0 = rocsolver_dgetrf_npvt_batched_(handle,m,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_dgetrf_npvt_batched_rank_1(handle,m,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrf_npvt_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetrf_npvt_batched_rank_1 = rocsolver_dgetrf_npvt_batched_(handle,m,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_cgetrf_npvt_batched_full_rank(handle,m,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrf_npvt_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetrf_npvt_batched_full_rank = rocsolver_cgetrf_npvt_batched_(handle,m,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_cgetrf_npvt_batched_rank_0(handle,m,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrf_npvt_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetrf_npvt_batched_rank_0 = rocsolver_cgetrf_npvt_batched_(handle,m,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_cgetrf_npvt_batched_rank_1(handle,m,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrf_npvt_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetrf_npvt_batched_rank_1 = rocsolver_cgetrf_npvt_batched_(handle,m,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_zgetrf_npvt_batched_full_rank(handle,m,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrf_npvt_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetrf_npvt_batched_full_rank = rocsolver_zgetrf_npvt_batched_(handle,m,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_zgetrf_npvt_batched_rank_0(handle,m,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrf_npvt_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetrf_npvt_batched_rank_0 = rocsolver_zgetrf_npvt_batched_(handle,m,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_zgetrf_npvt_batched_rank_1(handle,m,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrf_npvt_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetrf_npvt_batched_rank_1 = rocsolver_zgetrf_npvt_batched_(handle,m,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_sgetrf_npvt_strided_batched_full_rank(handle,m,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrf_npvt_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetrf_npvt_strided_batched_full_rank = rocsolver_sgetrf_npvt_strided_batched_(handle,m,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_sgetrf_npvt_strided_batched_rank_0(handle,m,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrf_npvt_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetrf_npvt_strided_batched_rank_0 = rocsolver_sgetrf_npvt_strided_batched_(handle,m,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_sgetrf_npvt_strided_batched_rank_1(handle,m,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrf_npvt_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetrf_npvt_strided_batched_rank_1 = rocsolver_sgetrf_npvt_strided_batched_(handle,m,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_dgetrf_npvt_strided_batched_full_rank(handle,m,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrf_npvt_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetrf_npvt_strided_batched_full_rank = rocsolver_dgetrf_npvt_strided_batched_(handle,m,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_dgetrf_npvt_strided_batched_rank_0(handle,m,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrf_npvt_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetrf_npvt_strided_batched_rank_0 = rocsolver_dgetrf_npvt_strided_batched_(handle,m,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_dgetrf_npvt_strided_batched_rank_1(handle,m,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrf_npvt_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetrf_npvt_strided_batched_rank_1 = rocsolver_dgetrf_npvt_strided_batched_(handle,m,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_cgetrf_npvt_strided_batched_full_rank(handle,m,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrf_npvt_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetrf_npvt_strided_batched_full_rank = rocsolver_cgetrf_npvt_strided_batched_(handle,m,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_cgetrf_npvt_strided_batched_rank_0(handle,m,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrf_npvt_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetrf_npvt_strided_batched_rank_0 = rocsolver_cgetrf_npvt_strided_batched_(handle,m,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_cgetrf_npvt_strided_batched_rank_1(handle,m,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrf_npvt_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetrf_npvt_strided_batched_rank_1 = rocsolver_cgetrf_npvt_strided_batched_(handle,m,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_zgetrf_npvt_strided_batched_full_rank(handle,m,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrf_npvt_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetrf_npvt_strided_batched_full_rank = rocsolver_zgetrf_npvt_strided_batched_(handle,m,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_zgetrf_npvt_strided_batched_rank_0(handle,m,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrf_npvt_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetrf_npvt_strided_batched_rank_0 = rocsolver_zgetrf_npvt_strided_batched_(handle,m,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_zgetrf_npvt_strided_batched_rank_1(handle,m,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrf_npvt_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetrf_npvt_strided_batched_rank_1 = rocsolver_zgetrf_npvt_strided_batched_(handle,m,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_sgetf2_full_rank(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetf2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_sgetf2_full_rank = rocsolver_sgetf2_(handle,m,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_sgetf2_rank_0(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetf2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_sgetf2_rank_0 = rocsolver_sgetf2_(handle,m,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_sgetf2_rank_1(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetf2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_sgetf2_rank_1 = rocsolver_sgetf2_(handle,m,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_dgetf2_full_rank(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetf2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_dgetf2_full_rank = rocsolver_dgetf2_(handle,m,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_dgetf2_rank_0(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetf2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_dgetf2_rank_0 = rocsolver_dgetf2_(handle,m,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_dgetf2_rank_1(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetf2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_dgetf2_rank_1 = rocsolver_dgetf2_(handle,m,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_cgetf2_full_rank(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetf2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_cgetf2_full_rank = rocsolver_cgetf2_(handle,m,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_cgetf2_rank_0(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetf2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_cgetf2_rank_0 = rocsolver_cgetf2_(handle,m,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_cgetf2_rank_1(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetf2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_cgetf2_rank_1 = rocsolver_cgetf2_(handle,m,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_zgetf2_full_rank(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetf2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_zgetf2_full_rank = rocsolver_zgetf2_(handle,m,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_zgetf2_rank_0(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetf2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_zgetf2_rank_0 = rocsolver_zgetf2_(handle,m,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_zgetf2_rank_1(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetf2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_zgetf2_rank_1 = rocsolver_zgetf2_(handle,m,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_sgetf2_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetf2_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetf2_batched_full_rank = rocsolver_sgetf2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_sgetf2_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetf2_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetf2_batched_rank_0 = rocsolver_sgetf2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_sgetf2_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetf2_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetf2_batched_rank_1 = rocsolver_sgetf2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dgetf2_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetf2_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetf2_batched_full_rank = rocsolver_dgetf2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dgetf2_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetf2_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetf2_batched_rank_0 = rocsolver_dgetf2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dgetf2_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetf2_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetf2_batched_rank_1 = rocsolver_dgetf2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_cgetf2_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetf2_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetf2_batched_full_rank = rocsolver_cgetf2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_cgetf2_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetf2_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetf2_batched_rank_0 = rocsolver_cgetf2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_cgetf2_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetf2_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetf2_batched_rank_1 = rocsolver_cgetf2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zgetf2_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetf2_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetf2_batched_full_rank = rocsolver_zgetf2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zgetf2_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetf2_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetf2_batched_rank_0 = rocsolver_zgetf2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zgetf2_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetf2_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetf2_batched_rank_1 = rocsolver_zgetf2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_sgetf2_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetf2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetf2_strided_batched_full_rank = rocsolver_sgetf2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_sgetf2_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetf2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetf2_strided_batched_rank_0 = rocsolver_sgetf2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_sgetf2_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetf2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetf2_strided_batched_rank_1 = rocsolver_sgetf2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dgetf2_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetf2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetf2_strided_batched_full_rank = rocsolver_dgetf2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dgetf2_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetf2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetf2_strided_batched_rank_0 = rocsolver_dgetf2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dgetf2_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetf2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetf2_strided_batched_rank_1 = rocsolver_dgetf2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_cgetf2_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetf2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetf2_strided_batched_full_rank = rocsolver_cgetf2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_cgetf2_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetf2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetf2_strided_batched_rank_0 = rocsolver_cgetf2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_cgetf2_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetf2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetf2_strided_batched_rank_1 = rocsolver_cgetf2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zgetf2_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetf2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetf2_strided_batched_full_rank = rocsolver_zgetf2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zgetf2_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetf2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetf2_strided_batched_rank_0 = rocsolver_zgetf2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zgetf2_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetf2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetf2_strided_batched_rank_1 = rocsolver_zgetf2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_sgetrf_full_rank(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_sgetrf_full_rank = rocsolver_sgetrf_(handle,m,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_sgetrf_rank_0(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_sgetrf_rank_0 = rocsolver_sgetrf_(handle,m,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_sgetrf_rank_1(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_sgetrf_rank_1 = rocsolver_sgetrf_(handle,m,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_dgetrf_full_rank(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_dgetrf_full_rank = rocsolver_dgetrf_(handle,m,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_dgetrf_rank_0(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_dgetrf_rank_0 = rocsolver_dgetrf_(handle,m,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_dgetrf_rank_1(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_dgetrf_rank_1 = rocsolver_dgetrf_(handle,m,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_cgetrf_full_rank(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_cgetrf_full_rank = rocsolver_cgetrf_(handle,m,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_cgetrf_rank_0(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_cgetrf_rank_0 = rocsolver_cgetrf_(handle,m,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_cgetrf_rank_1(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_cgetrf_rank_1 = rocsolver_cgetrf_(handle,m,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_zgetrf_full_rank(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_zgetrf_full_rank = rocsolver_zgetrf_(handle,m,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_zgetrf_rank_0(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_zgetrf_rank_0 = rocsolver_zgetrf_(handle,m,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_zgetrf_rank_1(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_zgetrf_rank_1 = rocsolver_zgetrf_(handle,m,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_sgetrf_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrf_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetrf_batched_full_rank = rocsolver_sgetrf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_sgetrf_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrf_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetrf_batched_rank_0 = rocsolver_sgetrf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_sgetrf_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrf_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetrf_batched_rank_1 = rocsolver_sgetrf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dgetrf_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrf_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetrf_batched_full_rank = rocsolver_dgetrf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dgetrf_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrf_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetrf_batched_rank_0 = rocsolver_dgetrf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dgetrf_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrf_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetrf_batched_rank_1 = rocsolver_dgetrf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_cgetrf_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrf_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetrf_batched_full_rank = rocsolver_cgetrf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_cgetrf_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrf_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetrf_batched_rank_0 = rocsolver_cgetrf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_cgetrf_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrf_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetrf_batched_rank_1 = rocsolver_cgetrf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zgetrf_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrf_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetrf_batched_full_rank = rocsolver_zgetrf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zgetrf_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrf_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetrf_batched_rank_0 = rocsolver_zgetrf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zgetrf_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrf_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetrf_batched_rank_1 = rocsolver_zgetrf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_sgetrf_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrf_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetrf_strided_batched_full_rank = rocsolver_sgetrf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_sgetrf_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrf_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetrf_strided_batched_rank_0 = rocsolver_sgetrf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_sgetrf_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrf_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetrf_strided_batched_rank_1 = rocsolver_sgetrf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dgetrf_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrf_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetrf_strided_batched_full_rank = rocsolver_dgetrf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dgetrf_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrf_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetrf_strided_batched_rank_0 = rocsolver_dgetrf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dgetrf_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrf_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetrf_strided_batched_rank_1 = rocsolver_dgetrf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_cgetrf_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrf_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetrf_strided_batched_full_rank = rocsolver_cgetrf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_cgetrf_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrf_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetrf_strided_batched_rank_0 = rocsolver_cgetrf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_cgetrf_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrf_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetrf_strided_batched_rank_1 = rocsolver_cgetrf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zgetrf_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrf_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetrf_strided_batched_full_rank = rocsolver_zgetrf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zgetrf_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrf_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetrf_strided_batched_rank_0 = rocsolver_zgetrf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zgetrf_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrf_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetrf_strided_batched_rank_1 = rocsolver_zgetrf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_sgeqr2_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqr2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sgeqr2_full_rank = rocsolver_sgeqr2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sgeqr2_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqr2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      !
      rocsolver_sgeqr2_rank_0 = rocsolver_sgeqr2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sgeqr2_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqr2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sgeqr2_rank_1 = rocsolver_sgeqr2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dgeqr2_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqr2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dgeqr2_full_rank = rocsolver_dgeqr2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dgeqr2_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqr2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      !
      rocsolver_dgeqr2_rank_0 = rocsolver_dgeqr2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dgeqr2_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqr2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dgeqr2_rank_1 = rocsolver_dgeqr2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cgeqr2_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqr2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cgeqr2_full_rank = rocsolver_cgeqr2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cgeqr2_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqr2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      !
      rocsolver_cgeqr2_rank_0 = rocsolver_cgeqr2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cgeqr2_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqr2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cgeqr2_rank_1 = rocsolver_cgeqr2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zgeqr2_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqr2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zgeqr2_full_rank = rocsolver_zgeqr2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zgeqr2_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqr2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      !
      rocsolver_zgeqr2_rank_0 = rocsolver_zgeqr2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zgeqr2_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqr2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zgeqr2_rank_1 = rocsolver_zgeqr2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sgeqr2_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqr2_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgeqr2_batched_full_rank = rocsolver_sgeqr2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgeqr2_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqr2_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgeqr2_batched_rank_0 = rocsolver_sgeqr2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgeqr2_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqr2_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgeqr2_batched_rank_1 = rocsolver_sgeqr2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgeqr2_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqr2_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgeqr2_batched_full_rank = rocsolver_dgeqr2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgeqr2_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqr2_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgeqr2_batched_rank_0 = rocsolver_dgeqr2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgeqr2_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqr2_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgeqr2_batched_rank_1 = rocsolver_dgeqr2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgeqr2_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqr2_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgeqr2_batched_full_rank = rocsolver_cgeqr2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgeqr2_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqr2_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgeqr2_batched_rank_0 = rocsolver_cgeqr2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgeqr2_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqr2_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgeqr2_batched_rank_1 = rocsolver_cgeqr2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgeqr2_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqr2_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgeqr2_batched_full_rank = rocsolver_zgeqr2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgeqr2_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqr2_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgeqr2_batched_rank_0 = rocsolver_zgeqr2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgeqr2_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqr2_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgeqr2_batched_rank_1 = rocsolver_zgeqr2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgeqr2_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqr2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgeqr2_strided_batched_full_rank = rocsolver_sgeqr2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgeqr2_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqr2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgeqr2_strided_batched_rank_0 = rocsolver_sgeqr2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgeqr2_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqr2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgeqr2_strided_batched_rank_1 = rocsolver_sgeqr2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgeqr2_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqr2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgeqr2_strided_batched_full_rank = rocsolver_dgeqr2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgeqr2_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqr2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgeqr2_strided_batched_rank_0 = rocsolver_dgeqr2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgeqr2_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqr2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgeqr2_strided_batched_rank_1 = rocsolver_dgeqr2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgeqr2_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqr2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgeqr2_strided_batched_full_rank = rocsolver_cgeqr2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgeqr2_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqr2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgeqr2_strided_batched_rank_0 = rocsolver_cgeqr2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgeqr2_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqr2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgeqr2_strided_batched_rank_1 = rocsolver_cgeqr2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgeqr2_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqr2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgeqr2_strided_batched_full_rank = rocsolver_zgeqr2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgeqr2_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqr2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgeqr2_strided_batched_rank_0 = rocsolver_zgeqr2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgeqr2_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqr2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgeqr2_strided_batched_rank_1 = rocsolver_zgeqr2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgerq2_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgerq2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sgerq2_full_rank = rocsolver_sgerq2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sgerq2_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgerq2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      !
      rocsolver_sgerq2_rank_0 = rocsolver_sgerq2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sgerq2_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgerq2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sgerq2_rank_1 = rocsolver_sgerq2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dgerq2_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgerq2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dgerq2_full_rank = rocsolver_dgerq2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dgerq2_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgerq2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      !
      rocsolver_dgerq2_rank_0 = rocsolver_dgerq2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dgerq2_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgerq2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dgerq2_rank_1 = rocsolver_dgerq2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cgerq2_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgerq2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cgerq2_full_rank = rocsolver_cgerq2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cgerq2_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgerq2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      !
      rocsolver_cgerq2_rank_0 = rocsolver_cgerq2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cgerq2_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgerq2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cgerq2_rank_1 = rocsolver_cgerq2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zgerq2_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgerq2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zgerq2_full_rank = rocsolver_zgerq2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zgerq2_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgerq2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      !
      rocsolver_zgerq2_rank_0 = rocsolver_zgerq2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zgerq2_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgerq2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zgerq2_rank_1 = rocsolver_zgerq2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sgerq2_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgerq2_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgerq2_batched_full_rank = rocsolver_sgerq2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgerq2_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgerq2_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgerq2_batched_rank_0 = rocsolver_sgerq2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgerq2_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgerq2_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgerq2_batched_rank_1 = rocsolver_sgerq2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgerq2_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgerq2_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgerq2_batched_full_rank = rocsolver_dgerq2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgerq2_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgerq2_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgerq2_batched_rank_0 = rocsolver_dgerq2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgerq2_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgerq2_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgerq2_batched_rank_1 = rocsolver_dgerq2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgerq2_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgerq2_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgerq2_batched_full_rank = rocsolver_cgerq2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgerq2_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgerq2_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgerq2_batched_rank_0 = rocsolver_cgerq2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgerq2_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgerq2_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgerq2_batched_rank_1 = rocsolver_cgerq2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgerq2_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgerq2_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgerq2_batched_full_rank = rocsolver_zgerq2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgerq2_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgerq2_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgerq2_batched_rank_0 = rocsolver_zgerq2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgerq2_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgerq2_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgerq2_batched_rank_1 = rocsolver_zgerq2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgerq2_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgerq2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgerq2_strided_batched_full_rank = rocsolver_sgerq2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgerq2_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgerq2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgerq2_strided_batched_rank_0 = rocsolver_sgerq2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgerq2_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgerq2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgerq2_strided_batched_rank_1 = rocsolver_sgerq2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgerq2_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgerq2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgerq2_strided_batched_full_rank = rocsolver_dgerq2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgerq2_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgerq2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgerq2_strided_batched_rank_0 = rocsolver_dgerq2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgerq2_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgerq2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgerq2_strided_batched_rank_1 = rocsolver_dgerq2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgerq2_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgerq2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgerq2_strided_batched_full_rank = rocsolver_cgerq2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgerq2_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgerq2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgerq2_strided_batched_rank_0 = rocsolver_cgerq2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgerq2_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgerq2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgerq2_strided_batched_rank_1 = rocsolver_cgerq2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgerq2_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgerq2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgerq2_strided_batched_full_rank = rocsolver_zgerq2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgerq2_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgerq2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgerq2_strided_batched_rank_0 = rocsolver_zgerq2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgerq2_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgerq2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgerq2_strided_batched_rank_1 = rocsolver_zgerq2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgeql2_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeql2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sgeql2_full_rank = rocsolver_sgeql2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sgeql2_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeql2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      !
      rocsolver_sgeql2_rank_0 = rocsolver_sgeql2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sgeql2_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeql2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sgeql2_rank_1 = rocsolver_sgeql2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dgeql2_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeql2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dgeql2_full_rank = rocsolver_dgeql2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dgeql2_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeql2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      !
      rocsolver_dgeql2_rank_0 = rocsolver_dgeql2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dgeql2_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeql2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dgeql2_rank_1 = rocsolver_dgeql2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cgeql2_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeql2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cgeql2_full_rank = rocsolver_cgeql2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cgeql2_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeql2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      !
      rocsolver_cgeql2_rank_0 = rocsolver_cgeql2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cgeql2_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeql2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cgeql2_rank_1 = rocsolver_cgeql2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zgeql2_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeql2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zgeql2_full_rank = rocsolver_zgeql2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zgeql2_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeql2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      !
      rocsolver_zgeql2_rank_0 = rocsolver_zgeql2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zgeql2_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeql2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zgeql2_rank_1 = rocsolver_zgeql2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sgeql2_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeql2_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgeql2_batched_full_rank = rocsolver_sgeql2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgeql2_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeql2_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgeql2_batched_rank_0 = rocsolver_sgeql2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgeql2_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeql2_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgeql2_batched_rank_1 = rocsolver_sgeql2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgeql2_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeql2_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgeql2_batched_full_rank = rocsolver_dgeql2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgeql2_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeql2_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgeql2_batched_rank_0 = rocsolver_dgeql2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgeql2_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeql2_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgeql2_batched_rank_1 = rocsolver_dgeql2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgeql2_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeql2_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgeql2_batched_full_rank = rocsolver_cgeql2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgeql2_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeql2_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgeql2_batched_rank_0 = rocsolver_cgeql2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgeql2_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeql2_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgeql2_batched_rank_1 = rocsolver_cgeql2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgeql2_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeql2_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgeql2_batched_full_rank = rocsolver_zgeql2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgeql2_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeql2_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgeql2_batched_rank_0 = rocsolver_zgeql2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgeql2_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeql2_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgeql2_batched_rank_1 = rocsolver_zgeql2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgeql2_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeql2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgeql2_strided_batched_full_rank = rocsolver_sgeql2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgeql2_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeql2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgeql2_strided_batched_rank_0 = rocsolver_sgeql2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgeql2_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeql2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgeql2_strided_batched_rank_1 = rocsolver_sgeql2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgeql2_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeql2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgeql2_strided_batched_full_rank = rocsolver_dgeql2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgeql2_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeql2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgeql2_strided_batched_rank_0 = rocsolver_dgeql2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgeql2_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeql2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgeql2_strided_batched_rank_1 = rocsolver_dgeql2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgeql2_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeql2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgeql2_strided_batched_full_rank = rocsolver_cgeql2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgeql2_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeql2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgeql2_strided_batched_rank_0 = rocsolver_cgeql2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgeql2_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeql2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgeql2_strided_batched_rank_1 = rocsolver_cgeql2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgeql2_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeql2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgeql2_strided_batched_full_rank = rocsolver_zgeql2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgeql2_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeql2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgeql2_strided_batched_rank_0 = rocsolver_zgeql2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgeql2_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeql2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgeql2_strided_batched_rank_1 = rocsolver_zgeql2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgelq2_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgelq2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sgelq2_full_rank = rocsolver_sgelq2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sgelq2_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgelq2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      !
      rocsolver_sgelq2_rank_0 = rocsolver_sgelq2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sgelq2_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgelq2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sgelq2_rank_1 = rocsolver_sgelq2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dgelq2_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgelq2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dgelq2_full_rank = rocsolver_dgelq2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dgelq2_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgelq2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      !
      rocsolver_dgelq2_rank_0 = rocsolver_dgelq2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dgelq2_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgelq2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dgelq2_rank_1 = rocsolver_dgelq2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cgelq2_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgelq2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cgelq2_full_rank = rocsolver_cgelq2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cgelq2_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgelq2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      !
      rocsolver_cgelq2_rank_0 = rocsolver_cgelq2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cgelq2_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgelq2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cgelq2_rank_1 = rocsolver_cgelq2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zgelq2_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgelq2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zgelq2_full_rank = rocsolver_zgelq2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zgelq2_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgelq2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      !
      rocsolver_zgelq2_rank_0 = rocsolver_zgelq2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zgelq2_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgelq2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zgelq2_rank_1 = rocsolver_zgelq2_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sgelq2_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgelq2_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgelq2_batched_full_rank = rocsolver_sgelq2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgelq2_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgelq2_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgelq2_batched_rank_0 = rocsolver_sgelq2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgelq2_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgelq2_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgelq2_batched_rank_1 = rocsolver_sgelq2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgelq2_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgelq2_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgelq2_batched_full_rank = rocsolver_dgelq2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgelq2_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgelq2_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgelq2_batched_rank_0 = rocsolver_dgelq2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgelq2_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgelq2_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgelq2_batched_rank_1 = rocsolver_dgelq2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgelq2_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgelq2_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgelq2_batched_full_rank = rocsolver_cgelq2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgelq2_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgelq2_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgelq2_batched_rank_0 = rocsolver_cgelq2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgelq2_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgelq2_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgelq2_batched_rank_1 = rocsolver_cgelq2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgelq2_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgelq2_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgelq2_batched_full_rank = rocsolver_zgelq2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgelq2_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgelq2_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgelq2_batched_rank_0 = rocsolver_zgelq2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgelq2_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgelq2_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgelq2_batched_rank_1 = rocsolver_zgelq2_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgelq2_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgelq2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgelq2_strided_batched_full_rank = rocsolver_sgelq2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgelq2_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgelq2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgelq2_strided_batched_rank_0 = rocsolver_sgelq2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgelq2_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgelq2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgelq2_strided_batched_rank_1 = rocsolver_sgelq2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgelq2_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgelq2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgelq2_strided_batched_full_rank = rocsolver_dgelq2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgelq2_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgelq2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgelq2_strided_batched_rank_0 = rocsolver_dgelq2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgelq2_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgelq2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgelq2_strided_batched_rank_1 = rocsolver_dgelq2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgelq2_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgelq2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgelq2_strided_batched_full_rank = rocsolver_cgelq2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgelq2_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgelq2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgelq2_strided_batched_rank_0 = rocsolver_cgelq2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgelq2_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgelq2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgelq2_strided_batched_rank_1 = rocsolver_cgelq2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgelq2_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgelq2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgelq2_strided_batched_full_rank = rocsolver_zgelq2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgelq2_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgelq2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgelq2_strided_batched_rank_0 = rocsolver_zgelq2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgelq2_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgelq2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgelq2_strided_batched_rank_1 = rocsolver_zgelq2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgeqrf_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqrf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sgeqrf_full_rank = rocsolver_sgeqrf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sgeqrf_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqrf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      !
      rocsolver_sgeqrf_rank_0 = rocsolver_sgeqrf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sgeqrf_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqrf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sgeqrf_rank_1 = rocsolver_sgeqrf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dgeqrf_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqrf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dgeqrf_full_rank = rocsolver_dgeqrf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dgeqrf_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqrf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      !
      rocsolver_dgeqrf_rank_0 = rocsolver_dgeqrf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dgeqrf_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqrf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dgeqrf_rank_1 = rocsolver_dgeqrf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cgeqrf_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqrf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cgeqrf_full_rank = rocsolver_cgeqrf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cgeqrf_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqrf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      !
      rocsolver_cgeqrf_rank_0 = rocsolver_cgeqrf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cgeqrf_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqrf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cgeqrf_rank_1 = rocsolver_cgeqrf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zgeqrf_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqrf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zgeqrf_full_rank = rocsolver_zgeqrf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zgeqrf_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqrf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      !
      rocsolver_zgeqrf_rank_0 = rocsolver_zgeqrf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zgeqrf_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqrf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zgeqrf_rank_1 = rocsolver_zgeqrf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sgeqrf_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqrf_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgeqrf_batched_full_rank = rocsolver_sgeqrf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgeqrf_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqrf_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgeqrf_batched_rank_0 = rocsolver_sgeqrf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgeqrf_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqrf_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgeqrf_batched_rank_1 = rocsolver_sgeqrf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgeqrf_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqrf_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgeqrf_batched_full_rank = rocsolver_dgeqrf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgeqrf_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqrf_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgeqrf_batched_rank_0 = rocsolver_dgeqrf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgeqrf_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqrf_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgeqrf_batched_rank_1 = rocsolver_dgeqrf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgeqrf_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqrf_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgeqrf_batched_full_rank = rocsolver_cgeqrf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgeqrf_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqrf_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgeqrf_batched_rank_0 = rocsolver_cgeqrf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgeqrf_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqrf_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgeqrf_batched_rank_1 = rocsolver_cgeqrf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgeqrf_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqrf_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgeqrf_batched_full_rank = rocsolver_zgeqrf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgeqrf_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqrf_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgeqrf_batched_rank_0 = rocsolver_zgeqrf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgeqrf_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqrf_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgeqrf_batched_rank_1 = rocsolver_zgeqrf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgeqrf_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqrf_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgeqrf_strided_batched_full_rank = rocsolver_sgeqrf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgeqrf_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqrf_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgeqrf_strided_batched_rank_0 = rocsolver_sgeqrf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgeqrf_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqrf_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgeqrf_strided_batched_rank_1 = rocsolver_sgeqrf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgeqrf_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqrf_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgeqrf_strided_batched_full_rank = rocsolver_dgeqrf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgeqrf_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqrf_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgeqrf_strided_batched_rank_0 = rocsolver_dgeqrf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgeqrf_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqrf_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgeqrf_strided_batched_rank_1 = rocsolver_dgeqrf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgeqrf_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqrf_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgeqrf_strided_batched_full_rank = rocsolver_cgeqrf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgeqrf_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqrf_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgeqrf_strided_batched_rank_0 = rocsolver_cgeqrf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgeqrf_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqrf_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgeqrf_strided_batched_rank_1 = rocsolver_cgeqrf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgeqrf_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqrf_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgeqrf_strided_batched_full_rank = rocsolver_zgeqrf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgeqrf_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqrf_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgeqrf_strided_batched_rank_0 = rocsolver_zgeqrf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgeqrf_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqrf_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgeqrf_strided_batched_rank_1 = rocsolver_zgeqrf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgerqf_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgerqf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sgerqf_full_rank = rocsolver_sgerqf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sgerqf_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgerqf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      !
      rocsolver_sgerqf_rank_0 = rocsolver_sgerqf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sgerqf_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgerqf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sgerqf_rank_1 = rocsolver_sgerqf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dgerqf_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgerqf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dgerqf_full_rank = rocsolver_dgerqf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dgerqf_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgerqf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      !
      rocsolver_dgerqf_rank_0 = rocsolver_dgerqf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dgerqf_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgerqf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dgerqf_rank_1 = rocsolver_dgerqf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cgerqf_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgerqf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cgerqf_full_rank = rocsolver_cgerqf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cgerqf_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgerqf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      !
      rocsolver_cgerqf_rank_0 = rocsolver_cgerqf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cgerqf_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgerqf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cgerqf_rank_1 = rocsolver_cgerqf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zgerqf_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgerqf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zgerqf_full_rank = rocsolver_zgerqf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zgerqf_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgerqf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      !
      rocsolver_zgerqf_rank_0 = rocsolver_zgerqf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zgerqf_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgerqf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zgerqf_rank_1 = rocsolver_zgerqf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sgerqf_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgerqf_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgerqf_batched_full_rank = rocsolver_sgerqf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgerqf_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgerqf_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgerqf_batched_rank_0 = rocsolver_sgerqf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgerqf_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgerqf_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgerqf_batched_rank_1 = rocsolver_sgerqf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgerqf_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgerqf_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgerqf_batched_full_rank = rocsolver_dgerqf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgerqf_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgerqf_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgerqf_batched_rank_0 = rocsolver_dgerqf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgerqf_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgerqf_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgerqf_batched_rank_1 = rocsolver_dgerqf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgerqf_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgerqf_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgerqf_batched_full_rank = rocsolver_cgerqf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgerqf_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgerqf_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgerqf_batched_rank_0 = rocsolver_cgerqf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgerqf_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgerqf_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgerqf_batched_rank_1 = rocsolver_cgerqf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgerqf_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgerqf_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgerqf_batched_full_rank = rocsolver_zgerqf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgerqf_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgerqf_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgerqf_batched_rank_0 = rocsolver_zgerqf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgerqf_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgerqf_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgerqf_batched_rank_1 = rocsolver_zgerqf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgerqf_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgerqf_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgerqf_strided_batched_full_rank = rocsolver_sgerqf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgerqf_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgerqf_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgerqf_strided_batched_rank_0 = rocsolver_sgerqf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgerqf_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgerqf_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgerqf_strided_batched_rank_1 = rocsolver_sgerqf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgerqf_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgerqf_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgerqf_strided_batched_full_rank = rocsolver_dgerqf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgerqf_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgerqf_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgerqf_strided_batched_rank_0 = rocsolver_dgerqf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgerqf_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgerqf_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgerqf_strided_batched_rank_1 = rocsolver_dgerqf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgerqf_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgerqf_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgerqf_strided_batched_full_rank = rocsolver_cgerqf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgerqf_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgerqf_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgerqf_strided_batched_rank_0 = rocsolver_cgerqf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgerqf_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgerqf_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgerqf_strided_batched_rank_1 = rocsolver_cgerqf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgerqf_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgerqf_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgerqf_strided_batched_full_rank = rocsolver_zgerqf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgerqf_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgerqf_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgerqf_strided_batched_rank_0 = rocsolver_zgerqf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgerqf_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgerqf_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgerqf_strided_batched_rank_1 = rocsolver_zgerqf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgeqlf_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqlf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sgeqlf_full_rank = rocsolver_sgeqlf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sgeqlf_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqlf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      !
      rocsolver_sgeqlf_rank_0 = rocsolver_sgeqlf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sgeqlf_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqlf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sgeqlf_rank_1 = rocsolver_sgeqlf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dgeqlf_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqlf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dgeqlf_full_rank = rocsolver_dgeqlf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dgeqlf_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqlf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      !
      rocsolver_dgeqlf_rank_0 = rocsolver_dgeqlf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dgeqlf_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqlf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dgeqlf_rank_1 = rocsolver_dgeqlf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cgeqlf_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqlf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cgeqlf_full_rank = rocsolver_cgeqlf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cgeqlf_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqlf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      !
      rocsolver_cgeqlf_rank_0 = rocsolver_cgeqlf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cgeqlf_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqlf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cgeqlf_rank_1 = rocsolver_cgeqlf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zgeqlf_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqlf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zgeqlf_full_rank = rocsolver_zgeqlf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zgeqlf_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqlf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      !
      rocsolver_zgeqlf_rank_0 = rocsolver_zgeqlf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zgeqlf_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqlf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zgeqlf_rank_1 = rocsolver_zgeqlf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sgeqlf_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqlf_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgeqlf_batched_full_rank = rocsolver_sgeqlf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgeqlf_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqlf_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgeqlf_batched_rank_0 = rocsolver_sgeqlf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgeqlf_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqlf_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgeqlf_batched_rank_1 = rocsolver_sgeqlf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgeqlf_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqlf_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgeqlf_batched_full_rank = rocsolver_dgeqlf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgeqlf_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqlf_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgeqlf_batched_rank_0 = rocsolver_dgeqlf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgeqlf_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqlf_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgeqlf_batched_rank_1 = rocsolver_dgeqlf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgeqlf_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqlf_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgeqlf_batched_full_rank = rocsolver_cgeqlf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgeqlf_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqlf_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgeqlf_batched_rank_0 = rocsolver_cgeqlf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgeqlf_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqlf_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgeqlf_batched_rank_1 = rocsolver_cgeqlf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgeqlf_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqlf_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgeqlf_batched_full_rank = rocsolver_zgeqlf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgeqlf_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqlf_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgeqlf_batched_rank_0 = rocsolver_zgeqlf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgeqlf_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqlf_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgeqlf_batched_rank_1 = rocsolver_zgeqlf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgeqlf_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqlf_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgeqlf_strided_batched_full_rank = rocsolver_sgeqlf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgeqlf_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqlf_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgeqlf_strided_batched_rank_0 = rocsolver_sgeqlf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgeqlf_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeqlf_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgeqlf_strided_batched_rank_1 = rocsolver_sgeqlf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgeqlf_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqlf_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgeqlf_strided_batched_full_rank = rocsolver_dgeqlf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgeqlf_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqlf_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgeqlf_strided_batched_rank_0 = rocsolver_dgeqlf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgeqlf_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeqlf_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgeqlf_strided_batched_rank_1 = rocsolver_dgeqlf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgeqlf_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqlf_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgeqlf_strided_batched_full_rank = rocsolver_cgeqlf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgeqlf_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqlf_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgeqlf_strided_batched_rank_0 = rocsolver_cgeqlf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgeqlf_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeqlf_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgeqlf_strided_batched_rank_1 = rocsolver_cgeqlf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgeqlf_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqlf_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgeqlf_strided_batched_full_rank = rocsolver_zgeqlf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgeqlf_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqlf_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgeqlf_strided_batched_rank_0 = rocsolver_zgeqlf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgeqlf_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeqlf_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgeqlf_strided_batched_rank_1 = rocsolver_zgeqlf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgelqf_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgelqf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sgelqf_full_rank = rocsolver_sgelqf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sgelqf_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgelqf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      !
      rocsolver_sgelqf_rank_0 = rocsolver_sgelqf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sgelqf_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgelqf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      !
      rocsolver_sgelqf_rank_1 = rocsolver_sgelqf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dgelqf_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgelqf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dgelqf_full_rank = rocsolver_dgelqf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dgelqf_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgelqf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      !
      rocsolver_dgelqf_rank_0 = rocsolver_dgelqf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_dgelqf_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgelqf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      !
      rocsolver_dgelqf_rank_1 = rocsolver_dgelqf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cgelqf_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgelqf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cgelqf_full_rank = rocsolver_cgelqf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cgelqf_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgelqf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      !
      rocsolver_cgelqf_rank_0 = rocsolver_cgelqf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_cgelqf_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgelqf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      !
      rocsolver_cgelqf_rank_1 = rocsolver_cgelqf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zgelqf_full_rank(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgelqf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zgelqf_full_rank = rocsolver_zgelqf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zgelqf_rank_0(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgelqf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      !
      rocsolver_zgelqf_rank_0 = rocsolver_zgelqf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_zgelqf_rank_1(handle,m,n,A,lda,ipiv)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgelqf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      !
      rocsolver_zgelqf_rank_1 = rocsolver_zgelqf_(handle,m,n,c_loc(A),lda,c_loc(ipiv))
    end function

    function rocsolver_sgelqf_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgelqf_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgelqf_batched_full_rank = rocsolver_sgelqf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgelqf_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgelqf_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgelqf_batched_rank_0 = rocsolver_sgelqf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgelqf_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgelqf_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgelqf_batched_rank_1 = rocsolver_sgelqf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgelqf_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgelqf_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgelqf_batched_full_rank = rocsolver_dgelqf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgelqf_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgelqf_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgelqf_batched_rank_0 = rocsolver_dgelqf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgelqf_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgelqf_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgelqf_batched_rank_1 = rocsolver_dgelqf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgelqf_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgelqf_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgelqf_batched_full_rank = rocsolver_cgelqf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgelqf_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgelqf_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgelqf_batched_rank_0 = rocsolver_cgelqf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgelqf_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgelqf_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgelqf_batched_rank_1 = rocsolver_cgelqf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgelqf_batched_full_rank(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgelqf_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgelqf_batched_full_rank = rocsolver_zgelqf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgelqf_batched_rank_0(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgelqf_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgelqf_batched_rank_0 = rocsolver_zgelqf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgelqf_batched_rank_1(handle,m,n,A,lda,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgelqf_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgelqf_batched_rank_1 = rocsolver_zgelqf_batched_(handle,m,n,c_loc(A),lda,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgelqf_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgelqf_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgelqf_strided_batched_full_rank = rocsolver_sgelqf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgelqf_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgelqf_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgelqf_strided_batched_rank_0 = rocsolver_sgelqf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgelqf_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgelqf_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgelqf_strided_batched_rank_1 = rocsolver_sgelqf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgelqf_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgelqf_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgelqf_strided_batched_full_rank = rocsolver_dgelqf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgelqf_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgelqf_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgelqf_strided_batched_rank_0 = rocsolver_dgelqf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_dgelqf_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgelqf_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgelqf_strided_batched_rank_1 = rocsolver_dgelqf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgelqf_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgelqf_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgelqf_strided_batched_full_rank = rocsolver_cgelqf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgelqf_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgelqf_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgelqf_strided_batched_rank_0 = rocsolver_cgelqf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_cgelqf_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgelqf_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgelqf_strided_batched_rank_1 = rocsolver_cgelqf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgelqf_strided_batched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgelqf_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgelqf_strided_batched_full_rank = rocsolver_zgelqf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgelqf_strided_batched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgelqf_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgelqf_strided_batched_rank_0 = rocsolver_zgelqf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_zgelqf_strided_batched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgelqf_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgelqf_strided_batched_rank_1 = rocsolver_zgelqf_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,batch_count)
    end function

    function rocsolver_sgebd2_full_rank(handle,m,n,A,lda,D,E,tauq,taup)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgebd2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      real(c_float),target,dimension(:) :: tauq
      real(c_float),target,dimension(:) :: taup
      !
      rocsolver_sgebd2_full_rank = rocsolver_sgebd2_(handle,m,n,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup))
    end function

    function rocsolver_sgebd2_rank_0(handle,m,n,A,lda,D,E,tauq,taup)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgebd2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: D
      real(c_float),target :: E
      real(c_float),target :: tauq
      real(c_float),target :: taup
      !
      rocsolver_sgebd2_rank_0 = rocsolver_sgebd2_(handle,m,n,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup))
    end function

    function rocsolver_sgebd2_rank_1(handle,m,n,A,lda,D,E,tauq,taup)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgebd2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      real(c_float),target,dimension(:) :: tauq
      real(c_float),target,dimension(:) :: taup
      !
      rocsolver_sgebd2_rank_1 = rocsolver_sgebd2_(handle,m,n,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup))
    end function

    function rocsolver_dgebd2_full_rank(handle,m,n,A,lda,D,E,tauq,taup)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgebd2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      real(c_double),target,dimension(:) :: tauq
      real(c_double),target,dimension(:) :: taup
      !
      rocsolver_dgebd2_full_rank = rocsolver_dgebd2_(handle,m,n,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup))
    end function

    function rocsolver_dgebd2_rank_0(handle,m,n,A,lda,D,E,tauq,taup)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgebd2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: D
      real(c_double),target :: E
      real(c_double),target :: tauq
      real(c_double),target :: taup
      !
      rocsolver_dgebd2_rank_0 = rocsolver_dgebd2_(handle,m,n,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup))
    end function

    function rocsolver_dgebd2_rank_1(handle,m,n,A,lda,D,E,tauq,taup)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgebd2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      real(c_double),target,dimension(:) :: tauq
      real(c_double),target,dimension(:) :: taup
      !
      rocsolver_dgebd2_rank_1 = rocsolver_dgebd2_(handle,m,n,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup))
    end function

    function rocsolver_cgebd2_full_rank(handle,m,n,A,lda,D,E,tauq,taup)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgebd2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      complex(c_float_complex),target,dimension(:) :: tauq
      complex(c_float_complex),target,dimension(:) :: taup
      !
      rocsolver_cgebd2_full_rank = rocsolver_cgebd2_(handle,m,n,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup))
    end function

    function rocsolver_cgebd2_rank_0(handle,m,n,A,lda,D,E,tauq,taup)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgebd2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      real(c_float),target :: D
      real(c_float),target :: E
      complex(c_float_complex),target :: tauq
      complex(c_float_complex),target :: taup
      !
      rocsolver_cgebd2_rank_0 = rocsolver_cgebd2_(handle,m,n,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup))
    end function

    function rocsolver_cgebd2_rank_1(handle,m,n,A,lda,D,E,tauq,taup)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgebd2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      complex(c_float_complex),target,dimension(:) :: tauq
      complex(c_float_complex),target,dimension(:) :: taup
      !
      rocsolver_cgebd2_rank_1 = rocsolver_cgebd2_(handle,m,n,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup))
    end function

    function rocsolver_zgebd2_full_rank(handle,m,n,A,lda,D,E,tauq,taup)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgebd2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      complex(c_double_complex),target,dimension(:) :: tauq
      complex(c_double_complex),target,dimension(:) :: taup
      !
      rocsolver_zgebd2_full_rank = rocsolver_zgebd2_(handle,m,n,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup))
    end function

    function rocsolver_zgebd2_rank_0(handle,m,n,A,lda,D,E,tauq,taup)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgebd2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      real(c_double),target :: D
      real(c_double),target :: E
      complex(c_double_complex),target :: tauq
      complex(c_double_complex),target :: taup
      !
      rocsolver_zgebd2_rank_0 = rocsolver_zgebd2_(handle,m,n,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup))
    end function

    function rocsolver_zgebd2_rank_1(handle,m,n,A,lda,D,E,tauq,taup)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgebd2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      complex(c_double_complex),target,dimension(:) :: tauq
      complex(c_double_complex),target,dimension(:) :: taup
      !
      rocsolver_zgebd2_rank_1 = rocsolver_zgebd2_(handle,m,n,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup))
    end function

    function rocsolver_sgebd2_batched_full_rank(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgebd2_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_float),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      real(c_float),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgebd2_batched_full_rank = rocsolver_sgebd2_batched_(handle,m,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_sgebd2_batched_rank_0(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgebd2_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      real(c_float),target :: tauq
      integer(c_int64_t) :: strideQ
      real(c_float),target :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgebd2_batched_rank_0 = rocsolver_sgebd2_batched_(handle,m,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_sgebd2_batched_rank_1(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgebd2_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_float),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      real(c_float),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgebd2_batched_rank_1 = rocsolver_sgebd2_batched_(handle,m,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_dgebd2_batched_full_rank(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgebd2_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_double),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      real(c_double),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgebd2_batched_full_rank = rocsolver_dgebd2_batched_(handle,m,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_dgebd2_batched_rank_0(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgebd2_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      real(c_double),target :: tauq
      integer(c_int64_t) :: strideQ
      real(c_double),target :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgebd2_batched_rank_0 = rocsolver_dgebd2_batched_(handle,m,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_dgebd2_batched_rank_1(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgebd2_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_double),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      real(c_double),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgebd2_batched_rank_1 = rocsolver_dgebd2_batched_(handle,m,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_cgebd2_batched_full_rank(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgebd2_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_float_complex),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      complex(c_float_complex),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgebd2_batched_full_rank = rocsolver_cgebd2_batched_(handle,m,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_cgebd2_batched_rank_0(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgebd2_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      complex(c_float_complex),target :: tauq
      integer(c_int64_t) :: strideQ
      complex(c_float_complex),target :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgebd2_batched_rank_0 = rocsolver_cgebd2_batched_(handle,m,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_cgebd2_batched_rank_1(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgebd2_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_float_complex),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      complex(c_float_complex),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgebd2_batched_rank_1 = rocsolver_cgebd2_batched_(handle,m,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_zgebd2_batched_full_rank(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgebd2_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_double_complex),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      complex(c_double_complex),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgebd2_batched_full_rank = rocsolver_zgebd2_batched_(handle,m,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_zgebd2_batched_rank_0(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgebd2_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      complex(c_double_complex),target :: tauq
      integer(c_int64_t) :: strideQ
      complex(c_double_complex),target :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgebd2_batched_rank_0 = rocsolver_zgebd2_batched_(handle,m,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_zgebd2_batched_rank_1(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgebd2_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_double_complex),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      complex(c_double_complex),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgebd2_batched_rank_1 = rocsolver_zgebd2_batched_(handle,m,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_sgebd2_strided_batched_full_rank(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgebd2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_float),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      real(c_float),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgebd2_strided_batched_full_rank = rocsolver_sgebd2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_sgebd2_strided_batched_rank_0(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgebd2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      real(c_float),target :: tauq
      integer(c_int64_t) :: strideQ
      real(c_float),target :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgebd2_strided_batched_rank_0 = rocsolver_sgebd2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_sgebd2_strided_batched_rank_1(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgebd2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_float),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      real(c_float),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgebd2_strided_batched_rank_1 = rocsolver_sgebd2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_dgebd2_strided_batched_full_rank(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgebd2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_double),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      real(c_double),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgebd2_strided_batched_full_rank = rocsolver_dgebd2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_dgebd2_strided_batched_rank_0(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgebd2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      real(c_double),target :: tauq
      integer(c_int64_t) :: strideQ
      real(c_double),target :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgebd2_strided_batched_rank_0 = rocsolver_dgebd2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_dgebd2_strided_batched_rank_1(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgebd2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_double),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      real(c_double),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgebd2_strided_batched_rank_1 = rocsolver_dgebd2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_cgebd2_strided_batched_full_rank(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgebd2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_float_complex),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      complex(c_float_complex),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgebd2_strided_batched_full_rank = rocsolver_cgebd2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_cgebd2_strided_batched_rank_0(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgebd2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      complex(c_float_complex),target :: tauq
      integer(c_int64_t) :: strideQ
      complex(c_float_complex),target :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgebd2_strided_batched_rank_0 = rocsolver_cgebd2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_cgebd2_strided_batched_rank_1(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgebd2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_float_complex),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      complex(c_float_complex),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgebd2_strided_batched_rank_1 = rocsolver_cgebd2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_zgebd2_strided_batched_full_rank(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgebd2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_double_complex),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      complex(c_double_complex),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgebd2_strided_batched_full_rank = rocsolver_zgebd2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_zgebd2_strided_batched_rank_0(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgebd2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      complex(c_double_complex),target :: tauq
      integer(c_int64_t) :: strideQ
      complex(c_double_complex),target :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgebd2_strided_batched_rank_0 = rocsolver_zgebd2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_zgebd2_strided_batched_rank_1(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgebd2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_double_complex),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      complex(c_double_complex),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgebd2_strided_batched_rank_1 = rocsolver_zgebd2_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_sgebrd_full_rank(handle,m,n,A,lda,D,E,tauq,taup)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgebrd_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      real(c_float),target,dimension(:) :: tauq
      real(c_float),target,dimension(:) :: taup
      !
      rocsolver_sgebrd_full_rank = rocsolver_sgebrd_(handle,m,n,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup))
    end function

    function rocsolver_sgebrd_rank_0(handle,m,n,A,lda,D,E,tauq,taup)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgebrd_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: D
      real(c_float),target :: E
      real(c_float),target :: tauq
      real(c_float),target :: taup
      !
      rocsolver_sgebrd_rank_0 = rocsolver_sgebrd_(handle,m,n,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup))
    end function

    function rocsolver_sgebrd_rank_1(handle,m,n,A,lda,D,E,tauq,taup)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgebrd_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      real(c_float),target,dimension(:) :: tauq
      real(c_float),target,dimension(:) :: taup
      !
      rocsolver_sgebrd_rank_1 = rocsolver_sgebrd_(handle,m,n,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup))
    end function

    function rocsolver_dgebrd_full_rank(handle,m,n,A,lda,D,E,tauq,taup)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgebrd_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      real(c_double),target,dimension(:) :: tauq
      real(c_double),target,dimension(:) :: taup
      !
      rocsolver_dgebrd_full_rank = rocsolver_dgebrd_(handle,m,n,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup))
    end function

    function rocsolver_dgebrd_rank_0(handle,m,n,A,lda,D,E,tauq,taup)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgebrd_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: D
      real(c_double),target :: E
      real(c_double),target :: tauq
      real(c_double),target :: taup
      !
      rocsolver_dgebrd_rank_0 = rocsolver_dgebrd_(handle,m,n,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup))
    end function

    function rocsolver_dgebrd_rank_1(handle,m,n,A,lda,D,E,tauq,taup)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgebrd_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      real(c_double),target,dimension(:) :: tauq
      real(c_double),target,dimension(:) :: taup
      !
      rocsolver_dgebrd_rank_1 = rocsolver_dgebrd_(handle,m,n,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup))
    end function

    function rocsolver_cgebrd_full_rank(handle,m,n,A,lda,D,E,tauq,taup)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgebrd_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      complex(c_float_complex),target,dimension(:) :: tauq
      complex(c_float_complex),target,dimension(:) :: taup
      !
      rocsolver_cgebrd_full_rank = rocsolver_cgebrd_(handle,m,n,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup))
    end function

    function rocsolver_cgebrd_rank_0(handle,m,n,A,lda,D,E,tauq,taup)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgebrd_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      real(c_float),target :: D
      real(c_float),target :: E
      complex(c_float_complex),target :: tauq
      complex(c_float_complex),target :: taup
      !
      rocsolver_cgebrd_rank_0 = rocsolver_cgebrd_(handle,m,n,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup))
    end function

    function rocsolver_cgebrd_rank_1(handle,m,n,A,lda,D,E,tauq,taup)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgebrd_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      complex(c_float_complex),target,dimension(:) :: tauq
      complex(c_float_complex),target,dimension(:) :: taup
      !
      rocsolver_cgebrd_rank_1 = rocsolver_cgebrd_(handle,m,n,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup))
    end function

    function rocsolver_zgebrd_full_rank(handle,m,n,A,lda,D,E,tauq,taup)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgebrd_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      complex(c_double_complex),target,dimension(:) :: tauq
      complex(c_double_complex),target,dimension(:) :: taup
      !
      rocsolver_zgebrd_full_rank = rocsolver_zgebrd_(handle,m,n,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup))
    end function

    function rocsolver_zgebrd_rank_0(handle,m,n,A,lda,D,E,tauq,taup)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgebrd_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      real(c_double),target :: D
      real(c_double),target :: E
      complex(c_double_complex),target :: tauq
      complex(c_double_complex),target :: taup
      !
      rocsolver_zgebrd_rank_0 = rocsolver_zgebrd_(handle,m,n,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup))
    end function

    function rocsolver_zgebrd_rank_1(handle,m,n,A,lda,D,E,tauq,taup)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgebrd_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      complex(c_double_complex),target,dimension(:) :: tauq
      complex(c_double_complex),target,dimension(:) :: taup
      !
      rocsolver_zgebrd_rank_1 = rocsolver_zgebrd_(handle,m,n,c_loc(A),lda,c_loc(D),c_loc(E),c_loc(tauq),c_loc(taup))
    end function

    function rocsolver_sgebrd_batched_full_rank(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgebrd_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_float),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      real(c_float),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgebrd_batched_full_rank = rocsolver_sgebrd_batched_(handle,m,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_sgebrd_batched_rank_0(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgebrd_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      real(c_float),target :: tauq
      integer(c_int64_t) :: strideQ
      real(c_float),target :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgebrd_batched_rank_0 = rocsolver_sgebrd_batched_(handle,m,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_sgebrd_batched_rank_1(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgebrd_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_float),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      real(c_float),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgebrd_batched_rank_1 = rocsolver_sgebrd_batched_(handle,m,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_dgebrd_batched_full_rank(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgebrd_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_double),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      real(c_double),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgebrd_batched_full_rank = rocsolver_dgebrd_batched_(handle,m,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_dgebrd_batched_rank_0(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgebrd_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      real(c_double),target :: tauq
      integer(c_int64_t) :: strideQ
      real(c_double),target :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgebrd_batched_rank_0 = rocsolver_dgebrd_batched_(handle,m,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_dgebrd_batched_rank_1(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgebrd_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_double),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      real(c_double),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgebrd_batched_rank_1 = rocsolver_dgebrd_batched_(handle,m,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_cgebrd_batched_full_rank(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgebrd_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_float_complex),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      complex(c_float_complex),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgebrd_batched_full_rank = rocsolver_cgebrd_batched_(handle,m,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_cgebrd_batched_rank_0(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgebrd_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      complex(c_float_complex),target :: tauq
      integer(c_int64_t) :: strideQ
      complex(c_float_complex),target :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgebrd_batched_rank_0 = rocsolver_cgebrd_batched_(handle,m,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_cgebrd_batched_rank_1(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgebrd_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_float_complex),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      complex(c_float_complex),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgebrd_batched_rank_1 = rocsolver_cgebrd_batched_(handle,m,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_zgebrd_batched_full_rank(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgebrd_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_double_complex),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      complex(c_double_complex),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgebrd_batched_full_rank = rocsolver_zgebrd_batched_(handle,m,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_zgebrd_batched_rank_0(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgebrd_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      complex(c_double_complex),target :: tauq
      integer(c_int64_t) :: strideQ
      complex(c_double_complex),target :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgebrd_batched_rank_0 = rocsolver_zgebrd_batched_(handle,m,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_zgebrd_batched_rank_1(handle,m,n,A,lda,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgebrd_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_double_complex),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      complex(c_double_complex),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgebrd_batched_rank_1 = rocsolver_zgebrd_batched_(handle,m,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_sgebrd_strided_batched_full_rank(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgebrd_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_float),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      real(c_float),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgebrd_strided_batched_full_rank = rocsolver_sgebrd_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_sgebrd_strided_batched_rank_0(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgebrd_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      real(c_float),target :: tauq
      integer(c_int64_t) :: strideQ
      real(c_float),target :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgebrd_strided_batched_rank_0 = rocsolver_sgebrd_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_sgebrd_strided_batched_rank_1(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgebrd_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_float),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      real(c_float),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_sgebrd_strided_batched_rank_1 = rocsolver_sgebrd_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_dgebrd_strided_batched_full_rank(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgebrd_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_double),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      real(c_double),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgebrd_strided_batched_full_rank = rocsolver_dgebrd_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_dgebrd_strided_batched_rank_0(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgebrd_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      real(c_double),target :: tauq
      integer(c_int64_t) :: strideQ
      real(c_double),target :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgebrd_strided_batched_rank_0 = rocsolver_dgebrd_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_dgebrd_strided_batched_rank_1(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgebrd_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_double),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      real(c_double),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dgebrd_strided_batched_rank_1 = rocsolver_dgebrd_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_cgebrd_strided_batched_full_rank(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgebrd_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_float_complex),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      complex(c_float_complex),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgebrd_strided_batched_full_rank = rocsolver_cgebrd_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_cgebrd_strided_batched_rank_0(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgebrd_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      complex(c_float_complex),target :: tauq
      integer(c_int64_t) :: strideQ
      complex(c_float_complex),target :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgebrd_strided_batched_rank_0 = rocsolver_cgebrd_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_cgebrd_strided_batched_rank_1(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgebrd_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_float_complex),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      complex(c_float_complex),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_cgebrd_strided_batched_rank_1 = rocsolver_cgebrd_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_zgebrd_strided_batched_full_rank(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgebrd_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_double_complex),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      complex(c_double_complex),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgebrd_strided_batched_full_rank = rocsolver_zgebrd_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_zgebrd_strided_batched_rank_0(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgebrd_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      complex(c_double_complex),target :: tauq
      integer(c_int64_t) :: strideQ
      complex(c_double_complex),target :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgebrd_strided_batched_rank_0 = rocsolver_zgebrd_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_zgebrd_strided_batched_rank_1(handle,m,n,A,lda,strideA,D,strideD,E,strideE,tauq,strideQ,taup,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgebrd_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_double_complex),target,dimension(:) :: tauq
      integer(c_int64_t) :: strideQ
      complex(c_double_complex),target,dimension(:) :: taup
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zgebrd_strided_batched_rank_1 = rocsolver_zgebrd_strided_batched_(handle,m,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,c_loc(tauq),strideQ,c_loc(taup),strideP,batch_count)
    end function

    function rocsolver_sgetrs_full_rank(handle,trans,n,nrhs,A,lda,ipiv,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrs_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_sgetrs_full_rank = rocsolver_sgetrs_(handle,trans,n,nrhs,c_loc(A),lda,c_loc(ipiv),c_loc(B),ldb)
    end function

    function rocsolver_sgetrs_rank_0(handle,trans,n,nrhs,A,lda,ipiv,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrs_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      real(c_float),target :: B
      integer(c_int) :: ldb
      !
      rocsolver_sgetrs_rank_0 = rocsolver_sgetrs_(handle,trans,n,nrhs,c_loc(A),lda,c_loc(ipiv),c_loc(B),ldb)
    end function

    function rocsolver_sgetrs_rank_1(handle,trans,n,nrhs,A,lda,ipiv,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrs_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_sgetrs_rank_1 = rocsolver_sgetrs_(handle,trans,n,nrhs,c_loc(A),lda,c_loc(ipiv),c_loc(B),ldb)
    end function

    function rocsolver_dgetrs_full_rank(handle,trans,n,nrhs,A,lda,ipiv,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrs_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_dgetrs_full_rank = rocsolver_dgetrs_(handle,trans,n,nrhs,c_loc(A),lda,c_loc(ipiv),c_loc(B),ldb)
    end function

    function rocsolver_dgetrs_rank_0(handle,trans,n,nrhs,A,lda,ipiv,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrs_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      real(c_double),target :: B
      integer(c_int) :: ldb
      !
      rocsolver_dgetrs_rank_0 = rocsolver_dgetrs_(handle,trans,n,nrhs,c_loc(A),lda,c_loc(ipiv),c_loc(B),ldb)
    end function

    function rocsolver_dgetrs_rank_1(handle,trans,n,nrhs,A,lda,ipiv,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrs_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_dgetrs_rank_1 = rocsolver_dgetrs_(handle,trans,n,nrhs,c_loc(A),lda,c_loc(ipiv),c_loc(B),ldb)
    end function

    function rocsolver_cgetrs_full_rank(handle,trans,n,nrhs,A,lda,ipiv,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrs_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_cgetrs_full_rank = rocsolver_cgetrs_(handle,trans,n,nrhs,c_loc(A),lda,c_loc(ipiv),c_loc(B),ldb)
    end function

    function rocsolver_cgetrs_rank_0(handle,trans,n,nrhs,A,lda,ipiv,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrs_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      !
      rocsolver_cgetrs_rank_0 = rocsolver_cgetrs_(handle,trans,n,nrhs,c_loc(A),lda,c_loc(ipiv),c_loc(B),ldb)
    end function

    function rocsolver_cgetrs_rank_1(handle,trans,n,nrhs,A,lda,ipiv,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrs_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_cgetrs_rank_1 = rocsolver_cgetrs_(handle,trans,n,nrhs,c_loc(A),lda,c_loc(ipiv),c_loc(B),ldb)
    end function

    function rocsolver_zgetrs_full_rank(handle,trans,n,nrhs,A,lda,ipiv,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrs_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_zgetrs_full_rank = rocsolver_zgetrs_(handle,trans,n,nrhs,c_loc(A),lda,c_loc(ipiv),c_loc(B),ldb)
    end function

    function rocsolver_zgetrs_rank_0(handle,trans,n,nrhs,A,lda,ipiv,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrs_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      !
      rocsolver_zgetrs_rank_0 = rocsolver_zgetrs_(handle,trans,n,nrhs,c_loc(A),lda,c_loc(ipiv),c_loc(B),ldb)
    end function

    function rocsolver_zgetrs_rank_1(handle,trans,n,nrhs,A,lda,ipiv,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrs_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_zgetrs_rank_1 = rocsolver_zgetrs_(handle,trans,n,nrhs,c_loc(A),lda,c_loc(ipiv),c_loc(B),ldb)
    end function

    function rocsolver_sgetrs_batched_full_rank(handle,trans,n,nrhs,A,lda,ipiv,strideP,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrs_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_sgetrs_batched_full_rank = rocsolver_sgetrs_batched_(handle,trans,n,nrhs,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_sgetrs_batched_rank_0(handle,trans,n,nrhs,A,lda,ipiv,strideP,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrs_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_sgetrs_batched_rank_0 = rocsolver_sgetrs_batched_(handle,trans,n,nrhs,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_sgetrs_batched_rank_1(handle,trans,n,nrhs,A,lda,ipiv,strideP,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrs_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_sgetrs_batched_rank_1 = rocsolver_sgetrs_batched_(handle,trans,n,nrhs,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_dgetrs_batched_full_rank(handle,trans,n,nrhs,A,lda,ipiv,strideP,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrs_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_dgetrs_batched_full_rank = rocsolver_dgetrs_batched_(handle,trans,n,nrhs,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_dgetrs_batched_rank_0(handle,trans,n,nrhs,A,lda,ipiv,strideP,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrs_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_dgetrs_batched_rank_0 = rocsolver_dgetrs_batched_(handle,trans,n,nrhs,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_dgetrs_batched_rank_1(handle,trans,n,nrhs,A,lda,ipiv,strideP,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrs_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_dgetrs_batched_rank_1 = rocsolver_dgetrs_batched_(handle,trans,n,nrhs,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_cgetrs_batched_full_rank(handle,trans,n,nrhs,A,lda,ipiv,strideP,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrs_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_cgetrs_batched_full_rank = rocsolver_cgetrs_batched_(handle,trans,n,nrhs,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_cgetrs_batched_rank_0(handle,trans,n,nrhs,A,lda,ipiv,strideP,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrs_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_cgetrs_batched_rank_0 = rocsolver_cgetrs_batched_(handle,trans,n,nrhs,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_cgetrs_batched_rank_1(handle,trans,n,nrhs,A,lda,ipiv,strideP,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrs_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_cgetrs_batched_rank_1 = rocsolver_cgetrs_batched_(handle,trans,n,nrhs,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_zgetrs_batched_full_rank(handle,trans,n,nrhs,A,lda,ipiv,strideP,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrs_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_zgetrs_batched_full_rank = rocsolver_zgetrs_batched_(handle,trans,n,nrhs,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_zgetrs_batched_rank_0(handle,trans,n,nrhs,A,lda,ipiv,strideP,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrs_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_zgetrs_batched_rank_0 = rocsolver_zgetrs_batched_(handle,trans,n,nrhs,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_zgetrs_batched_rank_1(handle,trans,n,nrhs,A,lda,ipiv,strideP,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrs_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_zgetrs_batched_rank_1 = rocsolver_zgetrs_batched_(handle,trans,n,nrhs,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_sgetrs_strided_batched_full_rank(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrs_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_sgetrs_strided_batched_full_rank = rocsolver_sgetrs_strided_batched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_sgetrs_strided_batched_rank_0(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrs_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_sgetrs_strided_batched_rank_0 = rocsolver_sgetrs_strided_batched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_sgetrs_strided_batched_rank_1(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetrs_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_sgetrs_strided_batched_rank_1 = rocsolver_sgetrs_strided_batched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_dgetrs_strided_batched_full_rank(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrs_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_dgetrs_strided_batched_full_rank = rocsolver_dgetrs_strided_batched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_dgetrs_strided_batched_rank_0(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrs_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_dgetrs_strided_batched_rank_0 = rocsolver_dgetrs_strided_batched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_dgetrs_strided_batched_rank_1(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetrs_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_dgetrs_strided_batched_rank_1 = rocsolver_dgetrs_strided_batched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_cgetrs_strided_batched_full_rank(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrs_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_cgetrs_strided_batched_full_rank = rocsolver_cgetrs_strided_batched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_cgetrs_strided_batched_rank_0(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrs_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_cgetrs_strided_batched_rank_0 = rocsolver_cgetrs_strided_batched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_cgetrs_strided_batched_rank_1(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetrs_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_cgetrs_strided_batched_rank_1 = rocsolver_cgetrs_strided_batched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_zgetrs_strided_batched_full_rank(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrs_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_zgetrs_strided_batched_full_rank = rocsolver_zgetrs_strided_batched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_zgetrs_strided_batched_rank_0(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrs_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_zgetrs_strided_batched_rank_0 = rocsolver_zgetrs_strided_batched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_zgetrs_strided_batched_rank_1(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetrs_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_zgetrs_strided_batched_rank_1 = rocsolver_zgetrs_strided_batched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_sgesv_full_rank(handle,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesv_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_sgesv_full_rank = rocsolver_sgesv_(handle,n,nrhs,c_loc(A),lda,c_loc(ipiv),c_loc(B),ldb,myInfo)
    end function

    function rocsolver_sgesv_rank_0(handle,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesv_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      real(c_float),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_sgesv_rank_0 = rocsolver_sgesv_(handle,n,nrhs,c_loc(A),lda,c_loc(ipiv),c_loc(B),ldb,myInfo)
    end function

    function rocsolver_sgesv_rank_1(handle,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesv_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_sgesv_rank_1 = rocsolver_sgesv_(handle,n,nrhs,c_loc(A),lda,c_loc(ipiv),c_loc(B),ldb,myInfo)
    end function

    function rocsolver_dgesv_full_rank(handle,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesv_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_dgesv_full_rank = rocsolver_dgesv_(handle,n,nrhs,c_loc(A),lda,c_loc(ipiv),c_loc(B),ldb,myInfo)
    end function

    function rocsolver_dgesv_rank_0(handle,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesv_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      real(c_double),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_dgesv_rank_0 = rocsolver_dgesv_(handle,n,nrhs,c_loc(A),lda,c_loc(ipiv),c_loc(B),ldb,myInfo)
    end function

    function rocsolver_dgesv_rank_1(handle,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesv_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_dgesv_rank_1 = rocsolver_dgesv_(handle,n,nrhs,c_loc(A),lda,c_loc(ipiv),c_loc(B),ldb,myInfo)
    end function

    function rocsolver_cgesv_full_rank(handle,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesv_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_cgesv_full_rank = rocsolver_cgesv_(handle,n,nrhs,c_loc(A),lda,c_loc(ipiv),c_loc(B),ldb,myInfo)
    end function

    function rocsolver_cgesv_rank_0(handle,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesv_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_cgesv_rank_0 = rocsolver_cgesv_(handle,n,nrhs,c_loc(A),lda,c_loc(ipiv),c_loc(B),ldb,myInfo)
    end function

    function rocsolver_cgesv_rank_1(handle,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesv_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_cgesv_rank_1 = rocsolver_cgesv_(handle,n,nrhs,c_loc(A),lda,c_loc(ipiv),c_loc(B),ldb,myInfo)
    end function

    function rocsolver_zgesv_full_rank(handle,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesv_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_zgesv_full_rank = rocsolver_zgesv_(handle,n,nrhs,c_loc(A),lda,c_loc(ipiv),c_loc(B),ldb,myInfo)
    end function

    function rocsolver_zgesv_rank_0(handle,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesv_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_zgesv_rank_0 = rocsolver_zgesv_(handle,n,nrhs,c_loc(A),lda,c_loc(ipiv),c_loc(B),ldb,myInfo)
    end function

    function rocsolver_zgesv_rank_1(handle,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesv_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_zgesv_rank_1 = rocsolver_zgesv_(handle,n,nrhs,c_loc(A),lda,c_loc(ipiv),c_loc(B),ldb,myInfo)
    end function

    function rocsolver_sgesv_batched_full_rank(handle,n,nrhs,A,lda,ipiv,strideP,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesv_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgesv_batched_full_rank = rocsolver_sgesv_batched_(handle,n,nrhs,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_sgesv_batched_rank_0(handle,n,nrhs,A,lda,ipiv,strideP,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesv_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      real(c_float),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgesv_batched_rank_0 = rocsolver_sgesv_batched_(handle,n,nrhs,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_sgesv_batched_rank_1(handle,n,nrhs,A,lda,ipiv,strideP,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesv_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgesv_batched_rank_1 = rocsolver_sgesv_batched_(handle,n,nrhs,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_dgesv_batched_full_rank(handle,n,nrhs,A,lda,ipiv,strideP,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesv_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgesv_batched_full_rank = rocsolver_dgesv_batched_(handle,n,nrhs,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_dgesv_batched_rank_0(handle,n,nrhs,A,lda,ipiv,strideP,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesv_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      real(c_double),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgesv_batched_rank_0 = rocsolver_dgesv_batched_(handle,n,nrhs,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_dgesv_batched_rank_1(handle,n,nrhs,A,lda,ipiv,strideP,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesv_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgesv_batched_rank_1 = rocsolver_dgesv_batched_(handle,n,nrhs,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_cgesv_batched_full_rank(handle,n,nrhs,A,lda,ipiv,strideP,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesv_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgesv_batched_full_rank = rocsolver_cgesv_batched_(handle,n,nrhs,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_cgesv_batched_rank_0(handle,n,nrhs,A,lda,ipiv,strideP,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesv_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgesv_batched_rank_0 = rocsolver_cgesv_batched_(handle,n,nrhs,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_cgesv_batched_rank_1(handle,n,nrhs,A,lda,ipiv,strideP,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesv_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgesv_batched_rank_1 = rocsolver_cgesv_batched_(handle,n,nrhs,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_zgesv_batched_full_rank(handle,n,nrhs,A,lda,ipiv,strideP,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesv_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgesv_batched_full_rank = rocsolver_zgesv_batched_(handle,n,nrhs,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_zgesv_batched_rank_0(handle,n,nrhs,A,lda,ipiv,strideP,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesv_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgesv_batched_rank_0 = rocsolver_zgesv_batched_(handle,n,nrhs,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_zgesv_batched_rank_1(handle,n,nrhs,A,lda,ipiv,strideP,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesv_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgesv_batched_rank_1 = rocsolver_zgesv_batched_(handle,n,nrhs,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_sgesv_strided_batched_full_rank(handle,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgesv_strided_batched_full_rank = rocsolver_sgesv_strided_batched_(handle,n,nrhs,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_sgesv_strided_batched_rank_0(handle,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgesv_strided_batched_rank_0 = rocsolver_sgesv_strided_batched_(handle,n,nrhs,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_sgesv_strided_batched_rank_1(handle,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgesv_strided_batched_rank_1 = rocsolver_sgesv_strided_batched_(handle,n,nrhs,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_dgesv_strided_batched_full_rank(handle,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgesv_strided_batched_full_rank = rocsolver_dgesv_strided_batched_(handle,n,nrhs,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_dgesv_strided_batched_rank_0(handle,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgesv_strided_batched_rank_0 = rocsolver_dgesv_strided_batched_(handle,n,nrhs,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_dgesv_strided_batched_rank_1(handle,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgesv_strided_batched_rank_1 = rocsolver_dgesv_strided_batched_(handle,n,nrhs,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_cgesv_strided_batched_full_rank(handle,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgesv_strided_batched_full_rank = rocsolver_cgesv_strided_batched_(handle,n,nrhs,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_cgesv_strided_batched_rank_0(handle,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgesv_strided_batched_rank_0 = rocsolver_cgesv_strided_batched_(handle,n,nrhs,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_cgesv_strided_batched_rank_1(handle,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgesv_strided_batched_rank_1 = rocsolver_cgesv_strided_batched_(handle,n,nrhs,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_zgesv_strided_batched_full_rank(handle,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgesv_strided_batched_full_rank = rocsolver_zgesv_strided_batched_(handle,n,nrhs,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_zgesv_strided_batched_rank_0(handle,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgesv_strided_batched_rank_0 = rocsolver_zgesv_strided_batched_(handle,n,nrhs,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_zgesv_strided_batched_rank_1(handle,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgesv_strided_batched_rank_1 = rocsolver_zgesv_strided_batched_(handle,n,nrhs,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_sgetri_full_rank(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_sgetri_full_rank = rocsolver_sgetri_(handle,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_sgetri_rank_0(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_sgetri_rank_0 = rocsolver_sgetri_(handle,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_sgetri_rank_1(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_sgetri_rank_1 = rocsolver_sgetri_(handle,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_dgetri_full_rank(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_dgetri_full_rank = rocsolver_dgetri_(handle,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_dgetri_rank_0(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_dgetri_rank_0 = rocsolver_dgetri_(handle,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_dgetri_rank_1(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_dgetri_rank_1 = rocsolver_dgetri_(handle,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_cgetri_full_rank(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_cgetri_full_rank = rocsolver_cgetri_(handle,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_cgetri_rank_0(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_cgetri_rank_0 = rocsolver_cgetri_(handle,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_cgetri_rank_1(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_cgetri_rank_1 = rocsolver_cgetri_(handle,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_zgetri_full_rank(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_zgetri_full_rank = rocsolver_zgetri_(handle,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_zgetri_rank_0(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_zgetri_rank_0 = rocsolver_zgetri_(handle,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_zgetri_rank_1(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_zgetri_rank_1 = rocsolver_zgetri_(handle,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_sgetri_batched_full_rank(handle,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetri_batched_full_rank = rocsolver_sgetri_batched_(handle,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_sgetri_batched_rank_0(handle,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetri_batched_rank_0 = rocsolver_sgetri_batched_(handle,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_sgetri_batched_rank_1(handle,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetri_batched_rank_1 = rocsolver_sgetri_batched_(handle,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dgetri_batched_full_rank(handle,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetri_batched_full_rank = rocsolver_dgetri_batched_(handle,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dgetri_batched_rank_0(handle,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetri_batched_rank_0 = rocsolver_dgetri_batched_(handle,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dgetri_batched_rank_1(handle,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetri_batched_rank_1 = rocsolver_dgetri_batched_(handle,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_cgetri_batched_full_rank(handle,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetri_batched_full_rank = rocsolver_cgetri_batched_(handle,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_cgetri_batched_rank_0(handle,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetri_batched_rank_0 = rocsolver_cgetri_batched_(handle,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_cgetri_batched_rank_1(handle,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetri_batched_rank_1 = rocsolver_cgetri_batched_(handle,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zgetri_batched_full_rank(handle,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetri_batched_full_rank = rocsolver_zgetri_batched_(handle,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zgetri_batched_rank_0(handle,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetri_batched_rank_0 = rocsolver_zgetri_batched_(handle,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zgetri_batched_rank_1(handle,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetri_batched_rank_1 = rocsolver_zgetri_batched_(handle,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_sgetri_strided_batched_full_rank(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetri_strided_batched_full_rank = rocsolver_sgetri_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_sgetri_strided_batched_rank_0(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetri_strided_batched_rank_0 = rocsolver_sgetri_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_sgetri_strided_batched_rank_1(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetri_strided_batched_rank_1 = rocsolver_sgetri_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dgetri_strided_batched_full_rank(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetri_strided_batched_full_rank = rocsolver_dgetri_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dgetri_strided_batched_rank_0(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetri_strided_batched_rank_0 = rocsolver_dgetri_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dgetri_strided_batched_rank_1(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetri_strided_batched_rank_1 = rocsolver_dgetri_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_cgetri_strided_batched_full_rank(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetri_strided_batched_full_rank = rocsolver_cgetri_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_cgetri_strided_batched_rank_0(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetri_strided_batched_rank_0 = rocsolver_cgetri_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_cgetri_strided_batched_rank_1(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetri_strided_batched_rank_1 = rocsolver_cgetri_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zgetri_strided_batched_full_rank(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetri_strided_batched_full_rank = rocsolver_zgetri_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zgetri_strided_batched_rank_0(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetri_strided_batched_rank_0 = rocsolver_zgetri_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zgetri_strided_batched_rank_1(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetri_strided_batched_rank_1 = rocsolver_zgetri_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_sgetri_npvt_full_rank(handle,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_npvt_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_sgetri_npvt_full_rank = rocsolver_sgetri_npvt_(handle,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_sgetri_npvt_rank_0(handle,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_npvt_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_sgetri_npvt_rank_0 = rocsolver_sgetri_npvt_(handle,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_sgetri_npvt_rank_1(handle,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_npvt_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_sgetri_npvt_rank_1 = rocsolver_sgetri_npvt_(handle,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_dgetri_npvt_full_rank(handle,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_npvt_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_dgetri_npvt_full_rank = rocsolver_dgetri_npvt_(handle,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_dgetri_npvt_rank_0(handle,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_npvt_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_dgetri_npvt_rank_0 = rocsolver_dgetri_npvt_(handle,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_dgetri_npvt_rank_1(handle,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_npvt_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_dgetri_npvt_rank_1 = rocsolver_dgetri_npvt_(handle,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_cgetri_npvt_full_rank(handle,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_npvt_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_cgetri_npvt_full_rank = rocsolver_cgetri_npvt_(handle,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_cgetri_npvt_rank_0(handle,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_npvt_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_cgetri_npvt_rank_0 = rocsolver_cgetri_npvt_(handle,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_cgetri_npvt_rank_1(handle,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_npvt_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_cgetri_npvt_rank_1 = rocsolver_cgetri_npvt_(handle,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_zgetri_npvt_full_rank(handle,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_npvt_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_zgetri_npvt_full_rank = rocsolver_zgetri_npvt_(handle,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_zgetri_npvt_rank_0(handle,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_npvt_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_zgetri_npvt_rank_0 = rocsolver_zgetri_npvt_(handle,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_zgetri_npvt_rank_1(handle,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_npvt_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_zgetri_npvt_rank_1 = rocsolver_zgetri_npvt_(handle,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_sgetri_npvt_batched_full_rank(handle,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_npvt_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetri_npvt_batched_full_rank = rocsolver_sgetri_npvt_batched_(handle,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_sgetri_npvt_batched_rank_0(handle,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_npvt_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetri_npvt_batched_rank_0 = rocsolver_sgetri_npvt_batched_(handle,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_sgetri_npvt_batched_rank_1(handle,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_npvt_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetri_npvt_batched_rank_1 = rocsolver_sgetri_npvt_batched_(handle,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_dgetri_npvt_batched_full_rank(handle,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_npvt_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetri_npvt_batched_full_rank = rocsolver_dgetri_npvt_batched_(handle,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_dgetri_npvt_batched_rank_0(handle,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_npvt_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetri_npvt_batched_rank_0 = rocsolver_dgetri_npvt_batched_(handle,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_dgetri_npvt_batched_rank_1(handle,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_npvt_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetri_npvt_batched_rank_1 = rocsolver_dgetri_npvt_batched_(handle,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_cgetri_npvt_batched_full_rank(handle,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_npvt_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetri_npvt_batched_full_rank = rocsolver_cgetri_npvt_batched_(handle,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_cgetri_npvt_batched_rank_0(handle,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_npvt_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetri_npvt_batched_rank_0 = rocsolver_cgetri_npvt_batched_(handle,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_cgetri_npvt_batched_rank_1(handle,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_npvt_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetri_npvt_batched_rank_1 = rocsolver_cgetri_npvt_batched_(handle,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_zgetri_npvt_batched_full_rank(handle,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_npvt_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetri_npvt_batched_full_rank = rocsolver_zgetri_npvt_batched_(handle,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_zgetri_npvt_batched_rank_0(handle,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_npvt_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetri_npvt_batched_rank_0 = rocsolver_zgetri_npvt_batched_(handle,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_zgetri_npvt_batched_rank_1(handle,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_npvt_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetri_npvt_batched_rank_1 = rocsolver_zgetri_npvt_batched_(handle,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_sgetri_npvt_strided_batched_full_rank(handle,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_npvt_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetri_npvt_strided_batched_full_rank = rocsolver_sgetri_npvt_strided_batched_(handle,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_sgetri_npvt_strided_batched_rank_0(handle,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_npvt_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetri_npvt_strided_batched_rank_0 = rocsolver_sgetri_npvt_strided_batched_(handle,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_sgetri_npvt_strided_batched_rank_1(handle,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_npvt_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetri_npvt_strided_batched_rank_1 = rocsolver_sgetri_npvt_strided_batched_(handle,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_dgetri_npvt_strided_batched_full_rank(handle,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_npvt_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetri_npvt_strided_batched_full_rank = rocsolver_dgetri_npvt_strided_batched_(handle,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_dgetri_npvt_strided_batched_rank_0(handle,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_npvt_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetri_npvt_strided_batched_rank_0 = rocsolver_dgetri_npvt_strided_batched_(handle,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_dgetri_npvt_strided_batched_rank_1(handle,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_npvt_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetri_npvt_strided_batched_rank_1 = rocsolver_dgetri_npvt_strided_batched_(handle,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_cgetri_npvt_strided_batched_full_rank(handle,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_npvt_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetri_npvt_strided_batched_full_rank = rocsolver_cgetri_npvt_strided_batched_(handle,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_cgetri_npvt_strided_batched_rank_0(handle,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_npvt_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetri_npvt_strided_batched_rank_0 = rocsolver_cgetri_npvt_strided_batched_(handle,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_cgetri_npvt_strided_batched_rank_1(handle,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_npvt_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetri_npvt_strided_batched_rank_1 = rocsolver_cgetri_npvt_strided_batched_(handle,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_zgetri_npvt_strided_batched_full_rank(handle,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_npvt_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetri_npvt_strided_batched_full_rank = rocsolver_zgetri_npvt_strided_batched_(handle,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_zgetri_npvt_strided_batched_rank_0(handle,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_npvt_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetri_npvt_strided_batched_rank_0 = rocsolver_zgetri_npvt_strided_batched_(handle,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_zgetri_npvt_strided_batched_rank_1(handle,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_npvt_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetri_npvt_strided_batched_rank_1 = rocsolver_zgetri_npvt_strided_batched_(handle,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_sgels_full_rank(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgels_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_sgels_full_rank = rocsolver_sgels_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo)
    end function

    function rocsolver_sgels_rank_0(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgels_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_sgels_rank_0 = rocsolver_sgels_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo)
    end function

    function rocsolver_sgels_rank_1(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgels_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_sgels_rank_1 = rocsolver_sgels_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo)
    end function

    function rocsolver_dgels_full_rank(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgels_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_dgels_full_rank = rocsolver_dgels_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo)
    end function

    function rocsolver_dgels_rank_0(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgels_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_dgels_rank_0 = rocsolver_dgels_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo)
    end function

    function rocsolver_dgels_rank_1(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgels_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_dgels_rank_1 = rocsolver_dgels_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo)
    end function

    function rocsolver_cgels_full_rank(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgels_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_cgels_full_rank = rocsolver_cgels_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo)
    end function

    function rocsolver_cgels_rank_0(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgels_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_cgels_rank_0 = rocsolver_cgels_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo)
    end function

    function rocsolver_cgels_rank_1(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgels_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_cgels_rank_1 = rocsolver_cgels_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo)
    end function

    function rocsolver_zgels_full_rank(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgels_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_zgels_full_rank = rocsolver_zgels_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo)
    end function

    function rocsolver_zgels_rank_0(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgels_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_zgels_rank_0 = rocsolver_zgels_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo)
    end function

    function rocsolver_zgels_rank_1(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgels_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_zgels_rank_1 = rocsolver_zgels_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo)
    end function

    function rocsolver_sgels_batched_full_rank(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgels_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgels_batched_full_rank = rocsolver_sgels_batched_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_sgels_batched_rank_0(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgels_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgels_batched_rank_0 = rocsolver_sgels_batched_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_sgels_batched_rank_1(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgels_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgels_batched_rank_1 = rocsolver_sgels_batched_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_dgels_batched_full_rank(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgels_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgels_batched_full_rank = rocsolver_dgels_batched_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_dgels_batched_rank_0(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgels_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgels_batched_rank_0 = rocsolver_dgels_batched_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_dgels_batched_rank_1(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgels_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgels_batched_rank_1 = rocsolver_dgels_batched_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_cgels_batched_full_rank(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgels_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgels_batched_full_rank = rocsolver_cgels_batched_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_cgels_batched_rank_0(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgels_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgels_batched_rank_0 = rocsolver_cgels_batched_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_cgels_batched_rank_1(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgels_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgels_batched_rank_1 = rocsolver_cgels_batched_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_zgels_batched_full_rank(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgels_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgels_batched_full_rank = rocsolver_zgels_batched_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_zgels_batched_rank_0(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgels_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgels_batched_rank_0 = rocsolver_zgels_batched_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_zgels_batched_rank_1(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgels_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgels_batched_rank_1 = rocsolver_zgels_batched_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_sgels_strided_batched_full_rank(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgels_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgels_strided_batched_full_rank = rocsolver_sgels_strided_batched_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_sgels_strided_batched_rank_0(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgels_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgels_strided_batched_rank_0 = rocsolver_sgels_strided_batched_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_sgels_strided_batched_rank_1(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgels_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgels_strided_batched_rank_1 = rocsolver_sgels_strided_batched_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_dgels_strided_batched_full_rank(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgels_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgels_strided_batched_full_rank = rocsolver_dgels_strided_batched_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_dgels_strided_batched_rank_0(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgels_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgels_strided_batched_rank_0 = rocsolver_dgels_strided_batched_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_dgels_strided_batched_rank_1(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgels_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgels_strided_batched_rank_1 = rocsolver_dgels_strided_batched_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_cgels_strided_batched_full_rank(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgels_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgels_strided_batched_full_rank = rocsolver_cgels_strided_batched_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_cgels_strided_batched_rank_0(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgels_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgels_strided_batched_rank_0 = rocsolver_cgels_strided_batched_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_cgels_strided_batched_rank_1(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgels_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgels_strided_batched_rank_1 = rocsolver_cgels_strided_batched_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_zgels_strided_batched_full_rank(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgels_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgels_strided_batched_full_rank = rocsolver_zgels_strided_batched_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_zgels_strided_batched_rank_0(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgels_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgels_strided_batched_rank_0 = rocsolver_zgels_strided_batched_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_zgels_strided_batched_rank_1(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgels_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_operation_none)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgels_strided_batched_rank_1 = rocsolver_zgels_strided_batched_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_spotf2_full_rank(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotf2_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_spotf2_full_rank = rocsolver_spotf2_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_spotf2_rank_0(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotf2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_spotf2_rank_0 = rocsolver_spotf2_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_spotf2_rank_1(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotf2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_spotf2_rank_1 = rocsolver_spotf2_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_dpotf2_full_rank(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotf2_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_dpotf2_full_rank = rocsolver_dpotf2_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_dpotf2_rank_0(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotf2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_dpotf2_rank_0 = rocsolver_dpotf2_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_dpotf2_rank_1(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotf2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_dpotf2_rank_1 = rocsolver_dpotf2_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_cpotf2_full_rank(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotf2_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_cpotf2_full_rank = rocsolver_cpotf2_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_cpotf2_rank_0(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotf2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_cpotf2_rank_0 = rocsolver_cpotf2_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_cpotf2_rank_1(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotf2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_cpotf2_rank_1 = rocsolver_cpotf2_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_zpotf2_full_rank(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotf2_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_zpotf2_full_rank = rocsolver_zpotf2_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_zpotf2_rank_0(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotf2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_zpotf2_rank_0 = rocsolver_zpotf2_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_zpotf2_rank_1(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotf2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_zpotf2_rank_1 = rocsolver_zpotf2_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_spotf2_batched_full_rank(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotf2_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_spotf2_batched_full_rank = rocsolver_spotf2_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_spotf2_batched_rank_0(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotf2_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_spotf2_batched_rank_0 = rocsolver_spotf2_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_spotf2_batched_rank_1(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotf2_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_spotf2_batched_rank_1 = rocsolver_spotf2_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_dpotf2_batched_full_rank(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotf2_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dpotf2_batched_full_rank = rocsolver_dpotf2_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_dpotf2_batched_rank_0(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotf2_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dpotf2_batched_rank_0 = rocsolver_dpotf2_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_dpotf2_batched_rank_1(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotf2_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dpotf2_batched_rank_1 = rocsolver_dpotf2_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_cpotf2_batched_full_rank(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotf2_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cpotf2_batched_full_rank = rocsolver_cpotf2_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_cpotf2_batched_rank_0(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotf2_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cpotf2_batched_rank_0 = rocsolver_cpotf2_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_cpotf2_batched_rank_1(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotf2_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cpotf2_batched_rank_1 = rocsolver_cpotf2_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_zpotf2_batched_full_rank(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotf2_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zpotf2_batched_full_rank = rocsolver_zpotf2_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_zpotf2_batched_rank_0(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotf2_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zpotf2_batched_rank_0 = rocsolver_zpotf2_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_zpotf2_batched_rank_1(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotf2_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zpotf2_batched_rank_1 = rocsolver_zpotf2_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_spotf2_strided_batched_full_rank(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotf2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_spotf2_strided_batched_full_rank = rocsolver_spotf2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_spotf2_strided_batched_rank_0(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotf2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_spotf2_strided_batched_rank_0 = rocsolver_spotf2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_spotf2_strided_batched_rank_1(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotf2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_spotf2_strided_batched_rank_1 = rocsolver_spotf2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_dpotf2_strided_batched_full_rank(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotf2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dpotf2_strided_batched_full_rank = rocsolver_dpotf2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_dpotf2_strided_batched_rank_0(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotf2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dpotf2_strided_batched_rank_0 = rocsolver_dpotf2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_dpotf2_strided_batched_rank_1(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotf2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dpotf2_strided_batched_rank_1 = rocsolver_dpotf2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_cpotf2_strided_batched_full_rank(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotf2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cpotf2_strided_batched_full_rank = rocsolver_cpotf2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_cpotf2_strided_batched_rank_0(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotf2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cpotf2_strided_batched_rank_0 = rocsolver_cpotf2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_cpotf2_strided_batched_rank_1(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotf2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cpotf2_strided_batched_rank_1 = rocsolver_cpotf2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_zpotf2_strided_batched_full_rank(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotf2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zpotf2_strided_batched_full_rank = rocsolver_zpotf2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_zpotf2_strided_batched_rank_0(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotf2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zpotf2_strided_batched_rank_0 = rocsolver_zpotf2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_zpotf2_strided_batched_rank_1(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotf2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zpotf2_strided_batched_rank_1 = rocsolver_zpotf2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_spotrf_full_rank(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotrf_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_spotrf_full_rank = rocsolver_spotrf_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_spotrf_rank_0(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotrf_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_spotrf_rank_0 = rocsolver_spotrf_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_spotrf_rank_1(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotrf_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_spotrf_rank_1 = rocsolver_spotrf_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_dpotrf_full_rank(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotrf_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_dpotrf_full_rank = rocsolver_dpotrf_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_dpotrf_rank_0(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotrf_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_dpotrf_rank_0 = rocsolver_dpotrf_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_dpotrf_rank_1(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotrf_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_dpotrf_rank_1 = rocsolver_dpotrf_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_cpotrf_full_rank(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotrf_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_cpotrf_full_rank = rocsolver_cpotrf_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_cpotrf_rank_0(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotrf_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_cpotrf_rank_0 = rocsolver_cpotrf_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_cpotrf_rank_1(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotrf_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_cpotrf_rank_1 = rocsolver_cpotrf_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_zpotrf_full_rank(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotrf_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_zpotrf_full_rank = rocsolver_zpotrf_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_zpotrf_rank_0(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotrf_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_zpotrf_rank_0 = rocsolver_zpotrf_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_zpotrf_rank_1(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotrf_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_zpotrf_rank_1 = rocsolver_zpotrf_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_spotrf_batched_full_rank(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotrf_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_spotrf_batched_full_rank = rocsolver_spotrf_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_spotrf_batched_rank_0(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotrf_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_spotrf_batched_rank_0 = rocsolver_spotrf_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_spotrf_batched_rank_1(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotrf_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_spotrf_batched_rank_1 = rocsolver_spotrf_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_dpotrf_batched_full_rank(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotrf_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dpotrf_batched_full_rank = rocsolver_dpotrf_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_dpotrf_batched_rank_0(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotrf_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dpotrf_batched_rank_0 = rocsolver_dpotrf_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_dpotrf_batched_rank_1(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotrf_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dpotrf_batched_rank_1 = rocsolver_dpotrf_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_cpotrf_batched_full_rank(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotrf_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cpotrf_batched_full_rank = rocsolver_cpotrf_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_cpotrf_batched_rank_0(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotrf_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cpotrf_batched_rank_0 = rocsolver_cpotrf_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_cpotrf_batched_rank_1(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotrf_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cpotrf_batched_rank_1 = rocsolver_cpotrf_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_zpotrf_batched_full_rank(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotrf_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zpotrf_batched_full_rank = rocsolver_zpotrf_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_zpotrf_batched_rank_0(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotrf_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zpotrf_batched_rank_0 = rocsolver_zpotrf_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_zpotrf_batched_rank_1(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotrf_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zpotrf_batched_rank_1 = rocsolver_zpotrf_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_spotrf_strided_batched_full_rank(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotrf_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_spotrf_strided_batched_full_rank = rocsolver_spotrf_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_spotrf_strided_batched_rank_0(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotrf_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_spotrf_strided_batched_rank_0 = rocsolver_spotrf_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_spotrf_strided_batched_rank_1(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotrf_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_spotrf_strided_batched_rank_1 = rocsolver_spotrf_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_dpotrf_strided_batched_full_rank(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotrf_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dpotrf_strided_batched_full_rank = rocsolver_dpotrf_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_dpotrf_strided_batched_rank_0(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotrf_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dpotrf_strided_batched_rank_0 = rocsolver_dpotrf_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_dpotrf_strided_batched_rank_1(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotrf_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dpotrf_strided_batched_rank_1 = rocsolver_dpotrf_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_cpotrf_strided_batched_full_rank(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotrf_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cpotrf_strided_batched_full_rank = rocsolver_cpotrf_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_cpotrf_strided_batched_rank_0(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotrf_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cpotrf_strided_batched_rank_0 = rocsolver_cpotrf_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_cpotrf_strided_batched_rank_1(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotrf_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cpotrf_strided_batched_rank_1 = rocsolver_cpotrf_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_zpotrf_strided_batched_full_rank(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotrf_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zpotrf_strided_batched_full_rank = rocsolver_zpotrf_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_zpotrf_strided_batched_rank_0(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotrf_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zpotrf_strided_batched_rank_0 = rocsolver_zpotrf_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_zpotrf_strided_batched_rank_1(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotrf_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zpotrf_strided_batched_rank_1 = rocsolver_zpotrf_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_spotrs_full_rank(handle,uplo,n,nrhs,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotrs_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_spotrs_full_rank = rocsolver_spotrs_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_spotrs_rank_0(handle,uplo,n,nrhs,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotrs_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      !
      rocsolver_spotrs_rank_0 = rocsolver_spotrs_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_spotrs_rank_1(handle,uplo,n,nrhs,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotrs_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_spotrs_rank_1 = rocsolver_spotrs_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_dpotrs_full_rank(handle,uplo,n,nrhs,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotrs_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_dpotrs_full_rank = rocsolver_dpotrs_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_dpotrs_rank_0(handle,uplo,n,nrhs,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotrs_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      !
      rocsolver_dpotrs_rank_0 = rocsolver_dpotrs_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_dpotrs_rank_1(handle,uplo,n,nrhs,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotrs_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_dpotrs_rank_1 = rocsolver_dpotrs_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_cpotrs_full_rank(handle,uplo,n,nrhs,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotrs_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_cpotrs_full_rank = rocsolver_cpotrs_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_cpotrs_rank_0(handle,uplo,n,nrhs,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotrs_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      !
      rocsolver_cpotrs_rank_0 = rocsolver_cpotrs_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_cpotrs_rank_1(handle,uplo,n,nrhs,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotrs_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_cpotrs_rank_1 = rocsolver_cpotrs_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_zpotrs_full_rank(handle,uplo,n,nrhs,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotrs_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_zpotrs_full_rank = rocsolver_zpotrs_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_zpotrs_rank_0(handle,uplo,n,nrhs,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotrs_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      !
      rocsolver_zpotrs_rank_0 = rocsolver_zpotrs_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_zpotrs_rank_1(handle,uplo,n,nrhs,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotrs_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_zpotrs_rank_1 = rocsolver_zpotrs_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_spotrs_batched_full_rank(handle,uplo,n,nrhs,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotrs_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_spotrs_batched_full_rank = rocsolver_spotrs_batched_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_spotrs_batched_rank_0(handle,uplo,n,nrhs,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotrs_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_spotrs_batched_rank_0 = rocsolver_spotrs_batched_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_spotrs_batched_rank_1(handle,uplo,n,nrhs,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotrs_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_spotrs_batched_rank_1 = rocsolver_spotrs_batched_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_dpotrs_batched_full_rank(handle,uplo,n,nrhs,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotrs_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_dpotrs_batched_full_rank = rocsolver_dpotrs_batched_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_dpotrs_batched_rank_0(handle,uplo,n,nrhs,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotrs_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_dpotrs_batched_rank_0 = rocsolver_dpotrs_batched_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_dpotrs_batched_rank_1(handle,uplo,n,nrhs,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotrs_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_dpotrs_batched_rank_1 = rocsolver_dpotrs_batched_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_cpotrs_batched_full_rank(handle,uplo,n,nrhs,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotrs_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_cpotrs_batched_full_rank = rocsolver_cpotrs_batched_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_cpotrs_batched_rank_0(handle,uplo,n,nrhs,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotrs_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_cpotrs_batched_rank_0 = rocsolver_cpotrs_batched_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_cpotrs_batched_rank_1(handle,uplo,n,nrhs,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotrs_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_cpotrs_batched_rank_1 = rocsolver_cpotrs_batched_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_zpotrs_batched_full_rank(handle,uplo,n,nrhs,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotrs_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_zpotrs_batched_full_rank = rocsolver_zpotrs_batched_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_zpotrs_batched_rank_0(handle,uplo,n,nrhs,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotrs_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_zpotrs_batched_rank_0 = rocsolver_zpotrs_batched_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_zpotrs_batched_rank_1(handle,uplo,n,nrhs,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotrs_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_zpotrs_batched_rank_1 = rocsolver_zpotrs_batched_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_spotrs_strided_batched_full_rank(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotrs_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_spotrs_strided_batched_full_rank = rocsolver_spotrs_strided_batched_(handle,uplo,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_spotrs_strided_batched_rank_0(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotrs_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_spotrs_strided_batched_rank_0 = rocsolver_spotrs_strided_batched_(handle,uplo,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_spotrs_strided_batched_rank_1(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotrs_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_spotrs_strided_batched_rank_1 = rocsolver_spotrs_strided_batched_(handle,uplo,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_dpotrs_strided_batched_full_rank(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotrs_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_dpotrs_strided_batched_full_rank = rocsolver_dpotrs_strided_batched_(handle,uplo,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_dpotrs_strided_batched_rank_0(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotrs_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_dpotrs_strided_batched_rank_0 = rocsolver_dpotrs_strided_batched_(handle,uplo,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_dpotrs_strided_batched_rank_1(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotrs_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_dpotrs_strided_batched_rank_1 = rocsolver_dpotrs_strided_batched_(handle,uplo,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_cpotrs_strided_batched_full_rank(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotrs_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_cpotrs_strided_batched_full_rank = rocsolver_cpotrs_strided_batched_(handle,uplo,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_cpotrs_strided_batched_rank_0(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotrs_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_cpotrs_strided_batched_rank_0 = rocsolver_cpotrs_strided_batched_(handle,uplo,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_cpotrs_strided_batched_rank_1(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotrs_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_cpotrs_strided_batched_rank_1 = rocsolver_cpotrs_strided_batched_(handle,uplo,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_zpotrs_strided_batched_full_rank(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotrs_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_zpotrs_strided_batched_full_rank = rocsolver_zpotrs_strided_batched_(handle,uplo,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_zpotrs_strided_batched_rank_0(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotrs_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_zpotrs_strided_batched_rank_0 = rocsolver_zpotrs_strided_batched_(handle,uplo,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_zpotrs_strided_batched_rank_1(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotrs_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_zpotrs_strided_batched_rank_1 = rocsolver_zpotrs_strided_batched_(handle,uplo,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_sposv_full_rank(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sposv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_sposv_full_rank = rocsolver_sposv_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo)
    end function

    function rocsolver_sposv_rank_0(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sposv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_sposv_rank_0 = rocsolver_sposv_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo)
    end function

    function rocsolver_sposv_rank_1(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sposv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_sposv_rank_1 = rocsolver_sposv_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo)
    end function

    function rocsolver_dposv_full_rank(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dposv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_dposv_full_rank = rocsolver_dposv_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo)
    end function

    function rocsolver_dposv_rank_0(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dposv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_dposv_rank_0 = rocsolver_dposv_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo)
    end function

    function rocsolver_dposv_rank_1(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dposv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_dposv_rank_1 = rocsolver_dposv_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo)
    end function

    function rocsolver_cposv_full_rank(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cposv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_cposv_full_rank = rocsolver_cposv_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo)
    end function

    function rocsolver_cposv_rank_0(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cposv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_cposv_rank_0 = rocsolver_cposv_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo)
    end function

    function rocsolver_cposv_rank_1(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cposv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_cposv_rank_1 = rocsolver_cposv_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo)
    end function

    function rocsolver_zposv_full_rank(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zposv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_zposv_full_rank = rocsolver_zposv_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo)
    end function

    function rocsolver_zposv_rank_0(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zposv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_zposv_rank_0 = rocsolver_zposv_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo)
    end function

    function rocsolver_zposv_rank_1(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zposv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      rocsolver_zposv_rank_1 = rocsolver_zposv_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo)
    end function

    function rocsolver_sposv_batched_full_rank(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sposv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sposv_batched_full_rank = rocsolver_sposv_batched_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_sposv_batched_rank_0(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sposv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sposv_batched_rank_0 = rocsolver_sposv_batched_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_sposv_batched_rank_1(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sposv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sposv_batched_rank_1 = rocsolver_sposv_batched_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_dposv_batched_full_rank(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dposv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dposv_batched_full_rank = rocsolver_dposv_batched_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_dposv_batched_rank_0(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dposv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dposv_batched_rank_0 = rocsolver_dposv_batched_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_dposv_batched_rank_1(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dposv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dposv_batched_rank_1 = rocsolver_dposv_batched_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_cposv_batched_full_rank(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cposv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cposv_batched_full_rank = rocsolver_cposv_batched_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_cposv_batched_rank_0(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cposv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cposv_batched_rank_0 = rocsolver_cposv_batched_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_cposv_batched_rank_1(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cposv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cposv_batched_rank_1 = rocsolver_cposv_batched_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_zposv_batched_full_rank(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zposv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zposv_batched_full_rank = rocsolver_zposv_batched_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_zposv_batched_rank_0(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zposv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zposv_batched_rank_0 = rocsolver_zposv_batched_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_zposv_batched_rank_1(handle,uplo,n,nrhs,A,lda,B,ldb,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zposv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zposv_batched_rank_1 = rocsolver_zposv_batched_(handle,uplo,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,batch_count)
    end function

    function rocsolver_sposv_strided_batched_full_rank(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sposv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sposv_strided_batched_full_rank = rocsolver_sposv_strided_batched_(handle,uplo,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_sposv_strided_batched_rank_0(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sposv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sposv_strided_batched_rank_0 = rocsolver_sposv_strided_batched_(handle,uplo,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_sposv_strided_batched_rank_1(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sposv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sposv_strided_batched_rank_1 = rocsolver_sposv_strided_batched_(handle,uplo,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_dposv_strided_batched_full_rank(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dposv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dposv_strided_batched_full_rank = rocsolver_dposv_strided_batched_(handle,uplo,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_dposv_strided_batched_rank_0(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dposv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dposv_strided_batched_rank_0 = rocsolver_dposv_strided_batched_(handle,uplo,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_dposv_strided_batched_rank_1(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dposv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dposv_strided_batched_rank_1 = rocsolver_dposv_strided_batched_(handle,uplo,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_cposv_strided_batched_full_rank(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cposv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cposv_strided_batched_full_rank = rocsolver_cposv_strided_batched_(handle,uplo,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_cposv_strided_batched_rank_0(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cposv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cposv_strided_batched_rank_0 = rocsolver_cposv_strided_batched_(handle,uplo,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_cposv_strided_batched_rank_1(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cposv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cposv_strided_batched_rank_1 = rocsolver_cposv_strided_batched_(handle,uplo,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_zposv_strided_batched_full_rank(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zposv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zposv_strided_batched_full_rank = rocsolver_zposv_strided_batched_(handle,uplo,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_zposv_strided_batched_rank_0(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zposv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zposv_strided_batched_rank_0 = rocsolver_zposv_strided_batched_(handle,uplo,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_zposv_strided_batched_rank_1(handle,uplo,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zposv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zposv_strided_batched_rank_1 = rocsolver_zposv_strided_batched_(handle,uplo,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,batch_count)
    end function

    function rocsolver_spotri_full_rank(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotri_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_spotri_full_rank = rocsolver_spotri_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_spotri_rank_0(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotri_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_spotri_rank_0 = rocsolver_spotri_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_spotri_rank_1(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotri_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_spotri_rank_1 = rocsolver_spotri_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_dpotri_full_rank(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotri_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_dpotri_full_rank = rocsolver_dpotri_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_dpotri_rank_0(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotri_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_dpotri_rank_0 = rocsolver_dpotri_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_dpotri_rank_1(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotri_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_dpotri_rank_1 = rocsolver_dpotri_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_cpotri_full_rank(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotri_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_cpotri_full_rank = rocsolver_cpotri_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_cpotri_rank_0(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotri_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_cpotri_rank_0 = rocsolver_cpotri_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_cpotri_rank_1(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotri_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_cpotri_rank_1 = rocsolver_cpotri_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_zpotri_full_rank(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotri_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_zpotri_full_rank = rocsolver_zpotri_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_zpotri_rank_0(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotri_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_zpotri_rank_0 = rocsolver_zpotri_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_zpotri_rank_1(handle,uplo,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotri_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_zpotri_rank_1 = rocsolver_zpotri_(handle,uplo,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_spotri_batched_full_rank(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotri_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_spotri_batched_full_rank = rocsolver_spotri_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_spotri_batched_rank_0(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotri_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_spotri_batched_rank_0 = rocsolver_spotri_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_spotri_batched_rank_1(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotri_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_spotri_batched_rank_1 = rocsolver_spotri_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_dpotri_batched_full_rank(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotri_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dpotri_batched_full_rank = rocsolver_dpotri_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_dpotri_batched_rank_0(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotri_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dpotri_batched_rank_0 = rocsolver_dpotri_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_dpotri_batched_rank_1(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotri_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dpotri_batched_rank_1 = rocsolver_dpotri_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_cpotri_batched_full_rank(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotri_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cpotri_batched_full_rank = rocsolver_cpotri_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_cpotri_batched_rank_0(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotri_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cpotri_batched_rank_0 = rocsolver_cpotri_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_cpotri_batched_rank_1(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotri_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cpotri_batched_rank_1 = rocsolver_cpotri_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_zpotri_batched_full_rank(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotri_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zpotri_batched_full_rank = rocsolver_zpotri_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_zpotri_batched_rank_0(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotri_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zpotri_batched_rank_0 = rocsolver_zpotri_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_zpotri_batched_rank_1(handle,uplo,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotri_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zpotri_batched_rank_1 = rocsolver_zpotri_batched_(handle,uplo,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_spotri_strided_batched_full_rank(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotri_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_spotri_strided_batched_full_rank = rocsolver_spotri_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_spotri_strided_batched_rank_0(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotri_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_spotri_strided_batched_rank_0 = rocsolver_spotri_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_spotri_strided_batched_rank_1(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_spotri_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_spotri_strided_batched_rank_1 = rocsolver_spotri_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_dpotri_strided_batched_full_rank(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotri_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dpotri_strided_batched_full_rank = rocsolver_dpotri_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_dpotri_strided_batched_rank_0(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotri_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dpotri_strided_batched_rank_0 = rocsolver_dpotri_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_dpotri_strided_batched_rank_1(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dpotri_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dpotri_strided_batched_rank_1 = rocsolver_dpotri_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_cpotri_strided_batched_full_rank(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotri_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cpotri_strided_batched_full_rank = rocsolver_cpotri_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_cpotri_strided_batched_rank_0(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotri_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cpotri_strided_batched_rank_0 = rocsolver_cpotri_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_cpotri_strided_batched_rank_1(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cpotri_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cpotri_strided_batched_rank_1 = rocsolver_cpotri_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_zpotri_strided_batched_full_rank(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotri_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zpotri_strided_batched_full_rank = rocsolver_zpotri_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_zpotri_strided_batched_rank_0(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotri_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zpotri_strided_batched_rank_0 = rocsolver_zpotri_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_zpotri_strided_batched_rank_1(handle,uplo,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zpotri_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zpotri_strided_batched_rank_1 = rocsolver_zpotri_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_sgesvd_full_rank(handle,left_svect,right_svect,m,n,A,lda,S,U,ldu,V,ldv,E,fast_alg,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvd_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: S
      real(c_float),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      real(c_float),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      real(c_float),target,dimension(:) :: E
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      !
      rocsolver_sgesvd_full_rank = rocsolver_sgesvd_(handle,left_svect,right_svect,m,n,c_loc(A),lda,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,c_loc(E),fast_alg,myInfo)
    end function

    function rocsolver_sgesvd_rank_0(handle,left_svect,right_svect,m,n,A,lda,S,U,ldu,V,ldv,E,fast_alg,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvd_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: S
      real(c_float),target :: U
      integer(c_int) :: ldu
      real(c_float),target :: V
      integer(c_int) :: ldv
      real(c_float),target :: E
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      !
      rocsolver_sgesvd_rank_0 = rocsolver_sgesvd_(handle,left_svect,right_svect,m,n,c_loc(A),lda,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,c_loc(E),fast_alg,myInfo)
    end function

    function rocsolver_sgesvd_rank_1(handle,left_svect,right_svect,m,n,A,lda,S,U,ldu,V,ldv,E,fast_alg,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvd_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: S
      real(c_float),target,dimension(:) :: U
      integer(c_int) :: ldu
      real(c_float),target,dimension(:) :: V
      integer(c_int) :: ldv
      real(c_float),target,dimension(:) :: E
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      !
      rocsolver_sgesvd_rank_1 = rocsolver_sgesvd_(handle,left_svect,right_svect,m,n,c_loc(A),lda,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,c_loc(E),fast_alg,myInfo)
    end function

    function rocsolver_dgesvd_full_rank(handle,left_svect,right_svect,m,n,A,lda,S,U,ldu,V,ldv,E,fast_alg,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvd_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: S
      real(c_double),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      real(c_double),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      real(c_double),target,dimension(:) :: E
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      !
      rocsolver_dgesvd_full_rank = rocsolver_dgesvd_(handle,left_svect,right_svect,m,n,c_loc(A),lda,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,c_loc(E),fast_alg,myInfo)
    end function

    function rocsolver_dgesvd_rank_0(handle,left_svect,right_svect,m,n,A,lda,S,U,ldu,V,ldv,E,fast_alg,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvd_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: S
      real(c_double),target :: U
      integer(c_int) :: ldu
      real(c_double),target :: V
      integer(c_int) :: ldv
      real(c_double),target :: E
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      !
      rocsolver_dgesvd_rank_0 = rocsolver_dgesvd_(handle,left_svect,right_svect,m,n,c_loc(A),lda,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,c_loc(E),fast_alg,myInfo)
    end function

    function rocsolver_dgesvd_rank_1(handle,left_svect,right_svect,m,n,A,lda,S,U,ldu,V,ldv,E,fast_alg,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvd_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: S
      real(c_double),target,dimension(:) :: U
      integer(c_int) :: ldu
      real(c_double),target,dimension(:) :: V
      integer(c_int) :: ldv
      real(c_double),target,dimension(:) :: E
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      !
      rocsolver_dgesvd_rank_1 = rocsolver_dgesvd_(handle,left_svect,right_svect,m,n,c_loc(A),lda,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,c_loc(E),fast_alg,myInfo)
    end function

    function rocsolver_cgesvd_full_rank(handle,left_svect,right_svect,m,n,A,lda,S,U,ldu,V,ldv,E,fast_alg,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvd_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: S
      complex(c_float_complex),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      complex(c_float_complex),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      real(c_float),target,dimension(:) :: E
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      !
      rocsolver_cgesvd_full_rank = rocsolver_cgesvd_(handle,left_svect,right_svect,m,n,c_loc(A),lda,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,c_loc(E),fast_alg,myInfo)
    end function

    function rocsolver_cgesvd_rank_0(handle,left_svect,right_svect,m,n,A,lda,S,U,ldu,V,ldv,E,fast_alg,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvd_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      real(c_float),target :: S
      complex(c_float_complex),target :: U
      integer(c_int) :: ldu
      complex(c_float_complex),target :: V
      integer(c_int) :: ldv
      real(c_float),target :: E
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      !
      rocsolver_cgesvd_rank_0 = rocsolver_cgesvd_(handle,left_svect,right_svect,m,n,c_loc(A),lda,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,c_loc(E),fast_alg,myInfo)
    end function

    function rocsolver_cgesvd_rank_1(handle,left_svect,right_svect,m,n,A,lda,S,U,ldu,V,ldv,E,fast_alg,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvd_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: S
      complex(c_float_complex),target,dimension(:) :: U
      integer(c_int) :: ldu
      complex(c_float_complex),target,dimension(:) :: V
      integer(c_int) :: ldv
      real(c_float),target,dimension(:) :: E
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      !
      rocsolver_cgesvd_rank_1 = rocsolver_cgesvd_(handle,left_svect,right_svect,m,n,c_loc(A),lda,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,c_loc(E),fast_alg,myInfo)
    end function

    function rocsolver_zgesvd_full_rank(handle,left_svect,right_svect,m,n,A,lda,S,U,ldu,V,ldv,E,fast_alg,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvd_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: S
      complex(c_double_complex),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      complex(c_double_complex),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      real(c_double),target,dimension(:) :: E
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      !
      rocsolver_zgesvd_full_rank = rocsolver_zgesvd_(handle,left_svect,right_svect,m,n,c_loc(A),lda,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,c_loc(E),fast_alg,myInfo)
    end function

    function rocsolver_zgesvd_rank_0(handle,left_svect,right_svect,m,n,A,lda,S,U,ldu,V,ldv,E,fast_alg,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvd_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      real(c_double),target :: S
      complex(c_double_complex),target :: U
      integer(c_int) :: ldu
      complex(c_double_complex),target :: V
      integer(c_int) :: ldv
      real(c_double),target :: E
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      !
      rocsolver_zgesvd_rank_0 = rocsolver_zgesvd_(handle,left_svect,right_svect,m,n,c_loc(A),lda,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,c_loc(E),fast_alg,myInfo)
    end function

    function rocsolver_zgesvd_rank_1(handle,left_svect,right_svect,m,n,A,lda,S,U,ldu,V,ldv,E,fast_alg,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvd_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: S
      complex(c_double_complex),target,dimension(:) :: U
      integer(c_int) :: ldu
      complex(c_double_complex),target,dimension(:) :: V
      integer(c_int) :: ldv
      real(c_double),target,dimension(:) :: E
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      !
      rocsolver_zgesvd_rank_1 = rocsolver_zgesvd_(handle,left_svect,right_svect,m,n,c_loc(A),lda,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,c_loc(E),fast_alg,myInfo)
    end function

    function rocsolver_sgesvd_batched_full_rank(handle,left_svect,right_svect,m,n,A,lda,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvd_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      real(c_float),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_float),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgesvd_batched_full_rank = rocsolver_sgesvd_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,c_loc(E),strideE,fast_alg,myInfo,batch_count)
    end function

    function rocsolver_sgesvd_batched_rank_0(handle,left_svect,right_svect,m,n,A,lda,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvd_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: S
      integer(c_int64_t) :: strideS
      real(c_float),target :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_float),target :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgesvd_batched_rank_0 = rocsolver_sgesvd_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,c_loc(E),strideE,fast_alg,myInfo,batch_count)
    end function

    function rocsolver_sgesvd_batched_rank_1(handle,left_svect,right_svect,m,n,A,lda,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvd_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      real(c_float),target,dimension(:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_float),target,dimension(:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgesvd_batched_rank_1 = rocsolver_sgesvd_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,c_loc(E),strideE,fast_alg,myInfo,batch_count)
    end function

    function rocsolver_dgesvd_batched_full_rank(handle,left_svect,right_svect,m,n,A,lda,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvd_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      real(c_double),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_double),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgesvd_batched_full_rank = rocsolver_dgesvd_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,c_loc(E),strideE,fast_alg,myInfo,batch_count)
    end function

    function rocsolver_dgesvd_batched_rank_0(handle,left_svect,right_svect,m,n,A,lda,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvd_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: S
      integer(c_int64_t) :: strideS
      real(c_double),target :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_double),target :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgesvd_batched_rank_0 = rocsolver_dgesvd_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,c_loc(E),strideE,fast_alg,myInfo,batch_count)
    end function

    function rocsolver_dgesvd_batched_rank_1(handle,left_svect,right_svect,m,n,A,lda,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvd_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      real(c_double),target,dimension(:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_double),target,dimension(:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgesvd_batched_rank_1 = rocsolver_dgesvd_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,c_loc(E),strideE,fast_alg,myInfo,batch_count)
    end function

    function rocsolver_cgesvd_batched_full_rank(handle,left_svect,right_svect,m,n,A,lda,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvd_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      complex(c_float_complex),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_float_complex),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgesvd_batched_full_rank = rocsolver_cgesvd_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,c_loc(E),strideE,fast_alg,myInfo,batch_count)
    end function

    function rocsolver_cgesvd_batched_rank_0(handle,left_svect,right_svect,m,n,A,lda,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvd_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      real(c_float),target :: S
      integer(c_int64_t) :: strideS
      complex(c_float_complex),target :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_float_complex),target :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgesvd_batched_rank_0 = rocsolver_cgesvd_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,c_loc(E),strideE,fast_alg,myInfo,batch_count)
    end function

    function rocsolver_cgesvd_batched_rank_1(handle,left_svect,right_svect,m,n,A,lda,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvd_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      complex(c_float_complex),target,dimension(:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_float_complex),target,dimension(:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgesvd_batched_rank_1 = rocsolver_cgesvd_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,c_loc(E),strideE,fast_alg,myInfo,batch_count)
    end function

    function rocsolver_zgesvd_batched_full_rank(handle,left_svect,right_svect,m,n,A,lda,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvd_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      complex(c_double_complex),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_double_complex),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgesvd_batched_full_rank = rocsolver_zgesvd_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,c_loc(E),strideE,fast_alg,myInfo,batch_count)
    end function

    function rocsolver_zgesvd_batched_rank_0(handle,left_svect,right_svect,m,n,A,lda,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvd_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      real(c_double),target :: S
      integer(c_int64_t) :: strideS
      complex(c_double_complex),target :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_double_complex),target :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgesvd_batched_rank_0 = rocsolver_zgesvd_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,c_loc(E),strideE,fast_alg,myInfo,batch_count)
    end function

    function rocsolver_zgesvd_batched_rank_1(handle,left_svect,right_svect,m,n,A,lda,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvd_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      complex(c_double_complex),target,dimension(:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_double_complex),target,dimension(:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgesvd_batched_rank_1 = rocsolver_zgesvd_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,c_loc(E),strideE,fast_alg,myInfo,batch_count)
    end function

    function rocsolver_sgesvd_strided_batched_full_rank(handle,left_svect,right_svect,m,n,A,lda,strideA,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvd_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      real(c_float),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_float),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgesvd_strided_batched_full_rank = rocsolver_sgesvd_strided_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,strideA,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,c_loc(E),strideE,fast_alg,myInfo,batch_count)
    end function

    function rocsolver_sgesvd_strided_batched_rank_0(handle,left_svect,right_svect,m,n,A,lda,strideA,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvd_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: S
      integer(c_int64_t) :: strideS
      real(c_float),target :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_float),target :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgesvd_strided_batched_rank_0 = rocsolver_sgesvd_strided_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,strideA,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,c_loc(E),strideE,fast_alg,myInfo,batch_count)
    end function

    function rocsolver_sgesvd_strided_batched_rank_1(handle,left_svect,right_svect,m,n,A,lda,strideA,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvd_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      real(c_float),target,dimension(:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_float),target,dimension(:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgesvd_strided_batched_rank_1 = rocsolver_sgesvd_strided_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,strideA,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,c_loc(E),strideE,fast_alg,myInfo,batch_count)
    end function

    function rocsolver_dgesvd_strided_batched_full_rank(handle,left_svect,right_svect,m,n,A,lda,strideA,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvd_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      real(c_double),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_double),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgesvd_strided_batched_full_rank = rocsolver_dgesvd_strided_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,strideA,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,c_loc(E),strideE,fast_alg,myInfo,batch_count)
    end function

    function rocsolver_dgesvd_strided_batched_rank_0(handle,left_svect,right_svect,m,n,A,lda,strideA,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvd_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: S
      integer(c_int64_t) :: strideS
      real(c_double),target :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_double),target :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgesvd_strided_batched_rank_0 = rocsolver_dgesvd_strided_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,strideA,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,c_loc(E),strideE,fast_alg,myInfo,batch_count)
    end function

    function rocsolver_dgesvd_strided_batched_rank_1(handle,left_svect,right_svect,m,n,A,lda,strideA,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvd_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      real(c_double),target,dimension(:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_double),target,dimension(:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgesvd_strided_batched_rank_1 = rocsolver_dgesvd_strided_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,strideA,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,c_loc(E),strideE,fast_alg,myInfo,batch_count)
    end function

    function rocsolver_cgesvd_strided_batched_full_rank(handle,left_svect,right_svect,m,n,A,lda,strideA,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvd_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      complex(c_float_complex),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_float_complex),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgesvd_strided_batched_full_rank = rocsolver_cgesvd_strided_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,strideA,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,c_loc(E),strideE,fast_alg,myInfo,batch_count)
    end function

    function rocsolver_cgesvd_strided_batched_rank_0(handle,left_svect,right_svect,m,n,A,lda,strideA,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvd_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: S
      integer(c_int64_t) :: strideS
      complex(c_float_complex),target :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_float_complex),target :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgesvd_strided_batched_rank_0 = rocsolver_cgesvd_strided_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,strideA,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,c_loc(E),strideE,fast_alg,myInfo,batch_count)
    end function

    function rocsolver_cgesvd_strided_batched_rank_1(handle,left_svect,right_svect,m,n,A,lda,strideA,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvd_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      complex(c_float_complex),target,dimension(:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_float_complex),target,dimension(:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgesvd_strided_batched_rank_1 = rocsolver_cgesvd_strided_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,strideA,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,c_loc(E),strideE,fast_alg,myInfo,batch_count)
    end function

    function rocsolver_zgesvd_strided_batched_full_rank(handle,left_svect,right_svect,m,n,A,lda,strideA,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvd_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      complex(c_double_complex),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_double_complex),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgesvd_strided_batched_full_rank = rocsolver_zgesvd_strided_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,strideA,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,c_loc(E),strideE,fast_alg,myInfo,batch_count)
    end function

    function rocsolver_zgesvd_strided_batched_rank_0(handle,left_svect,right_svect,m,n,A,lda,strideA,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvd_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: S
      integer(c_int64_t) :: strideS
      complex(c_double_complex),target :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_double_complex),target :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgesvd_strided_batched_rank_0 = rocsolver_zgesvd_strided_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,strideA,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,c_loc(E),strideE,fast_alg,myInfo,batch_count)
    end function

    function rocsolver_zgesvd_strided_batched_rank_1(handle,left_svect,right_svect,m,n,A,lda,strideA,S,strideS,U,ldu,strideU,V,ldv,strideV,E,strideE,fast_alg,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvd_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      complex(c_double_complex),target,dimension(:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_double_complex),target,dimension(:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      integer(kind(rocblas_outofplace)) :: fast_alg
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgesvd_strided_batched_rank_1 = rocsolver_zgesvd_strided_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,strideA,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,c_loc(E),strideE,fast_alg,myInfo,batch_count)
    end function

    function rocsolver_sgesvdj_full_rank(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,U,ldu,V,ldv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvdj_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_float),target,dimension(:) :: S
      real(c_float),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      real(c_float),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      type(c_ptr) :: myInfo
      !
      rocsolver_sgesvdj_full_rank = rocsolver_sgesvdj_(handle,left_svect,right_svect,m,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,myInfo)
    end function

    function rocsolver_sgesvdj_rank_0(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,U,ldu,V,ldv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvdj_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_float),target :: S
      real(c_float),target :: U
      integer(c_int) :: ldu
      real(c_float),target :: V
      integer(c_int) :: ldv
      type(c_ptr) :: myInfo
      !
      rocsolver_sgesvdj_rank_0 = rocsolver_sgesvdj_(handle,left_svect,right_svect,m,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,myInfo)
    end function

    function rocsolver_sgesvdj_rank_1(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,U,ldu,V,ldv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvdj_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_float),target,dimension(:) :: S
      real(c_float),target,dimension(:) :: U
      integer(c_int) :: ldu
      real(c_float),target,dimension(:) :: V
      integer(c_int) :: ldv
      type(c_ptr) :: myInfo
      !
      rocsolver_sgesvdj_rank_1 = rocsolver_sgesvdj_(handle,left_svect,right_svect,m,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,myInfo)
    end function

    function rocsolver_dgesvdj_full_rank(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,U,ldu,V,ldv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvdj_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_double),target,dimension(:) :: S
      real(c_double),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      real(c_double),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      type(c_ptr) :: myInfo
      !
      rocsolver_dgesvdj_full_rank = rocsolver_dgesvdj_(handle,left_svect,right_svect,m,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,myInfo)
    end function

    function rocsolver_dgesvdj_rank_0(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,U,ldu,V,ldv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvdj_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_double),target :: S
      real(c_double),target :: U
      integer(c_int) :: ldu
      real(c_double),target :: V
      integer(c_int) :: ldv
      type(c_ptr) :: myInfo
      !
      rocsolver_dgesvdj_rank_0 = rocsolver_dgesvdj_(handle,left_svect,right_svect,m,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,myInfo)
    end function

    function rocsolver_dgesvdj_rank_1(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,U,ldu,V,ldv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvdj_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_double),target,dimension(:) :: S
      real(c_double),target,dimension(:) :: U
      integer(c_int) :: ldu
      real(c_double),target,dimension(:) :: V
      integer(c_int) :: ldv
      type(c_ptr) :: myInfo
      !
      rocsolver_dgesvdj_rank_1 = rocsolver_dgesvdj_(handle,left_svect,right_svect,m,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,myInfo)
    end function

    function rocsolver_cgesvdj_full_rank(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,U,ldu,V,ldv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvdj_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_float),target,dimension(:) :: S
      complex(c_float_complex),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      complex(c_float_complex),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      type(c_ptr) :: myInfo
      !
      rocsolver_cgesvdj_full_rank = rocsolver_cgesvdj_(handle,left_svect,right_svect,m,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,myInfo)
    end function

    function rocsolver_cgesvdj_rank_0(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,U,ldu,V,ldv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvdj_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_float),target :: S
      complex(c_float_complex),target :: U
      integer(c_int) :: ldu
      complex(c_float_complex),target :: V
      integer(c_int) :: ldv
      type(c_ptr) :: myInfo
      !
      rocsolver_cgesvdj_rank_0 = rocsolver_cgesvdj_(handle,left_svect,right_svect,m,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,myInfo)
    end function

    function rocsolver_cgesvdj_rank_1(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,U,ldu,V,ldv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvdj_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_float),target,dimension(:) :: S
      complex(c_float_complex),target,dimension(:) :: U
      integer(c_int) :: ldu
      complex(c_float_complex),target,dimension(:) :: V
      integer(c_int) :: ldv
      type(c_ptr) :: myInfo
      !
      rocsolver_cgesvdj_rank_1 = rocsolver_cgesvdj_(handle,left_svect,right_svect,m,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,myInfo)
    end function

    function rocsolver_zgesvdj_full_rank(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,U,ldu,V,ldv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvdj_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_double),target,dimension(:) :: S
      complex(c_double_complex),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      complex(c_double_complex),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      type(c_ptr) :: myInfo
      !
      rocsolver_zgesvdj_full_rank = rocsolver_zgesvdj_(handle,left_svect,right_svect,m,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,myInfo)
    end function

    function rocsolver_zgesvdj_rank_0(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,U,ldu,V,ldv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvdj_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_double),target :: S
      complex(c_double_complex),target :: U
      integer(c_int) :: ldu
      complex(c_double_complex),target :: V
      integer(c_int) :: ldv
      type(c_ptr) :: myInfo
      !
      rocsolver_zgesvdj_rank_0 = rocsolver_zgesvdj_(handle,left_svect,right_svect,m,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,myInfo)
    end function

    function rocsolver_zgesvdj_rank_1(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,U,ldu,V,ldv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvdj_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_double),target,dimension(:) :: S
      complex(c_double_complex),target,dimension(:) :: U
      integer(c_int) :: ldu
      complex(c_double_complex),target,dimension(:) :: V
      integer(c_int) :: ldv
      type(c_ptr) :: myInfo
      !
      rocsolver_zgesvdj_rank_1 = rocsolver_zgesvdj_(handle,left_svect,right_svect,m,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,myInfo)
    end function

    function rocsolver_sgesvdj_batched_full_rank(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvdj_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_float),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      real(c_float),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_float),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgesvdj_batched_full_rank = rocsolver_sgesvdj_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,myInfo,batch_count)
    end function

    function rocsolver_sgesvdj_batched_rank_0(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvdj_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_float),target :: S
      integer(c_int64_t) :: strideS
      real(c_float),target :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_float),target :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgesvdj_batched_rank_0 = rocsolver_sgesvdj_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,myInfo,batch_count)
    end function

    function rocsolver_sgesvdj_batched_rank_1(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvdj_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_float),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      real(c_float),target,dimension(:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_float),target,dimension(:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgesvdj_batched_rank_1 = rocsolver_sgesvdj_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,myInfo,batch_count)
    end function

    function rocsolver_dgesvdj_batched_full_rank(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvdj_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_double),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      real(c_double),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_double),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgesvdj_batched_full_rank = rocsolver_dgesvdj_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,myInfo,batch_count)
    end function

    function rocsolver_dgesvdj_batched_rank_0(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvdj_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_double),target :: S
      integer(c_int64_t) :: strideS
      real(c_double),target :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_double),target :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgesvdj_batched_rank_0 = rocsolver_dgesvdj_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,myInfo,batch_count)
    end function

    function rocsolver_dgesvdj_batched_rank_1(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvdj_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_double),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      real(c_double),target,dimension(:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_double),target,dimension(:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgesvdj_batched_rank_1 = rocsolver_dgesvdj_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,myInfo,batch_count)
    end function

    function rocsolver_cgesvdj_batched_full_rank(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvdj_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_float),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      complex(c_float_complex),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_float_complex),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgesvdj_batched_full_rank = rocsolver_cgesvdj_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,myInfo,batch_count)
    end function

    function rocsolver_cgesvdj_batched_rank_0(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvdj_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_float),target :: S
      integer(c_int64_t) :: strideS
      complex(c_float_complex),target :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_float_complex),target :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgesvdj_batched_rank_0 = rocsolver_cgesvdj_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,myInfo,batch_count)
    end function

    function rocsolver_cgesvdj_batched_rank_1(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvdj_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_float),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      complex(c_float_complex),target,dimension(:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_float_complex),target,dimension(:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgesvdj_batched_rank_1 = rocsolver_cgesvdj_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,myInfo,batch_count)
    end function

    function rocsolver_zgesvdj_batched_full_rank(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvdj_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_double),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      complex(c_double_complex),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_double_complex),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgesvdj_batched_full_rank = rocsolver_zgesvdj_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,myInfo,batch_count)
    end function

    function rocsolver_zgesvdj_batched_rank_0(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvdj_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_double),target :: S
      integer(c_int64_t) :: strideS
      complex(c_double_complex),target :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_double_complex),target :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgesvdj_batched_rank_0 = rocsolver_zgesvdj_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,myInfo,batch_count)
    end function

    function rocsolver_zgesvdj_batched_rank_1(handle,left_svect,right_svect,m,n,A,lda,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvdj_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_double),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      complex(c_double_complex),target,dimension(:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_double_complex),target,dimension(:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgesvdj_batched_rank_1 = rocsolver_zgesvdj_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,myInfo,batch_count)
    end function

    function rocsolver_sgesvdj_strided_batched_full_rank(handle,left_svect,right_svect,m,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvdj_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_float),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      real(c_float),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_float),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgesvdj_strided_batched_full_rank = rocsolver_sgesvdj_strided_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,strideA,abstol,residual,max_sweeps,n_sweeps,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,myInfo,batch_count)
    end function

    function rocsolver_sgesvdj_strided_batched_rank_0(handle,left_svect,right_svect,m,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvdj_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_float),target :: S
      integer(c_int64_t) :: strideS
      real(c_float),target :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_float),target :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgesvdj_strided_batched_rank_0 = rocsolver_sgesvdj_strided_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,strideA,abstol,residual,max_sweeps,n_sweeps,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,myInfo,batch_count)
    end function

    function rocsolver_sgesvdj_strided_batched_rank_1(handle,left_svect,right_svect,m,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvdj_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_float),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      real(c_float),target,dimension(:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_float),target,dimension(:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgesvdj_strided_batched_rank_1 = rocsolver_sgesvdj_strided_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,strideA,abstol,residual,max_sweeps,n_sweeps,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,myInfo,batch_count)
    end function

    function rocsolver_dgesvdj_strided_batched_full_rank(handle,left_svect,right_svect,m,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvdj_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_double),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      real(c_double),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_double),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgesvdj_strided_batched_full_rank = rocsolver_dgesvdj_strided_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,strideA,abstol,residual,max_sweeps,n_sweeps,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,myInfo,batch_count)
    end function

    function rocsolver_dgesvdj_strided_batched_rank_0(handle,left_svect,right_svect,m,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvdj_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_double),target :: S
      integer(c_int64_t) :: strideS
      real(c_double),target :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_double),target :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgesvdj_strided_batched_rank_0 = rocsolver_dgesvdj_strided_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,strideA,abstol,residual,max_sweeps,n_sweeps,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,myInfo,batch_count)
    end function

    function rocsolver_dgesvdj_strided_batched_rank_1(handle,left_svect,right_svect,m,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvdj_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_double),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      real(c_double),target,dimension(:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_double),target,dimension(:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgesvdj_strided_batched_rank_1 = rocsolver_dgesvdj_strided_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,strideA,abstol,residual,max_sweeps,n_sweeps,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,myInfo,batch_count)
    end function

    function rocsolver_cgesvdj_strided_batched_full_rank(handle,left_svect,right_svect,m,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvdj_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_float),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      complex(c_float_complex),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_float_complex),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgesvdj_strided_batched_full_rank = rocsolver_cgesvdj_strided_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,strideA,abstol,residual,max_sweeps,n_sweeps,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,myInfo,batch_count)
    end function

    function rocsolver_cgesvdj_strided_batched_rank_0(handle,left_svect,right_svect,m,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvdj_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_float),target :: S
      integer(c_int64_t) :: strideS
      complex(c_float_complex),target :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_float_complex),target :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgesvdj_strided_batched_rank_0 = rocsolver_cgesvdj_strided_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,strideA,abstol,residual,max_sweeps,n_sweeps,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,myInfo,batch_count)
    end function

    function rocsolver_cgesvdj_strided_batched_rank_1(handle,left_svect,right_svect,m,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvdj_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_float),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      complex(c_float_complex),target,dimension(:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_float_complex),target,dimension(:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgesvdj_strided_batched_rank_1 = rocsolver_cgesvdj_strided_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,strideA,abstol,residual,max_sweeps,n_sweeps,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,myInfo,batch_count)
    end function

    function rocsolver_zgesvdj_strided_batched_full_rank(handle,left_svect,right_svect,m,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvdj_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_double),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      complex(c_double_complex),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_double_complex),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgesvdj_strided_batched_full_rank = rocsolver_zgesvdj_strided_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,strideA,abstol,residual,max_sweeps,n_sweeps,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,myInfo,batch_count)
    end function

    function rocsolver_zgesvdj_strided_batched_rank_0(handle,left_svect,right_svect,m,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvdj_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_double),target :: S
      integer(c_int64_t) :: strideS
      complex(c_double_complex),target :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_double_complex),target :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgesvdj_strided_batched_rank_0 = rocsolver_zgesvdj_strided_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,strideA,abstol,residual,max_sweeps,n_sweeps,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,myInfo,batch_count)
    end function

    function rocsolver_zgesvdj_strided_batched_rank_1(handle,left_svect,right_svect,m,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,S,strideS,U,ldu,strideU,V,ldv,strideV,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvdj_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      real(c_double),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      complex(c_double_complex),target,dimension(:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_double_complex),target,dimension(:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgesvdj_strided_batched_rank_1 = rocsolver_zgesvdj_strided_batched_(handle,left_svect,right_svect,m,n,c_loc(A),lda,strideA,abstol,residual,max_sweeps,n_sweeps,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,myInfo,batch_count)
    end function

    function rocsolver_sgesvdx_full_rank(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,U,ldu,V,ldv,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvdx_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_float),target,dimension(:) :: S
      real(c_float),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      real(c_float),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_sgesvdx_full_rank = rocsolver_sgesvdx_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,vl,vu,il,iu,nsv,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,ifail,myInfo)
    end function

    function rocsolver_sgesvdx_rank_0(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,U,ldu,V,ldv,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvdx_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_float),target :: S
      real(c_float),target :: U
      integer(c_int) :: ldu
      real(c_float),target :: V
      integer(c_int) :: ldv
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_sgesvdx_rank_0 = rocsolver_sgesvdx_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,vl,vu,il,iu,nsv,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,ifail,myInfo)
    end function

    function rocsolver_sgesvdx_rank_1(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,U,ldu,V,ldv,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvdx_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_float),target,dimension(:) :: S
      real(c_float),target,dimension(:) :: U
      integer(c_int) :: ldu
      real(c_float),target,dimension(:) :: V
      integer(c_int) :: ldv
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_sgesvdx_rank_1 = rocsolver_sgesvdx_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,vl,vu,il,iu,nsv,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,ifail,myInfo)
    end function

    function rocsolver_dgesvdx_full_rank(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,U,ldu,V,ldv,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvdx_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_double),target,dimension(:) :: S
      real(c_double),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      real(c_double),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_dgesvdx_full_rank = rocsolver_dgesvdx_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,vl,vu,il,iu,nsv,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,ifail,myInfo)
    end function

    function rocsolver_dgesvdx_rank_0(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,U,ldu,V,ldv,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvdx_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_double),target :: S
      real(c_double),target :: U
      integer(c_int) :: ldu
      real(c_double),target :: V
      integer(c_int) :: ldv
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_dgesvdx_rank_0 = rocsolver_dgesvdx_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,vl,vu,il,iu,nsv,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,ifail,myInfo)
    end function

    function rocsolver_dgesvdx_rank_1(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,U,ldu,V,ldv,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvdx_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_double),target,dimension(:) :: S
      real(c_double),target,dimension(:) :: U
      integer(c_int) :: ldu
      real(c_double),target,dimension(:) :: V
      integer(c_int) :: ldv
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_dgesvdx_rank_1 = rocsolver_dgesvdx_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,vl,vu,il,iu,nsv,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,ifail,myInfo)
    end function

    function rocsolver_cgesvdx_full_rank(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,U,ldu,V,ldv,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvdx_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_float),target,dimension(:) :: S
      complex(c_float_complex),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      complex(c_float_complex),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_cgesvdx_full_rank = rocsolver_cgesvdx_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,vl,vu,il,iu,nsv,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,ifail,myInfo)
    end function

    function rocsolver_cgesvdx_rank_0(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,U,ldu,V,ldv,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvdx_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_float),target :: S
      complex(c_float_complex),target :: U
      integer(c_int) :: ldu
      complex(c_float_complex),target :: V
      integer(c_int) :: ldv
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_cgesvdx_rank_0 = rocsolver_cgesvdx_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,vl,vu,il,iu,nsv,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,ifail,myInfo)
    end function

    function rocsolver_cgesvdx_rank_1(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,U,ldu,V,ldv,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvdx_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_float),target,dimension(:) :: S
      complex(c_float_complex),target,dimension(:) :: U
      integer(c_int) :: ldu
      complex(c_float_complex),target,dimension(:) :: V
      integer(c_int) :: ldv
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_cgesvdx_rank_1 = rocsolver_cgesvdx_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,vl,vu,il,iu,nsv,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,ifail,myInfo)
    end function

    function rocsolver_zgesvdx_full_rank(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,U,ldu,V,ldv,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvdx_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_double),target,dimension(:) :: S
      complex(c_double_complex),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      complex(c_double_complex),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_zgesvdx_full_rank = rocsolver_zgesvdx_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,vl,vu,il,iu,nsv,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,ifail,myInfo)
    end function

    function rocsolver_zgesvdx_rank_0(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,U,ldu,V,ldv,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvdx_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_double),target :: S
      complex(c_double_complex),target :: U
      integer(c_int) :: ldu
      complex(c_double_complex),target :: V
      integer(c_int) :: ldv
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_zgesvdx_rank_0 = rocsolver_zgesvdx_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,vl,vu,il,iu,nsv,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,ifail,myInfo)
    end function

    function rocsolver_zgesvdx_rank_1(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,U,ldu,V,ldv,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvdx_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_double),target,dimension(:) :: S
      complex(c_double_complex),target,dimension(:) :: U
      integer(c_int) :: ldu
      complex(c_double_complex),target,dimension(:) :: V
      integer(c_int) :: ldv
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_zgesvdx_rank_1 = rocsolver_zgesvdx_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,vl,vu,il,iu,nsv,c_loc(S),c_loc(U),ldu,c_loc(V),ldv,ifail,myInfo)
    end function

    function rocsolver_sgesvdx_batched_full_rank(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvdx_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_float),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      real(c_float),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_float),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgesvdx_batched_full_rank = rocsolver_sgesvdx_batched_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,vl,vu,il,iu,nsv,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_sgesvdx_batched_rank_0(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvdx_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_float),target :: S
      integer(c_int64_t) :: strideS
      real(c_float),target :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_float),target :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgesvdx_batched_rank_0 = rocsolver_sgesvdx_batched_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,vl,vu,il,iu,nsv,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_sgesvdx_batched_rank_1(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvdx_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_float),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      real(c_float),target,dimension(:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_float),target,dimension(:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgesvdx_batched_rank_1 = rocsolver_sgesvdx_batched_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,vl,vu,il,iu,nsv,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_dgesvdx_batched_full_rank(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvdx_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_double),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      real(c_double),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_double),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgesvdx_batched_full_rank = rocsolver_dgesvdx_batched_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,vl,vu,il,iu,nsv,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_dgesvdx_batched_rank_0(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvdx_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_double),target :: S
      integer(c_int64_t) :: strideS
      real(c_double),target :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_double),target :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgesvdx_batched_rank_0 = rocsolver_dgesvdx_batched_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,vl,vu,il,iu,nsv,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_dgesvdx_batched_rank_1(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvdx_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_double),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      real(c_double),target,dimension(:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_double),target,dimension(:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgesvdx_batched_rank_1 = rocsolver_dgesvdx_batched_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,vl,vu,il,iu,nsv,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_cgesvdx_batched_full_rank(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvdx_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_float),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      complex(c_float_complex),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_float_complex),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgesvdx_batched_full_rank = rocsolver_cgesvdx_batched_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,vl,vu,il,iu,nsv,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_cgesvdx_batched_rank_0(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvdx_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_float),target :: S
      integer(c_int64_t) :: strideS
      complex(c_float_complex),target :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_float_complex),target :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgesvdx_batched_rank_0 = rocsolver_cgesvdx_batched_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,vl,vu,il,iu,nsv,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_cgesvdx_batched_rank_1(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvdx_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_float),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      complex(c_float_complex),target,dimension(:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_float_complex),target,dimension(:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgesvdx_batched_rank_1 = rocsolver_cgesvdx_batched_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,vl,vu,il,iu,nsv,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_zgesvdx_batched_full_rank(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvdx_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_double),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      complex(c_double_complex),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_double_complex),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgesvdx_batched_full_rank = rocsolver_zgesvdx_batched_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,vl,vu,il,iu,nsv,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_zgesvdx_batched_rank_0(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvdx_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_double),target :: S
      integer(c_int64_t) :: strideS
      complex(c_double_complex),target :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_double_complex),target :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgesvdx_batched_rank_0 = rocsolver_zgesvdx_batched_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,vl,vu,il,iu,nsv,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_zgesvdx_batched_rank_1(handle,left_svect,right_svect,srange,m,n,A,lda,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvdx_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_double),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      complex(c_double_complex),target,dimension(:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_double_complex),target,dimension(:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgesvdx_batched_rank_1 = rocsolver_zgesvdx_batched_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,vl,vu,il,iu,nsv,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_sgesvdx_strided_batched_full_rank(handle,left_svect,right_svect,srange,m,n,A,lda,strideA,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvdx_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_float),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      real(c_float),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_float),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgesvdx_strided_batched_full_rank = rocsolver_sgesvdx_strided_batched_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,strideA,vl,vu,il,iu,nsv,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_sgesvdx_strided_batched_rank_0(handle,left_svect,right_svect,srange,m,n,A,lda,strideA,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvdx_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_float),target :: S
      integer(c_int64_t) :: strideS
      real(c_float),target :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_float),target :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgesvdx_strided_batched_rank_0 = rocsolver_sgesvdx_strided_batched_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,strideA,vl,vu,il,iu,nsv,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_sgesvdx_strided_batched_rank_1(handle,left_svect,right_svect,srange,m,n,A,lda,strideA,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgesvdx_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_float),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      real(c_float),target,dimension(:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_float),target,dimension(:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgesvdx_strided_batched_rank_1 = rocsolver_sgesvdx_strided_batched_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,strideA,vl,vu,il,iu,nsv,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_dgesvdx_strided_batched_full_rank(handle,left_svect,right_svect,srange,m,n,A,lda,strideA,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvdx_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_double),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      real(c_double),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_double),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgesvdx_strided_batched_full_rank = rocsolver_dgesvdx_strided_batched_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,strideA,vl,vu,il,iu,nsv,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_dgesvdx_strided_batched_rank_0(handle,left_svect,right_svect,srange,m,n,A,lda,strideA,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvdx_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_double),target :: S
      integer(c_int64_t) :: strideS
      real(c_double),target :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_double),target :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgesvdx_strided_batched_rank_0 = rocsolver_dgesvdx_strided_batched_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,strideA,vl,vu,il,iu,nsv,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_dgesvdx_strided_batched_rank_1(handle,left_svect,right_svect,srange,m,n,A,lda,strideA,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgesvdx_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_double),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      real(c_double),target,dimension(:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      real(c_double),target,dimension(:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgesvdx_strided_batched_rank_1 = rocsolver_dgesvdx_strided_batched_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,strideA,vl,vu,il,iu,nsv,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_cgesvdx_strided_batched_full_rank(handle,left_svect,right_svect,srange,m,n,A,lda,strideA,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvdx_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_float),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      complex(c_float_complex),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_float_complex),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgesvdx_strided_batched_full_rank = rocsolver_cgesvdx_strided_batched_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,strideA,vl,vu,il,iu,nsv,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_cgesvdx_strided_batched_rank_0(handle,left_svect,right_svect,srange,m,n,A,lda,strideA,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvdx_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_float),target :: S
      integer(c_int64_t) :: strideS
      complex(c_float_complex),target :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_float_complex),target :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgesvdx_strided_batched_rank_0 = rocsolver_cgesvdx_strided_batched_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,strideA,vl,vu,il,iu,nsv,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_cgesvdx_strided_batched_rank_1(handle,left_svect,right_svect,srange,m,n,A,lda,strideA,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgesvdx_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_float),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      complex(c_float_complex),target,dimension(:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_float_complex),target,dimension(:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgesvdx_strided_batched_rank_1 = rocsolver_cgesvdx_strided_batched_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,strideA,vl,vu,il,iu,nsv,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_zgesvdx_strided_batched_full_rank(handle,left_svect,right_svect,srange,m,n,A,lda,strideA,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvdx_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_double),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      complex(c_double_complex),target,dimension(:,:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_double_complex),target,dimension(:,:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgesvdx_strided_batched_full_rank = rocsolver_zgesvdx_strided_batched_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,strideA,vl,vu,il,iu,nsv,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_zgesvdx_strided_batched_rank_0(handle,left_svect,right_svect,srange,m,n,A,lda,strideA,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvdx_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_double),target :: S
      integer(c_int64_t) :: strideS
      complex(c_double_complex),target :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_double_complex),target :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgesvdx_strided_batched_rank_0 = rocsolver_zgesvdx_strided_batched_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,strideA,vl,vu,il,iu,nsv,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_zgesvdx_strided_batched_rank_1(handle,left_svect,right_svect,srange,m,n,A,lda,strideA,vl,vu,il,iu,nsv,S,strideS,U,ldu,strideU,V,ldv,strideV,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgesvdx_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_svect_all)) :: left_svect
      integer(kind(rocblas_svect_all)) :: right_svect
      integer(kind(rocblas_srange_all)) :: srange
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      type(c_ptr) :: nsv
      real(c_double),target,dimension(:) :: S
      integer(c_int64_t) :: strideS
      complex(c_double_complex),target,dimension(:) :: U
      integer(c_int) :: ldu
      integer(c_int64_t) :: strideU
      complex(c_double_complex),target,dimension(:) :: V
      integer(c_int) :: ldv
      integer(c_int64_t) :: strideV
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgesvdx_strided_batched_rank_1 = rocsolver_zgesvdx_strided_batched_(handle,left_svect,right_svect,srange,m,n,c_loc(A),lda,strideA,vl,vu,il,iu,nsv,c_loc(S),strideS,c_loc(U),ldu,strideU,c_loc(V),ldv,strideV,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_ssytd2_full_rank(handle,uplo,n,A,lda,D,E,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytd2_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      real(c_float) :: tau
      !
      rocsolver_ssytd2_full_rank = rocsolver_ssytd2_(handle,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),tau)
    end function

    function rocsolver_ssytd2_rank_0(handle,uplo,n,A,lda,D,E,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytd2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: D
      real(c_float),target :: E
      real(c_float) :: tau
      !
      rocsolver_ssytd2_rank_0 = rocsolver_ssytd2_(handle,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),tau)
    end function

    function rocsolver_ssytd2_rank_1(handle,uplo,n,A,lda,D,E,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytd2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      real(c_float) :: tau
      !
      rocsolver_ssytd2_rank_1 = rocsolver_ssytd2_(handle,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),tau)
    end function

    function rocsolver_dsytd2_full_rank(handle,uplo,n,A,lda,D,E,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytd2_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      real(c_double) :: tau
      !
      rocsolver_dsytd2_full_rank = rocsolver_dsytd2_(handle,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),tau)
    end function

    function rocsolver_dsytd2_rank_0(handle,uplo,n,A,lda,D,E,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytd2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: D
      real(c_double),target :: E
      real(c_double) :: tau
      !
      rocsolver_dsytd2_rank_0 = rocsolver_dsytd2_(handle,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),tau)
    end function

    function rocsolver_dsytd2_rank_1(handle,uplo,n,A,lda,D,E,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytd2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      real(c_double) :: tau
      !
      rocsolver_dsytd2_rank_1 = rocsolver_dsytd2_(handle,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),tau)
    end function

    function rocsolver_chetd2_full_rank(handle,uplo,n,A,lda,D,E,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chetd2_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      complex(c_float_complex) :: tau
      !
      rocsolver_chetd2_full_rank = rocsolver_chetd2_(handle,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),tau)
    end function

    function rocsolver_chetd2_rank_0(handle,uplo,n,A,lda,D,E,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chetd2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      real(c_float),target :: D
      real(c_float),target :: E
      complex(c_float_complex) :: tau
      !
      rocsolver_chetd2_rank_0 = rocsolver_chetd2_(handle,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),tau)
    end function

    function rocsolver_chetd2_rank_1(handle,uplo,n,A,lda,D,E,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chetd2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      complex(c_float_complex) :: tau
      !
      rocsolver_chetd2_rank_1 = rocsolver_chetd2_(handle,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),tau)
    end function

    function rocsolver_zhetd2_full_rank(handle,uplo,n,A,lda,D,E,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhetd2_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      complex(c_double_complex) :: tau
      !
      rocsolver_zhetd2_full_rank = rocsolver_zhetd2_(handle,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),tau)
    end function

    function rocsolver_zhetd2_rank_0(handle,uplo,n,A,lda,D,E,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhetd2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      real(c_double),target :: D
      real(c_double),target :: E
      complex(c_double_complex) :: tau
      !
      rocsolver_zhetd2_rank_0 = rocsolver_zhetd2_(handle,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),tau)
    end function

    function rocsolver_zhetd2_rank_1(handle,uplo,n,A,lda,D,E,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhetd2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      complex(c_double_complex) :: tau
      !
      rocsolver_zhetd2_rank_1 = rocsolver_zhetd2_(handle,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),tau)
    end function

    function rocsolver_ssytd2_batched_full_rank(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytd2_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_float) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_ssytd2_batched_full_rank = rocsolver_ssytd2_batched_(handle,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_ssytd2_batched_rank_0(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytd2_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      real(c_float) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_ssytd2_batched_rank_0 = rocsolver_ssytd2_batched_(handle,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_ssytd2_batched_rank_1(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytd2_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_float) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_ssytd2_batched_rank_1 = rocsolver_ssytd2_batched_(handle,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_dsytd2_batched_full_rank(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytd2_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_double) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dsytd2_batched_full_rank = rocsolver_dsytd2_batched_(handle,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_dsytd2_batched_rank_0(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytd2_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      real(c_double) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dsytd2_batched_rank_0 = rocsolver_dsytd2_batched_(handle,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_dsytd2_batched_rank_1(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytd2_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_double) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dsytd2_batched_rank_1 = rocsolver_dsytd2_batched_(handle,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_chetd2_batched_full_rank(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chetd2_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_float_complex) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_chetd2_batched_full_rank = rocsolver_chetd2_batched_(handle,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_chetd2_batched_rank_0(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chetd2_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      complex(c_float_complex) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_chetd2_batched_rank_0 = rocsolver_chetd2_batched_(handle,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_chetd2_batched_rank_1(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chetd2_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_float_complex) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_chetd2_batched_rank_1 = rocsolver_chetd2_batched_(handle,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_zhetd2_batched_full_rank(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhetd2_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_double_complex) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zhetd2_batched_full_rank = rocsolver_zhetd2_batched_(handle,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_zhetd2_batched_rank_0(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhetd2_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      complex(c_double_complex) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zhetd2_batched_rank_0 = rocsolver_zhetd2_batched_(handle,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_zhetd2_batched_rank_1(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhetd2_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_double_complex) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zhetd2_batched_rank_1 = rocsolver_zhetd2_batched_(handle,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_ssytd2_strided_batched_full_rank(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytd2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_float) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_ssytd2_strided_batched_full_rank = rocsolver_ssytd2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_ssytd2_strided_batched_rank_0(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytd2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      real(c_float) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_ssytd2_strided_batched_rank_0 = rocsolver_ssytd2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_ssytd2_strided_batched_rank_1(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytd2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_float) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_ssytd2_strided_batched_rank_1 = rocsolver_ssytd2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_dsytd2_strided_batched_full_rank(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytd2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_double) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dsytd2_strided_batched_full_rank = rocsolver_dsytd2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_dsytd2_strided_batched_rank_0(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytd2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      real(c_double) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dsytd2_strided_batched_rank_0 = rocsolver_dsytd2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_dsytd2_strided_batched_rank_1(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytd2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_double) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dsytd2_strided_batched_rank_1 = rocsolver_dsytd2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_chetd2_strided_batched_full_rank(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chetd2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_float_complex) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_chetd2_strided_batched_full_rank = rocsolver_chetd2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_chetd2_strided_batched_rank_0(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chetd2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      complex(c_float_complex) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_chetd2_strided_batched_rank_0 = rocsolver_chetd2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_chetd2_strided_batched_rank_1(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chetd2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_float_complex) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_chetd2_strided_batched_rank_1 = rocsolver_chetd2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_zhetd2_strided_batched_full_rank(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhetd2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_double_complex) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zhetd2_strided_batched_full_rank = rocsolver_zhetd2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_zhetd2_strided_batched_rank_0(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhetd2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      complex(c_double_complex) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zhetd2_strided_batched_rank_0 = rocsolver_zhetd2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_zhetd2_strided_batched_rank_1(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhetd2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_double_complex) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zhetd2_strided_batched_rank_1 = rocsolver_zhetd2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_ssytrd_full_rank(handle,uplo,n,A,lda,D,E,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytrd_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      real(c_float) :: tau
      !
      rocsolver_ssytrd_full_rank = rocsolver_ssytrd_(handle,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),tau)
    end function

    function rocsolver_ssytrd_rank_0(handle,uplo,n,A,lda,D,E,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytrd_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: D
      real(c_float),target :: E
      real(c_float) :: tau
      !
      rocsolver_ssytrd_rank_0 = rocsolver_ssytrd_(handle,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),tau)
    end function

    function rocsolver_ssytrd_rank_1(handle,uplo,n,A,lda,D,E,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytrd_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      real(c_float) :: tau
      !
      rocsolver_ssytrd_rank_1 = rocsolver_ssytrd_(handle,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),tau)
    end function

    function rocsolver_dsytrd_full_rank(handle,uplo,n,A,lda,D,E,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytrd_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      real(c_double) :: tau
      !
      rocsolver_dsytrd_full_rank = rocsolver_dsytrd_(handle,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),tau)
    end function

    function rocsolver_dsytrd_rank_0(handle,uplo,n,A,lda,D,E,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytrd_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: D
      real(c_double),target :: E
      real(c_double) :: tau
      !
      rocsolver_dsytrd_rank_0 = rocsolver_dsytrd_(handle,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),tau)
    end function

    function rocsolver_dsytrd_rank_1(handle,uplo,n,A,lda,D,E,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytrd_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      real(c_double) :: tau
      !
      rocsolver_dsytrd_rank_1 = rocsolver_dsytrd_(handle,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),tau)
    end function

    function rocsolver_chetrd_full_rank(handle,uplo,n,A,lda,D,E,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chetrd_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      complex(c_float_complex) :: tau
      !
      rocsolver_chetrd_full_rank = rocsolver_chetrd_(handle,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),tau)
    end function

    function rocsolver_chetrd_rank_0(handle,uplo,n,A,lda,D,E,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chetrd_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      real(c_float),target :: D
      real(c_float),target :: E
      complex(c_float_complex) :: tau
      !
      rocsolver_chetrd_rank_0 = rocsolver_chetrd_(handle,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),tau)
    end function

    function rocsolver_chetrd_rank_1(handle,uplo,n,A,lda,D,E,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chetrd_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      complex(c_float_complex) :: tau
      !
      rocsolver_chetrd_rank_1 = rocsolver_chetrd_(handle,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),tau)
    end function

    function rocsolver_zhetrd_full_rank(handle,uplo,n,A,lda,D,E,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhetrd_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      complex(c_double_complex) :: tau
      !
      rocsolver_zhetrd_full_rank = rocsolver_zhetrd_(handle,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),tau)
    end function

    function rocsolver_zhetrd_rank_0(handle,uplo,n,A,lda,D,E,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhetrd_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      real(c_double),target :: D
      real(c_double),target :: E
      complex(c_double_complex) :: tau
      !
      rocsolver_zhetrd_rank_0 = rocsolver_zhetrd_(handle,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),tau)
    end function

    function rocsolver_zhetrd_rank_1(handle,uplo,n,A,lda,D,E,tau)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhetrd_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      complex(c_double_complex) :: tau
      !
      rocsolver_zhetrd_rank_1 = rocsolver_zhetrd_(handle,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),tau)
    end function

    function rocsolver_ssytrd_batched_full_rank(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytrd_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_float) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_ssytrd_batched_full_rank = rocsolver_ssytrd_batched_(handle,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_ssytrd_batched_rank_0(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytrd_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      real(c_float) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_ssytrd_batched_rank_0 = rocsolver_ssytrd_batched_(handle,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_ssytrd_batched_rank_1(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytrd_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_float) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_ssytrd_batched_rank_1 = rocsolver_ssytrd_batched_(handle,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_dsytrd_batched_full_rank(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytrd_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_double) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dsytrd_batched_full_rank = rocsolver_dsytrd_batched_(handle,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_dsytrd_batched_rank_0(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytrd_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      real(c_double) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dsytrd_batched_rank_0 = rocsolver_dsytrd_batched_(handle,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_dsytrd_batched_rank_1(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytrd_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_double) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dsytrd_batched_rank_1 = rocsolver_dsytrd_batched_(handle,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_chetrd_batched_full_rank(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chetrd_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_float_complex) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_chetrd_batched_full_rank = rocsolver_chetrd_batched_(handle,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_chetrd_batched_rank_0(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chetrd_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      complex(c_float_complex) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_chetrd_batched_rank_0 = rocsolver_chetrd_batched_(handle,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_chetrd_batched_rank_1(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chetrd_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_float_complex) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_chetrd_batched_rank_1 = rocsolver_chetrd_batched_(handle,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_zhetrd_batched_full_rank(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhetrd_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_double_complex) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zhetrd_batched_full_rank = rocsolver_zhetrd_batched_(handle,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_zhetrd_batched_rank_0(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhetrd_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      complex(c_double_complex) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zhetrd_batched_rank_0 = rocsolver_zhetrd_batched_(handle,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_zhetrd_batched_rank_1(handle,uplo,n,A,lda,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhetrd_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_double_complex) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zhetrd_batched_rank_1 = rocsolver_zhetrd_batched_(handle,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_ssytrd_strided_batched_full_rank(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytrd_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_float) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_ssytrd_strided_batched_full_rank = rocsolver_ssytrd_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_ssytrd_strided_batched_rank_0(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytrd_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      real(c_float) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_ssytrd_strided_batched_rank_0 = rocsolver_ssytrd_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_ssytrd_strided_batched_rank_1(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytrd_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_float) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_ssytrd_strided_batched_rank_1 = rocsolver_ssytrd_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_dsytrd_strided_batched_full_rank(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytrd_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_double) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dsytrd_strided_batched_full_rank = rocsolver_dsytrd_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_dsytrd_strided_batched_rank_0(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytrd_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      real(c_double) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dsytrd_strided_batched_rank_0 = rocsolver_dsytrd_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_dsytrd_strided_batched_rank_1(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytrd_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      real(c_double) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_dsytrd_strided_batched_rank_1 = rocsolver_dsytrd_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_chetrd_strided_batched_full_rank(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chetrd_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_float_complex) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_chetrd_strided_batched_full_rank = rocsolver_chetrd_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_chetrd_strided_batched_rank_0(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chetrd_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      complex(c_float_complex) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_chetrd_strided_batched_rank_0 = rocsolver_chetrd_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_chetrd_strided_batched_rank_1(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chetrd_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_float_complex) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_chetrd_strided_batched_rank_1 = rocsolver_chetrd_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_zhetrd_strided_batched_full_rank(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhetrd_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_double_complex) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zhetrd_strided_batched_full_rank = rocsolver_zhetrd_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_zhetrd_strided_batched_rank_0(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhetrd_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      complex(c_double_complex) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zhetrd_strided_batched_rank_0 = rocsolver_zhetrd_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_zhetrd_strided_batched_rank_1(handle,uplo,n,A,lda,strideA,D,strideD,E,strideE,tau,strideP,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhetrd_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      complex(c_double_complex) :: tau
      integer(c_int64_t) :: strideP
      integer(c_int) :: batch_count
      !
      rocsolver_zhetrd_strided_batched_rank_1 = rocsolver_zhetrd_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,tau,strideP,batch_count)
    end function

    function rocsolver_ssygs2_full_rank(handle,itype,uplo,n,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygs2_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_ssygs2_full_rank = rocsolver_ssygs2_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_ssygs2_rank_0(handle,itype,uplo,n,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygs2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      !
      rocsolver_ssygs2_rank_0 = rocsolver_ssygs2_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_ssygs2_rank_1(handle,itype,uplo,n,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygs2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_ssygs2_rank_1 = rocsolver_ssygs2_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_dsygs2_full_rank(handle,itype,uplo,n,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygs2_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_dsygs2_full_rank = rocsolver_dsygs2_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_dsygs2_rank_0(handle,itype,uplo,n,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygs2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      !
      rocsolver_dsygs2_rank_0 = rocsolver_dsygs2_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_dsygs2_rank_1(handle,itype,uplo,n,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygs2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_dsygs2_rank_1 = rocsolver_dsygs2_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_chegs2_full_rank(handle,itype,uplo,n,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegs2_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_chegs2_full_rank = rocsolver_chegs2_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_chegs2_rank_0(handle,itype,uplo,n,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegs2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      !
      rocsolver_chegs2_rank_0 = rocsolver_chegs2_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_chegs2_rank_1(handle,itype,uplo,n,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegs2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_chegs2_rank_1 = rocsolver_chegs2_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_zhegs2_full_rank(handle,itype,uplo,n,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegs2_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_zhegs2_full_rank = rocsolver_zhegs2_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_zhegs2_rank_0(handle,itype,uplo,n,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegs2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      !
      rocsolver_zhegs2_rank_0 = rocsolver_zhegs2_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_zhegs2_rank_1(handle,itype,uplo,n,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegs2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_zhegs2_rank_1 = rocsolver_zhegs2_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_ssygs2_batched_full_rank(handle,itype,uplo,n,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygs2_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_ssygs2_batched_full_rank = rocsolver_ssygs2_batched_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_ssygs2_batched_rank_0(handle,itype,uplo,n,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygs2_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_ssygs2_batched_rank_0 = rocsolver_ssygs2_batched_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_ssygs2_batched_rank_1(handle,itype,uplo,n,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygs2_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_ssygs2_batched_rank_1 = rocsolver_ssygs2_batched_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_dsygs2_batched_full_rank(handle,itype,uplo,n,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygs2_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_dsygs2_batched_full_rank = rocsolver_dsygs2_batched_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_dsygs2_batched_rank_0(handle,itype,uplo,n,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygs2_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_dsygs2_batched_rank_0 = rocsolver_dsygs2_batched_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_dsygs2_batched_rank_1(handle,itype,uplo,n,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygs2_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_dsygs2_batched_rank_1 = rocsolver_dsygs2_batched_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_chegs2_batched_full_rank(handle,itype,uplo,n,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegs2_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_chegs2_batched_full_rank = rocsolver_chegs2_batched_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_chegs2_batched_rank_0(handle,itype,uplo,n,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegs2_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_chegs2_batched_rank_0 = rocsolver_chegs2_batched_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_chegs2_batched_rank_1(handle,itype,uplo,n,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegs2_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_chegs2_batched_rank_1 = rocsolver_chegs2_batched_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_zhegs2_batched_full_rank(handle,itype,uplo,n,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegs2_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_zhegs2_batched_full_rank = rocsolver_zhegs2_batched_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_zhegs2_batched_rank_0(handle,itype,uplo,n,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegs2_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_zhegs2_batched_rank_0 = rocsolver_zhegs2_batched_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_zhegs2_batched_rank_1(handle,itype,uplo,n,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegs2_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_zhegs2_batched_rank_1 = rocsolver_zhegs2_batched_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_ssygs2_strided_batched_full_rank(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygs2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_ssygs2_strided_batched_full_rank = rocsolver_ssygs2_strided_batched_(handle,itype,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_ssygs2_strided_batched_rank_0(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygs2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_ssygs2_strided_batched_rank_0 = rocsolver_ssygs2_strided_batched_(handle,itype,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_ssygs2_strided_batched_rank_1(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygs2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_ssygs2_strided_batched_rank_1 = rocsolver_ssygs2_strided_batched_(handle,itype,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_dsygs2_strided_batched_full_rank(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygs2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_dsygs2_strided_batched_full_rank = rocsolver_dsygs2_strided_batched_(handle,itype,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_dsygs2_strided_batched_rank_0(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygs2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_dsygs2_strided_batched_rank_0 = rocsolver_dsygs2_strided_batched_(handle,itype,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_dsygs2_strided_batched_rank_1(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygs2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_dsygs2_strided_batched_rank_1 = rocsolver_dsygs2_strided_batched_(handle,itype,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_chegs2_strided_batched_full_rank(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegs2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_chegs2_strided_batched_full_rank = rocsolver_chegs2_strided_batched_(handle,itype,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_chegs2_strided_batched_rank_0(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegs2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_chegs2_strided_batched_rank_0 = rocsolver_chegs2_strided_batched_(handle,itype,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_chegs2_strided_batched_rank_1(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegs2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_chegs2_strided_batched_rank_1 = rocsolver_chegs2_strided_batched_(handle,itype,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_zhegs2_strided_batched_full_rank(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegs2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_zhegs2_strided_batched_full_rank = rocsolver_zhegs2_strided_batched_(handle,itype,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_zhegs2_strided_batched_rank_0(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegs2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_zhegs2_strided_batched_rank_0 = rocsolver_zhegs2_strided_batched_(handle,itype,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_zhegs2_strided_batched_rank_1(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegs2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_zhegs2_strided_batched_rank_1 = rocsolver_zhegs2_strided_batched_(handle,itype,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_ssygst_full_rank(handle,itype,uplo,n,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygst_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_ssygst_full_rank = rocsolver_ssygst_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_ssygst_rank_0(handle,itype,uplo,n,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygst_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      !
      rocsolver_ssygst_rank_0 = rocsolver_ssygst_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_ssygst_rank_1(handle,itype,uplo,n,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygst_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_ssygst_rank_1 = rocsolver_ssygst_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_dsygst_full_rank(handle,itype,uplo,n,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygst_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_dsygst_full_rank = rocsolver_dsygst_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_dsygst_rank_0(handle,itype,uplo,n,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygst_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      !
      rocsolver_dsygst_rank_0 = rocsolver_dsygst_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_dsygst_rank_1(handle,itype,uplo,n,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygst_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_dsygst_rank_1 = rocsolver_dsygst_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_chegst_full_rank(handle,itype,uplo,n,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegst_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_chegst_full_rank = rocsolver_chegst_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_chegst_rank_0(handle,itype,uplo,n,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegst_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      !
      rocsolver_chegst_rank_0 = rocsolver_chegst_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_chegst_rank_1(handle,itype,uplo,n,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegst_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_chegst_rank_1 = rocsolver_chegst_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_zhegst_full_rank(handle,itype,uplo,n,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegst_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_zhegst_full_rank = rocsolver_zhegst_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_zhegst_rank_0(handle,itype,uplo,n,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegst_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      !
      rocsolver_zhegst_rank_0 = rocsolver_zhegst_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_zhegst_rank_1(handle,itype,uplo,n,A,lda,B,ldb)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegst_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      !
      rocsolver_zhegst_rank_1 = rocsolver_zhegst_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb)
    end function

    function rocsolver_ssygst_batched_full_rank(handle,itype,uplo,n,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygst_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_ssygst_batched_full_rank = rocsolver_ssygst_batched_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_ssygst_batched_rank_0(handle,itype,uplo,n,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygst_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_ssygst_batched_rank_0 = rocsolver_ssygst_batched_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_ssygst_batched_rank_1(handle,itype,uplo,n,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygst_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_ssygst_batched_rank_1 = rocsolver_ssygst_batched_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_dsygst_batched_full_rank(handle,itype,uplo,n,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygst_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_dsygst_batched_full_rank = rocsolver_dsygst_batched_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_dsygst_batched_rank_0(handle,itype,uplo,n,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygst_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_dsygst_batched_rank_0 = rocsolver_dsygst_batched_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_dsygst_batched_rank_1(handle,itype,uplo,n,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygst_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_dsygst_batched_rank_1 = rocsolver_dsygst_batched_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_chegst_batched_full_rank(handle,itype,uplo,n,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegst_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_chegst_batched_full_rank = rocsolver_chegst_batched_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_chegst_batched_rank_0(handle,itype,uplo,n,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegst_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_chegst_batched_rank_0 = rocsolver_chegst_batched_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_chegst_batched_rank_1(handle,itype,uplo,n,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegst_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_chegst_batched_rank_1 = rocsolver_chegst_batched_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_zhegst_batched_full_rank(handle,itype,uplo,n,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegst_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_zhegst_batched_full_rank = rocsolver_zhegst_batched_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_zhegst_batched_rank_0(handle,itype,uplo,n,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegst_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_zhegst_batched_rank_0 = rocsolver_zhegst_batched_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_zhegst_batched_rank_1(handle,itype,uplo,n,A,lda,B,ldb,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegst_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int) :: batch_count
      !
      rocsolver_zhegst_batched_rank_1 = rocsolver_zhegst_batched_(handle,itype,uplo,n,c_loc(A),lda,c_loc(B),ldb,batch_count)
    end function

    function rocsolver_ssygst_strided_batched_full_rank(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygst_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_ssygst_strided_batched_full_rank = rocsolver_ssygst_strided_batched_(handle,itype,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_ssygst_strided_batched_rank_0(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygst_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_ssygst_strided_batched_rank_0 = rocsolver_ssygst_strided_batched_(handle,itype,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_ssygst_strided_batched_rank_1(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygst_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_ssygst_strided_batched_rank_1 = rocsolver_ssygst_strided_batched_(handle,itype,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_dsygst_strided_batched_full_rank(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygst_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_dsygst_strided_batched_full_rank = rocsolver_dsygst_strided_batched_(handle,itype,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_dsygst_strided_batched_rank_0(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygst_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_dsygst_strided_batched_rank_0 = rocsolver_dsygst_strided_batched_(handle,itype,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_dsygst_strided_batched_rank_1(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygst_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_dsygst_strided_batched_rank_1 = rocsolver_dsygst_strided_batched_(handle,itype,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_chegst_strided_batched_full_rank(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegst_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_chegst_strided_batched_full_rank = rocsolver_chegst_strided_batched_(handle,itype,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_chegst_strided_batched_rank_0(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegst_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_chegst_strided_batched_rank_0 = rocsolver_chegst_strided_batched_(handle,itype,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_chegst_strided_batched_rank_1(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegst_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_chegst_strided_batched_rank_1 = rocsolver_chegst_strided_batched_(handle,itype,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_zhegst_strided_batched_full_rank(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegst_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_zhegst_strided_batched_full_rank = rocsolver_zhegst_strided_batched_(handle,itype,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_zhegst_strided_batched_rank_0(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegst_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_zhegst_strided_batched_rank_0 = rocsolver_zhegst_strided_batched_(handle,itype,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_zhegst_strided_batched_rank_1(handle,itype,uplo,n,A,lda,strideA,B,ldb,strideB,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegst_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      integer(c_int) :: batch_count
      !
      rocsolver_zhegst_strided_batched_rank_1 = rocsolver_zhegst_strided_batched_(handle,itype,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,batch_count)
    end function

    function rocsolver_ssyev_full_rank(handle,evect,uplo,n,A,lda,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyev_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_ssyev_full_rank = rocsolver_ssyev_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_ssyev_rank_0(handle,evect,uplo,n,A,lda,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyev_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: D
      real(c_float),target :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_ssyev_rank_0 = rocsolver_ssyev_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_ssyev_rank_1(handle,evect,uplo,n,A,lda,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyev_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_ssyev_rank_1 = rocsolver_ssyev_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_dsyev_full_rank(handle,evect,uplo,n,A,lda,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyev_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_dsyev_full_rank = rocsolver_dsyev_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_dsyev_rank_0(handle,evect,uplo,n,A,lda,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyev_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: D
      real(c_double),target :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_dsyev_rank_0 = rocsolver_dsyev_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_dsyev_rank_1(handle,evect,uplo,n,A,lda,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyev_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_dsyev_rank_1 = rocsolver_dsyev_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_cheev_full_rank(handle,evect,uplo,n,A,lda,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheev_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_cheev_full_rank = rocsolver_cheev_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_cheev_rank_0(handle,evect,uplo,n,A,lda,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheev_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      real(c_float),target :: D
      real(c_float),target :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_cheev_rank_0 = rocsolver_cheev_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_cheev_rank_1(handle,evect,uplo,n,A,lda,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheev_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_cheev_rank_1 = rocsolver_cheev_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_zheev_full_rank(handle,evect,uplo,n,A,lda,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheev_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_zheev_full_rank = rocsolver_zheev_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_zheev_rank_0(handle,evect,uplo,n,A,lda,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheev_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      real(c_double),target :: D
      real(c_double),target :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_zheev_rank_0 = rocsolver_zheev_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_zheev_rank_1(handle,evect,uplo,n,A,lda,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheev_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_zheev_rank_1 = rocsolver_zheev_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_ssyev_batched_full_rank(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyev_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssyev_batched_full_rank = rocsolver_ssyev_batched_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_ssyev_batched_rank_0(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyev_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssyev_batched_rank_0 = rocsolver_ssyev_batched_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_ssyev_batched_rank_1(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyev_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssyev_batched_rank_1 = rocsolver_ssyev_batched_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_dsyev_batched_full_rank(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyev_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsyev_batched_full_rank = rocsolver_dsyev_batched_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_dsyev_batched_rank_0(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyev_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsyev_batched_rank_0 = rocsolver_dsyev_batched_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_dsyev_batched_rank_1(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyev_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsyev_batched_rank_1 = rocsolver_dsyev_batched_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_cheev_batched_full_rank(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheev_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cheev_batched_full_rank = rocsolver_cheev_batched_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_cheev_batched_rank_0(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheev_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cheev_batched_rank_0 = rocsolver_cheev_batched_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_cheev_batched_rank_1(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheev_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cheev_batched_rank_1 = rocsolver_cheev_batched_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_zheev_batched_full_rank(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheev_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zheev_batched_full_rank = rocsolver_zheev_batched_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_zheev_batched_rank_0(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheev_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zheev_batched_rank_0 = rocsolver_zheev_batched_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_zheev_batched_rank_1(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheev_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zheev_batched_rank_1 = rocsolver_zheev_batched_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_ssyev_strided_batched_full_rank(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyev_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssyev_strided_batched_full_rank = rocsolver_ssyev_strided_batched_(handle,evect,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_ssyev_strided_batched_rank_0(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyev_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssyev_strided_batched_rank_0 = rocsolver_ssyev_strided_batched_(handle,evect,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_ssyev_strided_batched_rank_1(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyev_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssyev_strided_batched_rank_1 = rocsolver_ssyev_strided_batched_(handle,evect,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_dsyev_strided_batched_full_rank(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyev_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsyev_strided_batched_full_rank = rocsolver_dsyev_strided_batched_(handle,evect,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_dsyev_strided_batched_rank_0(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyev_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsyev_strided_batched_rank_0 = rocsolver_dsyev_strided_batched_(handle,evect,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_dsyev_strided_batched_rank_1(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyev_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsyev_strided_batched_rank_1 = rocsolver_dsyev_strided_batched_(handle,evect,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_cheev_strided_batched_full_rank(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheev_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cheev_strided_batched_full_rank = rocsolver_cheev_strided_batched_(handle,evect,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_cheev_strided_batched_rank_0(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheev_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cheev_strided_batched_rank_0 = rocsolver_cheev_strided_batched_(handle,evect,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_cheev_strided_batched_rank_1(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheev_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cheev_strided_batched_rank_1 = rocsolver_cheev_strided_batched_(handle,evect,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_zheev_strided_batched_full_rank(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheev_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zheev_strided_batched_full_rank = rocsolver_zheev_strided_batched_(handle,evect,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_zheev_strided_batched_rank_0(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheev_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zheev_strided_batched_rank_0 = rocsolver_zheev_strided_batched_(handle,evect,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_zheev_strided_batched_rank_1(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheev_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zheev_strided_batched_rank_1 = rocsolver_zheev_strided_batched_(handle,evect,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_ssyevd_full_rank(handle,evect,uplo,n,A,lda,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevd_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_ssyevd_full_rank = rocsolver_ssyevd_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_ssyevd_rank_0(handle,evect,uplo,n,A,lda,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevd_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: D
      real(c_float),target :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_ssyevd_rank_0 = rocsolver_ssyevd_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_ssyevd_rank_1(handle,evect,uplo,n,A,lda,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevd_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_ssyevd_rank_1 = rocsolver_ssyevd_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_dsyevd_full_rank(handle,evect,uplo,n,A,lda,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevd_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_dsyevd_full_rank = rocsolver_dsyevd_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_dsyevd_rank_0(handle,evect,uplo,n,A,lda,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevd_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: D
      real(c_double),target :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_dsyevd_rank_0 = rocsolver_dsyevd_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_dsyevd_rank_1(handle,evect,uplo,n,A,lda,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevd_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_dsyevd_rank_1 = rocsolver_dsyevd_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_cheevd_full_rank(handle,evect,uplo,n,A,lda,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevd_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_cheevd_full_rank = rocsolver_cheevd_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_cheevd_rank_0(handle,evect,uplo,n,A,lda,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevd_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      real(c_float),target :: D
      real(c_float),target :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_cheevd_rank_0 = rocsolver_cheevd_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_cheevd_rank_1(handle,evect,uplo,n,A,lda,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevd_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_cheevd_rank_1 = rocsolver_cheevd_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_zheevd_full_rank(handle,evect,uplo,n,A,lda,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevd_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_zheevd_full_rank = rocsolver_zheevd_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_zheevd_rank_0(handle,evect,uplo,n,A,lda,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevd_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      real(c_double),target :: D
      real(c_double),target :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_zheevd_rank_0 = rocsolver_zheevd_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_zheevd_rank_1(handle,evect,uplo,n,A,lda,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevd_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_zheevd_rank_1 = rocsolver_zheevd_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_ssyevd_batched_full_rank(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevd_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssyevd_batched_full_rank = rocsolver_ssyevd_batched_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_ssyevd_batched_rank_0(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevd_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssyevd_batched_rank_0 = rocsolver_ssyevd_batched_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_ssyevd_batched_rank_1(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevd_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssyevd_batched_rank_1 = rocsolver_ssyevd_batched_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_dsyevd_batched_full_rank(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevd_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsyevd_batched_full_rank = rocsolver_dsyevd_batched_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_dsyevd_batched_rank_0(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevd_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsyevd_batched_rank_0 = rocsolver_dsyevd_batched_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_dsyevd_batched_rank_1(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevd_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsyevd_batched_rank_1 = rocsolver_dsyevd_batched_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_cheevd_batched_full_rank(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevd_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cheevd_batched_full_rank = rocsolver_cheevd_batched_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_cheevd_batched_rank_0(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevd_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cheevd_batched_rank_0 = rocsolver_cheevd_batched_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_cheevd_batched_rank_1(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevd_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cheevd_batched_rank_1 = rocsolver_cheevd_batched_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_zheevd_batched_full_rank(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevd_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zheevd_batched_full_rank = rocsolver_zheevd_batched_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_zheevd_batched_rank_0(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevd_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zheevd_batched_rank_0 = rocsolver_zheevd_batched_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_zheevd_batched_rank_1(handle,evect,uplo,n,A,lda,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevd_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zheevd_batched_rank_1 = rocsolver_zheevd_batched_(handle,evect,uplo,n,c_loc(A),lda,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_ssyevd_strided_batched_full_rank(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevd_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssyevd_strided_batched_full_rank = rocsolver_ssyevd_strided_batched_(handle,evect,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_ssyevd_strided_batched_rank_0(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevd_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssyevd_strided_batched_rank_0 = rocsolver_ssyevd_strided_batched_(handle,evect,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_ssyevd_strided_batched_rank_1(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevd_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssyevd_strided_batched_rank_1 = rocsolver_ssyevd_strided_batched_(handle,evect,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_dsyevd_strided_batched_full_rank(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevd_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsyevd_strided_batched_full_rank = rocsolver_dsyevd_strided_batched_(handle,evect,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_dsyevd_strided_batched_rank_0(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevd_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsyevd_strided_batched_rank_0 = rocsolver_dsyevd_strided_batched_(handle,evect,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_dsyevd_strided_batched_rank_1(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevd_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsyevd_strided_batched_rank_1 = rocsolver_dsyevd_strided_batched_(handle,evect,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_cheevd_strided_batched_full_rank(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevd_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cheevd_strided_batched_full_rank = rocsolver_cheevd_strided_batched_(handle,evect,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_cheevd_strided_batched_rank_0(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevd_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cheevd_strided_batched_rank_0 = rocsolver_cheevd_strided_batched_(handle,evect,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_cheevd_strided_batched_rank_1(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevd_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cheevd_strided_batched_rank_1 = rocsolver_cheevd_strided_batched_(handle,evect,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_zheevd_strided_batched_full_rank(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevd_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zheevd_strided_batched_full_rank = rocsolver_zheevd_strided_batched_(handle,evect,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_zheevd_strided_batched_rank_0(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevd_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zheevd_strided_batched_rank_0 = rocsolver_zheevd_strided_batched_(handle,evect,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_zheevd_strided_batched_rank_1(handle,evect,uplo,n,A,lda,strideA,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevd_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zheevd_strided_batched_rank_1 = rocsolver_zheevd_strided_batched_(handle,evect,uplo,n,c_loc(A),lda,strideA,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_ssyevj_full_rank(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevj_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      type(c_ptr) :: myInfo
      !
      rocsolver_ssyevj_full_rank = rocsolver_ssyevj_(handle,esort,evect,uplo,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
    end function

    function rocsolver_ssyevj_rank_0(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevj_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      type(c_ptr) :: myInfo
      !
      rocsolver_ssyevj_rank_0 = rocsolver_ssyevj_(handle,esort,evect,uplo,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
    end function

    function rocsolver_ssyevj_rank_1(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevj_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      type(c_ptr) :: myInfo
      !
      rocsolver_ssyevj_rank_1 = rocsolver_ssyevj_(handle,esort,evect,uplo,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
    end function

    function rocsolver_dsyevj_full_rank(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevj_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      type(c_ptr) :: myInfo
      !
      rocsolver_dsyevj_full_rank = rocsolver_dsyevj_(handle,esort,evect,uplo,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
    end function

    function rocsolver_dsyevj_rank_0(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevj_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      type(c_ptr) :: myInfo
      !
      rocsolver_dsyevj_rank_0 = rocsolver_dsyevj_(handle,esort,evect,uplo,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
    end function

    function rocsolver_dsyevj_rank_1(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevj_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      type(c_ptr) :: myInfo
      !
      rocsolver_dsyevj_rank_1 = rocsolver_dsyevj_(handle,esort,evect,uplo,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
    end function

    function rocsolver_cheevj_full_rank(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevj_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      type(c_ptr) :: myInfo
      !
      rocsolver_cheevj_full_rank = rocsolver_cheevj_(handle,esort,evect,uplo,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
    end function

    function rocsolver_cheevj_rank_0(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevj_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      type(c_ptr) :: myInfo
      !
      rocsolver_cheevj_rank_0 = rocsolver_cheevj_(handle,esort,evect,uplo,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
    end function

    function rocsolver_cheevj_rank_1(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevj_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      type(c_ptr) :: myInfo
      !
      rocsolver_cheevj_rank_1 = rocsolver_cheevj_(handle,esort,evect,uplo,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
    end function

    function rocsolver_zheevj_full_rank(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevj_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      type(c_ptr) :: myInfo
      !
      rocsolver_zheevj_full_rank = rocsolver_zheevj_(handle,esort,evect,uplo,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
    end function

    function rocsolver_zheevj_rank_0(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevj_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      type(c_ptr) :: myInfo
      !
      rocsolver_zheevj_rank_0 = rocsolver_zheevj_(handle,esort,evect,uplo,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
    end function

    function rocsolver_zheevj_rank_1(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevj_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      type(c_ptr) :: myInfo
      !
      rocsolver_zheevj_rank_1 = rocsolver_zheevj_(handle,esort,evect,uplo,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
    end function

    function rocsolver_ssyevj_batched_full_rank(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevj_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssyevj_batched_full_rank = rocsolver_ssyevj_batched_(handle,esort,evect,uplo,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_ssyevj_batched_rank_0(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevj_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssyevj_batched_rank_0 = rocsolver_ssyevj_batched_(handle,esort,evect,uplo,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_ssyevj_batched_rank_1(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevj_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssyevj_batched_rank_1 = rocsolver_ssyevj_batched_(handle,esort,evect,uplo,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_dsyevj_batched_full_rank(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevj_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsyevj_batched_full_rank = rocsolver_dsyevj_batched_(handle,esort,evect,uplo,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_dsyevj_batched_rank_0(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevj_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsyevj_batched_rank_0 = rocsolver_dsyevj_batched_(handle,esort,evect,uplo,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_dsyevj_batched_rank_1(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevj_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsyevj_batched_rank_1 = rocsolver_dsyevj_batched_(handle,esort,evect,uplo,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_cheevj_batched_full_rank(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevj_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cheevj_batched_full_rank = rocsolver_cheevj_batched_(handle,esort,evect,uplo,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_cheevj_batched_rank_0(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevj_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cheevj_batched_rank_0 = rocsolver_cheevj_batched_(handle,esort,evect,uplo,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_cheevj_batched_rank_1(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevj_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cheevj_batched_rank_1 = rocsolver_cheevj_batched_(handle,esort,evect,uplo,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_zheevj_batched_full_rank(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevj_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zheevj_batched_full_rank = rocsolver_zheevj_batched_(handle,esort,evect,uplo,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_zheevj_batched_rank_0(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevj_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zheevj_batched_rank_0 = rocsolver_zheevj_batched_(handle,esort,evect,uplo,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_zheevj_batched_rank_1(handle,esort,evect,uplo,n,A,lda,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevj_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zheevj_batched_rank_1 = rocsolver_zheevj_batched_(handle,esort,evect,uplo,n,c_loc(A),lda,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_ssyevj_strided_batched_full_rank(handle,esort,evect,uplo,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevj_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssyevj_strided_batched_full_rank = rocsolver_ssyevj_strided_batched_(handle,esort,evect,uplo,n,c_loc(A),lda,strideA,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_ssyevj_strided_batched_rank_0(handle,esort,evect,uplo,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevj_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssyevj_strided_batched_rank_0 = rocsolver_ssyevj_strided_batched_(handle,esort,evect,uplo,n,c_loc(A),lda,strideA,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_ssyevj_strided_batched_rank_1(handle,esort,evect,uplo,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevj_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssyevj_strided_batched_rank_1 = rocsolver_ssyevj_strided_batched_(handle,esort,evect,uplo,n,c_loc(A),lda,strideA,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_dsyevj_strided_batched_full_rank(handle,esort,evect,uplo,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevj_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsyevj_strided_batched_full_rank = rocsolver_dsyevj_strided_batched_(handle,esort,evect,uplo,n,c_loc(A),lda,strideA,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_dsyevj_strided_batched_rank_0(handle,esort,evect,uplo,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevj_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsyevj_strided_batched_rank_0 = rocsolver_dsyevj_strided_batched_(handle,esort,evect,uplo,n,c_loc(A),lda,strideA,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_dsyevj_strided_batched_rank_1(handle,esort,evect,uplo,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevj_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsyevj_strided_batched_rank_1 = rocsolver_dsyevj_strided_batched_(handle,esort,evect,uplo,n,c_loc(A),lda,strideA,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_cheevj_strided_batched_full_rank(handle,esort,evect,uplo,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevj_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cheevj_strided_batched_full_rank = rocsolver_cheevj_strided_batched_(handle,esort,evect,uplo,n,c_loc(A),lda,strideA,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_cheevj_strided_batched_rank_0(handle,esort,evect,uplo,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevj_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cheevj_strided_batched_rank_0 = rocsolver_cheevj_strided_batched_(handle,esort,evect,uplo,n,c_loc(A),lda,strideA,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_cheevj_strided_batched_rank_1(handle,esort,evect,uplo,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevj_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cheevj_strided_batched_rank_1 = rocsolver_cheevj_strided_batched_(handle,esort,evect,uplo,n,c_loc(A),lda,strideA,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_zheevj_strided_batched_full_rank(handle,esort,evect,uplo,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevj_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zheevj_strided_batched_full_rank = rocsolver_zheevj_strided_batched_(handle,esort,evect,uplo,n,c_loc(A),lda,strideA,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_zheevj_strided_batched_rank_0(handle,esort,evect,uplo,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevj_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zheevj_strided_batched_rank_0 = rocsolver_zheevj_strided_batched_(handle,esort,evect,uplo,n,c_loc(A),lda,strideA,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_zheevj_strided_batched_rank_1(handle,esort,evect,uplo,n,A,lda,strideA,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevj_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_esort_none)) :: esort
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zheevj_strided_batched_rank_1 = rocsolver_zheevj_strided_batched_(handle,esort,evect,uplo,n,c_loc(A),lda,strideA,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_ssyevx_full_rank(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevx_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_ssyevx_full_rank = rocsolver_ssyevx_(handle,evect,erange,uplo,n,c_loc(A),lda,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_ssyevx_rank_0(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevx_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_ssyevx_rank_0 = rocsolver_ssyevx_(handle,evect,erange,uplo,n,c_loc(A),lda,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_ssyevx_rank_1(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevx_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_ssyevx_rank_1 = rocsolver_ssyevx_(handle,evect,erange,uplo,n,c_loc(A),lda,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_dsyevx_full_rank(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevx_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_dsyevx_full_rank = rocsolver_dsyevx_(handle,evect,erange,uplo,n,c_loc(A),lda,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_dsyevx_rank_0(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevx_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_dsyevx_rank_0 = rocsolver_dsyevx_(handle,evect,erange,uplo,n,c_loc(A),lda,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_dsyevx_rank_1(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevx_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_dsyevx_rank_1 = rocsolver_dsyevx_(handle,evect,erange,uplo,n,c_loc(A),lda,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_cheevx_full_rank(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevx_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_cheevx_full_rank = rocsolver_cheevx_(handle,evect,erange,uplo,n,c_loc(A),lda,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_cheevx_rank_0(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevx_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_cheevx_rank_0 = rocsolver_cheevx_(handle,evect,erange,uplo,n,c_loc(A),lda,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_cheevx_rank_1(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevx_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_cheevx_rank_1 = rocsolver_cheevx_(handle,evect,erange,uplo,n,c_loc(A),lda,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_zheevx_full_rank(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevx_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_zheevx_full_rank = rocsolver_zheevx_(handle,evect,erange,uplo,n,c_loc(A),lda,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_zheevx_rank_0(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevx_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_zheevx_rank_0 = rocsolver_zheevx_(handle,evect,erange,uplo,n,c_loc(A),lda,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_zheevx_rank_1(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevx_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_zheevx_rank_1 = rocsolver_zheevx_(handle,evect,erange,uplo,n,c_loc(A),lda,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_ssyevx_batched_full_rank(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevx_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssyevx_batched_full_rank = rocsolver_ssyevx_batched_(handle,evect,erange,uplo,n,c_loc(A),lda,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_ssyevx_batched_rank_0(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevx_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssyevx_batched_rank_0 = rocsolver_ssyevx_batched_(handle,evect,erange,uplo,n,c_loc(A),lda,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_ssyevx_batched_rank_1(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevx_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssyevx_batched_rank_1 = rocsolver_ssyevx_batched_(handle,evect,erange,uplo,n,c_loc(A),lda,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_dsyevx_batched_full_rank(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevx_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsyevx_batched_full_rank = rocsolver_dsyevx_batched_(handle,evect,erange,uplo,n,c_loc(A),lda,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_dsyevx_batched_rank_0(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevx_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsyevx_batched_rank_0 = rocsolver_dsyevx_batched_(handle,evect,erange,uplo,n,c_loc(A),lda,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_dsyevx_batched_rank_1(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevx_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsyevx_batched_rank_1 = rocsolver_dsyevx_batched_(handle,evect,erange,uplo,n,c_loc(A),lda,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_cheevx_batched_full_rank(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevx_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cheevx_batched_full_rank = rocsolver_cheevx_batched_(handle,evect,erange,uplo,n,c_loc(A),lda,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_cheevx_batched_rank_0(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevx_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cheevx_batched_rank_0 = rocsolver_cheevx_batched_(handle,evect,erange,uplo,n,c_loc(A),lda,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_cheevx_batched_rank_1(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevx_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cheevx_batched_rank_1 = rocsolver_cheevx_batched_(handle,evect,erange,uplo,n,c_loc(A),lda,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_zheevx_batched_full_rank(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevx_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zheevx_batched_full_rank = rocsolver_zheevx_batched_(handle,evect,erange,uplo,n,c_loc(A),lda,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_zheevx_batched_rank_0(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevx_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zheevx_batched_rank_0 = rocsolver_zheevx_batched_(handle,evect,erange,uplo,n,c_loc(A),lda,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_zheevx_batched_rank_1(handle,evect,erange,uplo,n,A,lda,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevx_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zheevx_batched_rank_1 = rocsolver_zheevx_batched_(handle,evect,erange,uplo,n,c_loc(A),lda,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_ssyevx_strided_batched_full_rank(handle,evect,erange,uplo,n,A,lda,strideA,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevx_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      integer(c_int64_t) :: strideZ
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssyevx_strided_batched_full_rank = rocsolver_ssyevx_strided_batched_(handle,evect,erange,uplo,n,c_loc(A),lda,strideA,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_ssyevx_strided_batched_rank_0(handle,evect,erange,uplo,n,A,lda,strideA,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevx_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      integer(c_int64_t) :: strideZ
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssyevx_strided_batched_rank_0 = rocsolver_ssyevx_strided_batched_(handle,evect,erange,uplo,n,c_loc(A),lda,strideA,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_ssyevx_strided_batched_rank_1(handle,evect,erange,uplo,n,A,lda,strideA,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssyevx_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      integer(c_int64_t) :: strideZ
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssyevx_strided_batched_rank_1 = rocsolver_ssyevx_strided_batched_(handle,evect,erange,uplo,n,c_loc(A),lda,strideA,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_dsyevx_strided_batched_full_rank(handle,evect,erange,uplo,n,A,lda,strideA,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevx_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      integer(c_int64_t) :: strideZ
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsyevx_strided_batched_full_rank = rocsolver_dsyevx_strided_batched_(handle,evect,erange,uplo,n,c_loc(A),lda,strideA,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_dsyevx_strided_batched_rank_0(handle,evect,erange,uplo,n,A,lda,strideA,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevx_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      integer(c_int64_t) :: strideZ
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsyevx_strided_batched_rank_0 = rocsolver_dsyevx_strided_batched_(handle,evect,erange,uplo,n,c_loc(A),lda,strideA,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_dsyevx_strided_batched_rank_1(handle,evect,erange,uplo,n,A,lda,strideA,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsyevx_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      integer(c_int64_t) :: strideZ
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsyevx_strided_batched_rank_1 = rocsolver_dsyevx_strided_batched_(handle,evect,erange,uplo,n,c_loc(A),lda,strideA,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_cheevx_strided_batched_full_rank(handle,evect,erange,uplo,n,A,lda,strideA,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevx_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      integer(c_int64_t) :: strideZ
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cheevx_strided_batched_full_rank = rocsolver_cheevx_strided_batched_(handle,evect,erange,uplo,n,c_loc(A),lda,strideA,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_cheevx_strided_batched_rank_0(handle,evect,erange,uplo,n,A,lda,strideA,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevx_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      integer(c_int64_t) :: strideZ
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cheevx_strided_batched_rank_0 = rocsolver_cheevx_strided_batched_(handle,evect,erange,uplo,n,c_loc(A),lda,strideA,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_cheevx_strided_batched_rank_1(handle,evect,erange,uplo,n,A,lda,strideA,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cheevx_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      integer(c_int64_t) :: strideZ
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cheevx_strided_batched_rank_1 = rocsolver_cheevx_strided_batched_(handle,evect,erange,uplo,n,c_loc(A),lda,strideA,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_zheevx_strided_batched_full_rank(handle,evect,erange,uplo,n,A,lda,strideA,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevx_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      integer(c_int64_t) :: strideZ
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zheevx_strided_batched_full_rank = rocsolver_zheevx_strided_batched_(handle,evect,erange,uplo,n,c_loc(A),lda,strideA,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_zheevx_strided_batched_rank_0(handle,evect,erange,uplo,n,A,lda,strideA,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevx_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      integer(c_int64_t) :: strideZ
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zheevx_strided_batched_rank_0 = rocsolver_zheevx_strided_batched_(handle,evect,erange,uplo,n,c_loc(A),lda,strideA,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_zheevx_strided_batched_rank_1(handle,evect,erange,uplo,n,A,lda,strideA,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zheevx_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      integer(c_int64_t) :: strideZ
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zheevx_strided_batched_rank_1 = rocsolver_zheevx_strided_batched_(handle,evect,erange,uplo,n,c_loc(A),lda,strideA,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_ssygv_full_rank(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_ssygv_full_rank = rocsolver_ssygv_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_ssygv_rank_0(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float),target :: D
      real(c_float),target :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_ssygv_rank_0 = rocsolver_ssygv_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_ssygv_rank_1(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_ssygv_rank_1 = rocsolver_ssygv_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_dsygv_full_rank(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_dsygv_full_rank = rocsolver_dsygv_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_dsygv_rank_0(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double),target :: D
      real(c_double),target :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_dsygv_rank_0 = rocsolver_dsygv_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_dsygv_rank_1(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_dsygv_rank_1 = rocsolver_dsygv_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_chegv_full_rank(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_chegv_full_rank = rocsolver_chegv_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_chegv_rank_0(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      real(c_float),target :: D
      real(c_float),target :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_chegv_rank_0 = rocsolver_chegv_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_chegv_rank_1(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_chegv_rank_1 = rocsolver_chegv_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_zhegv_full_rank(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegv_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_zhegv_full_rank = rocsolver_zhegv_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_zhegv_rank_0(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegv_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      real(c_double),target :: D
      real(c_double),target :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_zhegv_rank_0 = rocsolver_zhegv_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_zhegv_rank_1(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegv_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_zhegv_rank_1 = rocsolver_zhegv_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_ssygv_batched_full_rank(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssygv_batched_full_rank = rocsolver_ssygv_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_ssygv_batched_rank_0(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssygv_batched_rank_0 = rocsolver_ssygv_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_ssygv_batched_rank_1(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssygv_batched_rank_1 = rocsolver_ssygv_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_dsygv_batched_full_rank(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsygv_batched_full_rank = rocsolver_dsygv_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_dsygv_batched_rank_0(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsygv_batched_rank_0 = rocsolver_dsygv_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_dsygv_batched_rank_1(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsygv_batched_rank_1 = rocsolver_dsygv_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_chegv_batched_full_rank(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_chegv_batched_full_rank = rocsolver_chegv_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_chegv_batched_rank_0(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_chegv_batched_rank_0 = rocsolver_chegv_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_chegv_batched_rank_1(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_chegv_batched_rank_1 = rocsolver_chegv_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_zhegv_batched_full_rank(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegv_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zhegv_batched_full_rank = rocsolver_zhegv_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_zhegv_batched_rank_0(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegv_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zhegv_batched_rank_0 = rocsolver_zhegv_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_zhegv_batched_rank_1(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegv_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zhegv_batched_rank_1 = rocsolver_zhegv_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_ssygv_strided_batched_full_rank(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssygv_strided_batched_full_rank = rocsolver_ssygv_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_ssygv_strided_batched_rank_0(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssygv_strided_batched_rank_0 = rocsolver_ssygv_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_ssygv_strided_batched_rank_1(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssygv_strided_batched_rank_1 = rocsolver_ssygv_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_dsygv_strided_batched_full_rank(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsygv_strided_batched_full_rank = rocsolver_dsygv_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_dsygv_strided_batched_rank_0(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsygv_strided_batched_rank_0 = rocsolver_dsygv_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_dsygv_strided_batched_rank_1(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsygv_strided_batched_rank_1 = rocsolver_dsygv_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_chegv_strided_batched_full_rank(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_chegv_strided_batched_full_rank = rocsolver_chegv_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_chegv_strided_batched_rank_0(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_chegv_strided_batched_rank_0 = rocsolver_chegv_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_chegv_strided_batched_rank_1(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_chegv_strided_batched_rank_1 = rocsolver_chegv_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_zhegv_strided_batched_full_rank(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegv_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zhegv_strided_batched_full_rank = rocsolver_zhegv_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_zhegv_strided_batched_rank_0(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegv_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zhegv_strided_batched_rank_0 = rocsolver_zhegv_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_zhegv_strided_batched_rank_1(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegv_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zhegv_strided_batched_rank_1 = rocsolver_zhegv_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_ssygvd_full_rank(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvd_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_ssygvd_full_rank = rocsolver_ssygvd_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_ssygvd_rank_0(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvd_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float),target :: D
      real(c_float),target :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_ssygvd_rank_0 = rocsolver_ssygvd_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_ssygvd_rank_1(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvd_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_ssygvd_rank_1 = rocsolver_ssygvd_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_dsygvd_full_rank(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvd_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_dsygvd_full_rank = rocsolver_dsygvd_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_dsygvd_rank_0(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvd_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double),target :: D
      real(c_double),target :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_dsygvd_rank_0 = rocsolver_dsygvd_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_dsygvd_rank_1(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvd_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_dsygvd_rank_1 = rocsolver_dsygvd_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_chegvd_full_rank(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvd_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_chegvd_full_rank = rocsolver_chegvd_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_chegvd_rank_0(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvd_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      real(c_float),target :: D
      real(c_float),target :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_chegvd_rank_0 = rocsolver_chegvd_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_chegvd_rank_1(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvd_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:) :: D
      real(c_float),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_chegvd_rank_1 = rocsolver_chegvd_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_zhegvd_full_rank(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvd_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_zhegvd_full_rank = rocsolver_zhegvd_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_zhegvd_rank_0(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvd_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      real(c_double),target :: D
      real(c_double),target :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_zhegvd_rank_0 = rocsolver_zhegvd_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_zhegvd_rank_1(handle,itype,evect,uplo,n,A,lda,B,ldb,D,E,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvd_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:) :: D
      real(c_double),target,dimension(:) :: E
      type(c_ptr) :: myInfo
      !
      rocsolver_zhegvd_rank_1 = rocsolver_zhegvd_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),c_loc(E),myInfo)
    end function

    function rocsolver_ssygvd_batched_full_rank(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvd_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssygvd_batched_full_rank = rocsolver_ssygvd_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_ssygvd_batched_rank_0(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvd_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssygvd_batched_rank_0 = rocsolver_ssygvd_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_ssygvd_batched_rank_1(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvd_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssygvd_batched_rank_1 = rocsolver_ssygvd_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_dsygvd_batched_full_rank(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvd_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsygvd_batched_full_rank = rocsolver_dsygvd_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_dsygvd_batched_rank_0(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvd_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsygvd_batched_rank_0 = rocsolver_dsygvd_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_dsygvd_batched_rank_1(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvd_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsygvd_batched_rank_1 = rocsolver_dsygvd_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_chegvd_batched_full_rank(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvd_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_chegvd_batched_full_rank = rocsolver_chegvd_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_chegvd_batched_rank_0(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvd_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_chegvd_batched_rank_0 = rocsolver_chegvd_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_chegvd_batched_rank_1(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvd_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_chegvd_batched_rank_1 = rocsolver_chegvd_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_zhegvd_batched_full_rank(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvd_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zhegvd_batched_full_rank = rocsolver_zhegvd_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_zhegvd_batched_rank_0(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvd_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zhegvd_batched_rank_0 = rocsolver_zhegvd_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_zhegvd_batched_rank_1(handle,itype,evect,uplo,n,A,lda,B,ldb,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvd_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zhegvd_batched_rank_1 = rocsolver_zhegvd_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_ssygvd_strided_batched_full_rank(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvd_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssygvd_strided_batched_full_rank = rocsolver_ssygvd_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_ssygvd_strided_batched_rank_0(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvd_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssygvd_strided_batched_rank_0 = rocsolver_ssygvd_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_ssygvd_strided_batched_rank_1(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvd_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssygvd_strided_batched_rank_1 = rocsolver_ssygvd_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_dsygvd_strided_batched_full_rank(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvd_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsygvd_strided_batched_full_rank = rocsolver_dsygvd_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_dsygvd_strided_batched_rank_0(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvd_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsygvd_strided_batched_rank_0 = rocsolver_dsygvd_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_dsygvd_strided_batched_rank_1(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvd_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsygvd_strided_batched_rank_1 = rocsolver_dsygvd_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_chegvd_strided_batched_full_rank(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvd_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_chegvd_strided_batched_full_rank = rocsolver_chegvd_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_chegvd_strided_batched_rank_0(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvd_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target :: D
      integer(c_int64_t) :: strideD
      real(c_float),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_chegvd_strided_batched_rank_0 = rocsolver_chegvd_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_chegvd_strided_batched_rank_1(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvd_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_float),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_chegvd_strided_batched_rank_1 = rocsolver_chegvd_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_zhegvd_strided_batched_full_rank(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvd_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zhegvd_strided_batched_full_rank = rocsolver_zhegvd_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_zhegvd_strided_batched_rank_0(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvd_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target :: D
      integer(c_int64_t) :: strideD
      real(c_double),target :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zhegvd_strided_batched_rank_0 = rocsolver_zhegvd_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_zhegvd_strided_batched_rank_1(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,D,strideD,E,strideE,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvd_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target,dimension(:) :: D
      integer(c_int64_t) :: strideD
      real(c_double),target,dimension(:) :: E
      integer(c_int64_t) :: strideE
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zhegvd_strided_batched_rank_1 = rocsolver_zhegvd_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(D),strideD,c_loc(E),strideE,myInfo,batch_count)
    end function

    function rocsolver_ssygvj_full_rank(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvj_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      type(c_ptr) :: myInfo
      !
      rocsolver_ssygvj_full_rank = rocsolver_ssygvj_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
    end function

    function rocsolver_ssygvj_rank_0(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvj_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      type(c_ptr) :: myInfo
      !
      rocsolver_ssygvj_rank_0 = rocsolver_ssygvj_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
    end function

    function rocsolver_ssygvj_rank_1(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvj_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      type(c_ptr) :: myInfo
      !
      rocsolver_ssygvj_rank_1 = rocsolver_ssygvj_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
    end function

    function rocsolver_dsygvj_full_rank(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvj_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      type(c_ptr) :: myInfo
      !
      rocsolver_dsygvj_full_rank = rocsolver_dsygvj_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
    end function

    function rocsolver_dsygvj_rank_0(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvj_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      type(c_ptr) :: myInfo
      !
      rocsolver_dsygvj_rank_0 = rocsolver_dsygvj_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
    end function

    function rocsolver_dsygvj_rank_1(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvj_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      type(c_ptr) :: myInfo
      !
      rocsolver_dsygvj_rank_1 = rocsolver_dsygvj_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
    end function

    function rocsolver_chegvj_full_rank(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvj_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      type(c_ptr) :: myInfo
      !
      rocsolver_chegvj_full_rank = rocsolver_chegvj_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
    end function

    function rocsolver_chegvj_rank_0(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvj_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      type(c_ptr) :: myInfo
      !
      rocsolver_chegvj_rank_0 = rocsolver_chegvj_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
    end function

    function rocsolver_chegvj_rank_1(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvj_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      type(c_ptr) :: myInfo
      !
      rocsolver_chegvj_rank_1 = rocsolver_chegvj_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
    end function

    function rocsolver_zhegvj_full_rank(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvj_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      type(c_ptr) :: myInfo
      !
      rocsolver_zhegvj_full_rank = rocsolver_zhegvj_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
    end function

    function rocsolver_zhegvj_rank_0(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvj_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      type(c_ptr) :: myInfo
      !
      rocsolver_zhegvj_rank_0 = rocsolver_zhegvj_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
    end function

    function rocsolver_zhegvj_rank_1(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvj_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      type(c_ptr) :: myInfo
      !
      rocsolver_zhegvj_rank_1 = rocsolver_zhegvj_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,abstol,residual,max_sweeps,n_sweeps,W,myInfo)
    end function

    function rocsolver_ssygvj_batched_full_rank(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvj_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssygvj_batched_full_rank = rocsolver_ssygvj_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_ssygvj_batched_rank_0(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvj_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssygvj_batched_rank_0 = rocsolver_ssygvj_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_ssygvj_batched_rank_1(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvj_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssygvj_batched_rank_1 = rocsolver_ssygvj_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_dsygvj_batched_full_rank(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvj_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsygvj_batched_full_rank = rocsolver_dsygvj_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_dsygvj_batched_rank_0(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvj_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsygvj_batched_rank_0 = rocsolver_dsygvj_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_dsygvj_batched_rank_1(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvj_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsygvj_batched_rank_1 = rocsolver_dsygvj_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_chegvj_batched_full_rank(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvj_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_chegvj_batched_full_rank = rocsolver_chegvj_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_chegvj_batched_rank_0(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvj_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_chegvj_batched_rank_0 = rocsolver_chegvj_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_chegvj_batched_rank_1(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvj_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_chegvj_batched_rank_1 = rocsolver_chegvj_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_zhegvj_batched_full_rank(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvj_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zhegvj_batched_full_rank = rocsolver_zhegvj_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_zhegvj_batched_rank_0(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvj_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zhegvj_batched_rank_0 = rocsolver_zhegvj_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_zhegvj_batched_rank_1(handle,itype,evect,uplo,n,A,lda,B,ldb,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvj_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zhegvj_batched_rank_1 = rocsolver_zhegvj_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,c_loc(B),ldb,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_ssygvj_strided_batched_full_rank(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvj_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssygvj_strided_batched_full_rank = rocsolver_ssygvj_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_ssygvj_strided_batched_rank_0(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvj_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssygvj_strided_batched_rank_0 = rocsolver_ssygvj_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_ssygvj_strided_batched_rank_1(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvj_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssygvj_strided_batched_rank_1 = rocsolver_ssygvj_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_dsygvj_strided_batched_full_rank(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvj_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsygvj_strided_batched_full_rank = rocsolver_dsygvj_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_dsygvj_strided_batched_rank_0(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvj_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsygvj_strided_batched_rank_0 = rocsolver_dsygvj_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_dsygvj_strided_batched_rank_1(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvj_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsygvj_strided_batched_rank_1 = rocsolver_dsygvj_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_chegvj_strided_batched_full_rank(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvj_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_chegvj_strided_batched_full_rank = rocsolver_chegvj_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_chegvj_strided_batched_rank_0(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvj_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_chegvj_strided_batched_rank_0 = rocsolver_chegvj_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_chegvj_strided_batched_rank_1(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvj_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_chegvj_strided_batched_rank_1 = rocsolver_chegvj_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_zhegvj_strided_batched_full_rank(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvj_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zhegvj_strided_batched_full_rank = rocsolver_zhegvj_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_zhegvj_strided_batched_rank_0(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvj_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zhegvj_strided_batched_rank_0 = rocsolver_zhegvj_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_zhegvj_strided_batched_rank_1(handle,itype,evect,uplo,n,A,lda,strideA,B,ldb,strideB,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvj_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double) :: abstol
      type(c_ptr) :: residual
      integer(c_int) :: max_sweeps
      type(c_ptr) :: n_sweeps
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zhegvj_strided_batched_rank_1 = rocsolver_zhegvj_strided_batched_(handle,itype,evect,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,abstol,residual,max_sweeps,n_sweeps,W,strideW,myInfo,batch_count)
    end function

    function rocsolver_ssygvx_full_rank(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvx_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_ssygvx_full_rank = rocsolver_ssygvx_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,c_loc(B),ldb,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_ssygvx_rank_0(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvx_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_ssygvx_rank_0 = rocsolver_ssygvx_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,c_loc(B),ldb,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_ssygvx_rank_1(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvx_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_ssygvx_rank_1 = rocsolver_ssygvx_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,c_loc(B),ldb,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_dsygvx_full_rank(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvx_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_dsygvx_full_rank = rocsolver_dsygvx_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,c_loc(B),ldb,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_dsygvx_rank_0(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvx_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_dsygvx_rank_0 = rocsolver_dsygvx_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,c_loc(B),ldb,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_dsygvx_rank_1(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvx_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_dsygvx_rank_1 = rocsolver_dsygvx_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,c_loc(B),ldb,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_chegvx_full_rank(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvx_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_chegvx_full_rank = rocsolver_chegvx_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,c_loc(B),ldb,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_chegvx_rank_0(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvx_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_chegvx_rank_0 = rocsolver_chegvx_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,c_loc(B),ldb,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_chegvx_rank_1(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvx_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_chegvx_rank_1 = rocsolver_chegvx_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,c_loc(B),ldb,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_zhegvx_full_rank(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvx_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_zhegvx_full_rank = rocsolver_zhegvx_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,c_loc(B),ldb,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_zhegvx_rank_0(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvx_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_zhegvx_rank_0 = rocsolver_zhegvx_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,c_loc(B),ldb,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_zhegvx_rank_1(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvx_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      type(c_ptr) :: myInfo
      !
      rocsolver_zhegvx_rank_1 = rocsolver_zhegvx_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,c_loc(B),ldb,vl,vu,il,iu,abstol,nev,W,Z,ldz,ifail,myInfo)
    end function

    function rocsolver_ssygvx_batched_full_rank(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvx_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssygvx_batched_full_rank = rocsolver_ssygvx_batched_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,c_loc(B),ldb,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_ssygvx_batched_rank_0(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvx_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssygvx_batched_rank_0 = rocsolver_ssygvx_batched_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,c_loc(B),ldb,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_ssygvx_batched_rank_1(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvx_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssygvx_batched_rank_1 = rocsolver_ssygvx_batched_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,c_loc(B),ldb,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_dsygvx_batched_full_rank(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvx_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsygvx_batched_full_rank = rocsolver_dsygvx_batched_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,c_loc(B),ldb,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_dsygvx_batched_rank_0(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvx_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsygvx_batched_rank_0 = rocsolver_dsygvx_batched_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,c_loc(B),ldb,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_dsygvx_batched_rank_1(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvx_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsygvx_batched_rank_1 = rocsolver_dsygvx_batched_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,c_loc(B),ldb,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_chegvx_batched_full_rank(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvx_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_chegvx_batched_full_rank = rocsolver_chegvx_batched_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,c_loc(B),ldb,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_chegvx_batched_rank_0(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvx_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_chegvx_batched_rank_0 = rocsolver_chegvx_batched_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,c_loc(B),ldb,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_chegvx_batched_rank_1(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvx_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_chegvx_batched_rank_1 = rocsolver_chegvx_batched_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,c_loc(B),ldb,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_zhegvx_batched_full_rank(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvx_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zhegvx_batched_full_rank = rocsolver_zhegvx_batched_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,c_loc(B),ldb,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_zhegvx_batched_rank_0(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvx_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zhegvx_batched_rank_0 = rocsolver_zhegvx_batched_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,c_loc(B),ldb,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_zhegvx_batched_rank_1(handle,itype,evect,erange,uplo,n,A,lda,B,ldb,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvx_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zhegvx_batched_rank_1 = rocsolver_zhegvx_batched_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,c_loc(B),ldb,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_ssygvx_strided_batched_full_rank(handle,itype,evect,erange,uplo,n,A,lda,strideA,B,ldb,strideB,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvx_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      integer(c_int64_t) :: strideZ
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssygvx_strided_batched_full_rank = rocsolver_ssygvx_strided_batched_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_ssygvx_strided_batched_rank_0(handle,itype,evect,erange,uplo,n,A,lda,strideA,B,ldb,strideB,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvx_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      integer(c_int64_t) :: strideZ
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssygvx_strided_batched_rank_0 = rocsolver_ssygvx_strided_batched_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_ssygvx_strided_batched_rank_1(handle,itype,evect,erange,uplo,n,A,lda,strideA,B,ldb,strideB,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssygvx_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      integer(c_int64_t) :: strideZ
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssygvx_strided_batched_rank_1 = rocsolver_ssygvx_strided_batched_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_dsygvx_strided_batched_full_rank(handle,itype,evect,erange,uplo,n,A,lda,strideA,B,ldb,strideB,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvx_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      integer(c_int64_t) :: strideZ
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsygvx_strided_batched_full_rank = rocsolver_dsygvx_strided_batched_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_dsygvx_strided_batched_rank_0(handle,itype,evect,erange,uplo,n,A,lda,strideA,B,ldb,strideB,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvx_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      integer(c_int64_t) :: strideZ
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsygvx_strided_batched_rank_0 = rocsolver_dsygvx_strided_batched_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_dsygvx_strided_batched_rank_1(handle,itype,evect,erange,uplo,n,A,lda,strideA,B,ldb,strideB,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsygvx_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      integer(c_int64_t) :: strideZ
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsygvx_strided_batched_rank_1 = rocsolver_dsygvx_strided_batched_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_chegvx_strided_batched_full_rank(handle,itype,evect,erange,uplo,n,A,lda,strideA,B,ldb,strideB,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvx_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      integer(c_int64_t) :: strideZ
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_chegvx_strided_batched_full_rank = rocsolver_chegvx_strided_batched_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_chegvx_strided_batched_rank_0(handle,itype,evect,erange,uplo,n,A,lda,strideA,B,ldb,strideB,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvx_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      integer(c_int64_t) :: strideZ
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_chegvx_strided_batched_rank_0 = rocsolver_chegvx_strided_batched_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_chegvx_strided_batched_rank_1(handle,itype,evect,erange,uplo,n,A,lda,strideA,B,ldb,strideB,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_chegvx_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float) :: vl
      real(c_float) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_float) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      integer(c_int64_t) :: strideZ
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_chegvx_strided_batched_rank_1 = rocsolver_chegvx_strided_batched_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_zhegvx_strided_batched_full_rank(handle,itype,evect,erange,uplo,n,A,lda,strideA,B,ldb,strideB,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvx_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      integer(c_int64_t) :: strideZ
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zhegvx_strided_batched_full_rank = rocsolver_zhegvx_strided_batched_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_zhegvx_strided_batched_rank_0(handle,itype,evect,erange,uplo,n,A,lda,strideA,B,ldb,strideB,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvx_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      integer(c_int64_t) :: strideZ
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zhegvx_strided_batched_rank_0 = rocsolver_zhegvx_strided_batched_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_zhegvx_strided_batched_rank_1(handle,itype,evect,erange,uplo,n,A,lda,strideA,B,ldb,strideB,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zhegvx_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_eform_ax)) :: itype
      integer(kind(rocblas_evect_original)) :: evect
      integer(kind(rocblas_erange_all)) :: erange
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double) :: vl
      real(c_double) :: vu
      integer(c_int) :: il
      integer(c_int) :: iu
      real(c_double) :: abstol
      type(c_ptr) :: nev
      type(c_ptr) :: W
      integer(c_int64_t) :: strideW
      type(c_ptr) :: Z
      integer(c_int) :: ldz
      integer(c_int64_t) :: strideZ
      type(c_ptr) :: ifail
      integer(c_int64_t) :: strideF
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zhegvx_strided_batched_rank_1 = rocsolver_zhegvx_strided_batched_(handle,itype,evect,erange,uplo,n,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,vl,vu,il,iu,abstol,nev,W,strideW,Z,ldz,strideZ,ifail,strideF,myInfo,batch_count)
    end function

    function rocsolver_sgetri_outofplace_full_rank(handle,n,A,lda,ipiv,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_outofplace_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_sgetri_outofplace_full_rank = rocsolver_sgetri_outofplace_(handle,n,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_sgetri_outofplace_rank_0(handle,n,A,lda,ipiv,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_outofplace_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      real(c_float),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_sgetri_outofplace_rank_0 = rocsolver_sgetri_outofplace_(handle,n,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_sgetri_outofplace_rank_1(handle,n,A,lda,ipiv,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_outofplace_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_sgetri_outofplace_rank_1 = rocsolver_sgetri_outofplace_(handle,n,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_dgetri_outofplace_full_rank(handle,n,A,lda,ipiv,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_outofplace_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_dgetri_outofplace_full_rank = rocsolver_dgetri_outofplace_(handle,n,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_dgetri_outofplace_rank_0(handle,n,A,lda,ipiv,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_outofplace_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      real(c_double),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_dgetri_outofplace_rank_0 = rocsolver_dgetri_outofplace_(handle,n,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_dgetri_outofplace_rank_1(handle,n,A,lda,ipiv,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_outofplace_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_dgetri_outofplace_rank_1 = rocsolver_dgetri_outofplace_(handle,n,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_cgetri_outofplace_full_rank(handle,n,A,lda,ipiv,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_outofplace_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_cgetri_outofplace_full_rank = rocsolver_cgetri_outofplace_(handle,n,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_cgetri_outofplace_rank_0(handle,n,A,lda,ipiv,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_outofplace_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_cgetri_outofplace_rank_0 = rocsolver_cgetri_outofplace_(handle,n,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_cgetri_outofplace_rank_1(handle,n,A,lda,ipiv,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_outofplace_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_cgetri_outofplace_rank_1 = rocsolver_cgetri_outofplace_(handle,n,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_zgetri_outofplace_full_rank(handle,n,A,lda,ipiv,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_outofplace_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_zgetri_outofplace_full_rank = rocsolver_zgetri_outofplace_(handle,n,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_zgetri_outofplace_rank_0(handle,n,A,lda,ipiv,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_outofplace_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_zgetri_outofplace_rank_0 = rocsolver_zgetri_outofplace_(handle,n,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_zgetri_outofplace_rank_1(handle,n,A,lda,ipiv,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_outofplace_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_zgetri_outofplace_rank_1 = rocsolver_zgetri_outofplace_(handle,n,c_loc(A),lda,c_loc(ipiv),c_loc(C),ldc,myInfo)
    end function

    function rocsolver_sgetri_outofplace_batched_full_rank(handle,n,A,lda,ipiv,strideP,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_outofplace_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetri_outofplace_batched_full_rank = rocsolver_sgetri_outofplace_batched_(handle,n,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_sgetri_outofplace_batched_rank_0(handle,n,A,lda,ipiv,strideP,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_outofplace_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      real(c_float),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetri_outofplace_batched_rank_0 = rocsolver_sgetri_outofplace_batched_(handle,n,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_sgetri_outofplace_batched_rank_1(handle,n,A,lda,ipiv,strideP,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_outofplace_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetri_outofplace_batched_rank_1 = rocsolver_sgetri_outofplace_batched_(handle,n,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_dgetri_outofplace_batched_full_rank(handle,n,A,lda,ipiv,strideP,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_outofplace_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetri_outofplace_batched_full_rank = rocsolver_dgetri_outofplace_batched_(handle,n,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_dgetri_outofplace_batched_rank_0(handle,n,A,lda,ipiv,strideP,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_outofplace_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      real(c_double),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetri_outofplace_batched_rank_0 = rocsolver_dgetri_outofplace_batched_(handle,n,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_dgetri_outofplace_batched_rank_1(handle,n,A,lda,ipiv,strideP,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_outofplace_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetri_outofplace_batched_rank_1 = rocsolver_dgetri_outofplace_batched_(handle,n,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_cgetri_outofplace_batched_full_rank(handle,n,A,lda,ipiv,strideP,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_outofplace_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetri_outofplace_batched_full_rank = rocsolver_cgetri_outofplace_batched_(handle,n,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_cgetri_outofplace_batched_rank_0(handle,n,A,lda,ipiv,strideP,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_outofplace_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetri_outofplace_batched_rank_0 = rocsolver_cgetri_outofplace_batched_(handle,n,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_cgetri_outofplace_batched_rank_1(handle,n,A,lda,ipiv,strideP,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_outofplace_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetri_outofplace_batched_rank_1 = rocsolver_cgetri_outofplace_batched_(handle,n,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_zgetri_outofplace_batched_full_rank(handle,n,A,lda,ipiv,strideP,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_outofplace_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetri_outofplace_batched_full_rank = rocsolver_zgetri_outofplace_batched_(handle,n,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_zgetri_outofplace_batched_rank_0(handle,n,A,lda,ipiv,strideP,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_outofplace_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetri_outofplace_batched_rank_0 = rocsolver_zgetri_outofplace_batched_(handle,n,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_zgetri_outofplace_batched_rank_1(handle,n,A,lda,ipiv,strideP,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_outofplace_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetri_outofplace_batched_rank_1 = rocsolver_zgetri_outofplace_batched_(handle,n,c_loc(A),lda,c_loc(ipiv),strideP,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_sgetri_outofplace_strided_batched_full_rank(handle,n,A,lda,strideA,ipiv,strideP,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_outofplace_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetri_outofplace_strided_batched_full_rank = rocsolver_sgetri_outofplace_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_sgetri_outofplace_strided_batched_rank_0(handle,n,A,lda,strideA,ipiv,strideP,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_outofplace_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetri_outofplace_strided_batched_rank_0 = rocsolver_sgetri_outofplace_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_sgetri_outofplace_strided_batched_rank_1(handle,n,A,lda,strideA,ipiv,strideP,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_outofplace_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetri_outofplace_strided_batched_rank_1 = rocsolver_sgetri_outofplace_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_dgetri_outofplace_strided_batched_full_rank(handle,n,A,lda,strideA,ipiv,strideP,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_outofplace_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetri_outofplace_strided_batched_full_rank = rocsolver_dgetri_outofplace_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_dgetri_outofplace_strided_batched_rank_0(handle,n,A,lda,strideA,ipiv,strideP,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_outofplace_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetri_outofplace_strided_batched_rank_0 = rocsolver_dgetri_outofplace_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_dgetri_outofplace_strided_batched_rank_1(handle,n,A,lda,strideA,ipiv,strideP,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_outofplace_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetri_outofplace_strided_batched_rank_1 = rocsolver_dgetri_outofplace_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_cgetri_outofplace_strided_batched_full_rank(handle,n,A,lda,strideA,ipiv,strideP,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_outofplace_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetri_outofplace_strided_batched_full_rank = rocsolver_cgetri_outofplace_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_cgetri_outofplace_strided_batched_rank_0(handle,n,A,lda,strideA,ipiv,strideP,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_outofplace_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetri_outofplace_strided_batched_rank_0 = rocsolver_cgetri_outofplace_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_cgetri_outofplace_strided_batched_rank_1(handle,n,A,lda,strideA,ipiv,strideP,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_outofplace_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetri_outofplace_strided_batched_rank_1 = rocsolver_cgetri_outofplace_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_zgetri_outofplace_strided_batched_full_rank(handle,n,A,lda,strideA,ipiv,strideP,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_outofplace_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetri_outofplace_strided_batched_full_rank = rocsolver_zgetri_outofplace_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_zgetri_outofplace_strided_batched_rank_0(handle,n,A,lda,strideA,ipiv,strideP,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_outofplace_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetri_outofplace_strided_batched_rank_0 = rocsolver_zgetri_outofplace_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_zgetri_outofplace_strided_batched_rank_1(handle,n,A,lda,strideA,ipiv,strideP,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_outofplace_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetri_outofplace_strided_batched_rank_1 = rocsolver_zgetri_outofplace_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_sgetri_npvt_outofplace_full_rank(handle,n,A,lda,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_npvt_outofplace_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_sgetri_npvt_outofplace_full_rank = rocsolver_sgetri_npvt_outofplace_(handle,n,c_loc(A),lda,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_sgetri_npvt_outofplace_rank_0(handle,n,A,lda,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_npvt_outofplace_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_sgetri_npvt_outofplace_rank_0 = rocsolver_sgetri_npvt_outofplace_(handle,n,c_loc(A),lda,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_sgetri_npvt_outofplace_rank_1(handle,n,A,lda,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_npvt_outofplace_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_sgetri_npvt_outofplace_rank_1 = rocsolver_sgetri_npvt_outofplace_(handle,n,c_loc(A),lda,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_dgetri_npvt_outofplace_full_rank(handle,n,A,lda,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_npvt_outofplace_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_dgetri_npvt_outofplace_full_rank = rocsolver_dgetri_npvt_outofplace_(handle,n,c_loc(A),lda,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_dgetri_npvt_outofplace_rank_0(handle,n,A,lda,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_npvt_outofplace_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_dgetri_npvt_outofplace_rank_0 = rocsolver_dgetri_npvt_outofplace_(handle,n,c_loc(A),lda,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_dgetri_npvt_outofplace_rank_1(handle,n,A,lda,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_npvt_outofplace_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_dgetri_npvt_outofplace_rank_1 = rocsolver_dgetri_npvt_outofplace_(handle,n,c_loc(A),lda,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_cgetri_npvt_outofplace_full_rank(handle,n,A,lda,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_npvt_outofplace_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_cgetri_npvt_outofplace_full_rank = rocsolver_cgetri_npvt_outofplace_(handle,n,c_loc(A),lda,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_cgetri_npvt_outofplace_rank_0(handle,n,A,lda,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_npvt_outofplace_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_cgetri_npvt_outofplace_rank_0 = rocsolver_cgetri_npvt_outofplace_(handle,n,c_loc(A),lda,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_cgetri_npvt_outofplace_rank_1(handle,n,A,lda,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_npvt_outofplace_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_cgetri_npvt_outofplace_rank_1 = rocsolver_cgetri_npvt_outofplace_(handle,n,c_loc(A),lda,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_zgetri_npvt_outofplace_full_rank(handle,n,A,lda,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_npvt_outofplace_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_zgetri_npvt_outofplace_full_rank = rocsolver_zgetri_npvt_outofplace_(handle,n,c_loc(A),lda,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_zgetri_npvt_outofplace_rank_0(handle,n,A,lda,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_npvt_outofplace_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_zgetri_npvt_outofplace_rank_0 = rocsolver_zgetri_npvt_outofplace_(handle,n,c_loc(A),lda,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_zgetri_npvt_outofplace_rank_1(handle,n,A,lda,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_npvt_outofplace_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_zgetri_npvt_outofplace_rank_1 = rocsolver_zgetri_npvt_outofplace_(handle,n,c_loc(A),lda,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_sgetri_npvt_outofplace_batched_full_rank(handle,n,A,lda,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_npvt_outofplace_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetri_npvt_outofplace_batched_full_rank = rocsolver_sgetri_npvt_outofplace_batched_(handle,n,c_loc(A),lda,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_sgetri_npvt_outofplace_batched_rank_0(handle,n,A,lda,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_npvt_outofplace_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetri_npvt_outofplace_batched_rank_0 = rocsolver_sgetri_npvt_outofplace_batched_(handle,n,c_loc(A),lda,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_sgetri_npvt_outofplace_batched_rank_1(handle,n,A,lda,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_npvt_outofplace_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetri_npvt_outofplace_batched_rank_1 = rocsolver_sgetri_npvt_outofplace_batched_(handle,n,c_loc(A),lda,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_dgetri_npvt_outofplace_batched_full_rank(handle,n,A,lda,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_npvt_outofplace_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetri_npvt_outofplace_batched_full_rank = rocsolver_dgetri_npvt_outofplace_batched_(handle,n,c_loc(A),lda,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_dgetri_npvt_outofplace_batched_rank_0(handle,n,A,lda,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_npvt_outofplace_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetri_npvt_outofplace_batched_rank_0 = rocsolver_dgetri_npvt_outofplace_batched_(handle,n,c_loc(A),lda,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_dgetri_npvt_outofplace_batched_rank_1(handle,n,A,lda,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_npvt_outofplace_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetri_npvt_outofplace_batched_rank_1 = rocsolver_dgetri_npvt_outofplace_batched_(handle,n,c_loc(A),lda,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_cgetri_npvt_outofplace_batched_full_rank(handle,n,A,lda,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_npvt_outofplace_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetri_npvt_outofplace_batched_full_rank = rocsolver_cgetri_npvt_outofplace_batched_(handle,n,c_loc(A),lda,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_cgetri_npvt_outofplace_batched_rank_0(handle,n,A,lda,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_npvt_outofplace_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetri_npvt_outofplace_batched_rank_0 = rocsolver_cgetri_npvt_outofplace_batched_(handle,n,c_loc(A),lda,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_cgetri_npvt_outofplace_batched_rank_1(handle,n,A,lda,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_npvt_outofplace_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetri_npvt_outofplace_batched_rank_1 = rocsolver_cgetri_npvt_outofplace_batched_(handle,n,c_loc(A),lda,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_zgetri_npvt_outofplace_batched_full_rank(handle,n,A,lda,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_npvt_outofplace_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetri_npvt_outofplace_batched_full_rank = rocsolver_zgetri_npvt_outofplace_batched_(handle,n,c_loc(A),lda,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_zgetri_npvt_outofplace_batched_rank_0(handle,n,A,lda,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_npvt_outofplace_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetri_npvt_outofplace_batched_rank_0 = rocsolver_zgetri_npvt_outofplace_batched_(handle,n,c_loc(A),lda,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_zgetri_npvt_outofplace_batched_rank_1(handle,n,A,lda,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_npvt_outofplace_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetri_npvt_outofplace_batched_rank_1 = rocsolver_zgetri_npvt_outofplace_batched_(handle,n,c_loc(A),lda,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_sgetri_npvt_outofplace_strided_batched_full_rank(handle,n,A,lda,strideA,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_npvt_outofplace_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetri_npvt_outofplace_strided_batched_full_rank = rocsolver_sgetri_npvt_outofplace_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_sgetri_npvt_outofplace_strided_batched_rank_0(handle,n,A,lda,strideA,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_npvt_outofplace_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetri_npvt_outofplace_strided_batched_rank_0 = rocsolver_sgetri_npvt_outofplace_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_sgetri_npvt_outofplace_strided_batched_rank_1(handle,n,A,lda,strideA,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgetri_npvt_outofplace_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgetri_npvt_outofplace_strided_batched_rank_1 = rocsolver_sgetri_npvt_outofplace_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_dgetri_npvt_outofplace_strided_batched_full_rank(handle,n,A,lda,strideA,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_npvt_outofplace_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetri_npvt_outofplace_strided_batched_full_rank = rocsolver_dgetri_npvt_outofplace_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_dgetri_npvt_outofplace_strided_batched_rank_0(handle,n,A,lda,strideA,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_npvt_outofplace_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetri_npvt_outofplace_strided_batched_rank_0 = rocsolver_dgetri_npvt_outofplace_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_dgetri_npvt_outofplace_strided_batched_rank_1(handle,n,A,lda,strideA,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgetri_npvt_outofplace_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgetri_npvt_outofplace_strided_batched_rank_1 = rocsolver_dgetri_npvt_outofplace_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_cgetri_npvt_outofplace_strided_batched_full_rank(handle,n,A,lda,strideA,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_npvt_outofplace_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetri_npvt_outofplace_strided_batched_full_rank = rocsolver_cgetri_npvt_outofplace_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_cgetri_npvt_outofplace_strided_batched_rank_0(handle,n,A,lda,strideA,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_npvt_outofplace_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetri_npvt_outofplace_strided_batched_rank_0 = rocsolver_cgetri_npvt_outofplace_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_cgetri_npvt_outofplace_strided_batched_rank_1(handle,n,A,lda,strideA,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgetri_npvt_outofplace_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgetri_npvt_outofplace_strided_batched_rank_1 = rocsolver_cgetri_npvt_outofplace_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_zgetri_npvt_outofplace_strided_batched_full_rank(handle,n,A,lda,strideA,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_npvt_outofplace_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetri_npvt_outofplace_strided_batched_full_rank = rocsolver_zgetri_npvt_outofplace_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_zgetri_npvt_outofplace_strided_batched_rank_0(handle,n,A,lda,strideA,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_npvt_outofplace_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetri_npvt_outofplace_strided_batched_rank_0 = rocsolver_zgetri_npvt_outofplace_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_zgetri_npvt_outofplace_strided_batched_rank_1(handle,n,A,lda,strideA,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgetri_npvt_outofplace_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgetri_npvt_outofplace_strided_batched_rank_1 = rocsolver_zgetri_npvt_outofplace_strided_batched_(handle,n,c_loc(A),lda,strideA,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_strtri_full_rank(handle,uplo,diag,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_strtri_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_strtri_full_rank = rocsolver_strtri_(handle,uplo,diag,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_strtri_rank_0(handle,uplo,diag,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_strtri_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_strtri_rank_0 = rocsolver_strtri_(handle,uplo,diag,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_strtri_rank_1(handle,uplo,diag,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_strtri_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_strtri_rank_1 = rocsolver_strtri_(handle,uplo,diag,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_dtrtri_full_rank(handle,uplo,diag,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dtrtri_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_dtrtri_full_rank = rocsolver_dtrtri_(handle,uplo,diag,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_dtrtri_rank_0(handle,uplo,diag,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dtrtri_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_dtrtri_rank_0 = rocsolver_dtrtri_(handle,uplo,diag,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_dtrtri_rank_1(handle,uplo,diag,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dtrtri_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_dtrtri_rank_1 = rocsolver_dtrtri_(handle,uplo,diag,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_ctrtri_full_rank(handle,uplo,diag,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ctrtri_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_ctrtri_full_rank = rocsolver_ctrtri_(handle,uplo,diag,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_ctrtri_rank_0(handle,uplo,diag,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ctrtri_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_ctrtri_rank_0 = rocsolver_ctrtri_(handle,uplo,diag,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_ctrtri_rank_1(handle,uplo,diag,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ctrtri_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_ctrtri_rank_1 = rocsolver_ctrtri_(handle,uplo,diag,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_ztrtri_full_rank(handle,uplo,diag,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ztrtri_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_ztrtri_full_rank = rocsolver_ztrtri_(handle,uplo,diag,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_ztrtri_rank_0(handle,uplo,diag,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ztrtri_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_ztrtri_rank_0 = rocsolver_ztrtri_(handle,uplo,diag,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_ztrtri_rank_1(handle,uplo,diag,n,A,lda,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ztrtri_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      !
      rocsolver_ztrtri_rank_1 = rocsolver_ztrtri_(handle,uplo,diag,n,c_loc(A),lda,myInfo)
    end function

    function rocsolver_strtri_batched_full_rank(handle,uplo,diag,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_strtri_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_strtri_batched_full_rank = rocsolver_strtri_batched_(handle,uplo,diag,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_strtri_batched_rank_0(handle,uplo,diag,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_strtri_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_strtri_batched_rank_0 = rocsolver_strtri_batched_(handle,uplo,diag,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_strtri_batched_rank_1(handle,uplo,diag,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_strtri_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_strtri_batched_rank_1 = rocsolver_strtri_batched_(handle,uplo,diag,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_dtrtri_batched_full_rank(handle,uplo,diag,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dtrtri_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dtrtri_batched_full_rank = rocsolver_dtrtri_batched_(handle,uplo,diag,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_dtrtri_batched_rank_0(handle,uplo,diag,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dtrtri_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dtrtri_batched_rank_0 = rocsolver_dtrtri_batched_(handle,uplo,diag,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_dtrtri_batched_rank_1(handle,uplo,diag,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dtrtri_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dtrtri_batched_rank_1 = rocsolver_dtrtri_batched_(handle,uplo,diag,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_ctrtri_batched_full_rank(handle,uplo,diag,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ctrtri_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ctrtri_batched_full_rank = rocsolver_ctrtri_batched_(handle,uplo,diag,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_ctrtri_batched_rank_0(handle,uplo,diag,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ctrtri_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ctrtri_batched_rank_0 = rocsolver_ctrtri_batched_(handle,uplo,diag,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_ctrtri_batched_rank_1(handle,uplo,diag,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ctrtri_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ctrtri_batched_rank_1 = rocsolver_ctrtri_batched_(handle,uplo,diag,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_ztrtri_batched_full_rank(handle,uplo,diag,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ztrtri_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ztrtri_batched_full_rank = rocsolver_ztrtri_batched_(handle,uplo,diag,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_ztrtri_batched_rank_0(handle,uplo,diag,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ztrtri_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ztrtri_batched_rank_0 = rocsolver_ztrtri_batched_(handle,uplo,diag,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_ztrtri_batched_rank_1(handle,uplo,diag,n,A,lda,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ztrtri_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ztrtri_batched_rank_1 = rocsolver_ztrtri_batched_(handle,uplo,diag,n,c_loc(A),lda,myInfo,batch_count)
    end function

    function rocsolver_strtri_strided_batched_full_rank(handle,uplo,diag,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_strtri_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_strtri_strided_batched_full_rank = rocsolver_strtri_strided_batched_(handle,uplo,diag,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_strtri_strided_batched_rank_0(handle,uplo,diag,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_strtri_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_strtri_strided_batched_rank_0 = rocsolver_strtri_strided_batched_(handle,uplo,diag,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_strtri_strided_batched_rank_1(handle,uplo,diag,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_strtri_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_strtri_strided_batched_rank_1 = rocsolver_strtri_strided_batched_(handle,uplo,diag,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_dtrtri_strided_batched_full_rank(handle,uplo,diag,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dtrtri_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dtrtri_strided_batched_full_rank = rocsolver_dtrtri_strided_batched_(handle,uplo,diag,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_dtrtri_strided_batched_rank_0(handle,uplo,diag,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dtrtri_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dtrtri_strided_batched_rank_0 = rocsolver_dtrtri_strided_batched_(handle,uplo,diag,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_dtrtri_strided_batched_rank_1(handle,uplo,diag,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dtrtri_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dtrtri_strided_batched_rank_1 = rocsolver_dtrtri_strided_batched_(handle,uplo,diag,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_ctrtri_strided_batched_full_rank(handle,uplo,diag,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ctrtri_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ctrtri_strided_batched_full_rank = rocsolver_ctrtri_strided_batched_(handle,uplo,diag,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_ctrtri_strided_batched_rank_0(handle,uplo,diag,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ctrtri_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ctrtri_strided_batched_rank_0 = rocsolver_ctrtri_strided_batched_(handle,uplo,diag,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_ctrtri_strided_batched_rank_1(handle,uplo,diag,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ctrtri_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ctrtri_strided_batched_rank_1 = rocsolver_ctrtri_strided_batched_(handle,uplo,diag,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_ztrtri_strided_batched_full_rank(handle,uplo,diag,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ztrtri_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ztrtri_strided_batched_full_rank = rocsolver_ztrtri_strided_batched_(handle,uplo,diag,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_ztrtri_strided_batched_rank_0(handle,uplo,diag,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ztrtri_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ztrtri_strided_batched_rank_0 = rocsolver_ztrtri_strided_batched_(handle,uplo,diag,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_ztrtri_strided_batched_rank_1(handle,uplo,diag,n,A,lda,strideA,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ztrtri_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(kind(rocblas_diagonal_non_unit)) :: diag
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ztrtri_strided_batched_rank_1 = rocsolver_ztrtri_strided_batched_(handle,uplo,diag,n,c_loc(A),lda,strideA,myInfo,batch_count)
    end function

    function rocsolver_ssytf2_full_rank(handle,uplo,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytf2_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_ssytf2_full_rank = rocsolver_ssytf2_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_ssytf2_rank_0(handle,uplo,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytf2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_ssytf2_rank_0 = rocsolver_ssytf2_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_ssytf2_rank_1(handle,uplo,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytf2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_ssytf2_rank_1 = rocsolver_ssytf2_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_dsytf2_full_rank(handle,uplo,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytf2_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_dsytf2_full_rank = rocsolver_dsytf2_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_dsytf2_rank_0(handle,uplo,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytf2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_dsytf2_rank_0 = rocsolver_dsytf2_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_dsytf2_rank_1(handle,uplo,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytf2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_dsytf2_rank_1 = rocsolver_dsytf2_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_csytf2_full_rank(handle,uplo,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_csytf2_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_csytf2_full_rank = rocsolver_csytf2_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_csytf2_rank_0(handle,uplo,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_csytf2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_csytf2_rank_0 = rocsolver_csytf2_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_csytf2_rank_1(handle,uplo,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_csytf2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_csytf2_rank_1 = rocsolver_csytf2_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_zsytf2_full_rank(handle,uplo,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zsytf2_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_zsytf2_full_rank = rocsolver_zsytf2_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_zsytf2_rank_0(handle,uplo,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zsytf2_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_zsytf2_rank_0 = rocsolver_zsytf2_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_zsytf2_rank_1(handle,uplo,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zsytf2_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_zsytf2_rank_1 = rocsolver_zsytf2_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_ssytf2_batched_full_rank(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytf2_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssytf2_batched_full_rank = rocsolver_ssytf2_batched_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_ssytf2_batched_rank_0(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytf2_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssytf2_batched_rank_0 = rocsolver_ssytf2_batched_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_ssytf2_batched_rank_1(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytf2_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssytf2_batched_rank_1 = rocsolver_ssytf2_batched_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dsytf2_batched_full_rank(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytf2_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsytf2_batched_full_rank = rocsolver_dsytf2_batched_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dsytf2_batched_rank_0(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytf2_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsytf2_batched_rank_0 = rocsolver_dsytf2_batched_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dsytf2_batched_rank_1(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytf2_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsytf2_batched_rank_1 = rocsolver_dsytf2_batched_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_csytf2_batched_full_rank(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_csytf2_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_csytf2_batched_full_rank = rocsolver_csytf2_batched_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_csytf2_batched_rank_0(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_csytf2_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_csytf2_batched_rank_0 = rocsolver_csytf2_batched_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_csytf2_batched_rank_1(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_csytf2_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_csytf2_batched_rank_1 = rocsolver_csytf2_batched_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zsytf2_batched_full_rank(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zsytf2_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zsytf2_batched_full_rank = rocsolver_zsytf2_batched_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zsytf2_batched_rank_0(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zsytf2_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zsytf2_batched_rank_0 = rocsolver_zsytf2_batched_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zsytf2_batched_rank_1(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zsytf2_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zsytf2_batched_rank_1 = rocsolver_zsytf2_batched_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_ssytf2_strided_batched_full_rank(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytf2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssytf2_strided_batched_full_rank = rocsolver_ssytf2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_ssytf2_strided_batched_rank_0(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytf2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssytf2_strided_batched_rank_0 = rocsolver_ssytf2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_ssytf2_strided_batched_rank_1(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytf2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssytf2_strided_batched_rank_1 = rocsolver_ssytf2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dsytf2_strided_batched_full_rank(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytf2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsytf2_strided_batched_full_rank = rocsolver_dsytf2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dsytf2_strided_batched_rank_0(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytf2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsytf2_strided_batched_rank_0 = rocsolver_dsytf2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dsytf2_strided_batched_rank_1(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytf2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsytf2_strided_batched_rank_1 = rocsolver_dsytf2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_csytf2_strided_batched_full_rank(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_csytf2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_csytf2_strided_batched_full_rank = rocsolver_csytf2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_csytf2_strided_batched_rank_0(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_csytf2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_csytf2_strided_batched_rank_0 = rocsolver_csytf2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_csytf2_strided_batched_rank_1(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_csytf2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_csytf2_strided_batched_rank_1 = rocsolver_csytf2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zsytf2_strided_batched_full_rank(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zsytf2_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zsytf2_strided_batched_full_rank = rocsolver_zsytf2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zsytf2_strided_batched_rank_0(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zsytf2_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zsytf2_strided_batched_rank_0 = rocsolver_zsytf2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zsytf2_strided_batched_rank_1(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zsytf2_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zsytf2_strided_batched_rank_1 = rocsolver_zsytf2_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_ssytrf_full_rank(handle,uplo,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytrf_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_ssytrf_full_rank = rocsolver_ssytrf_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_ssytrf_rank_0(handle,uplo,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytrf_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_ssytrf_rank_0 = rocsolver_ssytrf_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_ssytrf_rank_1(handle,uplo,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytrf_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_ssytrf_rank_1 = rocsolver_ssytrf_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_dsytrf_full_rank(handle,uplo,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytrf_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_dsytrf_full_rank = rocsolver_dsytrf_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_dsytrf_rank_0(handle,uplo,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytrf_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_dsytrf_rank_0 = rocsolver_dsytrf_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_dsytrf_rank_1(handle,uplo,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytrf_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_dsytrf_rank_1 = rocsolver_dsytrf_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_csytrf_full_rank(handle,uplo,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_csytrf_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_csytrf_full_rank = rocsolver_csytrf_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_csytrf_rank_0(handle,uplo,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_csytrf_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_csytrf_rank_0 = rocsolver_csytrf_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_csytrf_rank_1(handle,uplo,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_csytrf_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_csytrf_rank_1 = rocsolver_csytrf_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_zsytrf_full_rank(handle,uplo,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zsytrf_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_zsytrf_full_rank = rocsolver_zsytrf_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_zsytrf_rank_0(handle,uplo,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zsytrf_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_zsytrf_rank_0 = rocsolver_zsytrf_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_zsytrf_rank_1(handle,uplo,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zsytrf_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      type(c_ptr) :: myInfo
      !
      rocsolver_zsytrf_rank_1 = rocsolver_zsytrf_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),myInfo)
    end function

    function rocsolver_ssytrf_batched_full_rank(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytrf_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssytrf_batched_full_rank = rocsolver_ssytrf_batched_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_ssytrf_batched_rank_0(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytrf_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssytrf_batched_rank_0 = rocsolver_ssytrf_batched_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_ssytrf_batched_rank_1(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytrf_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssytrf_batched_rank_1 = rocsolver_ssytrf_batched_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dsytrf_batched_full_rank(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytrf_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsytrf_batched_full_rank = rocsolver_dsytrf_batched_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dsytrf_batched_rank_0(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytrf_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsytrf_batched_rank_0 = rocsolver_dsytrf_batched_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dsytrf_batched_rank_1(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytrf_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsytrf_batched_rank_1 = rocsolver_dsytrf_batched_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_csytrf_batched_full_rank(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_csytrf_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_csytrf_batched_full_rank = rocsolver_csytrf_batched_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_csytrf_batched_rank_0(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_csytrf_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_csytrf_batched_rank_0 = rocsolver_csytrf_batched_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_csytrf_batched_rank_1(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_csytrf_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_csytrf_batched_rank_1 = rocsolver_csytrf_batched_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zsytrf_batched_full_rank(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zsytrf_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zsytrf_batched_full_rank = rocsolver_zsytrf_batched_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zsytrf_batched_rank_0(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zsytrf_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zsytrf_batched_rank_0 = rocsolver_zsytrf_batched_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zsytrf_batched_rank_1(handle,uplo,n,A,lda,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zsytrf_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zsytrf_batched_rank_1 = rocsolver_zsytrf_batched_(handle,uplo,n,c_loc(A),lda,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_ssytrf_strided_batched_full_rank(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytrf_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssytrf_strided_batched_full_rank = rocsolver_ssytrf_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_ssytrf_strided_batched_rank_0(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytrf_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssytrf_strided_batched_rank_0 = rocsolver_ssytrf_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_ssytrf_strided_batched_rank_1(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_ssytrf_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_ssytrf_strided_batched_rank_1 = rocsolver_ssytrf_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dsytrf_strided_batched_full_rank(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytrf_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsytrf_strided_batched_full_rank = rocsolver_dsytrf_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dsytrf_strided_batched_rank_0(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytrf_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsytrf_strided_batched_rank_0 = rocsolver_dsytrf_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_dsytrf_strided_batched_rank_1(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dsytrf_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dsytrf_strided_batched_rank_1 = rocsolver_dsytrf_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_csytrf_strided_batched_full_rank(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_csytrf_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_csytrf_strided_batched_full_rank = rocsolver_csytrf_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_csytrf_strided_batched_rank_0(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_csytrf_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_csytrf_strided_batched_rank_0 = rocsolver_csytrf_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_csytrf_strided_batched_rank_1(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_csytrf_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_csytrf_strided_batched_rank_1 = rocsolver_csytrf_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zsytrf_strided_batched_full_rank(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zsytrf_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zsytrf_strided_batched_full_rank = rocsolver_zsytrf_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zsytrf_strided_batched_rank_0(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zsytrf_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zsytrf_strided_batched_rank_0 = rocsolver_zsytrf_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_zsytrf_strided_batched_rank_1(handle,uplo,n,A,lda,strideA,ipiv,strideP,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zsytrf_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(kind(rocblas_fill_upper)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int),target,dimension(:) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zsytrf_strided_batched_rank_1 = rocsolver_zsytrf_strided_batched_(handle,uplo,n,c_loc(A),lda,strideA,c_loc(ipiv),strideP,myInfo,batch_count)
    end function

    function rocsolver_sgeblttrf_npvt_full_rank(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrf_npvt_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_sgeblttrf_npvt_full_rank = rocsolver_sgeblttrf_npvt_(handle,nb,nblocks,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_sgeblttrf_npvt_rank_0(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrf_npvt_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_sgeblttrf_npvt_rank_0 = rocsolver_sgeblttrf_npvt_(handle,nb,nblocks,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_sgeblttrf_npvt_rank_1(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrf_npvt_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_sgeblttrf_npvt_rank_1 = rocsolver_sgeblttrf_npvt_(handle,nb,nblocks,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_dgeblttrf_npvt_full_rank(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrf_npvt_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_dgeblttrf_npvt_full_rank = rocsolver_dgeblttrf_npvt_(handle,nb,nblocks,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_dgeblttrf_npvt_rank_0(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrf_npvt_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_dgeblttrf_npvt_rank_0 = rocsolver_dgeblttrf_npvt_(handle,nb,nblocks,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_dgeblttrf_npvt_rank_1(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrf_npvt_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_dgeblttrf_npvt_rank_1 = rocsolver_dgeblttrf_npvt_(handle,nb,nblocks,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_cgeblttrf_npvt_full_rank(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrf_npvt_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_cgeblttrf_npvt_full_rank = rocsolver_cgeblttrf_npvt_(handle,nb,nblocks,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_cgeblttrf_npvt_rank_0(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrf_npvt_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_cgeblttrf_npvt_rank_0 = rocsolver_cgeblttrf_npvt_(handle,nb,nblocks,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_cgeblttrf_npvt_rank_1(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrf_npvt_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_cgeblttrf_npvt_rank_1 = rocsolver_cgeblttrf_npvt_(handle,nb,nblocks,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_zgeblttrf_npvt_full_rank(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrf_npvt_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_zgeblttrf_npvt_full_rank = rocsolver_zgeblttrf_npvt_(handle,nb,nblocks,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_zgeblttrf_npvt_rank_0(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrf_npvt_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_zgeblttrf_npvt_rank_0 = rocsolver_zgeblttrf_npvt_(handle,nb,nblocks,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_zgeblttrf_npvt_rank_1(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrf_npvt_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      !
      rocsolver_zgeblttrf_npvt_rank_1 = rocsolver_zgeblttrf_npvt_(handle,nb,nblocks,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,myInfo)
    end function

    function rocsolver_sgeblttrf_npvt_batched_full_rank(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrf_npvt_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgeblttrf_npvt_batched_full_rank = rocsolver_sgeblttrf_npvt_batched_(handle,nb,nblocks,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_sgeblttrf_npvt_batched_rank_0(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrf_npvt_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgeblttrf_npvt_batched_rank_0 = rocsolver_sgeblttrf_npvt_batched_(handle,nb,nblocks,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_sgeblttrf_npvt_batched_rank_1(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrf_npvt_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgeblttrf_npvt_batched_rank_1 = rocsolver_sgeblttrf_npvt_batched_(handle,nb,nblocks,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_dgeblttrf_npvt_batched_full_rank(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrf_npvt_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgeblttrf_npvt_batched_full_rank = rocsolver_dgeblttrf_npvt_batched_(handle,nb,nblocks,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_dgeblttrf_npvt_batched_rank_0(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrf_npvt_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgeblttrf_npvt_batched_rank_0 = rocsolver_dgeblttrf_npvt_batched_(handle,nb,nblocks,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_dgeblttrf_npvt_batched_rank_1(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrf_npvt_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgeblttrf_npvt_batched_rank_1 = rocsolver_dgeblttrf_npvt_batched_(handle,nb,nblocks,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_cgeblttrf_npvt_batched_full_rank(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrf_npvt_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgeblttrf_npvt_batched_full_rank = rocsolver_cgeblttrf_npvt_batched_(handle,nb,nblocks,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_cgeblttrf_npvt_batched_rank_0(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrf_npvt_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgeblttrf_npvt_batched_rank_0 = rocsolver_cgeblttrf_npvt_batched_(handle,nb,nblocks,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_cgeblttrf_npvt_batched_rank_1(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrf_npvt_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgeblttrf_npvt_batched_rank_1 = rocsolver_cgeblttrf_npvt_batched_(handle,nb,nblocks,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_zgeblttrf_npvt_batched_full_rank(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrf_npvt_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgeblttrf_npvt_batched_full_rank = rocsolver_zgeblttrf_npvt_batched_(handle,nb,nblocks,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_zgeblttrf_npvt_batched_rank_0(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrf_npvt_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgeblttrf_npvt_batched_rank_0 = rocsolver_zgeblttrf_npvt_batched_(handle,nb,nblocks,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_zgeblttrf_npvt_batched_rank_1(handle,nb,nblocks,A,lda,B,ldb,C,ldc,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrf_npvt_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgeblttrf_npvt_batched_rank_1 = rocsolver_zgeblttrf_npvt_batched_(handle,nb,nblocks,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,myInfo,batch_count)
    end function

    function rocsolver_sgeblttrf_npvt_strided_batched_full_rank(handle,nb,nblocks,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrf_npvt_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgeblttrf_npvt_strided_batched_full_rank = rocsolver_sgeblttrf_npvt_strided_batched_(handle,nb,nblocks,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_sgeblttrf_npvt_strided_batched_rank_0(handle,nb,nblocks,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrf_npvt_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgeblttrf_npvt_strided_batched_rank_0 = rocsolver_sgeblttrf_npvt_strided_batched_(handle,nb,nblocks,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_sgeblttrf_npvt_strided_batched_rank_1(handle,nb,nblocks,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrf_npvt_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgeblttrf_npvt_strided_batched_rank_1 = rocsolver_sgeblttrf_npvt_strided_batched_(handle,nb,nblocks,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_dgeblttrf_npvt_strided_batched_full_rank(handle,nb,nblocks,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrf_npvt_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgeblttrf_npvt_strided_batched_full_rank = rocsolver_dgeblttrf_npvt_strided_batched_(handle,nb,nblocks,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_dgeblttrf_npvt_strided_batched_rank_0(handle,nb,nblocks,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrf_npvt_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgeblttrf_npvt_strided_batched_rank_0 = rocsolver_dgeblttrf_npvt_strided_batched_(handle,nb,nblocks,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_dgeblttrf_npvt_strided_batched_rank_1(handle,nb,nblocks,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrf_npvt_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgeblttrf_npvt_strided_batched_rank_1 = rocsolver_dgeblttrf_npvt_strided_batched_(handle,nb,nblocks,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_cgeblttrf_npvt_strided_batched_full_rank(handle,nb,nblocks,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrf_npvt_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgeblttrf_npvt_strided_batched_full_rank = rocsolver_cgeblttrf_npvt_strided_batched_(handle,nb,nblocks,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_cgeblttrf_npvt_strided_batched_rank_0(handle,nb,nblocks,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrf_npvt_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgeblttrf_npvt_strided_batched_rank_0 = rocsolver_cgeblttrf_npvt_strided_batched_(handle,nb,nblocks,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_cgeblttrf_npvt_strided_batched_rank_1(handle,nb,nblocks,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrf_npvt_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgeblttrf_npvt_strided_batched_rank_1 = rocsolver_cgeblttrf_npvt_strided_batched_(handle,nb,nblocks,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_zgeblttrf_npvt_strided_batched_full_rank(handle,nb,nblocks,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrf_npvt_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgeblttrf_npvt_strided_batched_full_rank = rocsolver_zgeblttrf_npvt_strided_batched_(handle,nb,nblocks,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_zgeblttrf_npvt_strided_batched_rank_0(handle,nb,nblocks,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrf_npvt_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgeblttrf_npvt_strided_batched_rank_0 = rocsolver_zgeblttrf_npvt_strided_batched_(handle,nb,nblocks,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_zgeblttrf_npvt_strided_batched_rank_1(handle,nb,nblocks,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrf_npvt_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgeblttrf_npvt_strided_batched_rank_1 = rocsolver_zgeblttrf_npvt_strided_batched_(handle,nb,nblocks,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_sgeblttrf_npvt_interleaved_batched_full_rank(handle,nb,nblocks,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrf_npvt_interleaved_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: inca
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: incb
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: incc
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgeblttrf_npvt_interleaved_batched_full_rank = rocsolver_sgeblttrf_npvt_interleaved_batched_(handle,nb,nblocks,c_loc(A),inca,lda,strideA,c_loc(B),incb,ldb,strideB,c_loc(C),incc,ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_sgeblttrf_npvt_interleaved_batched_rank_0(handle,nb,nblocks,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrf_npvt_interleaved_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      real(c_float),target :: A
      integer(c_int) :: inca
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: B
      integer(c_int) :: incb
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target :: C
      integer(c_int) :: incc
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgeblttrf_npvt_interleaved_batched_rank_0 = rocsolver_sgeblttrf_npvt_interleaved_batched_(handle,nb,nblocks,c_loc(A),inca,lda,strideA,c_loc(B),incb,ldb,strideB,c_loc(C),incc,ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_sgeblttrf_npvt_interleaved_batched_rank_1(handle,nb,nblocks,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrf_npvt_interleaved_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: inca
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: incb
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: incc
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_sgeblttrf_npvt_interleaved_batched_rank_1 = rocsolver_sgeblttrf_npvt_interleaved_batched_(handle,nb,nblocks,c_loc(A),inca,lda,strideA,c_loc(B),incb,ldb,strideB,c_loc(C),incc,ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_dgeblttrf_npvt_interleaved_batched_full_rank(handle,nb,nblocks,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrf_npvt_interleaved_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: inca
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: incb
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: incc
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgeblttrf_npvt_interleaved_batched_full_rank = rocsolver_dgeblttrf_npvt_interleaved_batched_(handle,nb,nblocks,c_loc(A),inca,lda,strideA,c_loc(B),incb,ldb,strideB,c_loc(C),incc,ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_dgeblttrf_npvt_interleaved_batched_rank_0(handle,nb,nblocks,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrf_npvt_interleaved_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      real(c_double),target :: A
      integer(c_int) :: inca
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: B
      integer(c_int) :: incb
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target :: C
      integer(c_int) :: incc
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgeblttrf_npvt_interleaved_batched_rank_0 = rocsolver_dgeblttrf_npvt_interleaved_batched_(handle,nb,nblocks,c_loc(A),inca,lda,strideA,c_loc(B),incb,ldb,strideB,c_loc(C),incc,ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_dgeblttrf_npvt_interleaved_batched_rank_1(handle,nb,nblocks,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrf_npvt_interleaved_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: inca
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: incb
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: incc
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_dgeblttrf_npvt_interleaved_batched_rank_1 = rocsolver_dgeblttrf_npvt_interleaved_batched_(handle,nb,nblocks,c_loc(A),inca,lda,strideA,c_loc(B),incb,ldb,strideB,c_loc(C),incc,ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_cgeblttrf_npvt_interleaved_batched_full_rank(handle,nb,nblocks,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrf_npvt_interleaved_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: inca
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: incb
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: incc
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgeblttrf_npvt_interleaved_batched_full_rank = rocsolver_cgeblttrf_npvt_interleaved_batched_(handle,nb,nblocks,c_loc(A),inca,lda,strideA,c_loc(B),incb,ldb,strideB,c_loc(C),incc,ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_cgeblttrf_npvt_interleaved_batched_rank_0(handle,nb,nblocks,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrf_npvt_interleaved_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      complex(c_float_complex),target :: A
      integer(c_int) :: inca
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: B
      integer(c_int) :: incb
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex),target :: C
      integer(c_int) :: incc
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgeblttrf_npvt_interleaved_batched_rank_0 = rocsolver_cgeblttrf_npvt_interleaved_batched_(handle,nb,nblocks,c_loc(A),inca,lda,strideA,c_loc(B),incb,ldb,strideB,c_loc(C),incc,ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_cgeblttrf_npvt_interleaved_batched_rank_1(handle,nb,nblocks,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrf_npvt_interleaved_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: inca
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: incb
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: incc
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_cgeblttrf_npvt_interleaved_batched_rank_1 = rocsolver_cgeblttrf_npvt_interleaved_batched_(handle,nb,nblocks,c_loc(A),inca,lda,strideA,c_loc(B),incb,ldb,strideB,c_loc(C),incc,ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_zgeblttrf_npvt_interleaved_batched_full_rank(handle,nb,nblocks,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrf_npvt_interleaved_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: inca
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: incb
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: incc
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgeblttrf_npvt_interleaved_batched_full_rank = rocsolver_zgeblttrf_npvt_interleaved_batched_(handle,nb,nblocks,c_loc(A),inca,lda,strideA,c_loc(B),incb,ldb,strideB,c_loc(C),incc,ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_zgeblttrf_npvt_interleaved_batched_rank_0(handle,nb,nblocks,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrf_npvt_interleaved_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      complex(c_double_complex),target :: A
      integer(c_int) :: inca
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: B
      integer(c_int) :: incb
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex),target :: C
      integer(c_int) :: incc
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgeblttrf_npvt_interleaved_batched_rank_0 = rocsolver_zgeblttrf_npvt_interleaved_batched_(handle,nb,nblocks,c_loc(A),inca,lda,strideA,c_loc(B),incb,ldb,strideB,c_loc(C),incc,ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_zgeblttrf_npvt_interleaved_batched_rank_1(handle,nb,nblocks,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,myInfo,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrf_npvt_interleaved_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: inca
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: incb
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: incc
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      type(c_ptr) :: myInfo
      integer(c_int) :: batch_count
      !
      rocsolver_zgeblttrf_npvt_interleaved_batched_rank_1 = rocsolver_zgeblttrf_npvt_interleaved_batched_(handle,nb,nblocks,c_loc(A),inca,lda,strideA,c_loc(B),incb,ldb,strideB,c_loc(C),incc,ldc,strideC,myInfo,batch_count)
    end function

    function rocsolver_sgeblttrs_npvt_full_rank(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrs_npvt_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      real(c_float),target,dimension(:,:) :: X
      integer(c_int) :: ldx
      !
      rocsolver_sgeblttrs_npvt_full_rank = rocsolver_sgeblttrs_npvt_(handle,nb,nblocks,nrhs,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,c_loc(X),ldx)
    end function

    function rocsolver_sgeblttrs_npvt_rank_0(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrs_npvt_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float),target :: C
      integer(c_int) :: ldc
      real(c_float),target :: X
      integer(c_int) :: ldx
      !
      rocsolver_sgeblttrs_npvt_rank_0 = rocsolver_sgeblttrs_npvt_(handle,nb,nblocks,nrhs,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,c_loc(X),ldx)
    end function

    function rocsolver_sgeblttrs_npvt_rank_1(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrs_npvt_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      real(c_float),target,dimension(:) :: X
      integer(c_int) :: ldx
      !
      rocsolver_sgeblttrs_npvt_rank_1 = rocsolver_sgeblttrs_npvt_(handle,nb,nblocks,nrhs,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,c_loc(X),ldx)
    end function

    function rocsolver_dgeblttrs_npvt_full_rank(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrs_npvt_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      real(c_double),target,dimension(:,:) :: X
      integer(c_int) :: ldx
      !
      rocsolver_dgeblttrs_npvt_full_rank = rocsolver_dgeblttrs_npvt_(handle,nb,nblocks,nrhs,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,c_loc(X),ldx)
    end function

    function rocsolver_dgeblttrs_npvt_rank_0(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrs_npvt_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double),target :: C
      integer(c_int) :: ldc
      real(c_double),target :: X
      integer(c_int) :: ldx
      !
      rocsolver_dgeblttrs_npvt_rank_0 = rocsolver_dgeblttrs_npvt_(handle,nb,nblocks,nrhs,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,c_loc(X),ldx)
    end function

    function rocsolver_dgeblttrs_npvt_rank_1(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrs_npvt_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      real(c_double),target,dimension(:) :: X
      integer(c_int) :: ldx
      !
      rocsolver_dgeblttrs_npvt_rank_1 = rocsolver_dgeblttrs_npvt_(handle,nb,nblocks,nrhs,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,c_loc(X),ldx)
    end function

    function rocsolver_cgeblttrs_npvt_full_rank(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrs_npvt_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      complex(c_float_complex),target,dimension(:,:) :: X
      integer(c_int) :: ldx
      !
      rocsolver_cgeblttrs_npvt_full_rank = rocsolver_cgeblttrs_npvt_(handle,nb,nblocks,nrhs,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,c_loc(X),ldx)
    end function

    function rocsolver_cgeblttrs_npvt_rank_0(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrs_npvt_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      complex(c_float_complex),target :: X
      integer(c_int) :: ldx
      !
      rocsolver_cgeblttrs_npvt_rank_0 = rocsolver_cgeblttrs_npvt_(handle,nb,nblocks,nrhs,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,c_loc(X),ldx)
    end function

    function rocsolver_cgeblttrs_npvt_rank_1(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrs_npvt_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      complex(c_float_complex),target,dimension(:) :: X
      integer(c_int) :: ldx
      !
      rocsolver_cgeblttrs_npvt_rank_1 = rocsolver_cgeblttrs_npvt_(handle,nb,nblocks,nrhs,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,c_loc(X),ldx)
    end function

    function rocsolver_zgeblttrs_npvt_full_rank(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrs_npvt_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      complex(c_double_complex),target,dimension(:,:) :: X
      integer(c_int) :: ldx
      !
      rocsolver_zgeblttrs_npvt_full_rank = rocsolver_zgeblttrs_npvt_(handle,nb,nblocks,nrhs,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,c_loc(X),ldx)
    end function

    function rocsolver_zgeblttrs_npvt_rank_0(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrs_npvt_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      complex(c_double_complex),target :: X
      integer(c_int) :: ldx
      !
      rocsolver_zgeblttrs_npvt_rank_0 = rocsolver_zgeblttrs_npvt_(handle,nb,nblocks,nrhs,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,c_loc(X),ldx)
    end function

    function rocsolver_zgeblttrs_npvt_rank_1(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrs_npvt_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      complex(c_double_complex),target,dimension(:) :: X
      integer(c_int) :: ldx
      !
      rocsolver_zgeblttrs_npvt_rank_1 = rocsolver_zgeblttrs_npvt_(handle,nb,nblocks,nrhs,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,c_loc(X),ldx)
    end function

    function rocsolver_sgeblttrs_npvt_batched_full_rank(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrs_npvt_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      real(c_float),target,dimension(:,:,:) :: X
      integer(c_int) :: ldx
      integer(c_int) :: batch_count
      !
      rocsolver_sgeblttrs_npvt_batched_full_rank = rocsolver_sgeblttrs_npvt_batched_(handle,nb,nblocks,nrhs,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,c_loc(X),ldx,batch_count)
    end function

    function rocsolver_sgeblttrs_npvt_batched_rank_0(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrs_npvt_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float),target :: C
      integer(c_int) :: ldc
      real(c_float),target :: X
      integer(c_int) :: ldx
      integer(c_int) :: batch_count
      !
      rocsolver_sgeblttrs_npvt_batched_rank_0 = rocsolver_sgeblttrs_npvt_batched_(handle,nb,nblocks,nrhs,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,c_loc(X),ldx,batch_count)
    end function

    function rocsolver_sgeblttrs_npvt_batched_rank_1(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrs_npvt_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      real(c_float),target,dimension(:) :: X
      integer(c_int) :: ldx
      integer(c_int) :: batch_count
      !
      rocsolver_sgeblttrs_npvt_batched_rank_1 = rocsolver_sgeblttrs_npvt_batched_(handle,nb,nblocks,nrhs,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,c_loc(X),ldx,batch_count)
    end function

    function rocsolver_dgeblttrs_npvt_batched_full_rank(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrs_npvt_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      real(c_double),target,dimension(:,:,:) :: X
      integer(c_int) :: ldx
      integer(c_int) :: batch_count
      !
      rocsolver_dgeblttrs_npvt_batched_full_rank = rocsolver_dgeblttrs_npvt_batched_(handle,nb,nblocks,nrhs,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,c_loc(X),ldx,batch_count)
    end function

    function rocsolver_dgeblttrs_npvt_batched_rank_0(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrs_npvt_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double),target :: C
      integer(c_int) :: ldc
      real(c_double),target :: X
      integer(c_int) :: ldx
      integer(c_int) :: batch_count
      !
      rocsolver_dgeblttrs_npvt_batched_rank_0 = rocsolver_dgeblttrs_npvt_batched_(handle,nb,nblocks,nrhs,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,c_loc(X),ldx,batch_count)
    end function

    function rocsolver_dgeblttrs_npvt_batched_rank_1(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrs_npvt_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      real(c_double),target,dimension(:) :: X
      integer(c_int) :: ldx
      integer(c_int) :: batch_count
      !
      rocsolver_dgeblttrs_npvt_batched_rank_1 = rocsolver_dgeblttrs_npvt_batched_(handle,nb,nblocks,nrhs,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,c_loc(X),ldx,batch_count)
    end function

    function rocsolver_cgeblttrs_npvt_batched_full_rank(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrs_npvt_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      complex(c_float_complex),target,dimension(:,:,:) :: X
      integer(c_int) :: ldx
      integer(c_int) :: batch_count
      !
      rocsolver_cgeblttrs_npvt_batched_full_rank = rocsolver_cgeblttrs_npvt_batched_(handle,nb,nblocks,nrhs,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,c_loc(X),ldx,batch_count)
    end function

    function rocsolver_cgeblttrs_npvt_batched_rank_0(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrs_npvt_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      complex(c_float_complex),target :: X
      integer(c_int) :: ldx
      integer(c_int) :: batch_count
      !
      rocsolver_cgeblttrs_npvt_batched_rank_0 = rocsolver_cgeblttrs_npvt_batched_(handle,nb,nblocks,nrhs,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,c_loc(X),ldx,batch_count)
    end function

    function rocsolver_cgeblttrs_npvt_batched_rank_1(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrs_npvt_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      complex(c_float_complex),target,dimension(:) :: X
      integer(c_int) :: ldx
      integer(c_int) :: batch_count
      !
      rocsolver_cgeblttrs_npvt_batched_rank_1 = rocsolver_cgeblttrs_npvt_batched_(handle,nb,nblocks,nrhs,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,c_loc(X),ldx,batch_count)
    end function

    function rocsolver_zgeblttrs_npvt_batched_full_rank(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrs_npvt_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      complex(c_double_complex),target,dimension(:,:,:) :: X
      integer(c_int) :: ldx
      integer(c_int) :: batch_count
      !
      rocsolver_zgeblttrs_npvt_batched_full_rank = rocsolver_zgeblttrs_npvt_batched_(handle,nb,nblocks,nrhs,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,c_loc(X),ldx,batch_count)
    end function

    function rocsolver_zgeblttrs_npvt_batched_rank_0(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrs_npvt_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      complex(c_double_complex),target :: X
      integer(c_int) :: ldx
      integer(c_int) :: batch_count
      !
      rocsolver_zgeblttrs_npvt_batched_rank_0 = rocsolver_zgeblttrs_npvt_batched_(handle,nb,nblocks,nrhs,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,c_loc(X),ldx,batch_count)
    end function

    function rocsolver_zgeblttrs_npvt_batched_rank_1(handle,nb,nblocks,nrhs,A,lda,B,ldb,C,ldc,X,ldx,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrs_npvt_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      complex(c_double_complex),target,dimension(:) :: X
      integer(c_int) :: ldx
      integer(c_int) :: batch_count
      !
      rocsolver_zgeblttrs_npvt_batched_rank_1 = rocsolver_zgeblttrs_npvt_batched_(handle,nb,nblocks,nrhs,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,c_loc(X),ldx,batch_count)
    end function

    function rocsolver_sgeblttrs_npvt_strided_batched_full_rank(handle,nb,nblocks,nrhs,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,X,ldx,strideX,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrs_npvt_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      real(c_float),target,dimension(:,:) :: X
      integer(c_int) :: ldx
      integer(c_int64_t) :: strideX
      integer(c_int) :: batch_count
      !
      rocsolver_sgeblttrs_npvt_strided_batched_full_rank = rocsolver_sgeblttrs_npvt_strided_batched_(handle,nb,nblocks,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,c_loc(X),ldx,strideX,batch_count)
    end function

    function rocsolver_sgeblttrs_npvt_strided_batched_rank_0(handle,nb,nblocks,nrhs,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,X,ldx,strideX,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrs_npvt_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      real(c_float),target :: X
      integer(c_int) :: ldx
      integer(c_int64_t) :: strideX
      integer(c_int) :: batch_count
      !
      rocsolver_sgeblttrs_npvt_strided_batched_rank_0 = rocsolver_sgeblttrs_npvt_strided_batched_(handle,nb,nblocks,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,c_loc(X),ldx,strideX,batch_count)
    end function

    function rocsolver_sgeblttrs_npvt_strided_batched_rank_1(handle,nb,nblocks,nrhs,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,X,ldx,strideX,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrs_npvt_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      real(c_float),target,dimension(:) :: X
      integer(c_int) :: ldx
      integer(c_int64_t) :: strideX
      integer(c_int) :: batch_count
      !
      rocsolver_sgeblttrs_npvt_strided_batched_rank_1 = rocsolver_sgeblttrs_npvt_strided_batched_(handle,nb,nblocks,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,c_loc(X),ldx,strideX,batch_count)
    end function

    function rocsolver_dgeblttrs_npvt_strided_batched_full_rank(handle,nb,nblocks,nrhs,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,X,ldx,strideX,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrs_npvt_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      real(c_double),target,dimension(:,:) :: X
      integer(c_int) :: ldx
      integer(c_int64_t) :: strideX
      integer(c_int) :: batch_count
      !
      rocsolver_dgeblttrs_npvt_strided_batched_full_rank = rocsolver_dgeblttrs_npvt_strided_batched_(handle,nb,nblocks,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,c_loc(X),ldx,strideX,batch_count)
    end function

    function rocsolver_dgeblttrs_npvt_strided_batched_rank_0(handle,nb,nblocks,nrhs,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,X,ldx,strideX,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrs_npvt_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      real(c_double),target :: X
      integer(c_int) :: ldx
      integer(c_int64_t) :: strideX
      integer(c_int) :: batch_count
      !
      rocsolver_dgeblttrs_npvt_strided_batched_rank_0 = rocsolver_dgeblttrs_npvt_strided_batched_(handle,nb,nblocks,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,c_loc(X),ldx,strideX,batch_count)
    end function

    function rocsolver_dgeblttrs_npvt_strided_batched_rank_1(handle,nb,nblocks,nrhs,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,X,ldx,strideX,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrs_npvt_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      real(c_double),target,dimension(:) :: X
      integer(c_int) :: ldx
      integer(c_int64_t) :: strideX
      integer(c_int) :: batch_count
      !
      rocsolver_dgeblttrs_npvt_strided_batched_rank_1 = rocsolver_dgeblttrs_npvt_strided_batched_(handle,nb,nblocks,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,c_loc(X),ldx,strideX,batch_count)
    end function

    function rocsolver_cgeblttrs_npvt_strided_batched_full_rank(handle,nb,nblocks,nrhs,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,X,ldx,strideX,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrs_npvt_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      complex(c_float_complex),target,dimension(:,:) :: X
      integer(c_int) :: ldx
      integer(c_int64_t) :: strideX
      integer(c_int) :: batch_count
      !
      rocsolver_cgeblttrs_npvt_strided_batched_full_rank = rocsolver_cgeblttrs_npvt_strided_batched_(handle,nb,nblocks,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,c_loc(X),ldx,strideX,batch_count)
    end function

    function rocsolver_cgeblttrs_npvt_strided_batched_rank_0(handle,nb,nblocks,nrhs,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,X,ldx,strideX,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrs_npvt_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      complex(c_float_complex),target :: X
      integer(c_int) :: ldx
      integer(c_int64_t) :: strideX
      integer(c_int) :: batch_count
      !
      rocsolver_cgeblttrs_npvt_strided_batched_rank_0 = rocsolver_cgeblttrs_npvt_strided_batched_(handle,nb,nblocks,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,c_loc(X),ldx,strideX,batch_count)
    end function

    function rocsolver_cgeblttrs_npvt_strided_batched_rank_1(handle,nb,nblocks,nrhs,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,X,ldx,strideX,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrs_npvt_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      complex(c_float_complex),target,dimension(:) :: X
      integer(c_int) :: ldx
      integer(c_int64_t) :: strideX
      integer(c_int) :: batch_count
      !
      rocsolver_cgeblttrs_npvt_strided_batched_rank_1 = rocsolver_cgeblttrs_npvt_strided_batched_(handle,nb,nblocks,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,c_loc(X),ldx,strideX,batch_count)
    end function

    function rocsolver_zgeblttrs_npvt_strided_batched_full_rank(handle,nb,nblocks,nrhs,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,X,ldx,strideX,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrs_npvt_strided_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      complex(c_double_complex),target,dimension(:,:) :: X
      integer(c_int) :: ldx
      integer(c_int64_t) :: strideX
      integer(c_int) :: batch_count
      !
      rocsolver_zgeblttrs_npvt_strided_batched_full_rank = rocsolver_zgeblttrs_npvt_strided_batched_(handle,nb,nblocks,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,c_loc(X),ldx,strideX,batch_count)
    end function

    function rocsolver_zgeblttrs_npvt_strided_batched_rank_0(handle,nb,nblocks,nrhs,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,X,ldx,strideX,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrs_npvt_strided_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      complex(c_double_complex),target :: X
      integer(c_int) :: ldx
      integer(c_int64_t) :: strideX
      integer(c_int) :: batch_count
      !
      rocsolver_zgeblttrs_npvt_strided_batched_rank_0 = rocsolver_zgeblttrs_npvt_strided_batched_(handle,nb,nblocks,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,c_loc(X),ldx,strideX,batch_count)
    end function

    function rocsolver_zgeblttrs_npvt_strided_batched_rank_1(handle,nb,nblocks,nrhs,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,X,ldx,strideX,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrs_npvt_strided_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      complex(c_double_complex),target,dimension(:) :: X
      integer(c_int) :: ldx
      integer(c_int64_t) :: strideX
      integer(c_int) :: batch_count
      !
      rocsolver_zgeblttrs_npvt_strided_batched_rank_1 = rocsolver_zgeblttrs_npvt_strided_batched_(handle,nb,nblocks,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,c_loc(X),ldx,strideX,batch_count)
    end function

    function rocsolver_sgeblttrs_npvt_interleaved_batched_full_rank(handle,nb,nblocks,nrhs,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,X,incx,ldx,strideX,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrs_npvt_interleaved_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: inca
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: incb
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: incc
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      real(c_float),target,dimension(:,:) :: X
      integer(c_int) :: incx
      integer(c_int) :: ldx
      integer(c_int64_t) :: strideX
      integer(c_int) :: batch_count
      !
      rocsolver_sgeblttrs_npvt_interleaved_batched_full_rank = rocsolver_sgeblttrs_npvt_interleaved_batched_(handle,nb,nblocks,nrhs,c_loc(A),inca,lda,strideA,c_loc(B),incb,ldb,strideB,c_loc(C),incc,ldc,strideC,c_loc(X),incx,ldx,strideX,batch_count)
    end function

    function rocsolver_sgeblttrs_npvt_interleaved_batched_rank_0(handle,nb,nblocks,nrhs,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,X,incx,ldx,strideX,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrs_npvt_interleaved_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      real(c_float),target :: A
      integer(c_int) :: inca
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: B
      integer(c_int) :: incb
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target :: C
      integer(c_int) :: incc
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      real(c_float),target :: X
      integer(c_int) :: incx
      integer(c_int) :: ldx
      integer(c_int64_t) :: strideX
      integer(c_int) :: batch_count
      !
      rocsolver_sgeblttrs_npvt_interleaved_batched_rank_0 = rocsolver_sgeblttrs_npvt_interleaved_batched_(handle,nb,nblocks,nrhs,c_loc(A),inca,lda,strideA,c_loc(B),incb,ldb,strideB,c_loc(C),incc,ldc,strideC,c_loc(X),incx,ldx,strideX,batch_count)
    end function

    function rocsolver_sgeblttrs_npvt_interleaved_batched_rank_1(handle,nb,nblocks,nrhs,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,X,incx,ldx,strideX,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_sgeblttrs_npvt_interleaved_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: inca
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: incb
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: incc
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      real(c_float),target,dimension(:) :: X
      integer(c_int) :: incx
      integer(c_int) :: ldx
      integer(c_int64_t) :: strideX
      integer(c_int) :: batch_count
      !
      rocsolver_sgeblttrs_npvt_interleaved_batched_rank_1 = rocsolver_sgeblttrs_npvt_interleaved_batched_(handle,nb,nblocks,nrhs,c_loc(A),inca,lda,strideA,c_loc(B),incb,ldb,strideB,c_loc(C),incc,ldc,strideC,c_loc(X),incx,ldx,strideX,batch_count)
    end function

    function rocsolver_dgeblttrs_npvt_interleaved_batched_full_rank(handle,nb,nblocks,nrhs,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,X,incx,ldx,strideX,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrs_npvt_interleaved_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: inca
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: incb
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: incc
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      real(c_double),target,dimension(:,:) :: X
      integer(c_int) :: incx
      integer(c_int) :: ldx
      integer(c_int64_t) :: strideX
      integer(c_int) :: batch_count
      !
      rocsolver_dgeblttrs_npvt_interleaved_batched_full_rank = rocsolver_dgeblttrs_npvt_interleaved_batched_(handle,nb,nblocks,nrhs,c_loc(A),inca,lda,strideA,c_loc(B),incb,ldb,strideB,c_loc(C),incc,ldc,strideC,c_loc(X),incx,ldx,strideX,batch_count)
    end function

    function rocsolver_dgeblttrs_npvt_interleaved_batched_rank_0(handle,nb,nblocks,nrhs,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,X,incx,ldx,strideX,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrs_npvt_interleaved_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      real(c_double),target :: A
      integer(c_int) :: inca
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: B
      integer(c_int) :: incb
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target :: C
      integer(c_int) :: incc
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      real(c_double),target :: X
      integer(c_int) :: incx
      integer(c_int) :: ldx
      integer(c_int64_t) :: strideX
      integer(c_int) :: batch_count
      !
      rocsolver_dgeblttrs_npvt_interleaved_batched_rank_0 = rocsolver_dgeblttrs_npvt_interleaved_batched_(handle,nb,nblocks,nrhs,c_loc(A),inca,lda,strideA,c_loc(B),incb,ldb,strideB,c_loc(C),incc,ldc,strideC,c_loc(X),incx,ldx,strideX,batch_count)
    end function

    function rocsolver_dgeblttrs_npvt_interleaved_batched_rank_1(handle,nb,nblocks,nrhs,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,X,incx,ldx,strideX,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dgeblttrs_npvt_interleaved_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: inca
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: incb
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: incc
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      real(c_double),target,dimension(:) :: X
      integer(c_int) :: incx
      integer(c_int) :: ldx
      integer(c_int64_t) :: strideX
      integer(c_int) :: batch_count
      !
      rocsolver_dgeblttrs_npvt_interleaved_batched_rank_1 = rocsolver_dgeblttrs_npvt_interleaved_batched_(handle,nb,nblocks,nrhs,c_loc(A),inca,lda,strideA,c_loc(B),incb,ldb,strideB,c_loc(C),incc,ldc,strideC,c_loc(X),incx,ldx,strideX,batch_count)
    end function

    function rocsolver_cgeblttrs_npvt_interleaved_batched_full_rank(handle,nb,nblocks,nrhs,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,X,incx,ldx,strideX,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrs_npvt_interleaved_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: inca
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: incb
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: incc
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      complex(c_float_complex),target,dimension(:,:) :: X
      integer(c_int) :: incx
      integer(c_int) :: ldx
      integer(c_int64_t) :: strideX
      integer(c_int) :: batch_count
      !
      rocsolver_cgeblttrs_npvt_interleaved_batched_full_rank = rocsolver_cgeblttrs_npvt_interleaved_batched_(handle,nb,nblocks,nrhs,c_loc(A),inca,lda,strideA,c_loc(B),incb,ldb,strideB,c_loc(C),incc,ldc,strideC,c_loc(X),incx,ldx,strideX,batch_count)
    end function

    function rocsolver_cgeblttrs_npvt_interleaved_batched_rank_0(handle,nb,nblocks,nrhs,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,X,incx,ldx,strideX,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrs_npvt_interleaved_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: inca
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: B
      integer(c_int) :: incb
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex),target :: C
      integer(c_int) :: incc
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      complex(c_float_complex),target :: X
      integer(c_int) :: incx
      integer(c_int) :: ldx
      integer(c_int64_t) :: strideX
      integer(c_int) :: batch_count
      !
      rocsolver_cgeblttrs_npvt_interleaved_batched_rank_0 = rocsolver_cgeblttrs_npvt_interleaved_batched_(handle,nb,nblocks,nrhs,c_loc(A),inca,lda,strideA,c_loc(B),incb,ldb,strideB,c_loc(C),incc,ldc,strideC,c_loc(X),incx,ldx,strideX,batch_count)
    end function

    function rocsolver_cgeblttrs_npvt_interleaved_batched_rank_1(handle,nb,nblocks,nrhs,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,X,incx,ldx,strideX,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_cgeblttrs_npvt_interleaved_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: inca
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: incb
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: incc
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      complex(c_float_complex),target,dimension(:) :: X
      integer(c_int) :: incx
      integer(c_int) :: ldx
      integer(c_int64_t) :: strideX
      integer(c_int) :: batch_count
      !
      rocsolver_cgeblttrs_npvt_interleaved_batched_rank_1 = rocsolver_cgeblttrs_npvt_interleaved_batched_(handle,nb,nblocks,nrhs,c_loc(A),inca,lda,strideA,c_loc(B),incb,ldb,strideB,c_loc(C),incc,ldc,strideC,c_loc(X),incx,ldx,strideX,batch_count)
    end function

    function rocsolver_zgeblttrs_npvt_interleaved_batched_full_rank(handle,nb,nblocks,nrhs,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,X,incx,ldx,strideX,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrs_npvt_interleaved_batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: inca
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: incb
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: incc
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      complex(c_double_complex),target,dimension(:,:) :: X
      integer(c_int) :: incx
      integer(c_int) :: ldx
      integer(c_int64_t) :: strideX
      integer(c_int) :: batch_count
      !
      rocsolver_zgeblttrs_npvt_interleaved_batched_full_rank = rocsolver_zgeblttrs_npvt_interleaved_batched_(handle,nb,nblocks,nrhs,c_loc(A),inca,lda,strideA,c_loc(B),incb,ldb,strideB,c_loc(C),incc,ldc,strideC,c_loc(X),incx,ldx,strideX,batch_count)
    end function

    function rocsolver_zgeblttrs_npvt_interleaved_batched_rank_0(handle,nb,nblocks,nrhs,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,X,incx,ldx,strideX,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrs_npvt_interleaved_batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: inca
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: B
      integer(c_int) :: incb
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex),target :: C
      integer(c_int) :: incc
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      complex(c_double_complex),target :: X
      integer(c_int) :: incx
      integer(c_int) :: ldx
      integer(c_int64_t) :: strideX
      integer(c_int) :: batch_count
      !
      rocsolver_zgeblttrs_npvt_interleaved_batched_rank_0 = rocsolver_zgeblttrs_npvt_interleaved_batched_(handle,nb,nblocks,nrhs,c_loc(A),inca,lda,strideA,c_loc(B),incb,ldb,strideB,c_loc(C),incc,ldc,strideC,c_loc(X),incx,ldx,strideX,batch_count)
    end function

    function rocsolver_zgeblttrs_npvt_interleaved_batched_rank_1(handle,nb,nblocks,nrhs,A,inca,lda,strideA,B,incb,ldb,strideB,C,incc,ldc,strideC,X,incx,ldx,strideX,batch_count)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_zgeblttrs_npvt_interleaved_batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: nb
      integer(c_int) :: nblocks
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: inca
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: incb
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: incc
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      complex(c_double_complex),target,dimension(:) :: X
      integer(c_int) :: incx
      integer(c_int) :: ldx
      integer(c_int64_t) :: strideX
      integer(c_int) :: batch_count
      !
      rocsolver_zgeblttrs_npvt_interleaved_batched_rank_1 = rocsolver_zgeblttrs_npvt_interleaved_batched_(handle,nb,nblocks,nrhs,c_loc(A),inca,lda,strideA,c_loc(B),incb,ldb,strideB,c_loc(C),incc,ldc,strideC,c_loc(X),incx,ldx,strideX,batch_count)
    end function

    function rocsolver_scsrrf_analysis_full_rank(handle,n,nrhs,nnzM,ptrM,indM,valM,nnzT,ptrT,indT,valT,pivP,pivQ,B,ldb,rfinfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_scsrrf_analysis_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      integer(c_int) :: nnzM
      type(c_ptr) :: ptrM
      type(c_ptr) :: indM
      type(c_ptr) :: valM
      integer(c_int) :: nnzT
      type(c_ptr) :: ptrT
      type(c_ptr) :: indT
      type(c_ptr) :: valT
      type(c_ptr) :: pivP
      type(c_ptr) :: pivQ
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: rfinfo
      !
      rocsolver_scsrrf_analysis_full_rank = rocsolver_scsrrf_analysis_(handle,n,nrhs,nnzM,ptrM,indM,valM,nnzT,ptrT,indT,valT,pivP,pivQ,c_loc(B),ldb,rfinfo)
    end function

    function rocsolver_scsrrf_analysis_rank_0(handle,n,nrhs,nnzM,ptrM,indM,valM,nnzT,ptrT,indT,valT,pivP,pivQ,B,ldb,rfinfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_scsrrf_analysis_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      integer(c_int) :: nnzM
      type(c_ptr) :: ptrM
      type(c_ptr) :: indM
      type(c_ptr) :: valM
      integer(c_int) :: nnzT
      type(c_ptr) :: ptrT
      type(c_ptr) :: indT
      type(c_ptr) :: valT
      type(c_ptr) :: pivP
      type(c_ptr) :: pivQ
      real(c_float),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: rfinfo
      !
      rocsolver_scsrrf_analysis_rank_0 = rocsolver_scsrrf_analysis_(handle,n,nrhs,nnzM,ptrM,indM,valM,nnzT,ptrT,indT,valT,pivP,pivQ,c_loc(B),ldb,rfinfo)
    end function

    function rocsolver_scsrrf_analysis_rank_1(handle,n,nrhs,nnzM,ptrM,indM,valM,nnzT,ptrT,indT,valT,pivP,pivQ,B,ldb,rfinfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_scsrrf_analysis_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      integer(c_int) :: nnzM
      type(c_ptr) :: ptrM
      type(c_ptr) :: indM
      type(c_ptr) :: valM
      integer(c_int) :: nnzT
      type(c_ptr) :: ptrT
      type(c_ptr) :: indT
      type(c_ptr) :: valT
      type(c_ptr) :: pivP
      type(c_ptr) :: pivQ
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: rfinfo
      !
      rocsolver_scsrrf_analysis_rank_1 = rocsolver_scsrrf_analysis_(handle,n,nrhs,nnzM,ptrM,indM,valM,nnzT,ptrT,indT,valT,pivP,pivQ,c_loc(B),ldb,rfinfo)
    end function

    function rocsolver_dcsrrf_analysis_full_rank(handle,n,nrhs,nnzM,ptrM,indM,valM,nnzT,ptrT,indT,valT,pivP,pivQ,B,ldb,rfinfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dcsrrf_analysis_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      integer(c_int) :: nnzM
      type(c_ptr) :: ptrM
      type(c_ptr) :: indM
      type(c_ptr) :: valM
      integer(c_int) :: nnzT
      type(c_ptr) :: ptrT
      type(c_ptr) :: indT
      type(c_ptr) :: valT
      type(c_ptr) :: pivP
      type(c_ptr) :: pivQ
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: rfinfo
      !
      rocsolver_dcsrrf_analysis_full_rank = rocsolver_dcsrrf_analysis_(handle,n,nrhs,nnzM,ptrM,indM,valM,nnzT,ptrT,indT,valT,pivP,pivQ,c_loc(B),ldb,rfinfo)
    end function

    function rocsolver_dcsrrf_analysis_rank_0(handle,n,nrhs,nnzM,ptrM,indM,valM,nnzT,ptrT,indT,valT,pivP,pivQ,B,ldb,rfinfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dcsrrf_analysis_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      integer(c_int) :: nnzM
      type(c_ptr) :: ptrM
      type(c_ptr) :: indM
      type(c_ptr) :: valM
      integer(c_int) :: nnzT
      type(c_ptr) :: ptrT
      type(c_ptr) :: indT
      type(c_ptr) :: valT
      type(c_ptr) :: pivP
      type(c_ptr) :: pivQ
      real(c_double),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: rfinfo
      !
      rocsolver_dcsrrf_analysis_rank_0 = rocsolver_dcsrrf_analysis_(handle,n,nrhs,nnzM,ptrM,indM,valM,nnzT,ptrT,indT,valT,pivP,pivQ,c_loc(B),ldb,rfinfo)
    end function

    function rocsolver_dcsrrf_analysis_rank_1(handle,n,nrhs,nnzM,ptrM,indM,valM,nnzT,ptrT,indT,valT,pivP,pivQ,B,ldb,rfinfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dcsrrf_analysis_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      integer(c_int) :: nnzM
      type(c_ptr) :: ptrM
      type(c_ptr) :: indM
      type(c_ptr) :: valM
      integer(c_int) :: nnzT
      type(c_ptr) :: ptrT
      type(c_ptr) :: indT
      type(c_ptr) :: valT
      type(c_ptr) :: pivP
      type(c_ptr) :: pivQ
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: rfinfo
      !
      rocsolver_dcsrrf_analysis_rank_1 = rocsolver_dcsrrf_analysis_(handle,n,nrhs,nnzM,ptrM,indM,valM,nnzT,ptrT,indT,valT,pivP,pivQ,c_loc(B),ldb,rfinfo)
    end function

    function rocsolver_scsrrf_solve_full_rank(handle,n,nrhs,nnzT,ptrT,indT,valT,pivP,pivQ,B,ldb,rfinfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_scsrrf_solve_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      integer(c_int) :: nnzT
      type(c_ptr) :: ptrT
      type(c_ptr) :: indT
      type(c_ptr) :: valT
      type(c_ptr) :: pivP
      type(c_ptr) :: pivQ
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: rfinfo
      !
      rocsolver_scsrrf_solve_full_rank = rocsolver_scsrrf_solve_(handle,n,nrhs,nnzT,ptrT,indT,valT,pivP,pivQ,c_loc(B),ldb,rfinfo)
    end function

    function rocsolver_scsrrf_solve_rank_0(handle,n,nrhs,nnzT,ptrT,indT,valT,pivP,pivQ,B,ldb,rfinfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_scsrrf_solve_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      integer(c_int) :: nnzT
      type(c_ptr) :: ptrT
      type(c_ptr) :: indT
      type(c_ptr) :: valT
      type(c_ptr) :: pivP
      type(c_ptr) :: pivQ
      real(c_float),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: rfinfo
      !
      rocsolver_scsrrf_solve_rank_0 = rocsolver_scsrrf_solve_(handle,n,nrhs,nnzT,ptrT,indT,valT,pivP,pivQ,c_loc(B),ldb,rfinfo)
    end function

    function rocsolver_scsrrf_solve_rank_1(handle,n,nrhs,nnzT,ptrT,indT,valT,pivP,pivQ,B,ldb,rfinfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_scsrrf_solve_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      integer(c_int) :: nnzT
      type(c_ptr) :: ptrT
      type(c_ptr) :: indT
      type(c_ptr) :: valT
      type(c_ptr) :: pivP
      type(c_ptr) :: pivQ
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: rfinfo
      !
      rocsolver_scsrrf_solve_rank_1 = rocsolver_scsrrf_solve_(handle,n,nrhs,nnzT,ptrT,indT,valT,pivP,pivQ,c_loc(B),ldb,rfinfo)
    end function

    function rocsolver_dcsrrf_solve_full_rank(handle,n,nrhs,nnzT,ptrT,indT,valT,pivP,pivQ,B,ldb,rfinfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dcsrrf_solve_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      integer(c_int) :: nnzT
      type(c_ptr) :: ptrT
      type(c_ptr) :: indT
      type(c_ptr) :: valT
      type(c_ptr) :: pivP
      type(c_ptr) :: pivQ
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: rfinfo
      !
      rocsolver_dcsrrf_solve_full_rank = rocsolver_dcsrrf_solve_(handle,n,nrhs,nnzT,ptrT,indT,valT,pivP,pivQ,c_loc(B),ldb,rfinfo)
    end function

    function rocsolver_dcsrrf_solve_rank_0(handle,n,nrhs,nnzT,ptrT,indT,valT,pivP,pivQ,B,ldb,rfinfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dcsrrf_solve_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      integer(c_int) :: nnzT
      type(c_ptr) :: ptrT
      type(c_ptr) :: indT
      type(c_ptr) :: valT
      type(c_ptr) :: pivP
      type(c_ptr) :: pivQ
      real(c_double),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: rfinfo
      !
      rocsolver_dcsrrf_solve_rank_0 = rocsolver_dcsrrf_solve_(handle,n,nrhs,nnzT,ptrT,indT,valT,pivP,pivQ,c_loc(B),ldb,rfinfo)
    end function

    function rocsolver_dcsrrf_solve_rank_1(handle,n,nrhs,nnzT,ptrT,indT,valT,pivP,pivQ,B,ldb,rfinfo)
      use iso_c_binding
      use hipfort_rocsolver_enums
      use hipfort_rocblas_enums
      implicit none
      integer(kind(rocblas_status_success)) :: rocsolver_dcsrrf_solve_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      integer(c_int) :: nrhs
      integer(c_int) :: nnzT
      type(c_ptr) :: ptrT
      type(c_ptr) :: indT
      type(c_ptr) :: valT
      type(c_ptr) :: pivP
      type(c_ptr) :: pivQ
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: rfinfo
      !
      rocsolver_dcsrrf_solve_rank_1 = rocsolver_dcsrrf_solve_(handle,n,nrhs,nnzT,ptrT,indT,valT,pivP,pivQ,c_loc(B),ldb,rfinfo)
    end function

  
#endif
end module hipfort_rocsolver