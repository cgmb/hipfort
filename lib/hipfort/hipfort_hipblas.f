!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! ==============================================================================
! hipfort: FORTRAN Interfaces for GPU kernels
! ==============================================================================
! Copyright (c) 2021 Advanced Micro Devices, Inc. All rights reserved.
! [MITx11 License]
! 
! Permission is hereby granted, free of charge, to any person obtaining a copy
! of this software and associated documentation files (the "Software"), to deal
! in the Software without restriction, including without limitation the rights
! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
! copies of the Software, and to permit persons to whom the Software is
! furnished to do so, subject to the following conditions:
! 
! The above copyright notice and this permission notice shall be included in
! all copies or substantial portions of the Software.
! 
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
! THE SOFTWARE.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
          
           
module hipfort_hipblas
  use hipfort_hipblas_enums
  use hipfort_hipblas_auxiliary
  implicit none

 
  !> ! \brief Create hipblas handle. 
  interface hipblasCreate
#ifdef USE_CUDA_NAMES
    function hipblasCreate_(handle) bind(c, name="cublasCreate_v2")
#else
    function hipblasCreate_(handle) bind(c, name="hipblasCreate")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCreate_
      type(c_ptr) :: handle
    end function


  end interface
  !> ! \brief Destroys the library context created using hipblasCreate() 
  interface hipblasDestroy
#ifdef USE_CUDA_NAMES
    function hipblasDestroy_(handle) bind(c, name="cublasDestroy_v2")
#else
    function hipblasDestroy_(handle) bind(c, name="hipblasDestroy")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDestroy_
      type(c_ptr),value :: handle
    end function


  end interface
  !> ! \brief Set stream for handle 
  interface hipblasSetStream
#ifdef USE_CUDA_NAMES
    function hipblasSetStream_(handle,streamId) bind(c, name="cublasSetStream_v2")
#else
    function hipblasSetStream_(handle,streamId) bind(c, name="hipblasSetStream")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSetStream_
      type(c_ptr),value :: handle
      type(c_ptr),value :: streamId
    end function


  end interface
  !> ! \brief Get stream[0] for handle 
  interface hipblasGetStream
#ifdef USE_CUDA_NAMES
    function hipblasGetStream_(handle,streamId) bind(c, name="cublasGetStream_v2")
#else
    function hipblasGetStream_(handle,streamId) bind(c, name="hipblasGetStream")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasGetStream_
      type(c_ptr),value :: handle
      type(c_ptr) :: streamId
    end function


  end interface
  !> ! \brief Set hipblas pointer mode 
  interface hipblasSetPointerMode
#ifdef USE_CUDA_NAMES
    function hipblasSetPointerMode_(handle,mode) bind(c, name="cublasSetPointerMode_v2")
#else
    function hipblasSetPointerMode_(handle,mode) bind(c, name="hipblasSetPointerMode")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSetPointerMode_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_POINTER_MODE_HOST)),value :: mode
    end function


  end interface
  !> ! \brief Get hipblas pointer mode 
  interface hipblasGetPointerMode
#ifdef USE_CUDA_NAMES
    function hipblasGetPointerMode_(handle,mode) bind(c, name="cublasGetPointerMode_v2")
#else
    function hipblasGetPointerMode_(handle,mode) bind(c, name="hipblasGetPointerMode")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasGetPointerMode_
      type(c_ptr),value :: handle
      type(c_ptr),value :: mode
    end function


  end interface
  !> ! \brief Set hipblasSetAtomicsMode
  interface hipblasSetAtomicsMode
#ifdef USE_CUDA_NAMES
    function hipblasSetAtomicsMode_(handle,atomics_mode) bind(c, name="cublasSetAtomicsMode")
#else
    function hipblasSetAtomicsMode_(handle,atomics_mode) bind(c, name="hipblasSetAtomicsMode")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSetAtomicsMode_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_ATOMICS_NOT_ALLOWED)),value :: atomics_mode
    end function


  end interface
  !> ! \brief Get hipblasSetAtomicsMode
  interface hipblasGetAtomicsMode
#ifdef USE_CUDA_NAMES
    function hipblasGetAtomicsMode_(handle,atomics_mode) bind(c, name="cublasGetAtomicsMode")
#else
    function hipblasGetAtomicsMode_(handle,atomics_mode) bind(c, name="hipblasGetAtomicsMode")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasGetAtomicsMode_
      type(c_ptr),value :: handle
      type(c_ptr),value :: atomics_mode
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     amax finds the first index of the element of maximum magnitude of a vector x.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z.
  !>     - Supported precisions in cuBLAS  : s,d,c,z.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in x.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     result
  !>               device pointer or host pointer to store the amax index.
  !>               return is 0.0 if n, incx<=0.
  !>     
  interface hipblasIsamax
#ifdef USE_CUDA_NAMES
    function hipblasIsamax_(handle,n,x,incx,myResult) bind(c, name="cublasIsamax_v2")
#else
    function hipblasIsamax_(handle,n,x,incx,myResult) bind(c, name="hipblasIsamax")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsamax_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIsamax_rank_0,&
      
hipblasIsamax_rank_1
#endif

  end interface
  
  interface hipblasIdamax
#ifdef USE_CUDA_NAMES
    function hipblasIdamax_(handle,n,x,incx,myResult) bind(c, name="cublasIdamax_v2")
#else
    function hipblasIdamax_(handle,n,x,incx,myResult) bind(c, name="hipblasIdamax")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdamax_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIdamax_rank_0,&
      
hipblasIdamax_rank_1
#endif

  end interface
  
  interface hipblasIcamax
#ifdef USE_CUDA_NAMES
    function hipblasIcamax_(handle,n,x,incx,myResult) bind(c, name="cublasIcamax_v2")
#else
    function hipblasIcamax_(handle,n,x,incx,myResult) bind(c, name="hipblasIcamax")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamax_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIcamax_rank_0,&
      
hipblasIcamax_rank_1
#endif

  end interface
  
  interface hipblasIzamax
#ifdef USE_CUDA_NAMES
    function hipblasIzamax_(handle,n,x,incx,myResult) bind(c, name="cublasIzamax_v2")
#else
    function hipblasIzamax_(handle,n,x,incx,myResult) bind(c, name="hipblasIzamax")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamax_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIzamax_rank_0,&
      
hipblasIzamax_rank_1
#endif

  end interface
  
  interface hipblasIcamax_v2
#ifdef USE_CUDA_NAMES
    function hipblasIcamax_v2_(handle,n,x,incx,myResult) bind(c, name="cublasIcamax_v2")
#else
    function hipblasIcamax_v2_(handle,n,x,incx,myResult) bind(c, name="hipblasIcamax_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamax_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIcamax_v2_rank_0,&
      
hipblasIcamax_v2_rank_1
#endif

  end interface
  
  interface hipblasIzamax_v2
#ifdef USE_CUDA_NAMES
    function hipblasIzamax_v2_(handle,n,x,incx,myResult) bind(c, name="cublasIzamax_v2")
#else
    function hipblasIzamax_v2_(handle,n,x,incx,myResult) bind(c, name="hipblasIzamax_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamax_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIzamax_v2_rank_0,&
      
hipblasIzamax_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>      amaxBatched finds the first index of the element of maximum magnitude of each vector x_i in a batch, for i = 1, ..., batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z.
  !>     - Supported precisions in cuBLAS  : No support.
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               number of elements in each vector x_i
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     batchCount [int]
  !>               number of instances in the batch, must be > 0.
  !>     @param[out]
  !>     result
  !>               device or host array of pointers of batchCount size for results.
  !>               return is 0 if n, incx<=0.
  !>     
  interface hipblasIsamaxBatched
#ifdef USE_CUDA_NAMES
    function hipblasIsamaxBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasIsamaxBatched")
#else
    function hipblasIsamaxBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasIsamaxBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsamaxBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIsamaxBatched_full_rank,&
      
hipblasIsamaxBatched_rank_0,&
      
hipblasIsamaxBatched_rank_1
#endif

  end interface
  
  interface hipblasIdamaxBatched
#ifdef USE_CUDA_NAMES
    function hipblasIdamaxBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasIdamaxBatched")
#else
    function hipblasIdamaxBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasIdamaxBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdamaxBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIdamaxBatched_full_rank,&
      
hipblasIdamaxBatched_rank_0,&
      
hipblasIdamaxBatched_rank_1
#endif

  end interface
  
  interface hipblasIcamaxBatched
#ifdef USE_CUDA_NAMES
    function hipblasIcamaxBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasIcamaxBatched")
#else
    function hipblasIcamaxBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasIcamaxBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamaxBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIcamaxBatched_full_rank,&
      
hipblasIcamaxBatched_rank_0,&
      
hipblasIcamaxBatched_rank_1
#endif

  end interface
  
  interface hipblasIzamaxBatched
#ifdef USE_CUDA_NAMES
    function hipblasIzamaxBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasIzamaxBatched")
#else
    function hipblasIzamaxBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasIzamaxBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamaxBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIzamaxBatched_full_rank,&
      
hipblasIzamaxBatched_rank_0,&
      
hipblasIzamaxBatched_rank_1
#endif

  end interface
  
  interface hipblasIcamaxBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasIcamaxBatched_v2_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasIcamaxBatched_v2")
#else
    function hipblasIcamaxBatched_v2_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasIcamaxBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamaxBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIcamaxBatched_v2_full_rank,&
      
hipblasIcamaxBatched_v2_rank_0,&
      
hipblasIcamaxBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasIzamaxBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasIzamaxBatched_v2_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasIzamaxBatched_v2")
#else
    function hipblasIzamaxBatched_v2_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasIzamaxBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamaxBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIzamaxBatched_v2_full_rank,&
      
hipblasIzamaxBatched_v2_rank_0,&
      
hipblasIzamaxBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>      amaxStridedBatched finds the first index of the element of maximum magnitude of each vector x_i in a batch, for i = 1, ..., batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               number of elements in each vector x_i
  !>     @param[in]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     stridex   [hipblasStride]
  !>               specifies the pointer increment between one x_i and the next x_(i + 1).
  !>     @param[in]
  !>     batchCount [int]
  !>               number of instances in the batch
  !>     @param[out]
  !>     result
  !>               device or host pointer for storing contiguous batchCount results.
  !>               return is 0 if n <= 0, incx<=0.
  !> 
  !>     
  interface hipblasIsamaxStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasIsamaxStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasIsamaxStridedBatched")
#else
    function hipblasIsamaxStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasIsamaxStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsamaxStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIsamaxStridedBatched_rank_0,&
      
hipblasIsamaxStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasIdamaxStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasIdamaxStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasIdamaxStridedBatched")
#else
    function hipblasIdamaxStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasIdamaxStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdamaxStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIdamaxStridedBatched_rank_0,&
      
hipblasIdamaxStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasIcamaxStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasIcamaxStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasIcamaxStridedBatched")
#else
    function hipblasIcamaxStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasIcamaxStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamaxStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIcamaxStridedBatched_rank_0,&
      
hipblasIcamaxStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasIzamaxStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasIzamaxStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasIzamaxStridedBatched")
#else
    function hipblasIzamaxStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasIzamaxStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamaxStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIzamaxStridedBatched_rank_0,&
      
hipblasIzamaxStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasIcamaxStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasIcamaxStridedBatched_v2_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasIcamaxStridedBatched_v2")
#else
    function hipblasIcamaxStridedBatched_v2_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasIcamaxStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamaxStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIcamaxStridedBatched_v2_rank_0,&
      
hipblasIcamaxStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasIzamaxStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasIzamaxStridedBatched_v2_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasIzamaxStridedBatched_v2")
#else
    function hipblasIzamaxStridedBatched_v2_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasIzamaxStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamaxStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIzamaxStridedBatched_v2_rank_0,&
      
hipblasIzamaxStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     amin finds the first index of the element of minimum magnitude of a vector x.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in x.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     result
  !>               device pointer or host pointer to store the amin index.
  !>               return is 0.0 if n, incx<=0.
  !>     
  interface hipblasIsamin
#ifdef USE_CUDA_NAMES
    function hipblasIsamin_(handle,n,x,incx,myResult) bind(c, name="cublasIsamin_v2")
#else
    function hipblasIsamin_(handle,n,x,incx,myResult) bind(c, name="hipblasIsamin")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsamin_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIsamin_rank_0,&
      
hipblasIsamin_rank_1
#endif

  end interface
  
  interface hipblasIdamin
#ifdef USE_CUDA_NAMES
    function hipblasIdamin_(handle,n,x,incx,myResult) bind(c, name="cublasIdamin_v2")
#else
    function hipblasIdamin_(handle,n,x,incx,myResult) bind(c, name="hipblasIdamin")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdamin_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIdamin_rank_0,&
      
hipblasIdamin_rank_1
#endif

  end interface
  
  interface hipblasIcamin
#ifdef USE_CUDA_NAMES
    function hipblasIcamin_(handle,n,x,incx,myResult) bind(c, name="cublasIcamin_v2")
#else
    function hipblasIcamin_(handle,n,x,incx,myResult) bind(c, name="hipblasIcamin")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamin_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIcamin_rank_0,&
      
hipblasIcamin_rank_1
#endif

  end interface
  
  interface hipblasIzamin
#ifdef USE_CUDA_NAMES
    function hipblasIzamin_(handle,n,x,incx,myResult) bind(c, name="cublasIzamin_v2")
#else
    function hipblasIzamin_(handle,n,x,incx,myResult) bind(c, name="hipblasIzamin")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamin_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIzamin_rank_0,&
      
hipblasIzamin_rank_1
#endif

  end interface
  
  interface hipblasIcamin_v2
#ifdef USE_CUDA_NAMES
    function hipblasIcamin_v2_(handle,n,x,incx,myResult) bind(c, name="cublasIcamin_v2")
#else
    function hipblasIcamin_v2_(handle,n,x,incx,myResult) bind(c, name="hipblasIcamin_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamin_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIcamin_v2_rank_0,&
      
hipblasIcamin_v2_rank_1
#endif

  end interface
  
  interface hipblasIzamin_v2
#ifdef USE_CUDA_NAMES
    function hipblasIzamin_v2_(handle,n,x,incx,myResult) bind(c, name="cublasIzamin_v2")
#else
    function hipblasIzamin_v2_(handle,n,x,incx,myResult) bind(c, name="hipblasIzamin_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamin_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIzamin_v2_rank_0,&
      
hipblasIzamin_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     aminBatched finds the first index of the element of minimum magnitude of each vector x_i in a batch, for i = 1, ..., batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               number of elements in each vector x_i
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     batchCount [int]
  !>               number of instances in the batch, must be > 0.
  !>     @param[out]
  !>     result
  !>               device or host pointers to array of batchCount size for results.
  !>               return is 0 if n, incx<=0.
  !>     
  interface hipblasIsaminBatched
#ifdef USE_CUDA_NAMES
    function hipblasIsaminBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasIsaminBatched")
#else
    function hipblasIsaminBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasIsaminBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsaminBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIsaminBatched_full_rank,&
      
hipblasIsaminBatched_rank_0,&
      
hipblasIsaminBatched_rank_1
#endif

  end interface
  
  interface hipblasIdaminBatched
#ifdef USE_CUDA_NAMES
    function hipblasIdaminBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasIdaminBatched")
#else
    function hipblasIdaminBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasIdaminBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdaminBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIdaminBatched_full_rank,&
      
hipblasIdaminBatched_rank_0,&
      
hipblasIdaminBatched_rank_1
#endif

  end interface
  
  interface hipblasIcaminBatched
#ifdef USE_CUDA_NAMES
    function hipblasIcaminBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasIcaminBatched")
#else
    function hipblasIcaminBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasIcaminBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcaminBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIcaminBatched_full_rank,&
      
hipblasIcaminBatched_rank_0,&
      
hipblasIcaminBatched_rank_1
#endif

  end interface
  
  interface hipblasIzaminBatched
#ifdef USE_CUDA_NAMES
    function hipblasIzaminBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasIzaminBatched")
#else
    function hipblasIzaminBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasIzaminBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzaminBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIzaminBatched_full_rank,&
      
hipblasIzaminBatched_rank_0,&
      
hipblasIzaminBatched_rank_1
#endif

  end interface
  
  interface hipblasIcaminBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasIcaminBatched_v2_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasIcaminBatched_v2")
#else
    function hipblasIcaminBatched_v2_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasIcaminBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcaminBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIcaminBatched_v2_full_rank,&
      
hipblasIcaminBatched_v2_rank_0,&
      
hipblasIcaminBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasIzaminBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasIzaminBatched_v2_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasIzaminBatched_v2")
#else
    function hipblasIzaminBatched_v2_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasIzaminBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzaminBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIzaminBatched_v2_full_rank,&
      
hipblasIzaminBatched_v2_rank_0,&
      
hipblasIzaminBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>      aminStridedBatched finds the first index of the element of minimum magnitude of each vector x_i in a batch, for i = 1, ..., batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               number of elements in each vector x_i
  !>     @param[in]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     stridex   [hipblasStride]
  !>               specifies the pointer increment between one x_i and the next x_(i + 1)
  !>     @param[in]
  !>     batchCount [int]
  !>               number of instances in the batch
  !>     @param[out]
  !>     result
  !>               device or host pointer to array for storing contiguous batchCount results.
  !>               return is 0 if n <= 0, incx<=0.
  !> 
  !>     
  interface hipblasIsaminStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasIsaminStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasIsaminStridedBatched")
#else
    function hipblasIsaminStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasIsaminStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsaminStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIsaminStridedBatched_rank_0,&
      
hipblasIsaminStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasIdaminStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasIdaminStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasIdaminStridedBatched")
#else
    function hipblasIdaminStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasIdaminStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdaminStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIdaminStridedBatched_rank_0,&
      
hipblasIdaminStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasIcaminStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasIcaminStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasIcaminStridedBatched")
#else
    function hipblasIcaminStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasIcaminStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcaminStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIcaminStridedBatched_rank_0,&
      
hipblasIcaminStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasIzaminStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasIzaminStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasIzaminStridedBatched")
#else
    function hipblasIzaminStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasIzaminStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzaminStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIzaminStridedBatched_rank_0,&
      
hipblasIzaminStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasIcaminStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasIcaminStridedBatched_v2_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasIcaminStridedBatched_v2")
#else
    function hipblasIcaminStridedBatched_v2_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasIcaminStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcaminStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIcaminStridedBatched_v2_rank_0,&
      
hipblasIcaminStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasIzaminStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasIzaminStridedBatched_v2_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasIzaminStridedBatched_v2")
#else
    function hipblasIzaminStridedBatched_v2_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasIzaminStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzaminStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasIzaminStridedBatched_v2_rank_0,&
      
hipblasIzaminStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     asum computes the sum of the magnitudes of elements of a real vector x,
  !>          or the sum of magnitudes of the real and imaginary parts of elements if x is a complex vector.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in x and y.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x. incx must be > 0.
  !>     @param[inout]
  !>     result
  !>               device pointer or host pointer to store the asum product.
  !>               return is 0.0 if n <= 0.
  !> 
  !>     
  interface hipblasSasum
#ifdef USE_CUDA_NAMES
    function hipblasSasum_(handle,n,x,incx,myResult) bind(c, name="cublasSasum_v2")
#else
    function hipblasSasum_(handle,n,x,incx,myResult) bind(c, name="hipblasSasum")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSasum_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSasum_rank_0,&
      
hipblasSasum_rank_1
#endif

  end interface
  
  interface hipblasDasum
#ifdef USE_CUDA_NAMES
    function hipblasDasum_(handle,n,x,incx,myResult) bind(c, name="cublasDasum_v2")
#else
    function hipblasDasum_(handle,n,x,incx,myResult) bind(c, name="hipblasDasum")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDasum_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDasum_rank_0,&
      
hipblasDasum_rank_1
#endif

  end interface
  
  interface hipblasScasum
#ifdef USE_CUDA_NAMES
    function hipblasScasum_(handle,n,x,incx,myResult) bind(c, name="cublasScasum_v2")
#else
    function hipblasScasum_(handle,n,x,incx,myResult) bind(c, name="hipblasScasum")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasum_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasScasum_rank_0,&
      
hipblasScasum_rank_1
#endif

  end interface
  
  interface hipblasDzasum
#ifdef USE_CUDA_NAMES
    function hipblasDzasum_(handle,n,x,incx,myResult) bind(c, name="cublasDzasum_v2")
#else
    function hipblasDzasum_(handle,n,x,incx,myResult) bind(c, name="hipblasDzasum")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasum_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDzasum_rank_0,&
      
hipblasDzasum_rank_1
#endif

  end interface
  
  interface hipblasScasum_v2
#ifdef USE_CUDA_NAMES
    function hipblasScasum_v2_(handle,n,x,incx,myResult) bind(c, name="cublasScasum_v2")
#else
    function hipblasScasum_v2_(handle,n,x,incx,myResult) bind(c, name="hipblasScasum_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasum_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasScasum_v2_rank_0,&
      
hipblasScasum_v2_rank_1
#endif

  end interface
  
  interface hipblasDzasum_v2
#ifdef USE_CUDA_NAMES
    function hipblasDzasum_v2_(handle,n,x,incx,myResult) bind(c, name="cublasDzasum_v2")
#else
    function hipblasDzasum_v2_(handle,n,x,incx,myResult) bind(c, name="hipblasDzasum_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasum_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDzasum_v2_rank_0,&
      
hipblasDzasum_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     asumBatched computes the sum of the magnitudes of the elements in a batch of real vectors x_i,
  !>         or the sum of magnitudes of the real and imaginary parts of elements if x_i is a complex
  !>         vector, for i = 1, ..., batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               number of elements in each vector x_i
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     batchCount [int]
  !>               number of instances in the batch.
  !>     @param[out]
  !>     result
  !>               device array or host array of batchCount size for results.
  !>               return is 0.0 if n, incx<=0.
  !>     
  interface hipblasSasumBatched
#ifdef USE_CUDA_NAMES
    function hipblasSasumBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasSasumBatched")
#else
    function hipblasSasumBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasSasumBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSasumBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSasumBatched_full_rank,&
      
hipblasSasumBatched_rank_0,&
      
hipblasSasumBatched_rank_1
#endif

  end interface
  
  interface hipblasDasumBatched
#ifdef USE_CUDA_NAMES
    function hipblasDasumBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasDasumBatched")
#else
    function hipblasDasumBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasDasumBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDasumBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDasumBatched_full_rank,&
      
hipblasDasumBatched_rank_0,&
      
hipblasDasumBatched_rank_1
#endif

  end interface
  
  interface hipblasScasumBatched
#ifdef USE_CUDA_NAMES
    function hipblasScasumBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasScasumBatched")
#else
    function hipblasScasumBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasScasumBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasumBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasScasumBatched_full_rank,&
      
hipblasScasumBatched_rank_0,&
      
hipblasScasumBatched_rank_1
#endif

  end interface
  
  interface hipblasDzasumBatched
#ifdef USE_CUDA_NAMES
    function hipblasDzasumBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasDzasumBatched")
#else
    function hipblasDzasumBatched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasDzasumBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasumBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDzasumBatched_full_rank,&
      
hipblasDzasumBatched_rank_0,&
      
hipblasDzasumBatched_rank_1
#endif

  end interface
  
  interface hipblasScasumBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasScasumBatched_v2_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasScasumBatched_v2")
#else
    function hipblasScasumBatched_v2_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasScasumBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasumBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasScasumBatched_v2_full_rank,&
      
hipblasScasumBatched_v2_rank_0,&
      
hipblasScasumBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasDzasumBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasDzasumBatched_v2_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasDzasumBatched_v2")
#else
    function hipblasDzasumBatched_v2_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasDzasumBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasumBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDzasumBatched_v2_full_rank,&
      
hipblasDzasumBatched_v2_rank_0,&
      
hipblasDzasumBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     asumStridedBatched computes the sum of the magnitudes of elements of a real vectors x_i,
  !>         or the sum of magnitudes of the real and imaginary parts of elements if x_i is a complex
  !>         vector, for i = 1, ..., batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               number of elements in each vector x_i
  !>     @param[in]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     stridex   [hipblasStride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>               There are no restrictions placed on stride_x, however the user should
  !>               take care to ensure that stride_x is of appropriate size, for a typical
  !>               case this means stride_x >= n  incx.
  !>     @param[in]
  !>     batchCount [int]
  !>               number of instances in the batch
  !>     @param[out]
  !>     result
  !>               device pointer or host pointer to array for storing contiguous batchCount results.
  !>               return is 0.0 if n, incx<=0.
  !>     
  interface hipblasSasumStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSasumStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasSasumStridedBatched")
#else
    function hipblasSasumStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasSasumStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSasumStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSasumStridedBatched_rank_0,&
      
hipblasSasumStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDasumStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDasumStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasDasumStridedBatched")
#else
    function hipblasDasumStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasDasumStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDasumStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDasumStridedBatched_rank_0,&
      
hipblasDasumStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasScasumStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasScasumStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasScasumStridedBatched")
#else
    function hipblasScasumStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasScasumStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasumStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasScasumStridedBatched_rank_0,&
      
hipblasScasumStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDzasumStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDzasumStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasDzasumStridedBatched")
#else
    function hipblasDzasumStridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasDzasumStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasumStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDzasumStridedBatched_rank_0,&
      
hipblasDzasumStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasScasumStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasScasumStridedBatched_v2_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasScasumStridedBatched_v2")
#else
    function hipblasScasumStridedBatched_v2_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasScasumStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasumStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasScasumStridedBatched_v2_rank_0,&
      
hipblasScasumStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasDzasumStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasDzasumStridedBatched_v2_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasDzasumStridedBatched_v2")
#else
    function hipblasDzasumStridedBatched_v2_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasDzasumStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasumStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDzasumStridedBatched_v2_rank_0,&
      
hipblasDzasumStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasSaxpy
#ifdef USE_CUDA_NAMES
    function hipblasSaxpy_(handle,n,alpha,x,incx,y,incy) bind(c, name="cublasSaxpy_v2")
#else
    function hipblasSaxpy_(handle,n,alpha,x,incx,y,incy) bind(c, name="hipblasSaxpy")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSaxpy_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSaxpy_rank_0,&
      
hipblasSaxpy_rank_1
#endif

  end interface
  
  interface hipblasDaxpy
#ifdef USE_CUDA_NAMES
    function hipblasDaxpy_(handle,n,alpha,x,incx,y,incy) bind(c, name="cublasDaxpy_v2")
#else
    function hipblasDaxpy_(handle,n,alpha,x,incx,y,incy) bind(c, name="hipblasDaxpy")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDaxpy_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDaxpy_rank_0,&
      
hipblasDaxpy_rank_1
#endif

  end interface
  
  interface hipblasCaxpy
#ifdef USE_CUDA_NAMES
    function hipblasCaxpy_(handle,n,alpha,x,incx,y,incy) bind(c, name="cublasCaxpy_v2")
#else
    function hipblasCaxpy_(handle,n,alpha,x,incx,y,incy) bind(c, name="hipblasCaxpy")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpy_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCaxpy_rank_0,&
      
hipblasCaxpy_rank_1
#endif

  end interface
  
  interface hipblasZaxpy
#ifdef USE_CUDA_NAMES
    function hipblasZaxpy_(handle,n,alpha,x,incx,y,incy) bind(c, name="cublasZaxpy_v2")
#else
    function hipblasZaxpy_(handle,n,alpha,x,incx,y,incy) bind(c, name="hipblasZaxpy")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpy_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZaxpy_rank_0,&
      
hipblasZaxpy_rank_1
#endif

  end interface
  
  interface hipblasCaxpy_v2
#ifdef USE_CUDA_NAMES
    function hipblasCaxpy_v2_(handle,n,alpha,x,incx,y,incy) bind(c, name="cublasCaxpy_v2")
#else
    function hipblasCaxpy_v2_(handle,n,alpha,x,incx,y,incy) bind(c, name="hipblasCaxpy_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpy_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCaxpy_v2_rank_0,&
      
hipblasCaxpy_v2_rank_1
#endif

  end interface
  
  interface hipblasZaxpy_v2
#ifdef USE_CUDA_NAMES
    function hipblasZaxpy_v2_(handle,n,alpha,x,incx,y,incy) bind(c, name="cublasZaxpy_v2")
#else
    function hipblasZaxpy_v2_(handle,n,alpha,x,incx,y,incy) bind(c, name="hipblasZaxpy_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpy_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZaxpy_v2_rank_0,&
      
hipblasZaxpy_v2_rank_1
#endif

  end interface
  
  interface hipblasSaxpyBatched
#ifdef USE_CUDA_NAMES
    function hipblasSaxpyBatched_(handle,n,alpha,x,incx,y,incy,batchCount) bind(c, name="cublasSaxpyBatched")
#else
    function hipblasSaxpyBatched_(handle,n,alpha,x,incx,y,incy,batchCount) bind(c, name="hipblasSaxpyBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSaxpyBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSaxpyBatched_full_rank,&
      
hipblasSaxpyBatched_rank_0,&
      
hipblasSaxpyBatched_rank_1
#endif

  end interface
  
  interface hipblasDaxpyBatched
#ifdef USE_CUDA_NAMES
    function hipblasDaxpyBatched_(handle,n,alpha,x,incx,y,incy,batchCount) bind(c, name="cublasDaxpyBatched")
#else
    function hipblasDaxpyBatched_(handle,n,alpha,x,incx,y,incy,batchCount) bind(c, name="hipblasDaxpyBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDaxpyBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDaxpyBatched_full_rank,&
      
hipblasDaxpyBatched_rank_0,&
      
hipblasDaxpyBatched_rank_1
#endif

  end interface
  
  interface hipblasCaxpyBatched
#ifdef USE_CUDA_NAMES
    function hipblasCaxpyBatched_(handle,n,alpha,x,incx,y,incy,batchCount) bind(c, name="cublasCaxpyBatched")
#else
    function hipblasCaxpyBatched_(handle,n,alpha,x,incx,y,incy,batchCount) bind(c, name="hipblasCaxpyBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpyBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCaxpyBatched_full_rank,&
      
hipblasCaxpyBatched_rank_0,&
      
hipblasCaxpyBatched_rank_1
#endif

  end interface
  
  interface hipblasZaxpyBatched
#ifdef USE_CUDA_NAMES
    function hipblasZaxpyBatched_(handle,n,alpha,x,incx,y,incy,batchCount) bind(c, name="cublasZaxpyBatched")
#else
    function hipblasZaxpyBatched_(handle,n,alpha,x,incx,y,incy,batchCount) bind(c, name="hipblasZaxpyBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpyBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZaxpyBatched_full_rank,&
      
hipblasZaxpyBatched_rank_0,&
      
hipblasZaxpyBatched_rank_1
#endif

  end interface
  
  interface hipblasCaxpyBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCaxpyBatched_v2_(handle,n,alpha,x,incx,y,incy,batchCount) bind(c, name="cublasCaxpyBatched_v2")
#else
    function hipblasCaxpyBatched_v2_(handle,n,alpha,x,incx,y,incy,batchCount) bind(c, name="hipblasCaxpyBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpyBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCaxpyBatched_v2_full_rank,&
      
hipblasCaxpyBatched_v2_rank_0,&
      
hipblasCaxpyBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZaxpyBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZaxpyBatched_v2_(handle,n,alpha,x,incx,y,incy,batchCount) bind(c, name="cublasZaxpyBatched_v2")
#else
    function hipblasZaxpyBatched_v2_(handle,n,alpha,x,incx,y,incy,batchCount) bind(c, name="hipblasZaxpyBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpyBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZaxpyBatched_v2_full_rank,&
      
hipblasZaxpyBatched_v2_rank_0,&
      
hipblasZaxpyBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasSaxpyStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSaxpyStridedBatched_(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasSaxpyStridedBatched")
#else
    function hipblasSaxpyStridedBatched_(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasSaxpyStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSaxpyStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSaxpyStridedBatched_rank_0,&
      
hipblasSaxpyStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDaxpyStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDaxpyStridedBatched_(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasDaxpyStridedBatched")
#else
    function hipblasDaxpyStridedBatched_(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasDaxpyStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDaxpyStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDaxpyStridedBatched_rank_0,&
      
hipblasDaxpyStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCaxpyStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCaxpyStridedBatched_(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasCaxpyStridedBatched")
#else
    function hipblasCaxpyStridedBatched_(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasCaxpyStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpyStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCaxpyStridedBatched_rank_0,&
      
hipblasCaxpyStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZaxpyStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZaxpyStridedBatched_(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasZaxpyStridedBatched")
#else
    function hipblasZaxpyStridedBatched_(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasZaxpyStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpyStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZaxpyStridedBatched_rank_0,&
      
hipblasZaxpyStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCaxpyStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCaxpyStridedBatched_v2_(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasCaxpyStridedBatched_v2")
#else
    function hipblasCaxpyStridedBatched_v2_(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasCaxpyStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpyStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCaxpyStridedBatched_v2_rank_0,&
      
hipblasCaxpyStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZaxpyStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZaxpyStridedBatched_v2_(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasZaxpyStridedBatched_v2")
#else
    function hipblasZaxpyStridedBatched_v2_(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasZaxpyStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpyStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZaxpyStridedBatched_v2_rank_0,&
      
hipblasZaxpyStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     copy  copies each element x[i] into y[i], for  i = 1 , ... , n
  !> 
  !>         y := x,
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in x to be copied to y.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[out]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !> 
  !>     
  interface hipblasScopy
#ifdef USE_CUDA_NAMES
    function hipblasScopy_(handle,n,x,incx,y,incy) bind(c, name="cublasScopy_v2")
#else
    function hipblasScopy_(handle,n,x,incx,y,incy) bind(c, name="hipblasScopy")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScopy_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasScopy_rank_0,&
      
hipblasScopy_rank_1
#endif

  end interface
  
  interface hipblasDcopy
#ifdef USE_CUDA_NAMES
    function hipblasDcopy_(handle,n,x,incx,y,incy) bind(c, name="cublasDcopy_v2")
#else
    function hipblasDcopy_(handle,n,x,incx,y,incy) bind(c, name="hipblasDcopy")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDcopy_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDcopy_rank_0,&
      
hipblasDcopy_rank_1
#endif

  end interface
  
  interface hipblasCcopy
#ifdef USE_CUDA_NAMES
    function hipblasCcopy_(handle,n,x,incx,y,incy) bind(c, name="cublasCcopy_v2")
#else
    function hipblasCcopy_(handle,n,x,incx,y,incy) bind(c, name="hipblasCcopy")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopy_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCcopy_rank_0,&
      
hipblasCcopy_rank_1
#endif

  end interface
  
  interface hipblasZcopy
#ifdef USE_CUDA_NAMES
    function hipblasZcopy_(handle,n,x,incx,y,incy) bind(c, name="cublasZcopy_v2")
#else
    function hipblasZcopy_(handle,n,x,incx,y,incy) bind(c, name="hipblasZcopy")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopy_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZcopy_rank_0,&
      
hipblasZcopy_rank_1
#endif

  end interface
  
  interface hipblasCcopy_v2
#ifdef USE_CUDA_NAMES
    function hipblasCcopy_v2_(handle,n,x,incx,y,incy) bind(c, name="cublasCcopy_v2")
#else
    function hipblasCcopy_v2_(handle,n,x,incx,y,incy) bind(c, name="hipblasCcopy_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopy_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCcopy_v2_rank_0,&
      
hipblasCcopy_v2_rank_1
#endif

  end interface
  
  interface hipblasZcopy_v2
#ifdef USE_CUDA_NAMES
    function hipblasZcopy_v2_(handle,n,x,incx,y,incy) bind(c, name="cublasZcopy_v2")
#else
    function hipblasZcopy_v2_(handle,n,x,incx,y,incy) bind(c, name="hipblasZcopy_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopy_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZcopy_v2_rank_0,&
      
hipblasZcopy_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     copyBatched copies each element x_i[j] into y_i[j], for  j = 1 , ... , n; i = 1 , ... , batchCount
  !> 
  !>         y_i := x_i,
  !> 
  !>     where (x_i, y_i) is the i-th instance of the batch.
  !>     x_i and y_i are vectors.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in each x_i to be copied to y_i.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each vector x_i.
  !>     @param[out]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each vector y_i.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface hipblasScopyBatched
#ifdef USE_CUDA_NAMES
    function hipblasScopyBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="cublasScopyBatched")
#else
    function hipblasScopyBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="hipblasScopyBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScopyBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasScopyBatched_full_rank,&
      
hipblasScopyBatched_rank_0,&
      
hipblasScopyBatched_rank_1
#endif

  end interface
  
  interface hipblasDcopyBatched
#ifdef USE_CUDA_NAMES
    function hipblasDcopyBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="cublasDcopyBatched")
#else
    function hipblasDcopyBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="hipblasDcopyBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDcopyBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDcopyBatched_full_rank,&
      
hipblasDcopyBatched_rank_0,&
      
hipblasDcopyBatched_rank_1
#endif

  end interface
  
  interface hipblasCcopyBatched
#ifdef USE_CUDA_NAMES
    function hipblasCcopyBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="cublasCcopyBatched")
#else
    function hipblasCcopyBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="hipblasCcopyBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopyBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCcopyBatched_full_rank,&
      
hipblasCcopyBatched_rank_0,&
      
hipblasCcopyBatched_rank_1
#endif

  end interface
  
  interface hipblasZcopyBatched
#ifdef USE_CUDA_NAMES
    function hipblasZcopyBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="cublasZcopyBatched")
#else
    function hipblasZcopyBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="hipblasZcopyBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopyBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZcopyBatched_full_rank,&
      
hipblasZcopyBatched_rank_0,&
      
hipblasZcopyBatched_rank_1
#endif

  end interface
  
  interface hipblasCcopyBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCcopyBatched_v2_(handle,n,x,incx,y,incy,batchCount) bind(c, name="cublasCcopyBatched_v2")
#else
    function hipblasCcopyBatched_v2_(handle,n,x,incx,y,incy,batchCount) bind(c, name="hipblasCcopyBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopyBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCcopyBatched_v2_full_rank,&
      
hipblasCcopyBatched_v2_rank_0,&
      
hipblasCcopyBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZcopyBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZcopyBatched_v2_(handle,n,x,incx,y,incy,batchCount) bind(c, name="cublasZcopyBatched_v2")
#else
    function hipblasZcopyBatched_v2_(handle,n,x,incx,y,incy,batchCount) bind(c, name="hipblasZcopyBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopyBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZcopyBatched_v2_full_rank,&
      
hipblasZcopyBatched_v2_rank_0,&
      
hipblasZcopyBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     copyStridedBatched copies each element x_i[j] into y_i[j], for  j = 1 , ... , n; i = 1 , ... , batchCount
  !> 
  !>         y_i := x_i,
  !> 
  !>     where (x_i, y_i) is the i-th instance of the batch.
  !>     x_i and y_i are vectors.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in each x_i to be copied to y_i.
  !>     @param[in]
  !>     x         device pointer to the first vector (x_1) in the batch.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increments for the elements of vectors x_i.
  !>     @param[in]
  !>     stridex     [hipblasStride]
  !>                 stride from the start of one vector (x_i) and the next one (x_i+1).
  !>                 There are no restrictions placed on stride_x, however the user should
  !>                 take care to ensure that stride_x is of appropriate size, for a typical
  !>                 case this means stride_x >= n  incx.
  !>     @param[out]
  !>     y         device pointer to the first vector (y_1) in the batch.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of vectors y_i.
  !>     @param[in]
  !>     stridey     [hipblasStride]
  !>                 stride from the start of one vector (y_i) and the next one (y_i+1).
  !>                 There are no restrictions placed on stride_y, however the user should
  !>                 take care to ensure that stride_y is of appropriate size, for a typical
  !>                 case this means stride_y >= n  incy. stridey should be non zero.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface hipblasScopyStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasScopyStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasScopyStridedBatched")
#else
    function hipblasScopyStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasScopyStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScopyStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasScopyStridedBatched_rank_0,&
      
hipblasScopyStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDcopyStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDcopyStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasDcopyStridedBatched")
#else
    function hipblasDcopyStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasDcopyStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDcopyStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDcopyStridedBatched_rank_0,&
      
hipblasDcopyStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCcopyStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCcopyStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasCcopyStridedBatched")
#else
    function hipblasCcopyStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasCcopyStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopyStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCcopyStridedBatched_rank_0,&
      
hipblasCcopyStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZcopyStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZcopyStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasZcopyStridedBatched")
#else
    function hipblasZcopyStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasZcopyStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopyStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZcopyStridedBatched_rank_0,&
      
hipblasZcopyStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCcopyStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCcopyStridedBatched_v2_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasCcopyStridedBatched_v2")
#else
    function hipblasCcopyStridedBatched_v2_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasCcopyStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopyStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCcopyStridedBatched_v2_rank_0,&
      
hipblasCcopyStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZcopyStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZcopyStridedBatched_v2_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasZcopyStridedBatched_v2")
#else
    function hipblasZcopyStridedBatched_v2_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasZcopyStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopyStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZcopyStridedBatched_v2_rank_0,&
      
hipblasZcopyStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasSdot
#ifdef USE_CUDA_NAMES
    function hipblasSdot_(handle,n,x,incx,y,incy,myResult) bind(c, name="cublasSdot_v2")
#else
    function hipblasSdot_(handle,n,x,incx,y,incy,myResult) bind(c, name="hipblasSdot")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdot_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSdot_rank_0,&
      
hipblasSdot_rank_1
#endif

  end interface
  
  interface hipblasDdot
#ifdef USE_CUDA_NAMES
    function hipblasDdot_(handle,n,x,incx,y,incy,myResult) bind(c, name="cublasDdot_v2")
#else
    function hipblasDdot_(handle,n,x,incx,y,incy,myResult) bind(c, name="hipblasDdot")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdot_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDdot_rank_0,&
      
hipblasDdot_rank_1
#endif

  end interface
  
  interface hipblasCdotc
#ifdef USE_CUDA_NAMES
    function hipblasCdotc_(handle,n,x,incx,y,incy,myResult) bind(c, name="cublasCdotc_v2")
#else
    function hipblasCdotc_(handle,n,x,incx,y,incy,myResult) bind(c, name="hipblasCdotc")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotc_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCdotc_rank_0,&
      
hipblasCdotc_rank_1
#endif

  end interface
  
  interface hipblasCdotu
#ifdef USE_CUDA_NAMES
    function hipblasCdotu_(handle,n,x,incx,y,incy,myResult) bind(c, name="cublasCdotu_v2")
#else
    function hipblasCdotu_(handle,n,x,incx,y,incy,myResult) bind(c, name="hipblasCdotu")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotu_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCdotu_rank_0,&
      
hipblasCdotu_rank_1
#endif

  end interface
  
  interface hipblasZdotc
#ifdef USE_CUDA_NAMES
    function hipblasZdotc_(handle,n,x,incx,y,incy,myResult) bind(c, name="cublasZdotc_v2")
#else
    function hipblasZdotc_(handle,n,x,incx,y,incy,myResult) bind(c, name="hipblasZdotc")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotc_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdotc_rank_0,&
      
hipblasZdotc_rank_1
#endif

  end interface
  
  interface hipblasZdotu
#ifdef USE_CUDA_NAMES
    function hipblasZdotu_(handle,n,x,incx,y,incy,myResult) bind(c, name="cublasZdotu_v2")
#else
    function hipblasZdotu_(handle,n,x,incx,y,incy,myResult) bind(c, name="hipblasZdotu")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotu_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdotu_rank_0,&
      
hipblasZdotu_rank_1
#endif

  end interface
  
  interface hipblasCdotc_v2
#ifdef USE_CUDA_NAMES
    function hipblasCdotc_v2_(handle,n,x,incx,y,incy,myResult) bind(c, name="cublasCdotc_v2")
#else
    function hipblasCdotc_v2_(handle,n,x,incx,y,incy,myResult) bind(c, name="hipblasCdotc_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotc_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCdotc_v2_rank_0,&
      
hipblasCdotc_v2_rank_1
#endif

  end interface
  
  interface hipblasCdotu_v2
#ifdef USE_CUDA_NAMES
    function hipblasCdotu_v2_(handle,n,x,incx,y,incy,myResult) bind(c, name="cublasCdotu_v2")
#else
    function hipblasCdotu_v2_(handle,n,x,incx,y,incy,myResult) bind(c, name="hipblasCdotu_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotu_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCdotu_v2_rank_0,&
      
hipblasCdotu_v2_rank_1
#endif

  end interface
  
  interface hipblasZdotc_v2
#ifdef USE_CUDA_NAMES
    function hipblasZdotc_v2_(handle,n,x,incx,y,incy,myResult) bind(c, name="cublasZdotc_v2")
#else
    function hipblasZdotc_v2_(handle,n,x,incx,y,incy,myResult) bind(c, name="hipblasZdotc_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotc_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdotc_v2_rank_0,&
      
hipblasZdotc_v2_rank_1
#endif

  end interface
  
  interface hipblasZdotu_v2
#ifdef USE_CUDA_NAMES
    function hipblasZdotu_v2_(handle,n,x,incx,y,incy,myResult) bind(c, name="cublasZdotu_v2")
#else
    function hipblasZdotu_v2_(handle,n,x,incx,y,incy,myResult) bind(c, name="hipblasZdotu_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotu_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdotu_v2_rank_0,&
      
hipblasZdotu_v2_rank_1
#endif

  end interface
  
  interface hipblasSdotBatched
#ifdef USE_CUDA_NAMES
    function hipblasSdotBatched_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="cublasSdotBatched")
#else
    function hipblasSdotBatched_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="hipblasSdotBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdotBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSdotBatched_full_rank,&
      
hipblasSdotBatched_rank_0,&
      
hipblasSdotBatched_rank_1
#endif

  end interface
  
  interface hipblasDdotBatched
#ifdef USE_CUDA_NAMES
    function hipblasDdotBatched_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="cublasDdotBatched")
#else
    function hipblasDdotBatched_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="hipblasDdotBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdotBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDdotBatched_full_rank,&
      
hipblasDdotBatched_rank_0,&
      
hipblasDdotBatched_rank_1
#endif

  end interface
  
  interface hipblasCdotcBatched
#ifdef USE_CUDA_NAMES
    function hipblasCdotcBatched_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="cublasCdotcBatched")
#else
    function hipblasCdotcBatched_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="hipblasCdotcBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotcBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCdotcBatched_full_rank,&
      
hipblasCdotcBatched_rank_0,&
      
hipblasCdotcBatched_rank_1
#endif

  end interface
  
  interface hipblasCdotuBatched
#ifdef USE_CUDA_NAMES
    function hipblasCdotuBatched_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="cublasCdotuBatched")
#else
    function hipblasCdotuBatched_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="hipblasCdotuBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotuBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCdotuBatched_full_rank,&
      
hipblasCdotuBatched_rank_0,&
      
hipblasCdotuBatched_rank_1
#endif

  end interface
  
  interface hipblasZdotcBatched
#ifdef USE_CUDA_NAMES
    function hipblasZdotcBatched_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="cublasZdotcBatched")
#else
    function hipblasZdotcBatched_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="hipblasZdotcBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotcBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdotcBatched_full_rank,&
      
hipblasZdotcBatched_rank_0,&
      
hipblasZdotcBatched_rank_1
#endif

  end interface
  
  interface hipblasZdotuBatched
#ifdef USE_CUDA_NAMES
    function hipblasZdotuBatched_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="cublasZdotuBatched")
#else
    function hipblasZdotuBatched_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="hipblasZdotuBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotuBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdotuBatched_full_rank,&
      
hipblasZdotuBatched_rank_0,&
      
hipblasZdotuBatched_rank_1
#endif

  end interface
  
  interface hipblasCdotcBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCdotcBatched_v2_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="cublasCdotcBatched_v2")
#else
    function hipblasCdotcBatched_v2_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="hipblasCdotcBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotcBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCdotcBatched_v2_full_rank,&
      
hipblasCdotcBatched_v2_rank_0,&
      
hipblasCdotcBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasCdotuBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCdotuBatched_v2_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="cublasCdotuBatched_v2")
#else
    function hipblasCdotuBatched_v2_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="hipblasCdotuBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotuBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCdotuBatched_v2_full_rank,&
      
hipblasCdotuBatched_v2_rank_0,&
      
hipblasCdotuBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZdotcBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZdotcBatched_v2_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="cublasZdotcBatched_v2")
#else
    function hipblasZdotcBatched_v2_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="hipblasZdotcBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotcBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdotcBatched_v2_full_rank,&
      
hipblasZdotcBatched_v2_rank_0,&
      
hipblasZdotcBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZdotuBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZdotuBatched_v2_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="cublasZdotuBatched_v2")
#else
    function hipblasZdotuBatched_v2_(handle,n,x,incx,y,incy,batchCount,myResult) bind(c, name="hipblasZdotuBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotuBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdotuBatched_v2_full_rank,&
      
hipblasZdotuBatched_v2_rank_0,&
      
hipblasZdotuBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasSdotStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSdotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="cublasSdotStridedBatched")
#else
    function hipblasSdotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="hipblasSdotStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdotStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSdotStridedBatched_rank_0,&
      
hipblasSdotStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDdotStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDdotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="cublasDdotStridedBatched")
#else
    function hipblasDdotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="hipblasDdotStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdotStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDdotStridedBatched_rank_0,&
      
hipblasDdotStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCdotcStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCdotcStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="cublasCdotcStridedBatched")
#else
    function hipblasCdotcStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="hipblasCdotcStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotcStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCdotcStridedBatched_rank_0,&
      
hipblasCdotcStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCdotuStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCdotuStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="cublasCdotuStridedBatched")
#else
    function hipblasCdotuStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="hipblasCdotuStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotuStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCdotuStridedBatched_rank_0,&
      
hipblasCdotuStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZdotcStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZdotcStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="cublasZdotcStridedBatched")
#else
    function hipblasZdotcStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="hipblasZdotcStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotcStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdotcStridedBatched_rank_0,&
      
hipblasZdotcStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZdotuStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZdotuStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="cublasZdotuStridedBatched")
#else
    function hipblasZdotuStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="hipblasZdotuStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotuStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdotuStridedBatched_rank_0,&
      
hipblasZdotuStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCdotcStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCdotcStridedBatched_v2_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="cublasCdotcStridedBatched_v2")
#else
    function hipblasCdotcStridedBatched_v2_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="hipblasCdotcStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotcStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCdotcStridedBatched_v2_rank_0,&
      
hipblasCdotcStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasCdotuStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCdotuStridedBatched_v2_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="cublasCdotuStridedBatched_v2")
#else
    function hipblasCdotuStridedBatched_v2_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="hipblasCdotuStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotuStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCdotuStridedBatched_v2_rank_0,&
      
hipblasCdotuStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZdotcStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZdotcStridedBatched_v2_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="cublasZdotcStridedBatched_v2")
#else
    function hipblasZdotcStridedBatched_v2_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="hipblasZdotcStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotcStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdotcStridedBatched_v2_rank_0,&
      
hipblasZdotcStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZdotuStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZdotuStridedBatched_v2_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="cublasZdotuStridedBatched_v2")
#else
    function hipblasZdotuStridedBatched_v2_(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult) bind(c, name="hipblasZdotuStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotuStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdotuStridedBatched_v2_rank_0,&
      
hipblasZdotuStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     nrm2 computes the euclidean norm of a real or complex vector
  !> 
  !>               result := sqrt( x'x ) for real vectors
  !>               result := sqrt( xHx ) for complex vectors
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z,sc,dz
  !>     - Supported precisions in cuBLAS  : s,d,sc,dz
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in x.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     result
  !>               device pointer or host pointer to store the nrm2 product.
  !>               return is 0.0 if n, incx<=0.
  !>     
  interface hipblasSnrm2
#ifdef USE_CUDA_NAMES
    function hipblasSnrm2_(handle,n,x,incx,myResult) bind(c, name="cublasSnrm2_v2")
#else
    function hipblasSnrm2_(handle,n,x,incx,myResult) bind(c, name="hipblasSnrm2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSnrm2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSnrm2_rank_0,&
      
hipblasSnrm2_rank_1
#endif

  end interface
  
  interface hipblasDnrm2
#ifdef USE_CUDA_NAMES
    function hipblasDnrm2_(handle,n,x,incx,myResult) bind(c, name="cublasDnrm2_v2")
#else
    function hipblasDnrm2_(handle,n,x,incx,myResult) bind(c, name="hipblasDnrm2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDnrm2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDnrm2_rank_0,&
      
hipblasDnrm2_rank_1
#endif

  end interface
  
  interface hipblasScnrm2
#ifdef USE_CUDA_NAMES
    function hipblasScnrm2_(handle,n,x,incx,myResult) bind(c, name="cublasScnrm2_v2")
#else
    function hipblasScnrm2_(handle,n,x,incx,myResult) bind(c, name="hipblasScnrm2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasScnrm2_rank_0,&
      
hipblasScnrm2_rank_1
#endif

  end interface
  
  interface hipblasDznrm2
#ifdef USE_CUDA_NAMES
    function hipblasDznrm2_(handle,n,x,incx,myResult) bind(c, name="cublasDznrm2_v2")
#else
    function hipblasDznrm2_(handle,n,x,incx,myResult) bind(c, name="hipblasDznrm2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDznrm2_rank_0,&
      
hipblasDznrm2_rank_1
#endif

  end interface
  
  interface hipblasScnrm2_v2
#ifdef USE_CUDA_NAMES
    function hipblasScnrm2_v2_(handle,n,x,incx,myResult) bind(c, name="cublasScnrm2_v2")
#else
    function hipblasScnrm2_v2_(handle,n,x,incx,myResult) bind(c, name="hipblasScnrm2_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasScnrm2_v2_rank_0,&
      
hipblasScnrm2_v2_rank_1
#endif

  end interface
  
  interface hipblasDznrm2_v2
#ifdef USE_CUDA_NAMES
    function hipblasDznrm2_v2_(handle,n,x,incx,myResult) bind(c, name="cublasDznrm2_v2")
#else
    function hipblasDznrm2_v2_(handle,n,x,incx,myResult) bind(c, name="hipblasDznrm2_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDznrm2_v2_rank_0,&
      
hipblasDznrm2_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     nrm2Batched computes the euclidean norm over a batch of real or complex vectors
  !> 
  !>               result := sqrt( x_i'x_i ) for real vectors x, for i = 1, ..., batchCount
  !>               result := sqrt( x_iHx_i ) for complex vectors x, for i = 1, ..., batchCount
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z,sc,dz
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               number of elements in each x_i.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     batchCount [int]
  !>               number of instances in the batch
  !>     @param[out]
  !>     result
  !>               device pointer or host pointer to array of batchCount size for nrm2 results.
  !>               return is 0.0 for each element if n <= 0, incx<=0.
  !> 
  !>     
  interface hipblasSnrm2Batched
#ifdef USE_CUDA_NAMES
    function hipblasSnrm2Batched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasSnrm2Batched")
#else
    function hipblasSnrm2Batched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasSnrm2Batched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSnrm2Batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSnrm2Batched_full_rank,&
      
hipblasSnrm2Batched_rank_0,&
      
hipblasSnrm2Batched_rank_1
#endif

  end interface
  
  interface hipblasDnrm2Batched
#ifdef USE_CUDA_NAMES
    function hipblasDnrm2Batched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasDnrm2Batched")
#else
    function hipblasDnrm2Batched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasDnrm2Batched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDnrm2Batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDnrm2Batched_full_rank,&
      
hipblasDnrm2Batched_rank_0,&
      
hipblasDnrm2Batched_rank_1
#endif

  end interface
  
  interface hipblasScnrm2Batched
#ifdef USE_CUDA_NAMES
    function hipblasScnrm2Batched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasScnrm2Batched")
#else
    function hipblasScnrm2Batched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasScnrm2Batched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2Batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasScnrm2Batched_full_rank,&
      
hipblasScnrm2Batched_rank_0,&
      
hipblasScnrm2Batched_rank_1
#endif

  end interface
  
  interface hipblasDznrm2Batched
#ifdef USE_CUDA_NAMES
    function hipblasDznrm2Batched_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasDznrm2Batched")
#else
    function hipblasDznrm2Batched_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasDznrm2Batched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2Batched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDznrm2Batched_full_rank,&
      
hipblasDznrm2Batched_rank_0,&
      
hipblasDznrm2Batched_rank_1
#endif

  end interface
  
  interface hipblasScnrm2Batched_v2
#ifdef USE_CUDA_NAMES
    function hipblasScnrm2Batched_v2_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasScnrm2Batched_v2")
#else
    function hipblasScnrm2Batched_v2_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasScnrm2Batched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2Batched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasScnrm2Batched_v2_full_rank,&
      
hipblasScnrm2Batched_v2_rank_0,&
      
hipblasScnrm2Batched_v2_rank_1
#endif

  end interface
  
  interface hipblasDznrm2Batched_v2
#ifdef USE_CUDA_NAMES
    function hipblasDznrm2Batched_v2_(handle,n,x,incx,batchCount,myResult) bind(c, name="cublasDznrm2Batched_v2")
#else
    function hipblasDznrm2Batched_v2_(handle,n,x,incx,batchCount,myResult) bind(c, name="hipblasDznrm2Batched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2Batched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDznrm2Batched_v2_full_rank,&
      
hipblasDznrm2Batched_v2_rank_0,&
      
hipblasDznrm2Batched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     nrm2StridedBatched computes the euclidean norm over a batch of real or complex vectors
  !> 
  !>               := sqrt( x_i'x_i ) for real vectors x, for i = 1, ..., batchCount
  !>               := sqrt( x_iHx_i ) for complex vectors, for i = 1, ..., batchCount
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z,sc,dz
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               number of elements in each x_i.
  !>     @param[in]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     stridex   [hipblasStride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>               There are no restrictions placed on stride_x, however the user should
  !>               take care to ensure that stride_x is of appropriate size, for a typical
  !>               case this means stride_x >= n  incx.
  !>     @param[in]
  !>     batchCount [int]
  !>               number of instances in the batch
  !>     @param[out]
  !>     result
  !>               device pointer or host pointer to array for storing contiguous batchCount results.
  !>               return is 0.0 for each element if n <= 0, incx<=0.
  !> 
  !>     
  interface hipblasSnrm2StridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSnrm2StridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasSnrm2StridedBatched")
#else
    function hipblasSnrm2StridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasSnrm2StridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSnrm2StridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSnrm2StridedBatched_rank_0,&
      
hipblasSnrm2StridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDnrm2StridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDnrm2StridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasDnrm2StridedBatched")
#else
    function hipblasDnrm2StridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasDnrm2StridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDnrm2StridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDnrm2StridedBatched_rank_0,&
      
hipblasDnrm2StridedBatched_rank_1
#endif

  end interface
  
  interface hipblasScnrm2StridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasScnrm2StridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasScnrm2StridedBatched")
#else
    function hipblasScnrm2StridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasScnrm2StridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2StridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasScnrm2StridedBatched_rank_0,&
      
hipblasScnrm2StridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDznrm2StridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDznrm2StridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasDznrm2StridedBatched")
#else
    function hipblasDznrm2StridedBatched_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasDznrm2StridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2StridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDznrm2StridedBatched_rank_0,&
      
hipblasDznrm2StridedBatched_rank_1
#endif

  end interface
  
  interface hipblasScnrm2StridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasScnrm2StridedBatched_v2_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasScnrm2StridedBatched_v2")
#else
    function hipblasScnrm2StridedBatched_v2_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasScnrm2StridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2StridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasScnrm2StridedBatched_v2_rank_0,&
      
hipblasScnrm2StridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasDznrm2StridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasDznrm2StridedBatched_v2_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="cublasDznrm2StridedBatched_v2")
#else
    function hipblasDznrm2StridedBatched_v2_(handle,n,x,incx,stridex,batchCount,myResult) bind(c, name="hipblasDznrm2StridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2StridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDznrm2StridedBatched_v2_rank_0,&
      
hipblasDznrm2StridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rot applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to vectors x and y.
  !>         Scalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z,sc,dz
  !>     - Supported precisions in cuBLAS  : s,d,c,z,cs,zd
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !>     @param[in]
  !>     n       [int]
  !>             number of elements in the x and y vectors.
  !>     @param[inout]
  !>     x       device pointer storing vector x.
  !>     @param[in]
  !>     incx    [int]
  !>             specifies the increment between elements of x.
  !>     @param[inout]
  !>     y       device pointer storing vector y.
  !>     @param[in]
  !>     incy    [int]
  !>             specifies the increment between elements of y.
  !>     @param[in]
  !>     c       device pointer or host pointer storing scalar cosine component of the rotation matrix.
  !>     @param[in]
  !>     s       device pointer or host pointer storing scalar sine component of the rotation matrix.
  !> 
  !>     
  interface hipblasSrot
#ifdef USE_CUDA_NAMES
    function hipblasSrot_(handle,n,x,incx,y,incy,c,s) bind(c, name="cublasSrot_v2")
#else
    function hipblasSrot_(handle,n,x,incx,y,incy,c,s) bind(c, name="hipblasSrot")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrot_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSrot_rank_0,&
      
hipblasSrot_rank_1
#endif

  end interface
  
  interface hipblasDrot
#ifdef USE_CUDA_NAMES
    function hipblasDrot_(handle,n,x,incx,y,incy,c,s) bind(c, name="cublasDrot_v2")
#else
    function hipblasDrot_(handle,n,x,incx,y,incy,c,s) bind(c, name="hipblasDrot")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrot_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDrot_rank_0,&
      
hipblasDrot_rank_1
#endif

  end interface
  
  interface hipblasCrot
#ifdef USE_CUDA_NAMES
    function hipblasCrot_(handle,n,x,incx,y,incy,c,s) bind(c, name="cublasCrot_v2")
#else
    function hipblasCrot_(handle,n,x,incx,y,incy,c,s) bind(c, name="hipblasCrot")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrot_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCrot_rank_0,&
      
hipblasCrot_rank_1
#endif

  end interface
  
  interface hipblasCsrot
#ifdef USE_CUDA_NAMES
    function hipblasCsrot_(handle,n,x,incx,y,incy,c,s) bind(c, name="cublasCsrot_v2")
#else
    function hipblasCsrot_(handle,n,x,incx,y,incy,c,s) bind(c, name="hipblasCsrot")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrot_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsrot_rank_0,&
      
hipblasCsrot_rank_1
#endif

  end interface
  
  interface hipblasZrot
#ifdef USE_CUDA_NAMES
    function hipblasZrot_(handle,n,x,incx,y,incy,c,s) bind(c, name="cublasZrot_v2")
#else
    function hipblasZrot_(handle,n,x,incx,y,incy,c,s) bind(c, name="hipblasZrot")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrot_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZrot_rank_0,&
      
hipblasZrot_rank_1
#endif

  end interface
  
  interface hipblasZdrot
#ifdef USE_CUDA_NAMES
    function hipblasZdrot_(handle,n,x,incx,y,incy,c,s) bind(c, name="cublasZdrot_v2")
#else
    function hipblasZdrot_(handle,n,x,incx,y,incy,c,s) bind(c, name="hipblasZdrot")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrot_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdrot_rank_0,&
      
hipblasZdrot_rank_1
#endif

  end interface
  
  interface hipblasCrot_v2
#ifdef USE_CUDA_NAMES
    function hipblasCrot_v2_(handle,n,x,incx,y,incy,c,s) bind(c, name="cublasCrot_v2")
#else
    function hipblasCrot_v2_(handle,n,x,incx,y,incy,c,s) bind(c, name="hipblasCrot_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrot_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCrot_v2_rank_0,&
      
hipblasCrot_v2_rank_1
#endif

  end interface
  
  interface hipblasCsrot_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsrot_v2_(handle,n,x,incx,y,incy,c,s) bind(c, name="cublasCsrot_v2")
#else
    function hipblasCsrot_v2_(handle,n,x,incx,y,incy,c,s) bind(c, name="hipblasCsrot_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrot_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsrot_v2_rank_0,&
      
hipblasCsrot_v2_rank_1
#endif

  end interface
  
  interface hipblasZrot_v2
#ifdef USE_CUDA_NAMES
    function hipblasZrot_v2_(handle,n,x,incx,y,incy,c,s) bind(c, name="cublasZrot_v2")
#else
    function hipblasZrot_v2_(handle,n,x,incx,y,incy,c,s) bind(c, name="hipblasZrot_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrot_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZrot_v2_rank_0,&
      
hipblasZrot_v2_rank_1
#endif

  end interface
  
  interface hipblasZdrot_v2
#ifdef USE_CUDA_NAMES
    function hipblasZdrot_v2_(handle,n,x,incx,y,incy,c,s) bind(c, name="cublasZdrot_v2")
#else
    function hipblasZdrot_v2_(handle,n,x,incx,y,incy,c,s) bind(c, name="hipblasZdrot_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrot_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdrot_v2_rank_0,&
      
hipblasZdrot_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotBatched applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to batched vectors x_i and y_i, for i = 1, ..., batchCount.
  !>         Scalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,sc,dz
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !>     @param[in]
  !>     n       [int]
  !>             number of elements in each x_i and y_i vectors.
  !>     @param[inout]
  !>     x       device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx    [int]
  !>             specifies the increment between elements of each x_i.
  !>     @param[inout]
  !>     y       device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy    [int]
  !>             specifies the increment between elements of each y_i.
  !>     @param[in]
  !>     c       device pointer or host pointer to scalar cosine component of the rotation matrix.
  !>     @param[in]
  !>     s       device pointer or host pointer to scalar sine component of the rotation matrix.
  !>     @param[in]
  !>     batchCount [int]
  !>                 the number of x and y arrays, i.e. the number of batches.
  !> 
  !>     
  interface hipblasSrotBatched
#ifdef USE_CUDA_NAMES
    function hipblasSrotBatched_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="cublasSrotBatched")
#else
    function hipblasSrotBatched_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="hipblasSrotBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSrotBatched_full_rank,&
      
hipblasSrotBatched_rank_0,&
      
hipblasSrotBatched_rank_1
#endif

  end interface
  
  interface hipblasDrotBatched
#ifdef USE_CUDA_NAMES
    function hipblasDrotBatched_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="cublasDrotBatched")
#else
    function hipblasDrotBatched_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="hipblasDrotBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDrotBatched_full_rank,&
      
hipblasDrotBatched_rank_0,&
      
hipblasDrotBatched_rank_1
#endif

  end interface
  
  interface hipblasCrotBatched
#ifdef USE_CUDA_NAMES
    function hipblasCrotBatched_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="cublasCrotBatched")
#else
    function hipblasCrotBatched_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="hipblasCrotBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCrotBatched_full_rank,&
      
hipblasCrotBatched_rank_0,&
      
hipblasCrotBatched_rank_1
#endif

  end interface
  
  interface hipblasCsrotBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsrotBatched_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="cublasCsrotBatched")
#else
    function hipblasCsrotBatched_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="hipblasCsrotBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrotBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsrotBatched_full_rank,&
      
hipblasCsrotBatched_rank_0,&
      
hipblasCsrotBatched_rank_1
#endif

  end interface
  
  interface hipblasZrotBatched
#ifdef USE_CUDA_NAMES
    function hipblasZrotBatched_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="cublasZrotBatched")
#else
    function hipblasZrotBatched_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="hipblasZrotBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZrotBatched_full_rank,&
      
hipblasZrotBatched_rank_0,&
      
hipblasZrotBatched_rank_1
#endif

  end interface
  
  interface hipblasZdrotBatched
#ifdef USE_CUDA_NAMES
    function hipblasZdrotBatched_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="cublasZdrotBatched")
#else
    function hipblasZdrotBatched_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="hipblasZdrotBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrotBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdrotBatched_full_rank,&
      
hipblasZdrotBatched_rank_0,&
      
hipblasZdrotBatched_rank_1
#endif

  end interface
  
  interface hipblasCrotBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCrotBatched_v2_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="cublasCrotBatched_v2")
#else
    function hipblasCrotBatched_v2_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="hipblasCrotBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCrotBatched_v2_full_rank,&
      
hipblasCrotBatched_v2_rank_0,&
      
hipblasCrotBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasCsrotBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsrotBatched_v2_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="cublasCsrotBatched_v2")
#else
    function hipblasCsrotBatched_v2_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="hipblasCsrotBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrotBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsrotBatched_v2_full_rank,&
      
hipblasCsrotBatched_v2_rank_0,&
      
hipblasCsrotBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZrotBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZrotBatched_v2_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="cublasZrotBatched_v2")
#else
    function hipblasZrotBatched_v2_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="hipblasZrotBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZrotBatched_v2_full_rank,&
      
hipblasZrotBatched_v2_rank_0,&
      
hipblasZrotBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZdrotBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZdrotBatched_v2_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="cublasZdrotBatched_v2")
#else
    function hipblasZdrotBatched_v2_(handle,n,x,incx,y,incy,c,s,batchCount) bind(c, name="hipblasZdrotBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrotBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdrotBatched_v2_full_rank,&
      
hipblasZdrotBatched_v2_rank_0,&
      
hipblasZdrotBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotStridedBatched applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to strided batched vectors x_i and y_i, for i = 1, ..., batchCount.
  !>         Scalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,sc,dz
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !>     @param[in]
  !>     n       [int]
  !>             number of elements in each x_i and y_i vectors.
  !>     @param[inout]
  !>     x       device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx    [int]
  !>             specifies the increment between elements of each x_i.
  !>     @param[in]
  !>     stridex [hipblasStride]
  !>              specifies the increment from the beginning of x_i to the beginning of x_(i+1)
  !>     @param[inout]
  !>     y       device pointer to the first vector y_1.
  !>     @param[in]
  !>     incy    [int]
  !>             specifies the increment between elements of each y_i.
  !>     @param[in]
  !>     stridey  [hipblasStride]
  !>              specifies the increment from the beginning of y_i to the beginning of y_(i+1)
  !>     @param[in]
  !>     c       device pointer or host pointer to scalar cosine component of the rotation matrix.
  !>     @param[in]
  !>     s       device pointer or host pointer to scalar sine component of the rotation matrix.
  !>     @param[in]
  !>     batchCount [int]
  !>             the number of x and y arrays, i.e. the number of batches.
  !> 
  !>     
  interface hipblasSrotStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSrotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="cublasSrotStridedBatched")
#else
    function hipblasSrotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="hipblasSrotStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSrotStridedBatched_rank_0,&
      
hipblasSrotStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDrotStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDrotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="cublasDrotStridedBatched")
#else
    function hipblasDrotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="hipblasDrotStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDrotStridedBatched_rank_0,&
      
hipblasDrotStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCrotStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCrotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="cublasCrotStridedBatched")
#else
    function hipblasCrotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="hipblasCrotStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCrotStridedBatched_rank_0,&
      
hipblasCrotStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCsrotStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsrotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="cublasCsrotStridedBatched")
#else
    function hipblasCsrotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="hipblasCsrotStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrotStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsrotStridedBatched_rank_0,&
      
hipblasCsrotStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZrotStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZrotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="cublasZrotStridedBatched")
#else
    function hipblasZrotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="hipblasZrotStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZrotStridedBatched_rank_0,&
      
hipblasZrotStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZdrotStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZdrotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="cublasZdrotStridedBatched")
#else
    function hipblasZdrotStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="hipblasZdrotStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrotStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdrotStridedBatched_rank_0,&
      
hipblasZdrotStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCrotStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCrotStridedBatched_v2_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="cublasCrotStridedBatched_v2")
#else
    function hipblasCrotStridedBatched_v2_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="hipblasCrotStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCrotStridedBatched_v2_rank_0,&
      
hipblasCrotStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasCsrotStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsrotStridedBatched_v2_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="cublasCsrotStridedBatched_v2")
#else
    function hipblasCsrotStridedBatched_v2_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="hipblasCsrotStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrotStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsrotStridedBatched_v2_rank_0,&
      
hipblasCsrotStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZrotStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZrotStridedBatched_v2_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="cublasZrotStridedBatched_v2")
#else
    function hipblasZrotStridedBatched_v2_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="hipblasZrotStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZrotStridedBatched_v2_rank_0,&
      
hipblasZrotStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZdrotStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZdrotStridedBatched_v2_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="cublasZdrotStridedBatched_v2")
#else
    function hipblasZdrotStridedBatched_v2_(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount) bind(c, name="hipblasZdrotStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrotStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdrotStridedBatched_v2_rank_0,&
      
hipblasZdrotStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotg creates the Givens rotation matrix for the vector (a b).
  !>          Scalars c and s and arrays a and b may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !>          If the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.
  !>          If the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !>     @param[inout]
  !>     a       device pointer or host pointer to input vector element, overwritten with r.
  !>     @param[inout]
  !>     b       device pointer or host pointer to input vector element, overwritten with z.
  !>     @param[inout]
  !>     c       device pointer or host pointer to cosine element of Givens rotation.
  !>     @param[inout]
  !>     s       device pointer or host pointer sine element of Givens rotation.
  !> 
  !>     
  interface hipblasSrotg
#ifdef USE_CUDA_NAMES
    function hipblasSrotg_(handle,a,b,c,s) bind(c, name="cublasSrotg_v2")
#else
    function hipblasSrotg_(handle,a,b,c,s) bind(c, name="hipblasSrotg")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotg_
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      type(c_ptr),value :: b
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function


  end interface
  
  interface hipblasDrotg
#ifdef USE_CUDA_NAMES
    function hipblasDrotg_(handle,a,b,c,s) bind(c, name="cublasDrotg_v2")
#else
    function hipblasDrotg_(handle,a,b,c,s) bind(c, name="hipblasDrotg")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotg_
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      type(c_ptr),value :: b
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function


  end interface
  
  interface hipblasCrotg
#ifdef USE_CUDA_NAMES
    function hipblasCrotg_(handle,a,b,c,s) bind(c, name="cublasCrotg_v2")
#else
    function hipblasCrotg_(handle,a,b,c,s) bind(c, name="hipblasCrotg")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotg_
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      type(c_ptr),value :: b
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function


  end interface
  
  interface hipblasZrotg
#ifdef USE_CUDA_NAMES
    function hipblasZrotg_(handle,a,b,c,s) bind(c, name="cublasZrotg_v2")
#else
    function hipblasZrotg_(handle,a,b,c,s) bind(c, name="hipblasZrotg")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotg_
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      type(c_ptr),value :: b
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function


  end interface
  
  interface hipblasCrotg_v2
#ifdef USE_CUDA_NAMES
    function hipblasCrotg_v2_(handle,a,b,c,s) bind(c, name="cublasCrotg_v2")
#else
    function hipblasCrotg_v2_(handle,a,b,c,s) bind(c, name="hipblasCrotg_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotg_v2_
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      type(c_ptr),value :: b
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function


  end interface
  
  interface hipblasZrotg_v2
#ifdef USE_CUDA_NAMES
    function hipblasZrotg_v2_(handle,a,b,c,s) bind(c, name="cublasZrotg_v2")
#else
    function hipblasZrotg_v2_(handle,a,b,c,s) bind(c, name="hipblasZrotg_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotg_v2_
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      type(c_ptr),value :: b
      type(c_ptr),value :: c
      type(c_ptr),value :: s
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotgBatched creates the Givens rotation matrix for the batched vectors (a_i b_i), for i = 1, ..., batchCount.
  !>          a, b, c, and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !>          If the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.
  !>          If the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !>     @param[inout]
  !>     a       device array of device pointers storing each single input vector element a_i, overwritten with r_i.
  !>     @param[inout]
  !>     b       device array of device pointers storing each single input vector element b_i, overwritten with z_i.
  !>     @param[inout]
  !>     c       device array of device pointers storing each cosine element of Givens rotation for the batch.
  !>     @param[inout]
  !>     s       device array of device pointers storing each sine element of Givens rotation for the batch.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of batches (length of arrays a, b, c, and s).
  !> 
  !>     
  interface hipblasSrotgBatched
#ifdef USE_CUDA_NAMES
    function hipblasSrotgBatched_(handle,a,b,c,s,batchCount) bind(c, name="cublasSrotgBatched")
#else
    function hipblasSrotgBatched_(handle,a,b,c,s,batchCount) bind(c, name="hipblasSrotgBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotgBatched_
      type(c_ptr),value :: handle
      type(c_ptr) :: a
      type(c_ptr) :: b
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasDrotgBatched
#ifdef USE_CUDA_NAMES
    function hipblasDrotgBatched_(handle,a,b,c,s,batchCount) bind(c, name="cublasDrotgBatched")
#else
    function hipblasDrotgBatched_(handle,a,b,c,s,batchCount) bind(c, name="hipblasDrotgBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotgBatched_
      type(c_ptr),value :: handle
      type(c_ptr) :: a
      type(c_ptr) :: b
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCrotgBatched
#ifdef USE_CUDA_NAMES
    function hipblasCrotgBatched_(handle,a,b,c,s,batchCount) bind(c, name="cublasCrotgBatched")
#else
    function hipblasCrotgBatched_(handle,a,b,c,s,batchCount) bind(c, name="hipblasCrotgBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotgBatched_
      type(c_ptr),value :: handle
      type(c_ptr) :: a
      type(c_ptr) :: b
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZrotgBatched
#ifdef USE_CUDA_NAMES
    function hipblasZrotgBatched_(handle,a,b,c,s,batchCount) bind(c, name="cublasZrotgBatched")
#else
    function hipblasZrotgBatched_(handle,a,b,c,s,batchCount) bind(c, name="hipblasZrotgBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotgBatched_
      type(c_ptr),value :: handle
      type(c_ptr) :: a
      type(c_ptr) :: b
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCrotgBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCrotgBatched_v2_(handle,a,b,c,s,batchCount) bind(c, name="cublasCrotgBatched_v2")
#else
    function hipblasCrotgBatched_v2_(handle,a,b,c,s,batchCount) bind(c, name="hipblasCrotgBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotgBatched_v2_
      type(c_ptr),value :: handle
      type(c_ptr) :: a
      type(c_ptr) :: b
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZrotgBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZrotgBatched_v2_(handle,a,b,c,s,batchCount) bind(c, name="cublasZrotgBatched_v2")
#else
    function hipblasZrotgBatched_v2_(handle,a,b,c,s,batchCount) bind(c, name="hipblasZrotgBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotgBatched_v2_
      type(c_ptr),value :: handle
      type(c_ptr) :: a
      type(c_ptr) :: b
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int),value :: batchCount
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotgStridedBatched creates the Givens rotation matrix for the strided batched vectors (a_i b_i), for i = 1, ..., batchCount.
  !>          a, b, c, and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !>          If the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.
  !>          If the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function returns immediately and synchronization is required to read the results.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !>     @param[inout]
  !>     a       device strided_batched pointer or host strided_batched pointer to first single input vector element a_1, overwritten with r.
  !>     @param[in]
  !>     stridea [hipblasStride]
  !>              distance between elements of a in batch (distance between a_i and a_(i + 1))
  !>     @param[inout]
  !>     b       device strided_batched pointer or host strided_batched pointer to first single input vector element b_1, overwritten with z.
  !>     @param[in]
  !>     strideb [hipblasStride]
  !>              distance between elements of b in batch (distance between b_i and b_(i + 1))
  !>     @param[inout]
  !>     c       device strided_batched pointer or host strided_batched pointer to first cosine element of Givens rotations c_1.
  !>     @param[in]
  !>     stridec [hipblasStride]
  !>              distance between elements of c in batch (distance between c_i and c_(i + 1))
  !>     @param[inout]
  !>     s       device strided_batched pointer or host strided_batched pointer to sine element of Givens rotations s_1.
  !>     @param[in]
  !>     strides [hipblasStride]
  !>              distance between elements of s in batch (distance between s_i and s_(i + 1))
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of batches (length of arrays a, b, c, and s).
  !> 
  !>     
  interface hipblasSrotgStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSrotgStridedBatched_(handle,a,stridea,b,strideb,c,stridec,s,strides,batchCount) bind(c, name="cublasSrotgStridedBatched")
#else
    function hipblasSrotgStridedBatched_(handle,a,stridea,b,strideb,c,stridec,s,strides,batchCount) bind(c, name="hipblasSrotgStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotgStridedBatched_
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      integer(c_int64_t),value :: stridea
      type(c_ptr),value :: b
      integer(c_int64_t),value :: strideb
      type(c_ptr),value :: c
      integer(c_int64_t),value :: stridec
      type(c_ptr),value :: s
      integer(c_int64_t),value :: strides
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasDrotgStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDrotgStridedBatched_(handle,a,stridea,b,strideb,c,stridec,s,strides,batchCount) bind(c, name="cublasDrotgStridedBatched")
#else
    function hipblasDrotgStridedBatched_(handle,a,stridea,b,strideb,c,stridec,s,strides,batchCount) bind(c, name="hipblasDrotgStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotgStridedBatched_
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      integer(c_int64_t),value :: stridea
      type(c_ptr),value :: b
      integer(c_int64_t),value :: strideb
      type(c_ptr),value :: c
      integer(c_int64_t),value :: stridec
      type(c_ptr),value :: s
      integer(c_int64_t),value :: strides
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCrotgStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCrotgStridedBatched_(handle,a,stridea,b,strideb,c,stridec,s,strides,batchCount) bind(c, name="cublasCrotgStridedBatched")
#else
    function hipblasCrotgStridedBatched_(handle,a,stridea,b,strideb,c,stridec,s,strides,batchCount) bind(c, name="hipblasCrotgStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotgStridedBatched_
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      integer(c_int64_t),value :: stridea
      type(c_ptr),value :: b
      integer(c_int64_t),value :: strideb
      type(c_ptr),value :: c
      integer(c_int64_t),value :: stridec
      type(c_ptr),value :: s
      integer(c_int64_t),value :: strides
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZrotgStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZrotgStridedBatched_(handle,a,stridea,b,strideb,c,stridec,s,strides,batchCount) bind(c, name="cublasZrotgStridedBatched")
#else
    function hipblasZrotgStridedBatched_(handle,a,stridea,b,strideb,c,stridec,s,strides,batchCount) bind(c, name="hipblasZrotgStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotgStridedBatched_
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      integer(c_int64_t),value :: stridea
      type(c_ptr),value :: b
      integer(c_int64_t),value :: strideb
      type(c_ptr),value :: c
      integer(c_int64_t),value :: stridec
      type(c_ptr),value :: s
      integer(c_int64_t),value :: strides
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCrotgStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCrotgStridedBatched_v2_(handle,a,stridea,b,strideb,c,stridec,s,strides,batchCount) bind(c, name="cublasCrotgStridedBatched_v2")
#else
    function hipblasCrotgStridedBatched_v2_(handle,a,stridea,b,strideb,c,stridec,s,strides,batchCount) bind(c, name="hipblasCrotgStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotgStridedBatched_v2_
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      integer(c_int64_t),value :: stridea
      type(c_ptr),value :: b
      integer(c_int64_t),value :: strideb
      type(c_ptr),value :: c
      integer(c_int64_t),value :: stridec
      type(c_ptr),value :: s
      integer(c_int64_t),value :: strides
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZrotgStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZrotgStridedBatched_v2_(handle,a,stridea,b,strideb,c,stridec,s,strides,batchCount) bind(c, name="cublasZrotgStridedBatched_v2")
#else
    function hipblasZrotgStridedBatched_v2_(handle,a,stridea,b,strideb,c,stridec,s,strides,batchCount) bind(c, name="hipblasZrotgStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotgStridedBatched_v2_
      type(c_ptr),value :: handle
      type(c_ptr),value :: a
      integer(c_int64_t),value :: stridea
      type(c_ptr),value :: b
      integer(c_int64_t),value :: strideb
      type(c_ptr),value :: c
      integer(c_int64_t),value :: stridec
      type(c_ptr),value :: s
      integer(c_int64_t),value :: strides
      integer(c_int),value :: batchCount
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotm applies the modified Givens rotation matrix defined by param to vectors x and y.
  !> 
  !>     - Supported precisions in rocBLAS : s,d
  !>     - Supported precisions in cuBLAS  : s,d
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !>     @param[in]
  !>     n       [int]
  !>             number of elements in the x and y vectors.
  !>     @param[inout]
  !>     x       device pointer storing vector x.
  !>     @param[in]
  !>     incx    [int]
  !>             specifies the increment between elements of x.
  !>     @param[inout]
  !>     y       device pointer storing vector y.
  !>     @param[in]
  !>     incy    [int]
  !>             specifies the increment between elements of y.
  !>     @param[in]
  !>     param   device vector or host vector of 5 elements defining the rotation.
  !>             param[0] = flag
  !>             param[1] = H11
  !>             param[2] = H21
  !>             param[3] = H12
  !>             param[4] = H22
  !>             The flag parameter defines the form of H:
  !>             flag = -1 => H = ( H11 H12 H21 H22 )
  !>             flag =  0 => H = ( 1.0 H12 H21 1.0 )
  !>             flag =  1 => H = ( H11 1.0 -1.0 H22 )
  !>             flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
  !>             param may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !> 
  !>     
  interface hipblasSrotm
#ifdef USE_CUDA_NAMES
    function hipblasSrotm_(handle,n,x,incx,y,incy,param) bind(c, name="cublasSrotm_v2")
#else
    function hipblasSrotm_(handle,n,x,incx,y,incy,param) bind(c, name="hipblasSrotm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotm_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: param
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSrotm_rank_0,&
      
hipblasSrotm_rank_1
#endif

  end interface
  
  interface hipblasDrotm
#ifdef USE_CUDA_NAMES
    function hipblasDrotm_(handle,n,x,incx,y,incy,param) bind(c, name="cublasDrotm_v2")
#else
    function hipblasDrotm_(handle,n,x,incx,y,incy,param) bind(c, name="hipblasDrotm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotm_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: param
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDrotm_rank_0,&
      
hipblasDrotm_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotmBatched applies the modified Givens rotation matrix defined by param_i to batched vectors x_i and y_i, for i = 1, ..., batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : s,d
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !>     @param[in]
  !>     n       [int]
  !>             number of elements in the x and y vectors.
  !>     @param[inout]
  !>     x       device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx    [int]
  !>             specifies the increment between elements of each x_i.
  !>     @param[inout]
  !>     y       device array of device pointers storing each vector y_1.
  !>     @param[in]
  !>     incy    [int]
  !>             specifies the increment between elements of each y_i.
  !>     @param[in]
  !>     param   device array of device vectors of 5 elements defining the rotation.
  !>             param[0] = flag
  !>             param[1] = H11
  !>             param[2] = H21
  !>             param[3] = H12
  !>             param[4] = H22
  !>             The flag parameter defines the form of H:
  !>             flag = -1 => H = ( H11 H12 H21 H22 )
  !>             flag =  0 => H = ( 1.0 H12 H21 1.0 )
  !>             flag =  1 => H = ( H11 1.0 -1.0 H22 )
  !>             flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
  !>             param may ONLY be stored on the device for the batched version of this function.
  !>     @param[in]
  !>     batchCount [int]
  !>                 the number of x and y arrays, i.e. the number of batches.
  !> 
  !>     
  interface hipblasSrotmBatched
#ifdef USE_CUDA_NAMES
    function hipblasSrotmBatched_(handle,n,x,incx,y,incy,param,batchCount) bind(c, name="cublasSrotmBatched")
#else
    function hipblasSrotmBatched_(handle,n,x,incx,y,incy,param,batchCount) bind(c, name="hipblasSrotmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotmBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: param
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSrotmBatched_full_rank,&
      
hipblasSrotmBatched_rank_0,&
      
hipblasSrotmBatched_rank_1
#endif

  end interface
  
  interface hipblasDrotmBatched
#ifdef USE_CUDA_NAMES
    function hipblasDrotmBatched_(handle,n,x,incx,y,incy,param,batchCount) bind(c, name="cublasDrotmBatched")
#else
    function hipblasDrotmBatched_(handle,n,x,incx,y,incy,param,batchCount) bind(c, name="hipblasDrotmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotmBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: param
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDrotmBatched_full_rank,&
      
hipblasDrotmBatched_rank_0,&
      
hipblasDrotmBatched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotmStridedBatched applies the modified Givens rotation matrix defined by param_i to strided batched vectors x_i and y_i, for i = 1, ..., batchCount
  !> 
  !>     - Supported precisions in rocBLAS : s,d
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !>     @param[in]
  !>     n       [int]
  !>             number of elements in the x and y vectors.
  !>     @param[inout]
  !>     x       device pointer pointing to first strided batched vector x_1.
  !>     @param[in]
  !>     incx    [int]
  !>             specifies the increment between elements of each x_i.
  !>     @param[in]
  !>     stridex [hipblasStride]
  !>              specifies the increment between the beginning of x_i and x_(i + 1)
  !>     @param[inout]
  !>     y       device pointer pointing to first strided batched vector y_1.
  !>     @param[in]
  !>     incy    [int]
  !>             specifies the increment between elements of each y_i.
  !>     @param[in]
  !>     stridey  [hipblasStride]
  !>              specifies the increment between the beginning of y_i and y_(i + 1)
  !>     @param[in]
  !>     param   device pointer pointing to first array of 5 elements defining the rotation (param_1).
  !>             param[0] = flag
  !>             param[1] = H11
  !>             param[2] = H21
  !>             param[3] = H12
  !>             param[4] = H22
  !>             The flag parameter defines the form of H:
  !>             flag = -1 => H = ( H11 H12 H21 H22 )
  !>             flag =  0 => H = ( 1.0 H12 H21 1.0 )
  !>             flag =  1 => H = ( H11 1.0 -1.0 H22 )
  !>             flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
  !>             param may ONLY be stored on the device for the strided_batched version of this function.
  !>     @param[in]
  !>     strideParam [hipblasStride]
  !>                  specifies the increment between the beginning of param_i and param_(i + 1)
  !>     @param[in]
  !>     batchCount [int]
  !>                 the number of x and y arrays, i.e. the number of batches.
  !> 
  !>     
  interface hipblasSrotmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSrotmStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,param,strideParam,batchCount) bind(c, name="cublasSrotmStridedBatched")
#else
    function hipblasSrotmStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,param,strideParam,batchCount) bind(c, name="hipblasSrotmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotmStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: param
      integer(c_int64_t),value :: strideParam
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSrotmStridedBatched_rank_0,&
      
hipblasSrotmStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDrotmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDrotmStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,param,strideParam,batchCount) bind(c, name="cublasDrotmStridedBatched")
#else
    function hipblasDrotmStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,param,strideParam,batchCount) bind(c, name="hipblasDrotmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotmStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: param
      integer(c_int64_t),value :: strideParam
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDrotmStridedBatched_rank_0,&
      
hipblasDrotmStridedBatched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotmg creates the modified Givens rotation matrix for the vector (d1  x1, d2  y1).
  !>           Parameters may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !>           If the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.
  !>           If the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.
  !> 
  !>     - Supported precisions in rocBLAS : s,d
  !>     - Supported precisions in cuBLAS  : s,d
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !>     @param[inout]
  !>     d1      device pointer or host pointer to input scalar that is overwritten.
  !>     @param[inout]
  !>     d2      device pointer or host pointer to input scalar that is overwritten.
  !>     @param[inout]
  !>     x1      device pointer or host pointer to input scalar that is overwritten.
  !>     @param[in]
  !>     y1      device pointer or host pointer to input scalar.
  !>     @param[out]
  !>     param   device vector or host vector of 5 elements defining the rotation.
  !>             param[0] = flag
  !>             param[1] = H11
  !>             param[2] = H21
  !>             param[3] = H12
  !>             param[4] = H22
  !>             The flag parameter defines the form of H:
  !>             flag = -1 => H = ( H11 H12 H21 H22 )
  !>             flag =  0 => H = ( 1.0 H12 H21 1.0 )
  !>             flag =  1 => H = ( H11 1.0 -1.0 H22 )
  !>             flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
  !>             param may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !> 
  !>     
  interface hipblasSrotmg
#ifdef USE_CUDA_NAMES
    function hipblasSrotmg_(handle,d1,d2,x1,y1,param) bind(c, name="cublasSrotmg_v2")
#else
    function hipblasSrotmg_(handle,d1,d2,x1,y1,param) bind(c, name="hipblasSrotmg")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotmg_
      type(c_ptr),value :: handle
      type(c_ptr),value :: d1
      type(c_ptr),value :: d2
      type(c_ptr),value :: x1
      type(c_ptr),value :: y1
      type(c_ptr),value :: param
    end function


  end interface
  
  interface hipblasDrotmg
#ifdef USE_CUDA_NAMES
    function hipblasDrotmg_(handle,d1,d2,x1,y1,param) bind(c, name="cublasDrotmg_v2")
#else
    function hipblasDrotmg_(handle,d1,d2,x1,y1,param) bind(c, name="hipblasDrotmg")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotmg_
      type(c_ptr),value :: handle
      type(c_ptr),value :: d1
      type(c_ptr),value :: d2
      type(c_ptr),value :: x1
      type(c_ptr),value :: y1
      type(c_ptr),value :: param
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotmgBatched creates the modified Givens rotation matrix for the batched vectors (d1_i  x1_i, d2_i  y1_i), for i = 1, ..., batchCount.
  !>           Parameters may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !>           If the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.
  !>           If the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.
  !> 
  !>     - Supported precisions in rocBLAS : s,d
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !>     @param[inout]
  !>     d1      device batched array or host batched array of input scalars that is overwritten.
  !>     @param[inout]
  !>     d2      device batched array or host batched array of input scalars that is overwritten.
  !>     @param[inout]
  !>     x1      device batched array or host batched array of input scalars that is overwritten.
  !>     @param[in]
  !>     y1      device batched array or host batched array of input scalars.
  !>     @param[out]
  !>     param   device batched array or host batched array of vectors of 5 elements defining the rotation.
  !>             param[0] = flag
  !>             param[1] = H11
  !>             param[2] = H21
  !>             param[3] = H12
  !>             param[4] = H22
  !>             The flag parameter defines the form of H:
  !>             flag = -1 => H = ( H11 H12 H21 H22 )
  !>             flag =  0 => H = ( 1.0 H12 H21 1.0 )
  !>             flag =  1 => H = ( H11 1.0 -1.0 H22 )
  !>             flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
  !>             param may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !>     @param[in]
  !>     batchCount [int]
  !>                 the number of instances in the batch.
  !> 
  !>     
  interface hipblasSrotmgBatched
#ifdef USE_CUDA_NAMES
    function hipblasSrotmgBatched_(handle,d1,d2,x1,y1,param,batchCount) bind(c, name="cublasSrotmgBatched")
#else
    function hipblasSrotmgBatched_(handle,d1,d2,x1,y1,param,batchCount) bind(c, name="hipblasSrotmgBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotmgBatched_
      type(c_ptr),value :: handle
      type(c_ptr) :: d1
      type(c_ptr) :: d2
      type(c_ptr) :: x1
      type(c_ptr) :: y1
      type(c_ptr) :: param
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasDrotmgBatched
#ifdef USE_CUDA_NAMES
    function hipblasDrotmgBatched_(handle,d1,d2,x1,y1,param,batchCount) bind(c, name="cublasDrotmgBatched")
#else
    function hipblasDrotmgBatched_(handle,d1,d2,x1,y1,param,batchCount) bind(c, name="hipblasDrotmgBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotmgBatched_
      type(c_ptr),value :: handle
      type(c_ptr) :: d1
      type(c_ptr) :: d2
      type(c_ptr) :: x1
      type(c_ptr) :: y1
      type(c_ptr) :: param
      integer(c_int),value :: batchCount
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotmgStridedBatched creates the modified Givens rotation matrix for the strided batched vectors (d1_i  x1_i, d2_i  y1_i), for i = 1, ..., batchCount.
  !>           Parameters may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !>           If the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.
  !>           If the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.
  !> 
  !>     - Supported precisions in rocBLAS : s,d
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !>     @param[inout]
  !>     d1      device strided_batched array or host strided_batched array of input scalars that is overwritten.
  !>     @param[in]
  !>     strided1 [hipblasStride]
  !>               specifies the increment between the beginning of d1_i and d1_(i+1)
  !>     @param[inout]
  !>     d2      device strided_batched array or host strided_batched array of input scalars that is overwritten.
  !>     @param[in]
  !>     strided2 [hipblasStride]
  !>               specifies the increment between the beginning of d2_i and d2_(i+1)
  !>     @param[inout]
  !>     x1      device strided_batched array or host strided_batched array of input scalars that is overwritten.
  !>     @param[in]
  !>     stridex1 [hipblasStride]
  !>               specifies the increment between the beginning of x1_i and x1_(i+1)
  !>     @param[in]
  !>     y1      device strided_batched array or host strided_batched array of input scalars.
  !>     @param[in]
  !>     stridey1 [hipblasStride]
  !>               specifies the increment between the beginning of y1_i and y1_(i+1)
  !>     @param[out]
  !>     param   device stridedBatched array or host stridedBatched array of vectors of 5 elements defining the rotation.
  !>             param[0] = flag
  !>             param[1] = H11
  !>             param[2] = H21
  !>             param[3] = H12
  !>             param[4] = H22
  !>             The flag parameter defines the form of H:
  !>             flag = -1 => H = ( H11 H12 H21 H22 )
  !>             flag =  0 => H = ( 1.0 H12 H21 1.0 )
  !>             flag =  1 => H = ( H11 1.0 -1.0 H22 )
  !>             flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
  !>             param may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !>     @param[in]
  !>     strideParam [hipblasStride]
  !>                  specifies the increment between the beginning of param_i and param_(i + 1)
  !>     @param[in]
  !>     batchCount [int]
  !>                 the number of instances in the batch.
  !> 
  !>     
  interface hipblasSrotmgStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSrotmgStridedBatched_(handle,d1,strided1,d2,strided2,x1,stridex1,y1,stridey1,param,strideParam,batchCount) bind(c, name="cublasSrotmgStridedBatched")
#else
    function hipblasSrotmgStridedBatched_(handle,d1,strided1,d2,strided2,x1,stridex1,y1,stridey1,param,strideParam,batchCount) bind(c, name="hipblasSrotmgStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotmgStridedBatched_
      type(c_ptr),value :: handle
      type(c_ptr),value :: d1
      integer(c_int64_t),value :: strided1
      type(c_ptr),value :: d2
      integer(c_int64_t),value :: strided2
      type(c_ptr),value :: x1
      integer(c_int64_t),value :: stridex1
      type(c_ptr),value :: y1
      integer(c_int64_t),value :: stridey1
      type(c_ptr),value :: param
      integer(c_int64_t),value :: strideParam
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasDrotmgStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDrotmgStridedBatched_(handle,d1,strided1,d2,strided2,x1,stridex1,y1,stridey1,param,strideParam,batchCount) bind(c, name="cublasDrotmgStridedBatched")
#else
    function hipblasDrotmgStridedBatched_(handle,d1,strided1,d2,strided2,x1,stridex1,y1,stridey1,param,strideParam,batchCount) bind(c, name="hipblasDrotmgStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotmgStridedBatched_
      type(c_ptr),value :: handle
      type(c_ptr),value :: d1
      integer(c_int64_t),value :: strided1
      type(c_ptr),value :: d2
      integer(c_int64_t),value :: strided2
      type(c_ptr),value :: x1
      integer(c_int64_t),value :: stridex1
      type(c_ptr),value :: y1
      integer(c_int64_t),value :: stridey1
      type(c_ptr),value :: param
      integer(c_int64_t),value :: strideParam
      integer(c_int),value :: batchCount
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     scal  scales each element of vector x with scalar alpha.
  !> 
  !>         x := alpha  x
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z,cs,zd
  !>     - Supported precisions in cuBLAS  : s,d,c,z,cs,zd
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in x.
  !>     @param[in]
  !>     alpha     device pointer or host pointer for the scalar alpha.
  !>     @param[inout]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !> 
  !> 
  !>     
  interface hipblasSscal
#ifdef USE_CUDA_NAMES
    function hipblasSscal_(handle,n,alpha,x,incx) bind(c, name="cublasSscal_v2")
#else
    function hipblasSscal_(handle,n,alpha,x,incx) bind(c, name="hipblasSscal")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSscal_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSscal_rank_0,&
      
hipblasSscal_rank_1
#endif

  end interface
  
  interface hipblasDscal
#ifdef USE_CUDA_NAMES
    function hipblasDscal_(handle,n,alpha,x,incx) bind(c, name="cublasDscal_v2")
#else
    function hipblasDscal_(handle,n,alpha,x,incx) bind(c, name="hipblasDscal")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDscal_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDscal_rank_0,&
      
hipblasDscal_rank_1
#endif

  end interface
  
  interface hipblasCscal
#ifdef USE_CUDA_NAMES
    function hipblasCscal_(handle,n,alpha,x,incx) bind(c, name="cublasCscal_v2")
#else
    function hipblasCscal_(handle,n,alpha,x,incx) bind(c, name="hipblasCscal")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscal_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCscal_rank_0,&
      
hipblasCscal_rank_1
#endif

  end interface
  
  interface hipblasCsscal
#ifdef USE_CUDA_NAMES
    function hipblasCsscal_(handle,n,alpha,x,incx) bind(c, name="cublasCsscal_v2")
#else
    function hipblasCsscal_(handle,n,alpha,x,incx) bind(c, name="hipblasCsscal")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscal_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsscal_rank_0,&
      
hipblasCsscal_rank_1
#endif

  end interface
  
  interface hipblasZscal
#ifdef USE_CUDA_NAMES
    function hipblasZscal_(handle,n,alpha,x,incx) bind(c, name="cublasZscal_v2")
#else
    function hipblasZscal_(handle,n,alpha,x,incx) bind(c, name="hipblasZscal")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscal_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZscal_rank_0,&
      
hipblasZscal_rank_1
#endif

  end interface
  
  interface hipblasZdscal
#ifdef USE_CUDA_NAMES
    function hipblasZdscal_(handle,n,alpha,x,incx) bind(c, name="cublasZdscal_v2")
#else
    function hipblasZdscal_(handle,n,alpha,x,incx) bind(c, name="hipblasZdscal")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscal_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdscal_rank_0,&
      
hipblasZdscal_rank_1
#endif

  end interface
  
  interface hipblasCscal_v2
#ifdef USE_CUDA_NAMES
    function hipblasCscal_v2_(handle,n,alpha,x,incx) bind(c, name="cublasCscal_v2")
#else
    function hipblasCscal_v2_(handle,n,alpha,x,incx) bind(c, name="hipblasCscal_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscal_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCscal_v2_rank_0,&
      
hipblasCscal_v2_rank_1
#endif

  end interface
  
  interface hipblasCsscal_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsscal_v2_(handle,n,alpha,x,incx) bind(c, name="cublasCsscal_v2")
#else
    function hipblasCsscal_v2_(handle,n,alpha,x,incx) bind(c, name="hipblasCsscal_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscal_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsscal_v2_rank_0,&
      
hipblasCsscal_v2_rank_1
#endif

  end interface
  
  interface hipblasZscal_v2
#ifdef USE_CUDA_NAMES
    function hipblasZscal_v2_(handle,n,alpha,x,incx) bind(c, name="cublasZscal_v2")
#else
    function hipblasZscal_v2_(handle,n,alpha,x,incx) bind(c, name="hipblasZscal_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscal_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZscal_v2_rank_0,&
      
hipblasZscal_v2_rank_1
#endif

  end interface
  
  interface hipblasZdscal_v2
#ifdef USE_CUDA_NAMES
    function hipblasZdscal_v2_(handle,n,alpha,x,incx) bind(c, name="cublasZdscal_v2")
#else
    function hipblasZdscal_v2_(handle,n,alpha,x,incx) bind(c, name="hipblasZdscal_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscal_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdscal_v2_rank_0,&
      
hipblasZdscal_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !>     \details
  !>     scalBatched  scales each element of vector x_i with scalar alpha, for i = 1, ... , batchCount.
  !> 
  !>          x_i := alpha  x_i
  !> 
  !>      where (x_i) is the i-th instance of the batch.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z,cs,zd
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle      [hipblasHandle_t]
  !>                 handle to the hipblas library context queue.
  !>     @param[in]
  !>     n           [int]
  !>                 the number of elements in each x_i.
  !>     @param[in]
  !>     alpha       host pointer or device pointer for the scalar alpha.
  !>     @param[inout]
  !>     x           device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx        [int]
  !>                 specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     batchCount [int]
  !>                 specifies the number of batches in x.
  !>      
  interface hipblasSscalBatched
#ifdef USE_CUDA_NAMES
    function hipblasSscalBatched_(handle,n,alpha,x,incx,batchCount) bind(c, name="cublasSscalBatched")
#else
    function hipblasSscalBatched_(handle,n,alpha,x,incx,batchCount) bind(c, name="hipblasSscalBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSscalBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSscalBatched_full_rank,&
      
hipblasSscalBatched_rank_0,&
      
hipblasSscalBatched_rank_1
#endif

  end interface
  
  interface hipblasDscalBatched
#ifdef USE_CUDA_NAMES
    function hipblasDscalBatched_(handle,n,alpha,x,incx,batchCount) bind(c, name="cublasDscalBatched")
#else
    function hipblasDscalBatched_(handle,n,alpha,x,incx,batchCount) bind(c, name="hipblasDscalBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDscalBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDscalBatched_full_rank,&
      
hipblasDscalBatched_rank_0,&
      
hipblasDscalBatched_rank_1
#endif

  end interface
  
  interface hipblasCscalBatched
#ifdef USE_CUDA_NAMES
    function hipblasCscalBatched_(handle,n,alpha,x,incx,batchCount) bind(c, name="cublasCscalBatched")
#else
    function hipblasCscalBatched_(handle,n,alpha,x,incx,batchCount) bind(c, name="hipblasCscalBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscalBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCscalBatched_full_rank,&
      
hipblasCscalBatched_rank_0,&
      
hipblasCscalBatched_rank_1
#endif

  end interface
  
  interface hipblasZscalBatched
#ifdef USE_CUDA_NAMES
    function hipblasZscalBatched_(handle,n,alpha,x,incx,batchCount) bind(c, name="cublasZscalBatched")
#else
    function hipblasZscalBatched_(handle,n,alpha,x,incx,batchCount) bind(c, name="hipblasZscalBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscalBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZscalBatched_full_rank,&
      
hipblasZscalBatched_rank_0,&
      
hipblasZscalBatched_rank_1
#endif

  end interface
  
  interface hipblasCsscalBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsscalBatched_(handle,n,alpha,x,incx,batchCount) bind(c, name="cublasCsscalBatched")
#else
    function hipblasCsscalBatched_(handle,n,alpha,x,incx,batchCount) bind(c, name="hipblasCsscalBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscalBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsscalBatched_full_rank,&
      
hipblasCsscalBatched_rank_0,&
      
hipblasCsscalBatched_rank_1
#endif

  end interface
  
  interface hipblasZdscalBatched
#ifdef USE_CUDA_NAMES
    function hipblasZdscalBatched_(handle,n,alpha,x,incx,batchCount) bind(c, name="cublasZdscalBatched")
#else
    function hipblasZdscalBatched_(handle,n,alpha,x,incx,batchCount) bind(c, name="hipblasZdscalBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscalBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdscalBatched_full_rank,&
      
hipblasZdscalBatched_rank_0,&
      
hipblasZdscalBatched_rank_1
#endif

  end interface
  
  interface hipblasCscalBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCscalBatched_v2_(handle,n,alpha,x,incx,batchCount) bind(c, name="cublasCscalBatched_v2")
#else
    function hipblasCscalBatched_v2_(handle,n,alpha,x,incx,batchCount) bind(c, name="hipblasCscalBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscalBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCscalBatched_v2_full_rank,&
      
hipblasCscalBatched_v2_rank_0,&
      
hipblasCscalBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZscalBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZscalBatched_v2_(handle,n,alpha,x,incx,batchCount) bind(c, name="cublasZscalBatched_v2")
#else
    function hipblasZscalBatched_v2_(handle,n,alpha,x,incx,batchCount) bind(c, name="hipblasZscalBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscalBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZscalBatched_v2_full_rank,&
      
hipblasZscalBatched_v2_rank_0,&
      
hipblasZscalBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasCsscalBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsscalBatched_v2_(handle,n,alpha,x,incx,batchCount) bind(c, name="cublasCsscalBatched_v2")
#else
    function hipblasCsscalBatched_v2_(handle,n,alpha,x,incx,batchCount) bind(c, name="hipblasCsscalBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscalBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsscalBatched_v2_full_rank,&
      
hipblasCsscalBatched_v2_rank_0,&
      
hipblasCsscalBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZdscalBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZdscalBatched_v2_(handle,n,alpha,x,incx,batchCount) bind(c, name="cublasZdscalBatched_v2")
#else
    function hipblasZdscalBatched_v2_(handle,n,alpha,x,incx,batchCount) bind(c, name="hipblasZdscalBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscalBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdscalBatched_v2_full_rank,&
      
hipblasZdscalBatched_v2_rank_0,&
      
hipblasZdscalBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !>     \details
  !>     scalStridedBatched  scales each element of vector x_i with scalar alpha, for i = 1, ... , batchCount.
  !> 
  !>          x_i := alpha  x_i ,
  !> 
  !>      where (x_i) is the i-th instance of the batch.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z,cs,zd
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>      @param[in]
  !>     handle      [hipblasHandle_t]
  !>                 handle to the hipblas library context queue.
  !>     @param[in]
  !>     n           [int]
  !>                 the number of elements in each x_i.
  !>     @param[in]
  !>     alpha       host pointer or device pointer for the scalar alpha.
  !>     @param[inout]
  !>     x           device pointer to the first vector (x_1) in the batch.
  !>     @param[in]
  !>     incx        [int]
  !>                 specifies the increment for the elements of x.
  !>     @param[in]
  !>     stridex     [hipblasStride]
  !>                 stride from the start of one vector (x_i) and the next one (x_i+1).
  !>                 There are no restrictions placed on stride_x, however the user should
  !>                 take care to ensure that stride_x is of appropriate size, for a typical
  !>                 case this means stride_x >= n  incx.
  !>     @param[in]
  !>     batchCount [int]
  !>                 specifies the number of batches in x.
  !>      
  interface hipblasSscalStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSscalStridedBatched_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="cublasSscalStridedBatched")
#else
    function hipblasSscalStridedBatched_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="hipblasSscalStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSscalStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSscalStridedBatched_rank_0,&
      
hipblasSscalStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDscalStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDscalStridedBatched_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="cublasDscalStridedBatched")
#else
    function hipblasDscalStridedBatched_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="hipblasDscalStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDscalStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDscalStridedBatched_rank_0,&
      
hipblasDscalStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCscalStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCscalStridedBatched_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="cublasCscalStridedBatched")
#else
    function hipblasCscalStridedBatched_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="hipblasCscalStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscalStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCscalStridedBatched_rank_0,&
      
hipblasCscalStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZscalStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZscalStridedBatched_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="cublasZscalStridedBatched")
#else
    function hipblasZscalStridedBatched_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="hipblasZscalStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscalStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZscalStridedBatched_rank_0,&
      
hipblasZscalStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCsscalStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsscalStridedBatched_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="cublasCsscalStridedBatched")
#else
    function hipblasCsscalStridedBatched_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="hipblasCsscalStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscalStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsscalStridedBatched_rank_0,&
      
hipblasCsscalStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZdscalStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZdscalStridedBatched_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="cublasZdscalStridedBatched")
#else
    function hipblasZdscalStridedBatched_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="hipblasZdscalStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscalStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdscalStridedBatched_rank_0,&
      
hipblasZdscalStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCscalStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCscalStridedBatched_v2_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="cublasCscalStridedBatched_v2")
#else
    function hipblasCscalStridedBatched_v2_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="hipblasCscalStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscalStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCscalStridedBatched_v2_rank_0,&
      
hipblasCscalStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZscalStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZscalStridedBatched_v2_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="cublasZscalStridedBatched_v2")
#else
    function hipblasZscalStridedBatched_v2_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="hipblasZscalStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscalStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZscalStridedBatched_v2_rank_0,&
      
hipblasZscalStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasCsscalStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsscalStridedBatched_v2_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="cublasCsscalStridedBatched_v2")
#else
    function hipblasCsscalStridedBatched_v2_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="hipblasCsscalStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscalStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsscalStridedBatched_v2_rank_0,&
      
hipblasCsscalStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZdscalStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZdscalStridedBatched_v2_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="cublasZdscalStridedBatched_v2")
#else
    function hipblasZdscalStridedBatched_v2_(handle,n,alpha,x,incx,stridex,batchCount) bind(c, name="hipblasZdscalStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscalStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdscalStridedBatched_v2_rank_0,&
      
hipblasZdscalStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     swap  interchanges vectors x and y.
  !> 
  !>         y := x; x := y
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in x and y.
  !>     @param[inout]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[inout]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !> 
  !>     
  interface hipblasSswap
#ifdef USE_CUDA_NAMES
    function hipblasSswap_(handle,n,x,incx,y,incy) bind(c, name="cublasSswap_v2")
#else
    function hipblasSswap_(handle,n,x,incx,y,incy) bind(c, name="hipblasSswap")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSswap_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSswap_rank_0,&
      
hipblasSswap_rank_1
#endif

  end interface
  
  interface hipblasDswap
#ifdef USE_CUDA_NAMES
    function hipblasDswap_(handle,n,x,incx,y,incy) bind(c, name="cublasDswap_v2")
#else
    function hipblasDswap_(handle,n,x,incx,y,incy) bind(c, name="hipblasDswap")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDswap_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDswap_rank_0,&
      
hipblasDswap_rank_1
#endif

  end interface
  
  interface hipblasCswap
#ifdef USE_CUDA_NAMES
    function hipblasCswap_(handle,n,x,incx,y,incy) bind(c, name="cublasCswap_v2")
#else
    function hipblasCswap_(handle,n,x,incx,y,incy) bind(c, name="hipblasCswap")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswap_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCswap_rank_0,&
      
hipblasCswap_rank_1
#endif

  end interface
  
  interface hipblasZswap
#ifdef USE_CUDA_NAMES
    function hipblasZswap_(handle,n,x,incx,y,incy) bind(c, name="cublasZswap_v2")
#else
    function hipblasZswap_(handle,n,x,incx,y,incy) bind(c, name="hipblasZswap")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswap_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZswap_rank_0,&
      
hipblasZswap_rank_1
#endif

  end interface
  
  interface hipblasCswap_v2
#ifdef USE_CUDA_NAMES
    function hipblasCswap_v2_(handle,n,x,incx,y,incy) bind(c, name="cublasCswap_v2")
#else
    function hipblasCswap_v2_(handle,n,x,incx,y,incy) bind(c, name="hipblasCswap_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswap_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCswap_v2_rank_0,&
      
hipblasCswap_v2_rank_1
#endif

  end interface
  
  interface hipblasZswap_v2
#ifdef USE_CUDA_NAMES
    function hipblasZswap_v2_(handle,n,x,incx,y,incy) bind(c, name="cublasZswap_v2")
#else
    function hipblasZswap_v2_(handle,n,x,incx,y,incy) bind(c, name="hipblasZswap_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswap_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZswap_v2_rank_0,&
      
hipblasZswap_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     swapBatched interchanges vectors x_i and y_i, for i = 1 , ... , batchCount
  !> 
  !>         y_i := x_i; x_i := y_i
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in each x_i and y_i.
  !>     @param[inout]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[inout]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface hipblasSswapBatched
#ifdef USE_CUDA_NAMES
    function hipblasSswapBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="cublasSswapBatched")
#else
    function hipblasSswapBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="hipblasSswapBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSswapBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSswapBatched_full_rank,&
      
hipblasSswapBatched_rank_0,&
      
hipblasSswapBatched_rank_1
#endif

  end interface
  
  interface hipblasDswapBatched
#ifdef USE_CUDA_NAMES
    function hipblasDswapBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="cublasDswapBatched")
#else
    function hipblasDswapBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="hipblasDswapBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDswapBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDswapBatched_full_rank,&
      
hipblasDswapBatched_rank_0,&
      
hipblasDswapBatched_rank_1
#endif

  end interface
  
  interface hipblasCswapBatched
#ifdef USE_CUDA_NAMES
    function hipblasCswapBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="cublasCswapBatched")
#else
    function hipblasCswapBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="hipblasCswapBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswapBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCswapBatched_full_rank,&
      
hipblasCswapBatched_rank_0,&
      
hipblasCswapBatched_rank_1
#endif

  end interface
  
  interface hipblasZswapBatched
#ifdef USE_CUDA_NAMES
    function hipblasZswapBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="cublasZswapBatched")
#else
    function hipblasZswapBatched_(handle,n,x,incx,y,incy,batchCount) bind(c, name="hipblasZswapBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswapBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZswapBatched_full_rank,&
      
hipblasZswapBatched_rank_0,&
      
hipblasZswapBatched_rank_1
#endif

  end interface
  
  interface hipblasCswapBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCswapBatched_v2_(handle,n,x,incx,y,incy,batchCount) bind(c, name="cublasCswapBatched_v2")
#else
    function hipblasCswapBatched_v2_(handle,n,x,incx,y,incy,batchCount) bind(c, name="hipblasCswapBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswapBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCswapBatched_v2_full_rank,&
      
hipblasCswapBatched_v2_rank_0,&
      
hipblasCswapBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZswapBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZswapBatched_v2_(handle,n,x,incx,y,incy,batchCount) bind(c, name="cublasZswapBatched_v2")
#else
    function hipblasZswapBatched_v2_(handle,n,x,incx,y,incy,batchCount) bind(c, name="hipblasZswapBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswapBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZswapBatched_v2_full_rank,&
      
hipblasZswapBatched_v2_rank_0,&
      
hipblasZswapBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     swapStridedBatched interchanges vectors x_i and y_i, for i = 1 , ... , batchCount
  !> 
  !>         y_i := x_i; x_i := y_i
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in each x_i and y_i.
  !>     @param[inout]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     stridex   [hipblasStride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>               There are no restrictions placed on stride_x, however the user should
  !>               take care to ensure that stride_x is of appropriate size, for a typical
  !>               case this means stride_x >= n  incx.
  !>     @param[inout]
  !>     y         device pointer to the first vector y_1.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     stridey   [hipblasStride]
  !>               stride from the start of one vector (y_i) and the next one (y_i+1).
  !>               There are no restrictions placed on stride_x, however the user should
  !>               take care to ensure that stride_y is of appropriate size, for a typical
  !>               case this means stride_y >= n  incy. stridey should be non zero.
  !>      @param[in]
  !>      batchCount [int]
  !>                  number of instances in the batch.
  !> 
  !>     
  interface hipblasSswapStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSswapStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasSswapStridedBatched")
#else
    function hipblasSswapStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasSswapStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSswapStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSswapStridedBatched_rank_0,&
      
hipblasSswapStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDswapStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDswapStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasDswapStridedBatched")
#else
    function hipblasDswapStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasDswapStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDswapStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDswapStridedBatched_rank_0,&
      
hipblasDswapStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCswapStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCswapStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasCswapStridedBatched")
#else
    function hipblasCswapStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasCswapStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswapStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCswapStridedBatched_rank_0,&
      
hipblasCswapStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZswapStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZswapStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasZswapStridedBatched")
#else
    function hipblasZswapStridedBatched_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasZswapStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswapStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZswapStridedBatched_rank_0,&
      
hipblasZswapStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCswapStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCswapStridedBatched_v2_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasCswapStridedBatched_v2")
#else
    function hipblasCswapStridedBatched_v2_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasCswapStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswapStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCswapStridedBatched_v2_rank_0,&
      
hipblasCswapStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZswapStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZswapStridedBatched_v2_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="cublasZswapStridedBatched_v2")
#else
    function hipblasZswapStridedBatched_v2_(handle,n,x,incx,stridex,y,incy,stridey,batchCount) bind(c, name="hipblasZswapStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswapStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZswapStridedBatched_v2_rank_0,&
      
hipblasZswapStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     gbmv performs one of the matrix-vector operations
  !> 
  !>         y := alphaAx    + betay,   or
  !>         y := alphaATx + betay,   or
  !>         y := alphaAHx + betay,
  !> 
  !>     where alpha and beta are scalars, x and y are vectors and A is an
  !>     m by n banded matrix with kl sub-diagonals and ku super-diagonals.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     trans     [hipblasOperation_t]
  !>               indicates whether matrix A is tranposed (conjugated) or not
  !>     @param[in]
  !>     m         [int]
  !>               number of rows of matrix A
  !>     @param[in]
  !>     n         [int]
  !>               number of columns of matrix A
  !>     @param[in]
  !>     kl        [int]
  !>               number of sub-diagonals of A
  !>     @param[in]
  !>     ku        [int]
  !>               number of super-diagonals of A
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>         AP    device pointer storing banded matrix A.
  !>               Leading (kl + ku + 1) by n part of the matrix contains the coefficients
  !>               of the banded matrix. The leading diagonal resides in row (ku + 1) with
  !>               the first super-diagonal above on the RHS of row ku. The first sub-diagonal
  !>               resides below on the LHS of row ku + 2. This propagates up and down across
  !>               subsuper-diagonals.
  !>                 Ex: (m = n = 7; ku = 2, kl = 2)
  !>                 1 2 3 0 0 0 0             0 0 3 3 3 3 3
  !>                 4 1 2 3 0 0 0             0 2 2 2 2 2 2
  !>                 5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1
  !>                 0 5 4 1 2 3 0             4 4 4 4 4 4 0
  !>                 0 0 5 4 1 2 0             5 5 5 5 5 0 0
  !>                 0 0 0 5 4 1 2             0 0 0 0 0 0 0
  !>                 0 0 0 0 5 4 1             0 0 0 0 0 0 0
  !>               Note that the empty elements which don't correspond to data will not
  !>               be referenced.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A. Must be >= (kl + ku + 1)
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !> 
  !>     
  interface hipblasSgbmv
#ifdef USE_CUDA_NAMES
    function hipblasSgbmv_(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="cublasSgbmv_v2")
#else
    function hipblasSgbmv_(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="hipblasSgbmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgbmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSgbmv_rank_0,&
      
hipblasSgbmv_rank_1
#endif

  end interface
  
  interface hipblasDgbmv
#ifdef USE_CUDA_NAMES
    function hipblasDgbmv_(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="cublasDgbmv_v2")
#else
    function hipblasDgbmv_(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="hipblasDgbmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgbmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDgbmv_rank_0,&
      
hipblasDgbmv_rank_1
#endif

  end interface
  
  interface hipblasCgbmv
#ifdef USE_CUDA_NAMES
    function hipblasCgbmv_(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="cublasCgbmv_v2")
#else
    function hipblasCgbmv_(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="hipblasCgbmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgbmv_rank_0,&
      
hipblasCgbmv_rank_1
#endif

  end interface
  
  interface hipblasZgbmv
#ifdef USE_CUDA_NAMES
    function hipblasZgbmv_(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="cublasZgbmv_v2")
#else
    function hipblasZgbmv_(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="hipblasZgbmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgbmv_rank_0,&
      
hipblasZgbmv_rank_1
#endif

  end interface
  
  interface hipblasCgbmv_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgbmv_v2_(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="cublasCgbmv_v2")
#else
    function hipblasCgbmv_v2_(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="hipblasCgbmv_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmv_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgbmv_v2_rank_0,&
      
hipblasCgbmv_v2_rank_1
#endif

  end interface
  
  interface hipblasZgbmv_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgbmv_v2_(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="cublasZgbmv_v2")
#else
    function hipblasZgbmv_v2_(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="hipblasZgbmv_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmv_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgbmv_v2_rank_0,&
      
hipblasZgbmv_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     gbmvBatched performs one of the matrix-vector operations
  !> 
  !>         y_i := alphaA_ix_i    + betay_i,   or
  !>         y_i := alphaA_iTx_i + betay_i,   or
  !>         y_i := alphaA_iHx_i + betay_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     m by n banded matrix with kl sub-diagonals and ku super-diagonals,
  !>     for i = 1, ..., batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     trans     [hipblasOperation_t]
  !>               indicates whether matrix A is tranposed (conjugated) or not
  !>     @param[in]
  !>     m         [int]
  !>               number of rows of each matrix A_i
  !>     @param[in]
  !>     n         [int]
  !>               number of columns of each matrix A_i
  !>     @param[in]
  !>     kl        [int]
  !>               number of sub-diagonals of each A_i
  !>     @param[in]
  !>     ku        [int]
  !>               number of super-diagonals of each A_i
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>         AP    device array of device pointers storing each banded matrix A_i.
  !>               Leading (kl + ku + 1) by n part of the matrix contains the coefficients
  !>               of the banded matrix. The leading diagonal resides in row (ku + 1) with
  !>               the first super-diagonal above on the RHS of row ku. The first sub-diagonal
  !>               resides below on the LHS of row ku + 2. This propagates up and down across
  !>               subsuper-diagonals.
  !>                 Ex: (m = n = 7; ku = 2, kl = 2)
  !>                 1 2 3 0 0 0 0             0 0 3 3 3 3 3
  !>                 4 1 2 3 0 0 0             0 2 2 2 2 2 2
  !>                 5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1
  !>                 0 5 4 1 2 3 0             4 4 4 4 4 4 0
  !>                 0 0 5 4 1 2 0             5 5 5 5 5 0 0
  !>                 0 0 0 5 4 1 2             0 0 0 0 0 0 0
  !>                 0 0 0 0 5 4 1             0 0 0 0 0 0 0
  !>               Note that the empty elements which don't correspond to data will not
  !>               be referenced.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i. Must be >= (kl + ku + 1)
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     batchCount [int]
  !>                 specifies the number of instances in the batch.
  !> 
  !>     
  interface hipblasSgbmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgbmvBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasSgbmvBatched")
#else
    function hipblasSgbmvBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasSgbmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgbmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSgbmvBatched_full_rank,&
      
hipblasSgbmvBatched_rank_0,&
      
hipblasSgbmvBatched_rank_1
#endif

  end interface
  
  interface hipblasDgbmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgbmvBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasDgbmvBatched")
#else
    function hipblasDgbmvBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasDgbmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgbmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDgbmvBatched_full_rank,&
      
hipblasDgbmvBatched_rank_0,&
      
hipblasDgbmvBatched_rank_1
#endif

  end interface
  
  interface hipblasCgbmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgbmvBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasCgbmvBatched")
#else
    function hipblasCgbmvBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasCgbmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgbmvBatched_full_rank,&
      
hipblasCgbmvBatched_rank_0,&
      
hipblasCgbmvBatched_rank_1
#endif

  end interface
  
  interface hipblasZgbmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgbmvBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasZgbmvBatched")
#else
    function hipblasZgbmvBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasZgbmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgbmvBatched_full_rank,&
      
hipblasZgbmvBatched_rank_0,&
      
hipblasZgbmvBatched_rank_1
#endif

  end interface
  
  interface hipblasCgbmvBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgbmvBatched_v2_(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasCgbmvBatched_v2")
#else
    function hipblasCgbmvBatched_v2_(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasCgbmvBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmvBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgbmvBatched_v2_full_rank,&
      
hipblasCgbmvBatched_v2_rank_0,&
      
hipblasCgbmvBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZgbmvBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgbmvBatched_v2_(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasZgbmvBatched_v2")
#else
    function hipblasZgbmvBatched_v2_(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasZgbmvBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmvBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgbmvBatched_v2_full_rank,&
      
hipblasZgbmvBatched_v2_rank_0,&
      
hipblasZgbmvBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     gbmvStridedBatched performs one of the matrix-vector operations
  !> 
  !>         y_i := alphaA_ix_i    + betay_i,   or
  !>         y_i := alphaA_iTx_i + betay_i,   or
  !>         y_i := alphaA_iHx_i + betay_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     m by n banded matrix with kl sub-diagonals and ku super-diagonals,
  !>     for i = 1, ..., batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     trans     [hipblasOperation_t]
  !>               indicates whether matrix A is tranposed (conjugated) or not
  !>     @param[in]
  !>     m         [int]
  !>               number of rows of matrix A
  !>     @param[in]
  !>     n         [int]
  !>               number of columns of matrix A
  !>     @param[in]
  !>     kl        [int]
  !>               number of sub-diagonals of A
  !>     @param[in]
  !>     ku        [int]
  !>               number of super-diagonals of A
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>         AP    device pointer to first banded matrix (A_1).
  !>               Leading (kl + ku + 1) by n part of the matrix contains the coefficients
  !>               of the banded matrix. The leading diagonal resides in row (ku + 1) with
  !>               the first super-diagonal above on the RHS of row ku. The first sub-diagonal
  !>               resides below on the LHS of row ku + 2. This propagates up and down across
  !>               subsuper-diagonals.
  !>                 Ex: (m = n = 7; ku = 2, kl = 2)
  !>                 1 2 3 0 0 0 0             0 0 3 3 3 3 3
  !>                 4 1 2 3 0 0 0             0 2 2 2 2 2 2
  !>                 5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1
  !>                 0 5 4 1 2 3 0             4 4 4 4 4 4 0
  !>                 0 0 5 4 1 2 0             5 5 5 5 5 0 0
  !>                 0 0 0 5 4 1 2             0 0 0 0 0 0 0
  !>                 0 0 0 0 5 4 1             0 0 0 0 0 0 0
  !>               Note that the empty elements which don't correspond to data will not
  !>               be referenced.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A. Must be >= (kl + ku + 1)
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     x         device pointer to first vector (x_1).
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1)
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device pointer to first vector (y_1).
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     stridey  [hipblasStride]
  !>               stride from the start of one vector (y_i) and the next one (x_i+1)
  !>     @param[in]
  !>     batchCount [int]
  !>                 specifies the number of instances in the batch.
  !> 
  !>     
  interface hipblasSgbmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasSgbmvStridedBatched")
#else
    function hipblasSgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasSgbmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgbmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSgbmvStridedBatched_rank_0,&
      
hipblasSgbmvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDgbmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasDgbmvStridedBatched")
#else
    function hipblasDgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasDgbmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgbmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDgbmvStridedBatched_rank_0,&
      
hipblasDgbmvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCgbmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasCgbmvStridedBatched")
#else
    function hipblasCgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasCgbmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgbmvStridedBatched_rank_0,&
      
hipblasCgbmvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZgbmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasZgbmvStridedBatched")
#else
    function hipblasZgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasZgbmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgbmvStridedBatched_rank_0,&
      
hipblasZgbmvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCgbmvStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgbmvStridedBatched_v2_(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasCgbmvStridedBatched_v2")
#else
    function hipblasCgbmvStridedBatched_v2_(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasCgbmvStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmvStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgbmvStridedBatched_v2_rank_0,&
      
hipblasCgbmvStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZgbmvStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgbmvStridedBatched_v2_(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasZgbmvStridedBatched_v2")
#else
    function hipblasZgbmvStridedBatched_v2_(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasZgbmvStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmvStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: kl
      integer(c_int),value :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgbmvStridedBatched_v2_rank_0,&
      
hipblasZgbmvStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     gemv performs one of the matrix-vector operations
  !> 
  !>         y := alphaAx    + betay,   or
  !>         y := alphaATx + betay,   or
  !>         y := alphaAHx + betay,
  !> 
  !>     where alpha and beta are scalars, x and y are vectors and A is an
  !>     m by n matrix.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     trans     [hipblasOperation_t]
  !>               indicates whether matrix A is tranposed (conjugated) or not
  !>     @param[in]
  !>     m         [int]
  !>               number of rows of matrix A
  !>     @param[in]
  !>     n         [int]
  !>               number of columns of matrix A
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     AP        device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !> 
  !>     
  interface hipblasSgemv
#ifdef USE_CUDA_NAMES
    function hipblasSgemv_(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="cublasSgemv_v2")
#else
    function hipblasSgemv_(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="hipblasSgemv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSgemv_rank_0,&
      
hipblasSgemv_rank_1
#endif

  end interface
  
  interface hipblasDgemv
#ifdef USE_CUDA_NAMES
    function hipblasDgemv_(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="cublasDgemv_v2")
#else
    function hipblasDgemv_(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="hipblasDgemv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDgemv_rank_0,&
      
hipblasDgemv_rank_1
#endif

  end interface
  
  interface hipblasCgemv
#ifdef USE_CUDA_NAMES
    function hipblasCgemv_(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="cublasCgemv_v2")
#else
    function hipblasCgemv_(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="hipblasCgemv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgemv_rank_0,&
      
hipblasCgemv_rank_1
#endif

  end interface
  
  interface hipblasZgemv
#ifdef USE_CUDA_NAMES
    function hipblasZgemv_(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="cublasZgemv_v2")
#else
    function hipblasZgemv_(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="hipblasZgemv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgemv_rank_0,&
      
hipblasZgemv_rank_1
#endif

  end interface
  
  interface hipblasCgemv_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgemv_v2_(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="cublasCgemv_v2")
#else
    function hipblasCgemv_v2_(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="hipblasCgemv_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemv_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgemv_v2_rank_0,&
      
hipblasCgemv_v2_rank_1
#endif

  end interface
  
  interface hipblasZgemv_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgemv_v2_(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="cublasZgemv_v2")
#else
    function hipblasZgemv_v2_(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="hipblasZgemv_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemv_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgemv_v2_rank_0,&
      
hipblasZgemv_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     gemvBatched performs a batch of matrix-vector operations
  !> 
  !>         y_i := alphaA_ix_i    + betay_i,   or
  !>         y_i := alphaA_iTx_i + betay_i,   or
  !>         y_i := alphaA_iHx_i + betay_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     m by n matrix, for i = 1, ..., batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle      [hipblasHandle_t]
  !>                 handle to the hipblas library context queue.
  !>     @param[in]
  !>     trans       [hipblasOperation_t]
  !>                 indicates whether matrices A_i are tranposed (conjugated) or not
  !>     @param[in]
  !>     m           [int]
  !>                 number of rows of each matrix A_i
  !>     @param[in]
  !>     n           [int]
  !>                 number of columns of each matrix A_i
  !>     @param[in]
  !>     alpha       device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     AP         device array of device pointers storing each matrix A_i.
  !>     @param[in]
  !>     lda         [int]
  !>                 specifies the leading dimension of each matrix A_i.
  !>     @param[in]
  !>     x           device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx        [int]
  !>                 specifies the increment for the elements of each vector x_i.
  !>     @param[in]
  !>     beta        device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y           device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy        [int]
  !>                 specifies the increment for the elements of each vector y_i.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface hipblasSgemvBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgemvBatched_(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasSgemvBatched")
#else
    function hipblasSgemvBatched_(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasSgemvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSgemvBatched_full_rank,&
      
hipblasSgemvBatched_rank_0,&
      
hipblasSgemvBatched_rank_1
#endif

  end interface
  
  interface hipblasDgemvBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgemvBatched_(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasDgemvBatched")
#else
    function hipblasDgemvBatched_(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasDgemvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDgemvBatched_full_rank,&
      
hipblasDgemvBatched_rank_0,&
      
hipblasDgemvBatched_rank_1
#endif

  end interface
  
  interface hipblasCgemvBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgemvBatched_(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasCgemvBatched")
#else
    function hipblasCgemvBatched_(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasCgemvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgemvBatched_full_rank,&
      
hipblasCgemvBatched_rank_0,&
      
hipblasCgemvBatched_rank_1
#endif

  end interface
  
  interface hipblasZgemvBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgemvBatched_(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasZgemvBatched")
#else
    function hipblasZgemvBatched_(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasZgemvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgemvBatched_full_rank,&
      
hipblasZgemvBatched_rank_0,&
      
hipblasZgemvBatched_rank_1
#endif

  end interface
  
  interface hipblasCgemvBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgemvBatched_v2_(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasCgemvBatched_v2")
#else
    function hipblasCgemvBatched_v2_(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasCgemvBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemvBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgemvBatched_v2_full_rank,&
      
hipblasCgemvBatched_v2_rank_0,&
      
hipblasCgemvBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZgemvBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgemvBatched_v2_(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasZgemvBatched_v2")
#else
    function hipblasZgemvBatched_v2_(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasZgemvBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemvBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgemvBatched_v2_full_rank,&
      
hipblasZgemvBatched_v2_rank_0,&
      
hipblasZgemvBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     gemvStridedBatched performs a batch of matrix-vector operations
  !> 
  !>         y_i := alphaA_ix_i    + betay_i,   or
  !>         y_i := alphaA_iTx_i + betay_i,   or
  !>         y_i := alphaA_iHx_i + betay_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     m by n matrix, for i = 1, ..., batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle      [hipblasHandle_t]
  !>                 handle to the hipblas library context queue.
  !>     @param[in]
  !>     transA      [hipblasOperation_t]
  !>                 indicates whether matrices A_i are tranposed (conjugated) or not
  !>     @param[in]
  !>     m           [int]
  !>                 number of rows of matrices A_i
  !>     @param[in]
  !>     n           [int]
  !>                 number of columns of matrices A_i
  !>     @param[in]
  !>     alpha       device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     AP          device pointer to the first matrix (A_1) in the batch.
  !>     @param[in]
  !>     lda         [int]
  !>                 specifies the leading dimension of matrices A_i.
  !>     @param[in]
  !>     strideA     [hipblasStride]
  !>                 stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     x           device pointer to the first vector (x_1) in the batch.
  !>     @param[in]
  !>     incx        [int]
  !>                 specifies the increment for the elements of vectors x_i.
  !>     @param[in]
  !>     stridex     [hipblasStride]
  !>                 stride from the start of one vector (x_i) and the next one (x_i+1).
  !>                 There are no restrictions placed on stridex, however the user should
  !>                 take care to ensure that stridex is of appropriate size. When trans equals HIPBLAS_OP_N
  !>                 this typically means stridex >= n  incx, otherwise stridex >= m  incx.
  !>     @param[in]
  !>     beta        device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y           device pointer to the first vector (y_1) in the batch.
  !>     @param[in]
  !>     incy        [int]
  !>                 specifies the increment for the elements of vectors y_i.
  !>     @param[in]
  !>     stridey     [hipblasStride]
  !>                 stride from the start of one vector (y_i) and the next one (y_i+1).
  !>                 There are no restrictions placed on stridey, however the user should
  !>                 take care to ensure that stridey is of appropriate size. When trans equals HIPBLAS_OP_N
  !>                 this typically means stridey >= m  incy, otherwise stridey >= n  incy. stridey should be non zero.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface hipblasSgemvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgemvStridedBatched_(handle,transA,m,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasSgemvStridedBatched")
#else
    function hipblasSgemvStridedBatched_(handle,transA,m,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasSgemvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSgemvStridedBatched_rank_0,&
      
hipblasSgemvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDgemvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgemvStridedBatched_(handle,transA,m,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasDgemvStridedBatched")
#else
    function hipblasDgemvStridedBatched_(handle,transA,m,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasDgemvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDgemvStridedBatched_rank_0,&
      
hipblasDgemvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCgemvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgemvStridedBatched_(handle,transA,m,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasCgemvStridedBatched")
#else
    function hipblasCgemvStridedBatched_(handle,transA,m,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasCgemvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgemvStridedBatched_rank_0,&
      
hipblasCgemvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZgemvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgemvStridedBatched_(handle,transA,m,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasZgemvStridedBatched")
#else
    function hipblasZgemvStridedBatched_(handle,transA,m,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasZgemvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgemvStridedBatched_rank_0,&
      
hipblasZgemvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCgemvStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgemvStridedBatched_v2_(handle,transA,m,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasCgemvStridedBatched_v2")
#else
    function hipblasCgemvStridedBatched_v2_(handle,transA,m,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasCgemvStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemvStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgemvStridedBatched_v2_rank_0,&
      
hipblasCgemvStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZgemvStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgemvStridedBatched_v2_(handle,transA,m,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasZgemvStridedBatched_v2")
#else
    function hipblasZgemvStridedBatched_v2_(handle,transA,m,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasZgemvStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemvStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgemvStridedBatched_v2_rank_0,&
      
hipblasZgemvStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     ger,geru,gerc performs the matrix-vector operations
  !> 
  !>         A := A + alphaxyT , OR
  !>         A := A + alphaxyH for gerc
  !> 
  !>     where alpha is a scalar, x and y are vectors, and A is an
  !>     m by n matrix.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     m         [int]
  !>               the number of rows of the matrix A.
  !>     @param[in]
  !>     n         [int]
  !>               the number of columns of the matrix A.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     AP         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A.
  !> 
  !>     
  interface hipblasSger
#ifdef USE_CUDA_NAMES
    function hipblasSger_(handle,m,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="cublasSger_v2")
#else
    function hipblasSger_(handle,m,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="hipblasSger")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSger_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSger_rank_0,&
      
hipblasSger_rank_1
#endif

  end interface
  
  interface hipblasDger
#ifdef USE_CUDA_NAMES
    function hipblasDger_(handle,m,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="cublasDger_v2")
#else
    function hipblasDger_(handle,m,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="hipblasDger")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDger_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDger_rank_0,&
      
hipblasDger_rank_1
#endif

  end interface
  
  interface hipblasCgeru
#ifdef USE_CUDA_NAMES
    function hipblasCgeru_(handle,m,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="cublasCgeru_v2")
#else
    function hipblasCgeru_(handle,m,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="hipblasCgeru")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeru_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgeru_rank_0,&
      
hipblasCgeru_rank_1
#endif

  end interface
  
  interface hipblasCgerc
#ifdef USE_CUDA_NAMES
    function hipblasCgerc_(handle,m,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="cublasCgerc_v2")
#else
    function hipblasCgerc_(handle,m,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="hipblasCgerc")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgerc_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgerc_rank_0,&
      
hipblasCgerc_rank_1
#endif

  end interface
  
  interface hipblasZgeru
#ifdef USE_CUDA_NAMES
    function hipblasZgeru_(handle,m,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="cublasZgeru_v2")
#else
    function hipblasZgeru_(handle,m,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="hipblasZgeru")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeru_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgeru_rank_0,&
      
hipblasZgeru_rank_1
#endif

  end interface
  
  interface hipblasZgerc
#ifdef USE_CUDA_NAMES
    function hipblasZgerc_(handle,m,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="cublasZgerc_v2")
#else
    function hipblasZgerc_(handle,m,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="hipblasZgerc")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgerc_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgerc_rank_0,&
      
hipblasZgerc_rank_1
#endif

  end interface
  
  interface hipblasCgeru_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgeru_v2_(handle,m,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="cublasCgeru_v2")
#else
    function hipblasCgeru_v2_(handle,m,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="hipblasCgeru_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeru_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgeru_v2_rank_0,&
      
hipblasCgeru_v2_rank_1
#endif

  end interface
  
  interface hipblasCgerc_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgerc_v2_(handle,m,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="cublasCgerc_v2")
#else
    function hipblasCgerc_v2_(handle,m,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="hipblasCgerc_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgerc_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgerc_v2_rank_0,&
      
hipblasCgerc_v2_rank_1
#endif

  end interface
  
  interface hipblasZgeru_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgeru_v2_(handle,m,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="cublasZgeru_v2")
#else
    function hipblasZgeru_v2_(handle,m,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="hipblasZgeru_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeru_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgeru_v2_rank_0,&
      
hipblasZgeru_v2_rank_1
#endif

  end interface
  
  interface hipblasZgerc_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgerc_v2_(handle,m,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="cublasZgerc_v2")
#else
    function hipblasZgerc_v2_(handle,m,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="hipblasZgerc_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgerc_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgerc_v2_rank_0,&
      
hipblasZgerc_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     gerBatched,geruBatched,gercBatched performs a batch of the matrix-vector operations
  !> 
  !>         A := A + alphaxyT , OR
  !>         A := A + alphaxyH for gerc
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha is a scalar, x_i and y_i are vectors and A_i is an
  !>     m by n matrix, for i = 1, ..., batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     m         [int]
  !>               the number of rows of each matrix A_i.
  !>     @param[in]
  !>     n         [int]
  !>               the number of columns of eaceh matrix A_i.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each vector x_i.
  !>     @param[in]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each vector y_i.
  !>     @param[inout]
  !>     AP        device array of device pointers storing each matrix A_i.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface hipblasSgerBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgerBatched_(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="cublasSgerBatched")
#else
    function hipblasSgerBatched_(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="hipblasSgerBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgerBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSgerBatched_full_rank,&
      
hipblasSgerBatched_rank_0,&
      
hipblasSgerBatched_rank_1
#endif

  end interface
  
  interface hipblasDgerBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgerBatched_(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="cublasDgerBatched")
#else
    function hipblasDgerBatched_(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="hipblasDgerBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgerBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDgerBatched_full_rank,&
      
hipblasDgerBatched_rank_0,&
      
hipblasDgerBatched_rank_1
#endif

  end interface
  
  interface hipblasCgeruBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgeruBatched_(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="cublasCgeruBatched")
#else
    function hipblasCgeruBatched_(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="hipblasCgeruBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeruBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgeruBatched_full_rank,&
      
hipblasCgeruBatched_rank_0,&
      
hipblasCgeruBatched_rank_1
#endif

  end interface
  
  interface hipblasCgercBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgercBatched_(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="cublasCgercBatched")
#else
    function hipblasCgercBatched_(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="hipblasCgercBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgercBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgercBatched_full_rank,&
      
hipblasCgercBatched_rank_0,&
      
hipblasCgercBatched_rank_1
#endif

  end interface
  
  interface hipblasZgeruBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgeruBatched_(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="cublasZgeruBatched")
#else
    function hipblasZgeruBatched_(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="hipblasZgeruBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeruBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgeruBatched_full_rank,&
      
hipblasZgeruBatched_rank_0,&
      
hipblasZgeruBatched_rank_1
#endif

  end interface
  
  interface hipblasZgercBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgercBatched_(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="cublasZgercBatched")
#else
    function hipblasZgercBatched_(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="hipblasZgercBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgercBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgercBatched_full_rank,&
      
hipblasZgercBatched_rank_0,&
      
hipblasZgercBatched_rank_1
#endif

  end interface
  
  interface hipblasCgeruBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgeruBatched_v2_(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="cublasCgeruBatched_v2")
#else
    function hipblasCgeruBatched_v2_(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="hipblasCgeruBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeruBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgeruBatched_v2_full_rank,&
      
hipblasCgeruBatched_v2_rank_0,&
      
hipblasCgeruBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasCgercBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgercBatched_v2_(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="cublasCgercBatched_v2")
#else
    function hipblasCgercBatched_v2_(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="hipblasCgercBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgercBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgercBatched_v2_full_rank,&
      
hipblasCgercBatched_v2_rank_0,&
      
hipblasCgercBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZgeruBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgeruBatched_v2_(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="cublasZgeruBatched_v2")
#else
    function hipblasZgeruBatched_v2_(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="hipblasZgeruBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeruBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgeruBatched_v2_full_rank,&
      
hipblasZgeruBatched_v2_rank_0,&
      
hipblasZgeruBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZgercBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgercBatched_v2_(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="cublasZgercBatched_v2")
#else
    function hipblasZgercBatched_v2_(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="hipblasZgercBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgercBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgercBatched_v2_full_rank,&
      
hipblasZgercBatched_v2_rank_0,&
      
hipblasZgercBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     gerStridedBatched,geruStridedBatched,gercStridedBatched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alphax_iy_iT, OR
  !>         A_i := A_i + alphax_iy_iH  for gerc
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha is a scalar, x_i and y_i are vectors and A_i is an
  !>     m by n matrix, for i = 1, ..., batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     m         [int]
  !>               the number of rows of each matrix A_i.
  !>     @param[in]
  !>     n         [int]
  !>               the number of columns of each matrix A_i.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer to the first vector (x_1) in the batch.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increments for the elements of each vector x_i.
  !>     @param[in]
  !>     stridex   [hipblasStride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>               There are no restrictions placed on stridex, however the user should
  !>               take care to ensure that stridex is of appropriate size, for a typical
  !>               case this means stridex >= m  incx.
  !>     @param[inout]
  !>     y         device pointer to the first vector (y_1) in the batch.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each vector y_i.
  !>     @param[in]
  !>     stridey   [hipblasStride]
  !>               stride from the start of one vector (y_i) and the next one (y_i+1).
  !>               There are no restrictions placed on stridey, however the user should
  !>               take care to ensure that stridey is of appropriate size, for a typical
  !>               case this means stridey >= n  incy.
  !>     @param[inout]
  !>     AP        device pointer to the first matrix (A_1) in the batch.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     strideA     [hipblasStride]
  !>                 stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface hipblasSgerStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgerStridedBatched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="cublasSgerStridedBatched")
#else
    function hipblasSgerStridedBatched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="hipblasSgerStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgerStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSgerStridedBatched_rank_0,&
      
hipblasSgerStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDgerStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgerStridedBatched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="cublasDgerStridedBatched")
#else
    function hipblasDgerStridedBatched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="hipblasDgerStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgerStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDgerStridedBatched_rank_0,&
      
hipblasDgerStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCgeruStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgeruStridedBatched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="cublasCgeruStridedBatched")
#else
    function hipblasCgeruStridedBatched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="hipblasCgeruStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeruStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgeruStridedBatched_rank_0,&
      
hipblasCgeruStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCgercStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgercStridedBatched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="cublasCgercStridedBatched")
#else
    function hipblasCgercStridedBatched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="hipblasCgercStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgercStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgercStridedBatched_rank_0,&
      
hipblasCgercStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZgeruStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgeruStridedBatched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="cublasZgeruStridedBatched")
#else
    function hipblasZgeruStridedBatched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="hipblasZgeruStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeruStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgeruStridedBatched_rank_0,&
      
hipblasZgeruStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZgercStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgercStridedBatched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="cublasZgercStridedBatched")
#else
    function hipblasZgercStridedBatched_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="hipblasZgercStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgercStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgercStridedBatched_rank_0,&
      
hipblasZgercStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCgeruStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgeruStridedBatched_v2_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="cublasCgeruStridedBatched_v2")
#else
    function hipblasCgeruStridedBatched_v2_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="hipblasCgeruStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeruStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgeruStridedBatched_v2_rank_0,&
      
hipblasCgeruStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasCgercStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgercStridedBatched_v2_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="cublasCgercStridedBatched_v2")
#else
    function hipblasCgercStridedBatched_v2_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="hipblasCgercStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgercStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgercStridedBatched_v2_rank_0,&
      
hipblasCgercStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZgeruStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgeruStridedBatched_v2_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="cublasZgeruStridedBatched_v2")
#else
    function hipblasZgeruStridedBatched_v2_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="hipblasZgeruStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeruStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgeruStridedBatched_v2_rank_0,&
      
hipblasZgeruStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZgercStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgercStridedBatched_v2_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="cublasZgercStridedBatched_v2")
#else
    function hipblasZgercStridedBatched_v2_(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="hipblasZgercStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgercStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgercStridedBatched_v2_rank_0,&
      
hipblasZgercStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hbmv performs the matrix-vector operations
  !> 
  !>         y := alphaAx + betay
  !> 
  !>     where alpha and beta are scalars, x and y are n element vectors and A is an
  !>     n by n Hermitian band matrix, with k super-diagonals.
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is being supplied.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is being supplied.
  !>     @param[in]
  !>     n         [int]
  !>               the order of the matrix A.
  !>     @param[in]
  !>     k         [int]
  !>               the number of super-diagonals of the matrix A. Must be >= 0.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     AP        device pointer storing matrix A. Of dimension (lda, n).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The leading (k + 1) by n part of A must contain the upper
  !>                 triangular band part of the Hermitian matrix, with the leading
  !>                 diagonal in row (k + 1), the first super-diagonal on the RHS
  !>                 of row k, etc.
  !>                 The top left k by x triangle of A will not be referenced.
  !>                     Ex (upper, lda = n = 4, k = 1):
  !>                     A                             Represented matrix
  !>                     (0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)
  !>                     (1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)
  !>                     (0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)
  !>                     (0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)
  !> 
  !>               if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The leading (k + 1) by n part of A must contain the lower
  !>                 triangular band part of the Hermitian matrix, with the leading
  !>                 diagonal in row (1), the first sub-diagonal on the LHS of
  !>                 row 2, etc.
  !>                 The bottom right k by k triangle of A will not be referenced.
  !>                     Ex (lower, lda = 2, n = 4, k = 1):
  !>                     A                               Represented matrix
  !>                     (1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)
  !>                     (5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)
  !>                                                     (0, 0) (6, 8) (3, 0) (7,-7)
  !>                                                     (0, 0) (0, 0) (7, 7) (4, 0)
  !> 
  !>               As a Hermitian matrix, the imaginary part of the main diagonal
  !>               of A will not be referenced and is assumed to be == 0.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A. must be >= k + 1
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !> 
  !>     
  interface hipblasChbmv
#ifdef USE_CUDA_NAMES
    function hipblasChbmv_(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="cublasChbmv_v2")
#else
    function hipblasChbmv_(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="hipblasChbmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChbmv_rank_0,&
      
hipblasChbmv_rank_1
#endif

  end interface
  
  interface hipblasZhbmv
#ifdef USE_CUDA_NAMES
    function hipblasZhbmv_(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="cublasZhbmv_v2")
#else
    function hipblasZhbmv_(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="hipblasZhbmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhbmv_rank_0,&
      
hipblasZhbmv_rank_1
#endif

  end interface
  
  interface hipblasChbmv_v2
#ifdef USE_CUDA_NAMES
    function hipblasChbmv_v2_(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="cublasChbmv_v2")
#else
    function hipblasChbmv_v2_(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="hipblasChbmv_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmv_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChbmv_v2_rank_0,&
      
hipblasChbmv_v2_rank_1
#endif

  end interface
  
  interface hipblasZhbmv_v2
#ifdef USE_CUDA_NAMES
    function hipblasZhbmv_v2_(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="cublasZhbmv_v2")
#else
    function hipblasZhbmv_v2_(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="hipblasZhbmv_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmv_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhbmv_v2_rank_0,&
      
hipblasZhbmv_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hbmvBatched performs one of the matrix-vector operations
  !> 
  !>         y_i := alphaA_ix_i + betay_i
  !> 
  !>     where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
  !>     n by n Hermitian band matrix with k super-diagonals, for each batch in i = [1, batchCount].
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is being supplied.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is being supplied.
  !>     @param[in]
  !>     n         [int]
  !>               the order of each matrix A_i.
  !>     @param[in]
  !>     k         [int]
  !>               the number of super-diagonals of each matrix A_i. Must be >= 0.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     AP        device array of device pointers storing each matrix_i A of dimension (lda, n).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The leading (k + 1) by n part of each A_i must contain the upper
  !>                 triangular band part of the Hermitian matrix, with the leading
  !>                 diagonal in row (k + 1), the first super-diagonal on the RHS
  !>                 of row k, etc.
  !>                 The top left k by x triangle of each A_i will not be referenced.
  !>                     Ex (upper, lda = n = 4, k = 1):
  !>                     A                             Represented matrix
  !>                     (0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)
  !>                     (1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)
  !>                     (0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)
  !>                     (0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)
  !> 
  !>               if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The leading (k + 1) by n part of each A_i must contain the lower
  !>                 triangular band part of the Hermitian matrix, with the leading
  !>                 diagonal in row (1), the first sub-diagonal on the LHS of
  !>                 row 2, etc.
  !>                 The bottom right k by k triangle of each A_i will not be referenced.
  !>                     Ex (lower, lda = 2, n = 4, k = 1):
  !>                     A                               Represented matrix
  !>                     (1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)
  !>                     (5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)
  !>                                                     (0, 0) (6, 8) (3, 0) (7,-7)
  !>                                                     (0, 0) (0, 0) (7, 7) (4, 0)
  !> 
  !>               As a Hermitian matrix, the imaginary part of the main diagonal
  !>               of each A_i will not be referenced and is assumed to be == 0.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i. must be >= max(1, n)
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface hipblasChbmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasChbmvBatched_(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasChbmvBatched")
#else
    function hipblasChbmvBatched_(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasChbmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChbmvBatched_full_rank,&
      
hipblasChbmvBatched_rank_0,&
      
hipblasChbmvBatched_rank_1
#endif

  end interface
  
  interface hipblasZhbmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasZhbmvBatched_(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasZhbmvBatched")
#else
    function hipblasZhbmvBatched_(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasZhbmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhbmvBatched_full_rank,&
      
hipblasZhbmvBatched_rank_0,&
      
hipblasZhbmvBatched_rank_1
#endif

  end interface
  
  interface hipblasChbmvBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasChbmvBatched_v2_(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasChbmvBatched_v2")
#else
    function hipblasChbmvBatched_v2_(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasChbmvBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmvBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChbmvBatched_v2_full_rank,&
      
hipblasChbmvBatched_v2_rank_0,&
      
hipblasChbmvBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZhbmvBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZhbmvBatched_v2_(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasZhbmvBatched_v2")
#else
    function hipblasZhbmvBatched_v2_(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasZhbmvBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmvBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhbmvBatched_v2_full_rank,&
      
hipblasZhbmvBatched_v2_rank_0,&
      
hipblasZhbmvBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hbmvStridedBatched performs one of the matrix-vector operations
  !> 
  !>         y_i := alphaA_ix_i + betay_i
  !> 
  !>     where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
  !>     n by n Hermitian band matrix with k super-diagonals, for each batch in i = [1, batchCount].
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is being supplied.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is being supplied.
  !>     @param[in]
  !>     n         [int]
  !>               the order of each matrix A_i.
  !>     @param[in]
  !>     k         [int]
  !>               the number of super-diagonals of each matrix A_i. Must be >= 0.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     AP        device array pointing to the first matrix A_1. Each A_i is of dimension (lda, n).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The leading (k + 1) by n part of each A_i must contain the upper
  !>                 triangular band part of the Hermitian matrix, with the leading
  !>                 diagonal in row (k + 1), the first super-diagonal on the RHS
  !>                 of row k, etc.
  !>                 The top left k by x triangle of each A_i will not be referenced.
  !>                     Ex (upper, lda = n = 4, k = 1):
  !>                     A                             Represented matrix
  !>                     (0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)
  !>                     (1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)
  !>                     (0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)
  !>                     (0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)
  !> 
  !>               if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The leading (k + 1) by n part of each A_i must contain the lower
  !>                 triangular band part of the Hermitian matrix, with the leading
  !>                 diagonal in row (1), the first sub-diagonal on the LHS of
  !>                 row 2, etc.
  !>                 The bottom right k by k triangle of each A_i will not be referenced.
  !>                     Ex (lower, lda = 2, n = 4, k = 1):
  !>                     A                               Represented matrix
  !>                     (1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)
  !>                     (5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)
  !>                                                     (0, 0) (6, 8) (3, 0) (7,-7)
  !>                                                     (0, 0) (0, 0) (7, 7) (4, 0)
  !> 
  !>               As a Hermitian matrix, the imaginary part of the main diagonal
  !>               of each A_i will not be referenced and is assumed to be == 0.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i. must be >= max(1, n)
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     x         device array pointing to the first vector y_1.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1)
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device array pointing to the first vector y_1.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     stridey  [hipblasStride]
  !>               stride from the start of one vector (y_i) and the next one (y_i+1)
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface hipblasChbmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasChbmvStridedBatched_(handle,uplo,n,k,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasChbmvStridedBatched")
#else
    function hipblasChbmvStridedBatched_(handle,uplo,n,k,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasChbmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChbmvStridedBatched_rank_0,&
      
hipblasChbmvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZhbmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZhbmvStridedBatched_(handle,uplo,n,k,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasZhbmvStridedBatched")
#else
    function hipblasZhbmvStridedBatched_(handle,uplo,n,k,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasZhbmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhbmvStridedBatched_rank_0,&
      
hipblasZhbmvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasChbmvStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasChbmvStridedBatched_v2_(handle,uplo,n,k,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasChbmvStridedBatched_v2")
#else
    function hipblasChbmvStridedBatched_v2_(handle,uplo,n,k,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasChbmvStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmvStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChbmvStridedBatched_v2_rank_0,&
      
hipblasChbmvStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZhbmvStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZhbmvStridedBatched_v2_(handle,uplo,n,k,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasZhbmvStridedBatched_v2")
#else
    function hipblasZhbmvStridedBatched_v2_(handle,uplo,n,k,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasZhbmvStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmvStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhbmvStridedBatched_v2_rank_0,&
      
hipblasZhbmvStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hemv performs one of the matrix-vector operations
  !> 
  !>         y := alphaAx + betay
  !> 
  !>     where alpha and beta are scalars, x and y are n element vectors and A is an
  !>     n by n Hermitian matrix.
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               HIPBLAS_FILL_MODE_UPPER: the upper triangular part of the Hermitian matrix A is supplied.
  !>               HIPBLAS_FILL_MODE_LOWER: the lower triangular part of the Hermitian matrix A is supplied.
  !>     @param[in]
  !>     n         [int]
  !>               the order of the matrix A.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     AP        device pointer storing matrix A. Of dimension (lda, n).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular part of A must contain
  !>                 the upper triangular part of a Hermitian matrix. The lower
  !>                 triangular part of A will not be referenced.
  !>               if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular part of A must contain
  !>                 the lower triangular part of a Hermitian matrix. The upper
  !>                 triangular part of A will not be referenced.
  !>               As a Hermitian matrix, the imaginary part of the main diagonal
  !>               of A will not be referenced and is assumed to be == 0.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A. must be >= max(1, n)
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !> 
  !>     
  interface hipblasChemv
#ifdef USE_CUDA_NAMES
    function hipblasChemv_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="cublasChemv_v2")
#else
    function hipblasChemv_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="hipblasChemv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChemv_rank_0,&
      
hipblasChemv_rank_1
#endif

  end interface
  
  interface hipblasZhemv
#ifdef USE_CUDA_NAMES
    function hipblasZhemv_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="cublasZhemv_v2")
#else
    function hipblasZhemv_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="hipblasZhemv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhemv_rank_0,&
      
hipblasZhemv_rank_1
#endif

  end interface
  
  interface hipblasChemv_v2
#ifdef USE_CUDA_NAMES
    function hipblasChemv_v2_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="cublasChemv_v2")
#else
    function hipblasChemv_v2_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="hipblasChemv_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemv_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChemv_v2_rank_0,&
      
hipblasChemv_v2_rank_1
#endif

  end interface
  
  interface hipblasZhemv_v2
#ifdef USE_CUDA_NAMES
    function hipblasZhemv_v2_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="cublasZhemv_v2")
#else
    function hipblasZhemv_v2_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="hipblasZhemv_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemv_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhemv_v2_rank_0,&
      
hipblasZhemv_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hemvBatched performs one of the matrix-vector operations
  !> 
  !>         y_i := alphaA_ix_i + betay_i
  !> 
  !>     where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
  !>     n by n Hermitian matrix, for each batch in i = [1, batchCount].
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               HIPBLAS_FILL_MODE_UPPER: the upper triangular part of the Hermitian matrix A is supplied.
  !>               HIPBLAS_FILL_MODE_LOWER: the lower triangular part of the Hermitian matrix A is supplied.
  !>     @param[in]
  !>     n         [int]
  !>               the order of each matrix A_i.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     AP        device array of device pointers storing each matrix A_i of dimension (lda, n).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular part of each A_i must contain
  !>                 the upper triangular part of a Hermitian matrix. The lower
  !>                 triangular part of each A_i will not be referenced.
  !>               if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular part of each A_i must contain
  !>                 the lower triangular part of a Hermitian matrix. The upper
  !>                 triangular part of each A_i will not be referenced.
  !>               As a Hermitian matrix, the imaginary part of the main diagonal
  !>               of each A_i will not be referenced and is assumed to be == 0.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i. must be >= max(1, n)
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface hipblasChemvBatched
#ifdef USE_CUDA_NAMES
    function hipblasChemvBatched_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasChemvBatched")
#else
    function hipblasChemvBatched_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasChemvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChemvBatched_full_rank,&
      
hipblasChemvBatched_rank_0,&
      
hipblasChemvBatched_rank_1
#endif

  end interface
  
  interface hipblasZhemvBatched
#ifdef USE_CUDA_NAMES
    function hipblasZhemvBatched_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasZhemvBatched")
#else
    function hipblasZhemvBatched_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasZhemvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhemvBatched_full_rank,&
      
hipblasZhemvBatched_rank_0,&
      
hipblasZhemvBatched_rank_1
#endif

  end interface
  
  interface hipblasChemvBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasChemvBatched_v2_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasChemvBatched_v2")
#else
    function hipblasChemvBatched_v2_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasChemvBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemvBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChemvBatched_v2_full_rank,&
      
hipblasChemvBatched_v2_rank_0,&
      
hipblasChemvBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZhemvBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZhemvBatched_v2_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasZhemvBatched_v2")
#else
    function hipblasZhemvBatched_v2_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasZhemvBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemvBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhemvBatched_v2_full_rank,&
      
hipblasZhemvBatched_v2_rank_0,&
      
hipblasZhemvBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hemvStridedBatched performs one of the matrix-vector operations
  !> 
  !>         y_i := alphaA_ix_i + betay_i
  !> 
  !>     where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
  !>     n by n Hermitian matrix, for each batch in i = [1, batchCount].
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               HIPBLAS_FILL_MODE_UPPER: the upper triangular part of the Hermitian matrix A is supplied.
  !>               HIPBLAS_FILL_MODE_LOWER: the lower triangular part of the Hermitian matrix A is supplied.
  !>     @param[in]
  !>     n         [int]
  !>               the order of each matrix A_i.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     AP        device array of device pointers storing each matrix A_i of dimension (lda, n).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular part of each A_i must contain
  !>                 the upper triangular part of a Hermitian matrix. The lower
  !>                 triangular part of each A_i will not be referenced.
  !>               if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular part of each A_i must contain
  !>                 the lower triangular part of a Hermitian matrix. The upper
  !>                 triangular part of each A_i will not be referenced.
  !>               As a Hermitian matrix, the imaginary part of the main diagonal
  !>               of each A_i will not be referenced and is assumed to be == 0.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i. must be >= max(1, n)
  !>     @param[in]
  !>     strideA    [hipblasStride]
  !>                 stride from the start of one (A_i) to the next (A_i+1)
  !> 
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     stridey  [hipblasStride]
  !>               stride from the start of one vector (y_i) and the next one (y_i+1).
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface hipblasChemvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasChemvStridedBatched_(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasChemvStridedBatched")
#else
    function hipblasChemvStridedBatched_(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasChemvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChemvStridedBatched_rank_0,&
      
hipblasChemvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZhemvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZhemvStridedBatched_(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasZhemvStridedBatched")
#else
    function hipblasZhemvStridedBatched_(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasZhemvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhemvStridedBatched_rank_0,&
      
hipblasZhemvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasChemvStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasChemvStridedBatched_v2_(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasChemvStridedBatched_v2")
#else
    function hipblasChemvStridedBatched_v2_(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasChemvStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemvStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChemvStridedBatched_v2_rank_0,&
      
hipblasChemvStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZhemvStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZhemvStridedBatched_v2_(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasZhemvStridedBatched_v2")
#else
    function hipblasZhemvStridedBatched_v2_(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasZhemvStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemvStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhemvStridedBatched_v2_rank_0,&
      
hipblasZhemvStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     her performs the matrix-vector operations
  !> 
  !>         A := A + alphaxxH
  !> 
  !>     where alpha is a real scalar, x is a vector, and A is an
  !>     n by n Hermitian matrix.
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in A.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in A.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of matrix A, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[inout]
  !>     AP        device pointer storing the specified triangular portion of
  !>               the Hermitian matrix A. Of size (lda  n).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of the Hermitian matrix A is supplied. The lower
  !>                 triangluar portion will not be touched.
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of the Hermitian matrix A is supplied. The upper
  !>                 triangular portion will not be touched.
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A. Must be at least max(1, n).
  !>     
  interface hipblasCher
#ifdef USE_CUDA_NAMES
    function hipblasCher_(handle,uplo,n,alpha,x,incx,AP,lda) bind(c, name="cublasCher_v2")
#else
    function hipblasCher_(handle,uplo,n,alpha,x,incx,AP,lda) bind(c, name="hipblasCher")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCher_rank_0,&
      
hipblasCher_rank_1
#endif

  end interface
  
  interface hipblasZher
#ifdef USE_CUDA_NAMES
    function hipblasZher_(handle,uplo,n,alpha,x,incx,AP,lda) bind(c, name="cublasZher_v2")
#else
    function hipblasZher_(handle,uplo,n,alpha,x,incx,AP,lda) bind(c, name="hipblasZher")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZher_rank_0,&
      
hipblasZher_rank_1
#endif

  end interface
  
  interface hipblasCher_v2
#ifdef USE_CUDA_NAMES
    function hipblasCher_v2_(handle,uplo,n,alpha,x,incx,AP,lda) bind(c, name="cublasCher_v2")
#else
    function hipblasCher_v2_(handle,uplo,n,alpha,x,incx,AP,lda) bind(c, name="hipblasCher_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCher_v2_rank_0,&
      
hipblasCher_v2_rank_1
#endif

  end interface
  
  interface hipblasZher_v2
#ifdef USE_CUDA_NAMES
    function hipblasZher_v2_(handle,uplo,n,alpha,x,incx,AP,lda) bind(c, name="cublasZher_v2")
#else
    function hipblasZher_v2_(handle,uplo,n,alpha,x,incx,AP,lda) bind(c, name="hipblasZher_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZher_v2_rank_0,&
      
hipblasZher_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     herBatched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alphax_ix_iH
  !> 
  !>     where alpha is a real scalar, x_i is a vector, and A_i is an
  !>     n by n symmetric matrix, for i = 1, ..., batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in A.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in A.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[inout]
  !>     AP       device array of device pointers storing the specified triangular portion of
  !>               each Hermitian matrix A_i of at least size ((n  (n + 1))  2). Array is of at least size batchCount.
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular portion
  !>                 of each A_i will not be touched.
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular portion
  !>                 of each A_i will not be touched.
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i. Must be at least max(1, n).
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>     
  interface hipblasCherBatched
#ifdef USE_CUDA_NAMES
    function hipblasCherBatched_(handle,uplo,n,alpha,x,incx,AP,lda,batchCount) bind(c, name="cublasCherBatched")
#else
    function hipblasCherBatched_(handle,uplo,n,alpha,x,incx,AP,lda,batchCount) bind(c, name="hipblasCherBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCherBatched_full_rank,&
      
hipblasCherBatched_rank_0,&
      
hipblasCherBatched_rank_1
#endif

  end interface
  
  interface hipblasZherBatched
#ifdef USE_CUDA_NAMES
    function hipblasZherBatched_(handle,uplo,n,alpha,x,incx,AP,lda,batchCount) bind(c, name="cublasZherBatched")
#else
    function hipblasZherBatched_(handle,uplo,n,alpha,x,incx,AP,lda,batchCount) bind(c, name="hipblasZherBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZherBatched_full_rank,&
      
hipblasZherBatched_rank_0,&
      
hipblasZherBatched_rank_1
#endif

  end interface
  
  interface hipblasCherBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCherBatched_v2_(handle,uplo,n,alpha,x,incx,AP,lda,batchCount) bind(c, name="cublasCherBatched_v2")
#else
    function hipblasCherBatched_v2_(handle,uplo,n,alpha,x,incx,AP,lda,batchCount) bind(c, name="hipblasCherBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCherBatched_v2_full_rank,&
      
hipblasCherBatched_v2_rank_0,&
      
hipblasCherBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZherBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZherBatched_v2_(handle,uplo,n,alpha,x,incx,AP,lda,batchCount) bind(c, name="cublasZherBatched_v2")
#else
    function hipblasZherBatched_v2_(handle,uplo,n,alpha,x,incx,AP,lda,batchCount) bind(c, name="hipblasZherBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZherBatched_v2_full_rank,&
      
hipblasZherBatched_v2_rank_0,&
      
hipblasZherBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     herStridedBatched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alphax_ix_iH
  !> 
  !>     where alpha is a real scalar, x_i is a vector, and A_i is an
  !>     n by n Hermitian matrix, for i = 1, ..., batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in A.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in A.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer pointing to the first vector (x_1).
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>     @param[inout]
  !>     AP        device array of device pointers storing the specified triangular portion of
  !>               each Hermitian matrix A_i. Points to the first matrix (A_1).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular
  !>                 portion of each A_i will not be touched.
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular
  !>                 portion of each A_i will not be touched.
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     strideA    [hipblasStride]
  !>                 stride from the start of one (A_i) and the next (A_i+1)
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>     
  interface hipblasCherStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCherStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount) bind(c, name="cublasCherStridedBatched")
#else
    function hipblasCherStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount) bind(c, name="hipblasCherStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCherStridedBatched_rank_0,&
      
hipblasCherStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZherStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZherStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount) bind(c, name="cublasZherStridedBatched")
#else
    function hipblasZherStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount) bind(c, name="hipblasZherStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZherStridedBatched_rank_0,&
      
hipblasZherStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCherStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCherStridedBatched_v2_(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount) bind(c, name="cublasCherStridedBatched_v2")
#else
    function hipblasCherStridedBatched_v2_(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount) bind(c, name="hipblasCherStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCherStridedBatched_v2_rank_0,&
      
hipblasCherStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZherStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZherStridedBatched_v2_(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount) bind(c, name="cublasZherStridedBatched_v2")
#else
    function hipblasZherStridedBatched_v2_(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount) bind(c, name="hipblasZherStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZherStridedBatched_v2_rank_0,&
      
hipblasZherStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     her2 performs the matrix-vector operations
  !> 
  !>         A := A + alphaxyH + conj(alpha)yxH
  !> 
  !>     where alpha is a complex scalar, x and y are vectors, and A is an
  !>     n by n Hermitian matrix.
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of matrix A, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     AP         device pointer storing the specified triangular portion of
  !>               the Hermitian matrix A. Of size (lda, n).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of the Hermitian matrix A is supplied. The lower triangular
  !>                 portion of A will not be touched.
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of the Hermitian matrix A is supplied. The upper triangular
  !>                 portion of A will not be touched.
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A. Must be at least max(lda, 1).
  !>     
  interface hipblasCher2
#ifdef USE_CUDA_NAMES
    function hipblasCher2_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="cublasCher2_v2")
#else
    function hipblasCher2_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="hipblasCher2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCher2_rank_0,&
      
hipblasCher2_rank_1
#endif

  end interface
  
  interface hipblasZher2
#ifdef USE_CUDA_NAMES
    function hipblasZher2_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="cublasZher2_v2")
#else
    function hipblasZher2_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="hipblasZher2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZher2_rank_0,&
      
hipblasZher2_rank_1
#endif

  end interface
  
  interface hipblasCher2_v2
#ifdef USE_CUDA_NAMES
    function hipblasCher2_v2_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="cublasCher2_v2")
#else
    function hipblasCher2_v2_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="hipblasCher2_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCher2_v2_rank_0,&
      
hipblasCher2_v2_rank_1
#endif

  end interface
  
  interface hipblasZher2_v2
#ifdef USE_CUDA_NAMES
    function hipblasZher2_v2_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="cublasZher2_v2")
#else
    function hipblasZher2_v2_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="hipblasZher2_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZher2_v2_rank_0,&
      
hipblasZher2_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     her2Batched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alphax_iy_iH + conj(alpha)y_ix_iH
  !> 
  !>     where alpha is a complex scalar, x_i and y_i are vectors, and A_i is an
  !>     n by n Hermitian matrix for each batch in i = [1, batchCount].
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[inout]
  !>     AP         device array of device pointers storing the specified triangular portion of
  !>               each Hermitian matrix A_i of size (lda, n).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular
  !>                 portion of each A_i will not be touched.
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular
  !>                 portion of each A_i will not be touched.
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i. Must be at least max(lda, 1).
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>     
  interface hipblasCher2Batched
#ifdef USE_CUDA_NAMES
    function hipblasCher2Batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="cublasCher2Batched")
#else
    function hipblasCher2Batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="hipblasCher2Batched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2Batched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCher2Batched_full_rank,&
      
hipblasCher2Batched_rank_0,&
      
hipblasCher2Batched_rank_1
#endif

  end interface
  
  interface hipblasZher2Batched
#ifdef USE_CUDA_NAMES
    function hipblasZher2Batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="cublasZher2Batched")
#else
    function hipblasZher2Batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="hipblasZher2Batched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2Batched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZher2Batched_full_rank,&
      
hipblasZher2Batched_rank_0,&
      
hipblasZher2Batched_rank_1
#endif

  end interface
  
  interface hipblasCher2Batched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCher2Batched_v2_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="cublasCher2Batched_v2")
#else
    function hipblasCher2Batched_v2_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="hipblasCher2Batched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2Batched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCher2Batched_v2_full_rank,&
      
hipblasCher2Batched_v2_rank_0,&
      
hipblasCher2Batched_v2_rank_1
#endif

  end interface
  
  interface hipblasZher2Batched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZher2Batched_v2_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="cublasZher2Batched_v2")
#else
    function hipblasZher2Batched_v2_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="hipblasZher2Batched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2Batched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZher2Batched_v2_full_rank,&
      
hipblasZher2Batched_v2_rank_0,&
      
hipblasZher2Batched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     her2StridedBatched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alphax_iy_iH + conj(alpha)y_ix_iH
  !> 
  !>     where alpha is a complex scalar, x_i and y_i are vectors, and A_i is an
  !>     n by n Hermitian matrix for each batch in i = [1, batchCount].
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer pointing to the first vector x_1.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               specifies the stride between the beginning of one vector (x_i) and the next (x_i+1).
  !>     @param[in]
  !>     y         device pointer pointing to the first vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     stridey  [hipblasStride]
  !>               specifies the stride between the beginning of one vector (y_i) and the next (y_i+1).
  !>     @param[inout]
  !>     AP        device pointer pointing to the first matrix (A_1). Stores the specified triangular portion of
  !>               each Hermitian matrix A_i.
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular
  !>                 portion of each A_i will not be touched.
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular
  !>                 portion of each A_i will not be touched.
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i. Must be at least max(lda, 1).
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               specifies the stride between the beginning of one matrix (A_i) and the next (A_i+1).
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>     
  interface hipblasCher2StridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCher2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="cublasCher2StridedBatched")
#else
    function hipblasCher2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="hipblasCher2StridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2StridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCher2StridedBatched_rank_0,&
      
hipblasCher2StridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZher2StridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZher2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="cublasZher2StridedBatched")
#else
    function hipblasZher2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="hipblasZher2StridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2StridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZher2StridedBatched_rank_0,&
      
hipblasZher2StridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCher2StridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCher2StridedBatched_v2_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="cublasCher2StridedBatched_v2")
#else
    function hipblasCher2StridedBatched_v2_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="hipblasCher2StridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2StridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCher2StridedBatched_v2_rank_0,&
      
hipblasCher2StridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZher2StridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZher2StridedBatched_v2_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="cublasZher2StridedBatched_v2")
#else
    function hipblasZher2StridedBatched_v2_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="hipblasZher2StridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2StridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZher2StridedBatched_v2_rank_0,&
      
hipblasZher2StridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hpmv performs the matrix-vector operation
  !> 
  !>         y := alphaAx + betay
  !> 
  !>     where alpha and beta are scalars, x and y are n element vectors and A is an
  !>     n by n Hermitian matrix, supplied in packed form (see description below).
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               HIPBLAS_FILL_MODE_UPPER: the upper triangular part of the Hermitian matrix A is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: the lower triangular part of the Hermitian matrix A is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the order of the matrix A, must be >= 0.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     AP        device pointer storing the packed version of the specified triangular portion of
  !>               the Hermitian matrix A. Of at least size ((n  (n + 1))  2).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of the Hermitian matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
  !>                         (1, 0) (2, 1) (3, 2)
  !>                         (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,1), (4,0), (3,2), (5,-1), (6,0)]
  !>                         (3,-2) (5, 1) (6, 0)
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of the Hermitian matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
  !>                         (1, 0) (2, 1) (3, 2)
  !>                         (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,-1), (3,-2), (4,0), (5,1), (6,0)]
  !>                         (3,-2) (5, 1) (6, 0)
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !> 
  !>     
  interface hipblasChpmv
#ifdef USE_CUDA_NAMES
    function hipblasChpmv_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy) bind(c, name="cublasChpmv_v2")
#else
    function hipblasChpmv_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy) bind(c, name="hipblasChpmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChpmv_rank_0,&
      
hipblasChpmv_rank_1
#endif

  end interface
  
  interface hipblasZhpmv
#ifdef USE_CUDA_NAMES
    function hipblasZhpmv_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy) bind(c, name="cublasZhpmv_v2")
#else
    function hipblasZhpmv_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy) bind(c, name="hipblasZhpmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhpmv_rank_0,&
      
hipblasZhpmv_rank_1
#endif

  end interface
  
  interface hipblasChpmv_v2
#ifdef USE_CUDA_NAMES
    function hipblasChpmv_v2_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy) bind(c, name="cublasChpmv_v2")
#else
    function hipblasChpmv_v2_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy) bind(c, name="hipblasChpmv_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmv_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChpmv_v2_rank_0,&
      
hipblasChpmv_v2_rank_1
#endif

  end interface
  
  interface hipblasZhpmv_v2
#ifdef USE_CUDA_NAMES
    function hipblasZhpmv_v2_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy) bind(c, name="cublasZhpmv_v2")
#else
    function hipblasZhpmv_v2_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy) bind(c, name="hipblasZhpmv_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmv_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhpmv_v2_rank_0,&
      
hipblasZhpmv_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hpmvBatched performs the matrix-vector operation
  !> 
  !>         y_i := alphaA_ix_i + betay_i
  !> 
  !>     where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
  !>     n by n Hermitian matrix, supplied in packed form (see description below),
  !>     for each batch in i = [1, batchCount].
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               HIPBLAS_FILL_MODE_UPPER: the upper triangular part of each Hermitian matrix A_i is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: the lower triangular part of each Hermitian matrix A_i is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the order of each matrix A_i.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     AP      device pointer of device pointers storing the packed version of the specified triangular
  !>             portion of each Hermitian matrix A_i. Each A_i is of at least size ((n  (n + 1))  2).
  !>             if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>             The upper triangular portion of each Hermitian matrix A_i is supplied.
  !>             The matrix is compacted so that each AP_i contains the triangular portion column-by-column
  !>             so that:
  !>             AP(0) = A(0,0)
  !>             AP(1) = A(0,1)
  !>             AP(2) = A(1,1), etc.
  !>                 Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
  !>                     (1, 0) (2, 1) (3, 2)
  !>                     (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,1), (4,0), (3,2), (5,-1), (6,0)]
  !>                     (3,-2) (5, 1) (6, 0)
  !>         if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>             The lower triangular portion of each Hermitian matrix A_i is supplied.
  !>             The matrix is compacted so that each AP_i contains the triangular portion column-by-column
  !>             so that:
  !>             AP(0) = A(0,0)
  !>             AP(1) = A(1,0)
  !>             AP(2) = A(2,1), etc.
  !>                 Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
  !>                     (1, 0) (2, 1) (3, 2)
  !>                     (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,-1), (3,-2), (4,0), (5,1), (6,0)]
  !>                     (3,-2) (5, 1) (6, 0)
  !>         Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>         to be 0.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface hipblasChpmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasChpmvBatched_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount) bind(c, name="cublasChpmvBatched")
#else
    function hipblasChpmvBatched_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasChpmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChpmvBatched_full_rank,&
      
hipblasChpmvBatched_rank_0,&
      
hipblasChpmvBatched_rank_1
#endif

  end interface
  
  interface hipblasZhpmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasZhpmvBatched_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount) bind(c, name="cublasZhpmvBatched")
#else
    function hipblasZhpmvBatched_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasZhpmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhpmvBatched_full_rank,&
      
hipblasZhpmvBatched_rank_0,&
      
hipblasZhpmvBatched_rank_1
#endif

  end interface
  
  interface hipblasChpmvBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasChpmvBatched_v2_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount) bind(c, name="cublasChpmvBatched_v2")
#else
    function hipblasChpmvBatched_v2_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasChpmvBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmvBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChpmvBatched_v2_full_rank,&
      
hipblasChpmvBatched_v2_rank_0,&
      
hipblasChpmvBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZhpmvBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZhpmvBatched_v2_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount) bind(c, name="cublasZhpmvBatched_v2")
#else
    function hipblasZhpmvBatched_v2_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasZhpmvBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmvBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhpmvBatched_v2_full_rank,&
      
hipblasZhpmvBatched_v2_rank_0,&
      
hipblasZhpmvBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hpmvStridedBatched performs the matrix-vector operation
  !> 
  !>         y_i := alphaA_ix_i + betay_i
  !> 
  !>     where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
  !>     n by n Hermitian matrix, supplied in packed form (see description below),
  !>     for each batch in i = [1, batchCount].
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               HIPBLAS_FILL_MODE_UPPER: the upper triangular part of each Hermitian matrix A_i is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: the lower triangular part of each Hermitian matrix A_i is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the order of each matrix A_i.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     AP        device pointer pointing to the beginning of the first matrix (AP_1). Stores the packed
  !>               version of the specified triangular portion of each Hermitian matrix AP_i of size ((n  (n + 1))  2).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that each AP_i contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
  !>                         (1, 0) (2, 1) (3, 2)
  !>                         (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,1), (4,0), (3,2), (5,-1), (6,0)]
  !>                         (3,-2) (5, 1) (6, 0)
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that each AP_i contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
  !>                         (1, 0) (2, 1) (3, 2)
  !>                         (2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,-1), (3,-2), (4,0), (5,1), (6,0)]
  !>                         (3,-2) (5, 1) (6, 0)
  !>         Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>         to be 0.
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one matrix (AP_i) and the next one (AP_i+1).
  !>     @param[in]
  !>     x         device array pointing to the beginning of the first vector (x_1).
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta.
  !>     @param[inout]
  !>     y         device array pointing to the beginning of the first vector (y_1).
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     stridey  [hipblasStride]
  !>               stride from the start of one vector (y_i) and the next one (y_i+1).
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface hipblasChpmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasChpmvStridedBatched_(handle,uplo,n,alpha,AP,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasChpmvStridedBatched")
#else
    function hipblasChpmvStridedBatched_(handle,uplo,n,alpha,AP,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasChpmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChpmvStridedBatched_rank_0,&
      
hipblasChpmvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZhpmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZhpmvStridedBatched_(handle,uplo,n,alpha,AP,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasZhpmvStridedBatched")
#else
    function hipblasZhpmvStridedBatched_(handle,uplo,n,alpha,AP,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasZhpmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhpmvStridedBatched_rank_0,&
      
hipblasZhpmvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasChpmvStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasChpmvStridedBatched_v2_(handle,uplo,n,alpha,AP,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasChpmvStridedBatched_v2")
#else
    function hipblasChpmvStridedBatched_v2_(handle,uplo,n,alpha,AP,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasChpmvStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmvStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChpmvStridedBatched_v2_rank_0,&
      
hipblasChpmvStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZhpmvStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZhpmvStridedBatched_v2_(handle,uplo,n,alpha,AP,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasZhpmvStridedBatched_v2")
#else
    function hipblasZhpmvStridedBatched_v2_(handle,uplo,n,alpha,AP,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasZhpmvStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmvStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhpmvStridedBatched_v2_rank_0,&
      
hipblasZhpmvStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hpr performs the matrix-vector operations
  !> 
  !>         A := A + alphaxxH
  !> 
  !>     where alpha is a real scalar, x is a vector, and A is an
  !>     n by n Hermitian matrix, supplied in packed form.
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of matrix A, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[inout]
  !>     AP        device pointer storing the packed version of the specified triangular portion of
  !>               the Hermitian matrix A. Of at least size ((n  (n + 1))  2).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of the Hermitian matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of the Hermitian matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     
  interface hipblasChpr
#ifdef USE_CUDA_NAMES
    function hipblasChpr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="cublasChpr_v2")
#else
    function hipblasChpr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="hipblasChpr")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChpr_rank_0,&
      
hipblasChpr_rank_1
#endif

  end interface
  
  interface hipblasZhpr
#ifdef USE_CUDA_NAMES
    function hipblasZhpr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="cublasZhpr_v2")
#else
    function hipblasZhpr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="hipblasZhpr")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhpr_rank_0,&
      
hipblasZhpr_rank_1
#endif

  end interface
  
  interface hipblasChpr_v2
#ifdef USE_CUDA_NAMES
    function hipblasChpr_v2_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="cublasChpr_v2")
#else
    function hipblasChpr_v2_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="hipblasChpr_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChpr_v2_rank_0,&
      
hipblasChpr_v2_rank_1
#endif

  end interface
  
  interface hipblasZhpr_v2
#ifdef USE_CUDA_NAMES
    function hipblasZhpr_v2_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="cublasZhpr_v2")
#else
    function hipblasZhpr_v2_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="hipblasZhpr_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhpr_v2_rank_0,&
      
hipblasZhpr_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hprBatched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alphax_ix_iH
  !> 
  !>     where alpha is a real scalar, x_i is a vector, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[inout]
  !>     AP        device array of device pointers storing the packed version of the specified triangular portion of
  !>               each Hermitian matrix A_i of at least size ((n  (n + 1))  2). Array is of at least size batchCount.
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>     
  interface hipblasChprBatched
#ifdef USE_CUDA_NAMES
    function hipblasChprBatched_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="cublasChprBatched")
#else
    function hipblasChprBatched_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="hipblasChprBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChprBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChprBatched_full_rank,&
      
hipblasChprBatched_rank_0,&
      
hipblasChprBatched_rank_1
#endif

  end interface
  
  interface hipblasZhprBatched
#ifdef USE_CUDA_NAMES
    function hipblasZhprBatched_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="cublasZhprBatched")
#else
    function hipblasZhprBatched_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="hipblasZhprBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhprBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhprBatched_full_rank,&
      
hipblasZhprBatched_rank_0,&
      
hipblasZhprBatched_rank_1
#endif

  end interface
  
  interface hipblasChprBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasChprBatched_v2_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="cublasChprBatched_v2")
#else
    function hipblasChprBatched_v2_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="hipblasChprBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChprBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChprBatched_v2_full_rank,&
      
hipblasChprBatched_v2_rank_0,&
      
hipblasChprBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZhprBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZhprBatched_v2_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="cublasZhprBatched_v2")
#else
    function hipblasZhprBatched_v2_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="hipblasZhprBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhprBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhprBatched_v2_full_rank,&
      
hipblasZhprBatched_v2_rank_0,&
      
hipblasZhprBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hprStridedBatched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alphax_ix_iH
  !> 
  !>     where alpha is a real scalar, x_i is a vector, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer pointing to the first vector (x_1).
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>     @param[inout]
  !>     AP        device array of device pointers storing the packed version of the specified triangular portion of
  !>               each Hermitian matrix A_i. Points to the first matrix (A_1).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     strideA   [hipblasStride]
  !>                 stride from the start of one (A_i) and the next (A_i+1)
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>     
  interface hipblasChprStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasChprStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount) bind(c, name="cublasChprStridedBatched")
#else
    function hipblasChprStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount) bind(c, name="hipblasChprStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChprStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChprStridedBatched_rank_0,&
      
hipblasChprStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZhprStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZhprStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount) bind(c, name="cublasZhprStridedBatched")
#else
    function hipblasZhprStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount) bind(c, name="hipblasZhprStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhprStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhprStridedBatched_rank_0,&
      
hipblasZhprStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasChprStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasChprStridedBatched_v2_(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount) bind(c, name="cublasChprStridedBatched_v2")
#else
    function hipblasChprStridedBatched_v2_(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount) bind(c, name="hipblasChprStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChprStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChprStridedBatched_v2_rank_0,&
      
hipblasChprStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZhprStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZhprStridedBatched_v2_(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount) bind(c, name="cublasZhprStridedBatched_v2")
#else
    function hipblasZhprStridedBatched_v2_(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount) bind(c, name="hipblasZhprStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhprStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhprStridedBatched_v2_rank_0,&
      
hipblasZhprStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hpr2 performs the matrix-vector operations
  !> 
  !>         A := A + alphaxyH + conj(alpha)yxH
  !> 
  !>     where alpha is a complex scalar, x and y are vectors, and A is an
  !>     n by n Hermitian matrix, supplied in packed form.
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of matrix A, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     AP        device pointer storing the packed version of the specified triangular portion of
  !>               the Hermitian matrix A. Of at least size ((n  (n + 1))  2).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of the Hermitian matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of the Hermitian matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     
  interface hipblasChpr2
#ifdef USE_CUDA_NAMES
    function hipblasChpr2_(handle,uplo,n,alpha,x,incx,y,incy,AP) bind(c, name="cublasChpr2_v2")
#else
    function hipblasChpr2_(handle,uplo,n,alpha,x,incx,y,incy,AP) bind(c, name="hipblasChpr2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChpr2_rank_0,&
      
hipblasChpr2_rank_1
#endif

  end interface
  
  interface hipblasZhpr2
#ifdef USE_CUDA_NAMES
    function hipblasZhpr2_(handle,uplo,n,alpha,x,incx,y,incy,AP) bind(c, name="cublasZhpr2_v2")
#else
    function hipblasZhpr2_(handle,uplo,n,alpha,x,incx,y,incy,AP) bind(c, name="hipblasZhpr2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhpr2_rank_0,&
      
hipblasZhpr2_rank_1
#endif

  end interface
  
  interface hipblasChpr2_v2
#ifdef USE_CUDA_NAMES
    function hipblasChpr2_v2_(handle,uplo,n,alpha,x,incx,y,incy,AP) bind(c, name="cublasChpr2_v2")
#else
    function hipblasChpr2_v2_(handle,uplo,n,alpha,x,incx,y,incy,AP) bind(c, name="hipblasChpr2_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChpr2_v2_rank_0,&
      
hipblasChpr2_v2_rank_1
#endif

  end interface
  
  interface hipblasZhpr2_v2
#ifdef USE_CUDA_NAMES
    function hipblasZhpr2_v2_(handle,uplo,n,alpha,x,incx,y,incy,AP) bind(c, name="cublasZhpr2_v2")
#else
    function hipblasZhpr2_v2_(handle,uplo,n,alpha,x,incx,y,incy,AP) bind(c, name="hipblasZhpr2_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhpr2_v2_rank_0,&
      
hipblasZhpr2_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hpr2Batched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alphax_iy_iH + conj(alpha)y_ix_iH
  !> 
  !>     where alpha is a complex scalar, x_i and y_i are vectors, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[inout]
  !>     AP        device array of device pointers storing the packed version of the specified triangular portion of
  !>               each Hermitian matrix A_i of at least size ((n  (n + 1))  2). Array is of at least size batchCount.
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>     
  interface hipblasChpr2Batched
#ifdef USE_CUDA_NAMES
    function hipblasChpr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount) bind(c, name="cublasChpr2Batched")
#else
    function hipblasChpr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount) bind(c, name="hipblasChpr2Batched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2Batched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChpr2Batched_full_rank,&
      
hipblasChpr2Batched_rank_0,&
      
hipblasChpr2Batched_rank_1
#endif

  end interface
  
  interface hipblasZhpr2Batched
#ifdef USE_CUDA_NAMES
    function hipblasZhpr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount) bind(c, name="cublasZhpr2Batched")
#else
    function hipblasZhpr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount) bind(c, name="hipblasZhpr2Batched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2Batched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhpr2Batched_full_rank,&
      
hipblasZhpr2Batched_rank_0,&
      
hipblasZhpr2Batched_rank_1
#endif

  end interface
  
  interface hipblasChpr2Batched_v2
#ifdef USE_CUDA_NAMES
    function hipblasChpr2Batched_v2_(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount) bind(c, name="cublasChpr2Batched_v2")
#else
    function hipblasChpr2Batched_v2_(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount) bind(c, name="hipblasChpr2Batched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2Batched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChpr2Batched_v2_full_rank,&
      
hipblasChpr2Batched_v2_rank_0,&
      
hipblasChpr2Batched_v2_rank_1
#endif

  end interface
  
  interface hipblasZhpr2Batched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZhpr2Batched_v2_(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount) bind(c, name="cublasZhpr2Batched_v2")
#else
    function hipblasZhpr2Batched_v2_(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount) bind(c, name="hipblasZhpr2Batched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2Batched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhpr2Batched_v2_full_rank,&
      
hipblasZhpr2Batched_v2_rank_0,&
      
hipblasZhpr2Batched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     hpr2StridedBatched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alphax_iy_iH + conj(alpha)y_ix_iH
  !> 
  !>     where alpha is a complex scalar, x_i and y_i are vectors, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer pointing to the first vector (x_1).
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>     @param[in]
  !>     y         device pointer pointing to the first vector (y_1).
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     stridey  [hipblasStride]
  !>               stride from the start of one vector (y_i) and the next one (y_i+1).
  !>     @param[inout]
  !>     AP        device array of device pointers storing the packed version of the specified triangular portion of
  !>               each Hermitian matrix A_i. Points to the first matrix (A_1).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of each Hermitian matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
  !>                         (1, 0) (2, 1) (4,9)
  !>                         (2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
  !>                         (4,-9) (5,-3) (6,0)
  !>             Note that the imaginary part of the diagonal elements are not accessed and are assumed
  !>             to be 0.
  !>     @param[in]
  !>     strideA    [hipblasStride]
  !>                 stride from the start of one (A_i) and the next (A_i+1)
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>     
  interface hipblasChpr2StridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasChpr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideA,batchCount) bind(c, name="cublasChpr2StridedBatched")
#else
    function hipblasChpr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideA,batchCount) bind(c, name="hipblasChpr2StridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2StridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChpr2StridedBatched_rank_0,&
      
hipblasChpr2StridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZhpr2StridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZhpr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideA,batchCount) bind(c, name="cublasZhpr2StridedBatched")
#else
    function hipblasZhpr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideA,batchCount) bind(c, name="hipblasZhpr2StridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2StridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhpr2StridedBatched_rank_0,&
      
hipblasZhpr2StridedBatched_rank_1
#endif

  end interface
  
  interface hipblasChpr2StridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasChpr2StridedBatched_v2_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideA,batchCount) bind(c, name="cublasChpr2StridedBatched_v2")
#else
    function hipblasChpr2StridedBatched_v2_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideA,batchCount) bind(c, name="hipblasChpr2StridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2StridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasChpr2StridedBatched_v2_rank_0,&
      
hipblasChpr2StridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZhpr2StridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZhpr2StridedBatched_v2_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideA,batchCount) bind(c, name="cublasZhpr2StridedBatched_v2")
#else
    function hipblasZhpr2StridedBatched_v2_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideA,batchCount) bind(c, name="hipblasZhpr2StridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2StridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZhpr2StridedBatched_v2_rank_0,&
      
hipblasZhpr2StridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     sbmv performs the matrix-vector operation:
  !> 
  !>         y := alphaAx + betay,
  !> 
  !>     where alpha and beta are scalars, x and y are n element vectors and
  !>     A should contain an upper or lower triangular n by n symmetric banded matrix.
  !> 
  !>     - Supported precisions in rocBLAS : s,d
  !>     - Supported precisions in cuBLAS  : s,d
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [int]
  !>     @param[in]
  !>     k         [int]
  !>               specifies the number of sub- and super-diagonals
  !>     @param[in]
  !>     alpha
  !>               specifies the scalar alpha
  !>     @param[in]
  !>     AP         pointer storing matrix A on the GPU
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of matrix A
  !>     @param[in]
  !>     x         pointer storing vector x on the GPU
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x
  !>     @param[in]
  !>     beta      specifies the scalar beta
  !>     @param[out]
  !>     y         pointer storing vector y on the GPU
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y
  !> 
  !>     
  interface hipblasSsbmv
#ifdef USE_CUDA_NAMES
    function hipblasSsbmv_(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="cublasSsbmv_v2")
#else
    function hipblasSsbmv_(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="hipblasSsbmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsbmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSsbmv_rank_0,&
      
hipblasSsbmv_rank_1
#endif

  end interface
  
  interface hipblasDsbmv
#ifdef USE_CUDA_NAMES
    function hipblasDsbmv_(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="cublasDsbmv_v2")
#else
    function hipblasDsbmv_(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="hipblasDsbmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsbmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDsbmv_rank_0,&
      
hipblasDsbmv_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     sbmvBatched performs the matrix-vector operation:
  !> 
  !>         y_i := alphaA_ix_i + betay_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     n by n symmetric banded matrix, for i = 1, ..., batchCount.
  !>     A should contain an upper or lower triangular n by n symmetric banded matrix.
  !> 
  !>     - Supported precisions in rocBLAS : s,d
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [int]
  !>               number of rows and columns of each matrix A_i
  !>     @param[in]
  !>     k         [int]
  !>               specifies the number of sub- and super-diagonals
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha
  !>     @param[in]
  !>     AP         device array of device pointers storing each matrix A_i
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each matrix A_i
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each vector x_i
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta
  !>     @param[out]
  !>     y         device array of device pointers storing each vector y_i
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each vector y_i
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface hipblasSsbmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsbmvBatched_(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasSsbmvBatched")
#else
    function hipblasSsbmvBatched_(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasSsbmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsbmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSsbmvBatched_full_rank,&
      
hipblasSsbmvBatched_rank_0,&
      
hipblasSsbmvBatched_rank_1
#endif

  end interface
  
  interface hipblasDsbmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsbmvBatched_(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasDsbmvBatched")
#else
    function hipblasDsbmvBatched_(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasDsbmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsbmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDsbmvBatched_full_rank,&
      
hipblasDsbmvBatched_rank_0,&
      
hipblasDsbmvBatched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     sbmvStridedBatched performs the matrix-vector operation:
  !> 
  !>         y_i := alphaA_ix_i + betay_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     n by n symmetric banded matrix, for i = 1, ..., batchCount.
  !>     A should contain an upper or lower triangular n by n symmetric banded matrix.
  !> 
  !>     - Supported precisions in rocBLAS : s,d
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [int]
  !>               number of rows and columns of each matrix A_i
  !>     @param[in]
  !>     k         [int]
  !>               specifies the number of sub- and super-diagonals
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha
  !>     @param[in]
  !>     AP        Device pointer to the first matrix A_1 on the GPU
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each matrix A_i
  !>     @param[in]
  !>     strideA     [hipblasStride]
  !>                 stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     x         Device pointer to the first vector x_1 on the GPU
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each vector x_i
  !>     @param[in]
  !>     stridex     [hipblasStride]
  !>                 stride from the start of one vector (x_i) and the next one (x_i+1).
  !>                 There are no restrictions placed on stridex, however the user should
  !>                 take care to ensure that stridex is of appropriate size.
  !>                 This typically means stridex >= n  incx. stridex should be non zero.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta
  !>     @param[out]
  !>     y         Device pointer to the first vector y_1 on the GPU
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each vector y_i
  !>     @param[in]
  !>     stridey     [hipblasStride]
  !>                 stride from the start of one vector (y_i) and the next one (y_i+1).
  !>                 There are no restrictions placed on stridey, however the user should
  !>                 take care to ensure that stridey is of appropriate size.
  !>                 This typically means stridey >= n  incy. stridey should be non zero.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface hipblasSsbmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsbmvStridedBatched_(handle,uplo,n,k,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasSsbmvStridedBatched")
#else
    function hipblasSsbmvStridedBatched_(handle,uplo,n,k,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasSsbmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsbmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSsbmvStridedBatched_rank_0,&
      
hipblasSsbmvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDsbmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsbmvStridedBatched_(handle,uplo,n,k,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasDsbmvStridedBatched")
#else
    function hipblasDsbmvStridedBatched_(handle,uplo,n,k,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasDsbmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsbmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDsbmvStridedBatched_rank_0,&
      
hipblasDsbmvStridedBatched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     spmv performs the matrix-vector operation:
  !> 
  !>         y := alphaAx + betay,
  !> 
  !>     where alpha and beta are scalars, x and y are n element vectors and
  !>     A should contain an upper or lower triangular n by n packed symmetric matrix.
  !> 
  !>     - Supported precisions in rocBLAS : s,d
  !>     - Supported precisions in cuBLAS  : s,d
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [int]
  !>     @param[in]
  !>     alpha
  !>               specifies the scalar alpha
  !>     @param[in]
  !>     AP         pointer storing matrix A on the GPU
  !>     @param[in]
  !>     x         pointer storing vector x on the GPU
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x
  !>     @param[in]
  !>     beta      specifies the scalar beta
  !>     @param[out]
  !>     y         pointer storing vector y on the GPU
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y
  !> 
  !>     
  interface hipblasSspmv
#ifdef USE_CUDA_NAMES
    function hipblasSspmv_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy) bind(c, name="cublasSspmv_v2")
#else
    function hipblasSspmv_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy) bind(c, name="hipblasSspmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSspmv_rank_0,&
      
hipblasSspmv_rank_1
#endif

  end interface
  
  interface hipblasDspmv
#ifdef USE_CUDA_NAMES
    function hipblasDspmv_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy) bind(c, name="cublasDspmv_v2")
#else
    function hipblasDspmv_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy) bind(c, name="hipblasDspmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDspmv_rank_0,&
      
hipblasDspmv_rank_1
#endif

  end interface
  
  interface hipblasSspmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasSspmvBatched_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount) bind(c, name="cublasSspmvBatched")
#else
    function hipblasSspmvBatched_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasSspmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSspmvBatched_full_rank,&
      
hipblasSspmvBatched_rank_0,&
      
hipblasSspmvBatched_rank_1
#endif

  end interface
  
  interface hipblasDspmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasDspmvBatched_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount) bind(c, name="cublasDspmvBatched")
#else
    function hipblasDspmvBatched_(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasDspmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDspmvBatched_full_rank,&
      
hipblasDspmvBatched_rank_0,&
      
hipblasDspmvBatched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     spmvStridedBatched performs the matrix-vector operation:
  !> 
  !>         y_i := alphaA_ix_i + betay_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     n by n symmetric matrix, for i = 1, ..., batchCount.
  !>     A should contain an upper or lower triangular n by n packed symmetric matrix.
  !> 
  !>     - Supported precisions in rocBLAS : s,d
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [int]
  !>               number of rows and columns of each matrix A_i
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha
  !>     @param[in]
  !>     AP        Device pointer to the first matrix A_1 on the GPU
  !>     @param[in]
  !>     strideA    [hipblasStride]
  !>                 stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     x         Device pointer to the first vector x_1 on the GPU
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each vector x_i
  !>     @param[in]
  !>     stridex     [hipblasStride]
  !>                 stride from the start of one vector (x_i) and the next one (x_i+1).
  !>                 There are no restrictions placed on stridex, however the user should
  !>                 take care to ensure that stridex is of appropriate size.
  !>                 This typically means stridex >= n  incx. stridex should be non zero.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta
  !>     @param[out]
  !>     y         Device pointer to the first vector y_1 on the GPU
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each vector y_i
  !>     @param[in]
  !>     stridey     [hipblasStride]
  !>                 stride from the start of one vector (y_i) and the next one (y_i+1).
  !>                 There are no restrictions placed on stridey, however the user should
  !>                 take care to ensure that stridey is of appropriate size.
  !>                 This typically means stridey >= n  incy. stridey should be non zero.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface hipblasSspmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSspmvStridedBatched_(handle,uplo,n,alpha,AP,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasSspmvStridedBatched")
#else
    function hipblasSspmvStridedBatched_(handle,uplo,n,alpha,AP,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasSspmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSspmvStridedBatched_rank_0,&
      
hipblasSspmvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDspmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDspmvStridedBatched_(handle,uplo,n,alpha,AP,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasDspmvStridedBatched")
#else
    function hipblasDspmvStridedBatched_(handle,uplo,n,alpha,AP,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasDspmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDspmvStridedBatched_rank_0,&
      
hipblasDspmvStridedBatched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     spr performs the matrix-vector operations
  !> 
  !>         A := A + alphaxxT
  !> 
  !>     where alpha is a scalar, x is a vector, and A is an
  !>     n by n symmetric matrix, supplied in packed form.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of matrix A, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[inout]
  !>     AP        device pointer storing the packed version of the specified triangular portion of
  !>               the symmetric matrix A. Of at least size ((n  (n + 1))  2).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of the symmetric matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_UPPER; n = 4)
  !>                         1 2 4 7
  !>                         2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         4 5 6 9
  !>                         7 8 9 0
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of the symmetric matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_LOWER; n = 4)
  !>                         1 2 3 4
  !>                         2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         3 6 8 9
  !>                         4 7 9 0
  !>     
  interface hipblasSspr
#ifdef USE_CUDA_NAMES
    function hipblasSspr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="cublasSspr_v2")
#else
    function hipblasSspr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="hipblasSspr")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspr_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSspr_rank_0,&
      
hipblasSspr_rank_1
#endif

  end interface
  
  interface hipblasDspr
#ifdef USE_CUDA_NAMES
    function hipblasDspr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="cublasDspr_v2")
#else
    function hipblasDspr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="hipblasDspr")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspr_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDspr_rank_0,&
      
hipblasDspr_rank_1
#endif

  end interface
  
  interface hipblasCspr
#ifdef USE_CUDA_NAMES
    function hipblasCspr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="cublasCspr")
#else
    function hipblasCspr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="hipblasCspr")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCspr_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCspr_rank_0,&
      
hipblasCspr_rank_1
#endif

  end interface
  
  interface hipblasZspr
#ifdef USE_CUDA_NAMES
    function hipblasZspr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="cublasZspr")
#else
    function hipblasZspr_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="hipblasZspr")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZspr_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZspr_rank_0,&
      
hipblasZspr_rank_1
#endif

  end interface
  
  interface hipblasCspr_v2
#ifdef USE_CUDA_NAMES
    function hipblasCspr_v2_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="cublasCspr_v2")
#else
    function hipblasCspr_v2_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="hipblasCspr_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCspr_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCspr_v2_rank_0,&
      
hipblasCspr_v2_rank_1
#endif

  end interface
  
  interface hipblasZspr_v2
#ifdef USE_CUDA_NAMES
    function hipblasZspr_v2_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="cublasZspr_v2")
#else
    function hipblasZspr_v2_(handle,uplo,n,alpha,x,incx,AP) bind(c, name="hipblasZspr_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZspr_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZspr_v2_rank_0,&
      
hipblasZspr_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     sprBatched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alphax_ix_iT
  !> 
  !>     where alpha is a scalar, x_i is a vector, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[inout]
  !>     AP        device array of device pointers storing the packed version of the specified triangular portion of
  !>               each symmetric matrix A_i of at least size ((n  (n + 1))  2). Array is of at least size batchCount.
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_UPPER; n = 4)
  !>                         1 2 4 7
  !>                         2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         4 5 6 9
  !>                         7 8 9 0
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_LOWER; n = 4)
  !>                         1 2 3 4
  !>                         2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         3 6 8 9
  !>                         4 7 9 0
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>     
  interface hipblasSsprBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsprBatched_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="cublasSsprBatched")
#else
    function hipblasSsprBatched_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="hipblasSsprBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsprBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSsprBatched_full_rank,&
      
hipblasSsprBatched_rank_0,&
      
hipblasSsprBatched_rank_1
#endif

  end interface
  
  interface hipblasDsprBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsprBatched_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="cublasDsprBatched")
#else
    function hipblasDsprBatched_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="hipblasDsprBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsprBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDsprBatched_full_rank,&
      
hipblasDsprBatched_rank_0,&
      
hipblasDsprBatched_rank_1
#endif

  end interface
  
  interface hipblasCsprBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsprBatched_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="cublasCsprBatched")
#else
    function hipblasCsprBatched_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="hipblasCsprBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsprBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsprBatched_full_rank,&
      
hipblasCsprBatched_rank_0,&
      
hipblasCsprBatched_rank_1
#endif

  end interface
  
  interface hipblasZsprBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsprBatched_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="cublasZsprBatched")
#else
    function hipblasZsprBatched_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="hipblasZsprBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsprBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZsprBatched_full_rank,&
      
hipblasZsprBatched_rank_0,&
      
hipblasZsprBatched_rank_1
#endif

  end interface
  
  interface hipblasCsprBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsprBatched_v2_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="cublasCsprBatched_v2")
#else
    function hipblasCsprBatched_v2_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="hipblasCsprBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsprBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsprBatched_v2_full_rank,&
      
hipblasCsprBatched_v2_rank_0,&
      
hipblasCsprBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZsprBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZsprBatched_v2_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="cublasZsprBatched_v2")
#else
    function hipblasZsprBatched_v2_(handle,uplo,n,alpha,x,incx,AP,batchCount) bind(c, name="hipblasZsprBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsprBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZsprBatched_v2_full_rank,&
      
hipblasZsprBatched_v2_rank_0,&
      
hipblasZsprBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     sprStridedBatched performs the matrix-vector operations
  !> 
  !>         A_i := A_i + alphax_ix_iT
  !> 
  !>     where alpha is a scalar, x_i is a vector, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer pointing to the first vector (x_1).
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>     @param[inout]
  !>     AP        device pointer storing the packed version of the specified triangular portion of
  !>               each symmetric matrix A_i. Points to the first A_1.
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_UPPER; n = 4)
  !>                         1 2 4 7
  !>                         2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         4 5 6 9
  !>                         7 8 9 0
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(2) = A(2,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_LOWER; n = 4)
  !>                         1 2 3 4
  !>                         2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         3 6 8 9
  !>                         4 7 9 0
  !>     @param[in]
  !>     strideA    [hipblasStride]
  !>                 stride from the start of one (A_i) and the next (A_i+1)
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>     
  interface hipblasSsprStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsprStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount) bind(c, name="cublasSsprStridedBatched")
#else
    function hipblasSsprStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount) bind(c, name="hipblasSsprStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsprStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSsprStridedBatched_rank_0,&
      
hipblasSsprStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDsprStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsprStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount) bind(c, name="cublasDsprStridedBatched")
#else
    function hipblasDsprStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount) bind(c, name="hipblasDsprStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsprStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDsprStridedBatched_rank_0,&
      
hipblasDsprStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCsprStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsprStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount) bind(c, name="cublasCsprStridedBatched")
#else
    function hipblasCsprStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount) bind(c, name="hipblasCsprStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsprStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsprStridedBatched_rank_0,&
      
hipblasCsprStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZsprStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsprStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount) bind(c, name="cublasZsprStridedBatched")
#else
    function hipblasZsprStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount) bind(c, name="hipblasZsprStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsprStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZsprStridedBatched_rank_0,&
      
hipblasZsprStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCsprStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsprStridedBatched_v2_(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount) bind(c, name="cublasCsprStridedBatched_v2")
#else
    function hipblasCsprStridedBatched_v2_(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount) bind(c, name="hipblasCsprStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsprStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsprStridedBatched_v2_rank_0,&
      
hipblasCsprStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZsprStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZsprStridedBatched_v2_(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount) bind(c, name="cublasZsprStridedBatched_v2")
#else
    function hipblasZsprStridedBatched_v2_(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount) bind(c, name="hipblasZsprStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsprStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZsprStridedBatched_v2_rank_0,&
      
hipblasZsprStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     spr2 performs the matrix-vector operation
  !> 
  !>         A := A + alphaxyT + alphayxT
  !> 
  !>     where alpha is a scalar, x and y are vectors, and A is an
  !>     n by n symmetric matrix, supplied in packed form.
  !> 
  !>     - Supported precisions in rocBLAS : s,d
  !>     - Supported precisions in cuBLAS  : s,d
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of matrix A, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     AP        device pointer storing the packed version of the specified triangular portion of
  !>               the symmetric matrix A. Of at least size ((n  (n + 1))  2).
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of the symmetric matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_UPPER; n = 4)
  !>                         1 2 4 7
  !>                         2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         4 5 6 9
  !>                         7 8 9 0
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of the symmetric matrix A is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(n) = A(2,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_LOWER; n = 4)
  !>                         1 2 3 4
  !>                         2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         3 6 8 9
  !>                         4 7 9 0
  !>     
  interface hipblasSspr2
#ifdef USE_CUDA_NAMES
    function hipblasSspr2_(handle,uplo,n,alpha,x,incx,y,incy,AP) bind(c, name="cublasSspr2_v2")
#else
    function hipblasSspr2_(handle,uplo,n,alpha,x,incx,y,incy,AP) bind(c, name="hipblasSspr2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspr2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSspr2_rank_0,&
      
hipblasSspr2_rank_1
#endif

  end interface
  
  interface hipblasDspr2
#ifdef USE_CUDA_NAMES
    function hipblasDspr2_(handle,uplo,n,alpha,x,incx,y,incy,AP) bind(c, name="cublasDspr2_v2")
#else
    function hipblasDspr2_(handle,uplo,n,alpha,x,incx,y,incy,AP) bind(c, name="hipblasDspr2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspr2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDspr2_rank_0,&
      
hipblasDspr2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     spr2Batched performs the matrix-vector operation
  !> 
  !>         A_i := A_i + alphax_iy_iT + alphay_ix_iT
  !> 
  !>     where alpha is a scalar, x_i and y_i are vectors, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : s,d
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[inout]
  !>     AP        device array of device pointers storing the packed version of the specified triangular portion of
  !>               each symmetric matrix A_i of at least size ((n  (n + 1))  2). Array is of at least size batchCount.
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_UPPER; n = 4)
  !>                         1 2 4 7
  !>                         2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         4 5 6 9
  !>                         7 8 9 0
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(n) = A(2,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_LOWER; n = 4)
  !>                         1 2 3 4
  !>                         2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         3 6 8 9
  !>                         4 7 9 0
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>     
  interface hipblasSspr2Batched
#ifdef USE_CUDA_NAMES
    function hipblasSspr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount) bind(c, name="cublasSspr2Batched")
#else
    function hipblasSspr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount) bind(c, name="hipblasSspr2Batched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspr2Batched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSspr2Batched_full_rank,&
      
hipblasSspr2Batched_rank_0,&
      
hipblasSspr2Batched_rank_1
#endif

  end interface
  
  interface hipblasDspr2Batched
#ifdef USE_CUDA_NAMES
    function hipblasDspr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount) bind(c, name="cublasDspr2Batched")
#else
    function hipblasDspr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount) bind(c, name="hipblasDspr2Batched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspr2Batched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDspr2Batched_full_rank,&
      
hipblasDspr2Batched_rank_0,&
      
hipblasDspr2Batched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     spr2StridedBatched performs the matrix-vector operation
  !> 
  !>         A_i := A_i + alphax_iy_iT + alphay_ix_iT
  !> 
  !>     where alpha is a scalar, x_i amd y_i are vectors, and A_i is an
  !>     n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : s,d
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
  !>               HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of each matrix A_i, must be at least 0.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer pointing to the first vector (x_1).
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>     @param[in]
  !>     y         device pointer pointing to the first vector (y_1).
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     stridey  [hipblasStride]
  !>               stride from the start of one vector (y_i) and the next one (y_i+1).
  !>     @param[inout]
  !>     AP        device pointer storing the packed version of the specified triangular portion of
  !>               each symmetric matrix A_i. Points to the first A_1.
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The upper triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(0,1)
  !>                 AP(2) = A(1,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_UPPER; n = 4)
  !>                         1 2 4 7
  !>                         2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         4 5 6 9
  !>                         7 8 9 0
  !>             if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The lower triangular portion of each symmetric matrix A_i is supplied.
  !>                 The matrix is compacted so that AP contains the triangular portion column-by-column
  !>                 so that:
  !>                 AP(0) = A(0,0)
  !>                 AP(1) = A(1,0)
  !>                 AP(n) = A(2,1), etc.
  !>                     Ex: (HIPBLAS_FILL_MODE_LOWER; n = 4)
  !>                         1 2 3 4
  !>                         2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  !>                         3 6 8 9
  !>                         4 7 9 0
  !>     @param[in]
  !>     strideA   [hipblasStride]
  !>                 stride from the start of one (A_i) and the next (A_i+1)
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>     
  interface hipblasSspr2StridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSspr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideA,batchCount) bind(c, name="cublasSspr2StridedBatched")
#else
    function hipblasSspr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideA,batchCount) bind(c, name="hipblasSspr2StridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspr2StridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSspr2StridedBatched_rank_0,&
      
hipblasSspr2StridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDspr2StridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDspr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideA,batchCount) bind(c, name="cublasDspr2StridedBatched")
#else
    function hipblasDspr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideA,batchCount) bind(c, name="hipblasDspr2StridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspr2StridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDspr2StridedBatched_rank_0,&
      
hipblasDspr2StridedBatched_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     symv performs the matrix-vector operation:
  !> 
  !>         y := alphaAx + betay,
  !> 
  !>     where alpha and beta are scalars, x and y are n element vectors and
  !>     A should contain an upper or lower triangular n by n symmetric matrix.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [int]
  !>     @param[in]
  !>     alpha
  !>               specifies the scalar alpha
  !>     @param[in]
  !>     AP         pointer storing matrix A on the GPU
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A
  !>     @param[in]
  !>     x         pointer storing vector x on the GPU
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x
  !>     @param[in]
  !>     beta      specifies the scalar beta
  !>     @param[out]
  !>     y         pointer storing vector y on the GPU
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y
  !> 
  !>     
  interface hipblasSsymv
#ifdef USE_CUDA_NAMES
    function hipblasSsymv_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="cublasSsymv_v2")
#else
    function hipblasSsymv_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="hipblasSsymv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSsymv_rank_0,&
      
hipblasSsymv_rank_1
#endif

  end interface
  
  interface hipblasDsymv
#ifdef USE_CUDA_NAMES
    function hipblasDsymv_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="cublasDsymv_v2")
#else
    function hipblasDsymv_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="hipblasDsymv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDsymv_rank_0,&
      
hipblasDsymv_rank_1
#endif

  end interface
  
  interface hipblasCsymv
#ifdef USE_CUDA_NAMES
    function hipblasCsymv_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="cublasCsymv_v2")
#else
    function hipblasCsymv_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="hipblasCsymv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsymv_rank_0,&
      
hipblasCsymv_rank_1
#endif

  end interface
  
  interface hipblasZsymv
#ifdef USE_CUDA_NAMES
    function hipblasZsymv_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="cublasZsymv_v2")
#else
    function hipblasZsymv_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="hipblasZsymv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZsymv_rank_0,&
      
hipblasZsymv_rank_1
#endif

  end interface
  
  interface hipblasCsymv_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsymv_v2_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="cublasCsymv_v2")
#else
    function hipblasCsymv_v2_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="hipblasCsymv_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymv_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsymv_v2_rank_0,&
      
hipblasCsymv_v2_rank_1
#endif

  end interface
  
  interface hipblasZsymv_v2
#ifdef USE_CUDA_NAMES
    function hipblasZsymv_v2_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="cublasZsymv_v2")
#else
    function hipblasZsymv_v2_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy) bind(c, name="hipblasZsymv_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymv_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZsymv_v2_rank_0,&
      
hipblasZsymv_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     symvBatched performs the matrix-vector operation:
  !> 
  !>         y_i := alphaA_ix_i + betay_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     n by n symmetric matrix, for i = 1, ..., batchCount.
  !>     A a should contain an upper or lower triangular symmetric matrix
  !>     and the opposing triangular part of A is not referenced
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [int]
  !>               number of rows and columns of each matrix A_i
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha
  !>     @param[in]
  !>     AP        device array of device pointers storing each matrix A_i
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each matrix A_i
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each vector x_i
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta
  !>     @param[out]
  !>     y         device array of device pointers storing each vector y_i
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each vector y_i
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface hipblasSsymvBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsymvBatched_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasSsymvBatched")
#else
    function hipblasSsymvBatched_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasSsymvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_float) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSsymvBatched_full_rank,&
      
hipblasSsymvBatched_rank_0,&
      
hipblasSsymvBatched_rank_1
#endif

  end interface
  
  interface hipblasDsymvBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsymvBatched_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasDsymvBatched")
#else
    function hipblasDsymvBatched_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasDsymvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      real(c_double) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDsymvBatched_full_rank,&
      
hipblasDsymvBatched_rank_0,&
      
hipblasDsymvBatched_rank_1
#endif

  end interface
  
  interface hipblasCsymvBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsymvBatched_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasCsymvBatched")
#else
    function hipblasCsymvBatched_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasCsymvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsymvBatched_full_rank,&
      
hipblasCsymvBatched_rank_0,&
      
hipblasCsymvBatched_rank_1
#endif

  end interface
  
  interface hipblasZsymvBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsymvBatched_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasZsymvBatched")
#else
    function hipblasZsymvBatched_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasZsymvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZsymvBatched_full_rank,&
      
hipblasZsymvBatched_rank_0,&
      
hipblasZsymvBatched_rank_1
#endif

  end interface
  
  interface hipblasCsymvBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsymvBatched_v2_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasCsymvBatched_v2")
#else
    function hipblasCsymvBatched_v2_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasCsymvBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymvBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_float_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsymvBatched_v2_full_rank,&
      
hipblasCsymvBatched_v2_rank_0,&
      
hipblasCsymvBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZsymvBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZsymvBatched_v2_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="cublasZsymvBatched_v2")
#else
    function hipblasZsymvBatched_v2_(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount) bind(c, name="hipblasZsymvBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymvBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      complex(c_double_complex) :: beta
      type(c_ptr) :: y
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZsymvBatched_v2_full_rank,&
      
hipblasZsymvBatched_v2_rank_0,&
      
hipblasZsymvBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     symvStridedBatched performs the matrix-vector operation:
  !> 
  !>         y_i := alphaA_ix_i + betay_i,
  !> 
  !>     where (A_i, x_i, y_i) is the i-th instance of the batch.
  !>     alpha and beta are scalars, x_i and y_i are vectors and A_i is an
  !>     n by n symmetric matrix, for i = 1, ..., batchCount.
  !>     A a should contain an upper or lower triangular symmetric matrix
  !>     and the opposing triangular part of A is not referenced
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [int]
  !>               number of rows and columns of each matrix A_i
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha
  !>     @param[in]
  !>     AP         Device pointer to the first matrix A_1 on the GPU
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each matrix A_i
  !>     @param[in]
  !>     strideA     [hipblasStride]
  !>                 stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     x         Device pointer to the first vector x_1 on the GPU
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each vector x_i
  !>     @param[in]
  !>     stridex     [hipblasStride]
  !>                 stride from the start of one vector (x_i) and the next one (x_i+1).
  !>                 There are no restrictions placed on stridex, however the user should
  !>                 take care to ensure that stridex is of appropriate size.
  !>                 This typically means stridex >= n  incx. stridex should be non zero.
  !>     @param[in]
  !>     beta      device pointer or host pointer to scalar beta
  !>     @param[out]
  !>     y         Device pointer to the first vector y_1 on the GPU
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each vector y_i
  !>     @param[in]
  !>     stridey     [hipblasStride]
  !>                 stride from the start of one vector (y_i) and the next one (y_i+1).
  !>                 There are no restrictions placed on stridey, however the user should
  !>                 take care to ensure that stridey is of appropriate size.
  !>                 This typically means stridey >= n  incy. stridey should be non zero.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface hipblasSsymvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsymvStridedBatched_(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasSsymvStridedBatched")
#else
    function hipblasSsymvStridedBatched_(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasSsymvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_float) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSsymvStridedBatched_rank_0,&
      
hipblasSsymvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDsymvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsymvStridedBatched_(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasDsymvStridedBatched")
#else
    function hipblasDsymvStridedBatched_(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasDsymvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      real(c_double) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDsymvStridedBatched_rank_0,&
      
hipblasDsymvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCsymvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsymvStridedBatched_(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasCsymvStridedBatched")
#else
    function hipblasCsymvStridedBatched_(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasCsymvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsymvStridedBatched_rank_0,&
      
hipblasCsymvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZsymvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsymvStridedBatched_(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasZsymvStridedBatched")
#else
    function hipblasZsymvStridedBatched_(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasZsymvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZsymvStridedBatched_rank_0,&
      
hipblasZsymvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCsymvStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsymvStridedBatched_v2_(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasCsymvStridedBatched_v2")
#else
    function hipblasCsymvStridedBatched_v2_(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasCsymvStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymvStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_float_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsymvStridedBatched_v2_rank_0,&
      
hipblasCsymvStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZsymvStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZsymvStridedBatched_v2_(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="cublasZsymvStridedBatched_v2")
#else
    function hipblasZsymvStridedBatched_v2_(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount) bind(c, name="hipblasZsymvStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymvStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      complex(c_double_complex) :: beta
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZsymvStridedBatched_v2_rank_0,&
      
hipblasZsymvStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     syr performs the matrix-vector operations
  !> 
  !>         A := A + alphaxxT
  !> 
  !>     where alpha is a scalar, x is a vector, and A is an
  !>     n by n symmetric matrix.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !> 
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of matrix A.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[inout]
  !>     AP         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A.
  !> 
  !>     
  interface hipblasSsyr
#ifdef USE_CUDA_NAMES
    function hipblasSsyr_(handle,uplo,n,alpha,x,incx,AP,lda) bind(c, name="cublasSsyr_v2")
#else
    function hipblasSsyr_(handle,uplo,n,alpha,x,incx,AP,lda) bind(c, name="hipblasSsyr")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSsyr_rank_0,&
      
hipblasSsyr_rank_1
#endif

  end interface
  
  interface hipblasDsyr
#ifdef USE_CUDA_NAMES
    function hipblasDsyr_(handle,uplo,n,alpha,x,incx,AP,lda) bind(c, name="cublasDsyr_v2")
#else
    function hipblasDsyr_(handle,uplo,n,alpha,x,incx,AP,lda) bind(c, name="hipblasDsyr")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDsyr_rank_0,&
      
hipblasDsyr_rank_1
#endif

  end interface
  
  interface hipblasCsyr
#ifdef USE_CUDA_NAMES
    function hipblasCsyr_(handle,uplo,n,alpha,x,incx,AP,lda) bind(c, name="cublasCsyr_v2")
#else
    function hipblasCsyr_(handle,uplo,n,alpha,x,incx,AP,lda) bind(c, name="hipblasCsyr")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsyr_rank_0,&
      
hipblasCsyr_rank_1
#endif

  end interface
  
  interface hipblasZsyr
#ifdef USE_CUDA_NAMES
    function hipblasZsyr_(handle,uplo,n,alpha,x,incx,AP,lda) bind(c, name="cublasZsyr_v2")
#else
    function hipblasZsyr_(handle,uplo,n,alpha,x,incx,AP,lda) bind(c, name="hipblasZsyr")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZsyr_rank_0,&
      
hipblasZsyr_rank_1
#endif

  end interface
  
  interface hipblasCsyr_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsyr_v2_(handle,uplo,n,alpha,x,incx,AP,lda) bind(c, name="cublasCsyr_v2")
#else
    function hipblasCsyr_v2_(handle,uplo,n,alpha,x,incx,AP,lda) bind(c, name="hipblasCsyr_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsyr_v2_rank_0,&
      
hipblasCsyr_v2_rank_1
#endif

  end interface
  
  interface hipblasZsyr_v2
#ifdef USE_CUDA_NAMES
    function hipblasZsyr_v2_(handle,uplo,n,alpha,x,incx,AP,lda) bind(c, name="cublasZsyr_v2")
#else
    function hipblasZsyr_v2_(handle,uplo,n,alpha,x,incx,AP,lda) bind(c, name="hipblasZsyr_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZsyr_v2_rank_0,&
      
hipblasZsyr_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     syrBatched performs a batch of matrix-vector operations
  !> 
  !>         A[i] := A[i] + alphax[i]x[i]T
  !> 
  !>     where alpha is a scalar, x is an array of vectors, and A is an array of
  !>     n by n symmetric matrices, for i = 1 , ... , batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of matrix A.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[inout]
  !>     AP         device array of device pointers storing each matrix A_i.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface hipblasSsyrBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsyrBatched_(handle,uplo,n,alpha,x,incx,AP,lda,batchCount) bind(c, name="cublasSsyrBatched")
#else
    function hipblasSsyrBatched_(handle,uplo,n,alpha,x,incx,AP,lda,batchCount) bind(c, name="hipblasSsyrBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSsyrBatched_full_rank,&
      
hipblasSsyrBatched_rank_0,&
      
hipblasSsyrBatched_rank_1
#endif

  end interface
  
  interface hipblasDsyrBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsyrBatched_(handle,uplo,n,alpha,x,incx,AP,lda,batchCount) bind(c, name="cublasDsyrBatched")
#else
    function hipblasDsyrBatched_(handle,uplo,n,alpha,x,incx,AP,lda,batchCount) bind(c, name="hipblasDsyrBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDsyrBatched_full_rank,&
      
hipblasDsyrBatched_rank_0,&
      
hipblasDsyrBatched_rank_1
#endif

  end interface
  
  interface hipblasCsyrBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsyrBatched_(handle,uplo,n,alpha,x,incx,AP,lda,batchCount) bind(c, name="cublasCsyrBatched")
#else
    function hipblasCsyrBatched_(handle,uplo,n,alpha,x,incx,AP,lda,batchCount) bind(c, name="hipblasCsyrBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsyrBatched_full_rank,&
      
hipblasCsyrBatched_rank_0,&
      
hipblasCsyrBatched_rank_1
#endif

  end interface
  
  interface hipblasZsyrBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsyrBatched_(handle,uplo,n,alpha,x,incx,AP,lda,batchCount) bind(c, name="cublasZsyrBatched")
#else
    function hipblasZsyrBatched_(handle,uplo,n,alpha,x,incx,AP,lda,batchCount) bind(c, name="hipblasZsyrBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZsyrBatched_full_rank,&
      
hipblasZsyrBatched_rank_0,&
      
hipblasZsyrBatched_rank_1
#endif

  end interface
  
  interface hipblasCsyrBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsyrBatched_v2_(handle,uplo,n,alpha,x,incx,AP,lda,batchCount) bind(c, name="cublasCsyrBatched_v2")
#else
    function hipblasCsyrBatched_v2_(handle,uplo,n,alpha,x,incx,AP,lda,batchCount) bind(c, name="hipblasCsyrBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsyrBatched_v2_full_rank,&
      
hipblasCsyrBatched_v2_rank_0,&
      
hipblasCsyrBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZsyrBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZsyrBatched_v2_(handle,uplo,n,alpha,x,incx,AP,lda,batchCount) bind(c, name="cublasZsyrBatched_v2")
#else
    function hipblasZsyrBatched_v2_(handle,uplo,n,alpha,x,incx,AP,lda,batchCount) bind(c, name="hipblasZsyrBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZsyrBatched_v2_full_rank,&
      
hipblasZsyrBatched_v2_rank_0,&
      
hipblasZsyrBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     syrStridedBatched performs the matrix-vector operations
  !> 
  !>         A[i] := A[i] + alphax[i]x[i]T
  !> 
  !>     where alpha is a scalar, vectors, and A is an array of
  !>     n by n symmetric matrices, for i = 1 , ... , batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of each matrix A.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex   [hipblasStride]
  !>               specifies the pointer increment between vectors (x_i) and (x_i+1).
  !>     @param[inout]
  !>     AP         device pointer to the first matrix A_1.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     strideA   [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     batchCount [int]
  !>               number of instances in the batch
  !> 
  !>     
  interface hipblasSsyrStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsyrStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount) bind(c, name="cublasSsyrStridedBatched")
#else
    function hipblasSsyrStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount) bind(c, name="hipblasSsyrStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSsyrStridedBatched_rank_0,&
      
hipblasSsyrStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDsyrStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsyrStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount) bind(c, name="cublasDsyrStridedBatched")
#else
    function hipblasDsyrStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount) bind(c, name="hipblasDsyrStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDsyrStridedBatched_rank_0,&
      
hipblasDsyrStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCsyrStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsyrStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount) bind(c, name="cublasCsyrStridedBatched")
#else
    function hipblasCsyrStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount) bind(c, name="hipblasCsyrStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsyrStridedBatched_rank_0,&
      
hipblasCsyrStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZsyrStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsyrStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount) bind(c, name="cublasZsyrStridedBatched")
#else
    function hipblasZsyrStridedBatched_(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount) bind(c, name="hipblasZsyrStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZsyrStridedBatched_rank_0,&
      
hipblasZsyrStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCsyrStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsyrStridedBatched_v2_(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount) bind(c, name="cublasCsyrStridedBatched_v2")
#else
    function hipblasCsyrStridedBatched_v2_(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount) bind(c, name="hipblasCsyrStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsyrStridedBatched_v2_rank_0,&
      
hipblasCsyrStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZsyrStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZsyrStridedBatched_v2_(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount) bind(c, name="cublasZsyrStridedBatched_v2")
#else
    function hipblasZsyrStridedBatched_v2_(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount) bind(c, name="hipblasZsyrStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZsyrStridedBatched_v2_rank_0,&
      
hipblasZsyrStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     syr2 performs the matrix-vector operations
  !> 
  !>         A := A + alphaxyT + alphayxT
  !> 
  !>     where alpha is a scalar, x and y are vectors, and A is an
  !>     n by n symmetric matrix.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !> 
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of matrix A.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     AP         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A.
  !> 
  !>     
  interface hipblasSsyr2
#ifdef USE_CUDA_NAMES
    function hipblasSsyr2_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="cublasSsyr2_v2")
#else
    function hipblasSsyr2_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="hipblasSsyr2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSsyr2_rank_0,&
      
hipblasSsyr2_rank_1
#endif

  end interface
  
  interface hipblasDsyr2
#ifdef USE_CUDA_NAMES
    function hipblasDsyr2_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="cublasDsyr2_v2")
#else
    function hipblasDsyr2_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="hipblasDsyr2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDsyr2_rank_0,&
      
hipblasDsyr2_rank_1
#endif

  end interface
  
  interface hipblasCsyr2
#ifdef USE_CUDA_NAMES
    function hipblasCsyr2_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="cublasCsyr2_v2")
#else
    function hipblasCsyr2_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="hipblasCsyr2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsyr2_rank_0,&
      
hipblasCsyr2_rank_1
#endif

  end interface
  
  interface hipblasZsyr2
#ifdef USE_CUDA_NAMES
    function hipblasZsyr2_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="cublasZsyr2_v2")
#else
    function hipblasZsyr2_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="hipblasZsyr2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZsyr2_rank_0,&
      
hipblasZsyr2_rank_1
#endif

  end interface
  
  interface hipblasCsyr2_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsyr2_v2_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="cublasCsyr2_v2")
#else
    function hipblasCsyr2_v2_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="hipblasCsyr2_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsyr2_v2_rank_0,&
      
hipblasCsyr2_v2_rank_1
#endif

  end interface
  
  interface hipblasZsyr2_v2
#ifdef USE_CUDA_NAMES
    function hipblasZsyr2_v2_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="cublasZsyr2_v2")
#else
    function hipblasZsyr2_v2_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda) bind(c, name="hipblasZsyr2_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZsyr2_v2_rank_0,&
      
hipblasZsyr2_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     syr2Batched performs a batch of matrix-vector operations
  !> 
  !>         A[i] := A[i] + alphax[i]y[i]T + alphay[i]x[i]T
  !> 
  !>     where alpha is a scalar, x[i] and y[i] are vectors, and A[i] is a
  !>     n by n symmetric matrix, for i = 1 , ... , batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of matrix A.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[inout]
  !>     AP         device array of device pointers storing each matrix A_i.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface hipblasSsyr2Batched
#ifdef USE_CUDA_NAMES
    function hipblasSsyr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="cublasSsyr2Batched")
#else
    function hipblasSsyr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="hipblasSsyr2Batched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2Batched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSsyr2Batched_full_rank,&
      
hipblasSsyr2Batched_rank_0,&
      
hipblasSsyr2Batched_rank_1
#endif

  end interface
  
  interface hipblasDsyr2Batched
#ifdef USE_CUDA_NAMES
    function hipblasDsyr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="cublasDsyr2Batched")
#else
    function hipblasDsyr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="hipblasDsyr2Batched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2Batched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDsyr2Batched_full_rank,&
      
hipblasDsyr2Batched_rank_0,&
      
hipblasDsyr2Batched_rank_1
#endif

  end interface
  
  interface hipblasCsyr2Batched
#ifdef USE_CUDA_NAMES
    function hipblasCsyr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="cublasCsyr2Batched")
#else
    function hipblasCsyr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="hipblasCsyr2Batched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2Batched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsyr2Batched_full_rank,&
      
hipblasCsyr2Batched_rank_0,&
      
hipblasCsyr2Batched_rank_1
#endif

  end interface
  
  interface hipblasZsyr2Batched
#ifdef USE_CUDA_NAMES
    function hipblasZsyr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="cublasZsyr2Batched")
#else
    function hipblasZsyr2Batched_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="hipblasZsyr2Batched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2Batched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZsyr2Batched_full_rank,&
      
hipblasZsyr2Batched_rank_0,&
      
hipblasZsyr2Batched_rank_1
#endif

  end interface
  
  interface hipblasCsyr2Batched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsyr2Batched_v2_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="cublasCsyr2Batched_v2")
#else
    function hipblasCsyr2Batched_v2_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="hipblasCsyr2Batched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2Batched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsyr2Batched_v2_full_rank,&
      
hipblasCsyr2Batched_v2_rank_0,&
      
hipblasCsyr2Batched_v2_rank_1
#endif

  end interface
  
  interface hipblasZsyr2Batched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZsyr2Batched_v2_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="cublasZsyr2Batched_v2")
#else
    function hipblasZsyr2Batched_v2_(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount) bind(c, name="hipblasZsyr2Batched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2Batched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: y
      integer(c_int),value :: incy
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZsyr2Batched_v2_full_rank,&
      
hipblasZsyr2Batched_v2_rank_0,&
      
hipblasZsyr2Batched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     syr2StridedBatched the matrix-vector operations
  !> 
  !>         A[i] := A[i] + alphax[i]y[i]T + alphay[i]x[i]T
  !> 
  !>     where alpha is a scalar, x[i] and y[i] are vectors, and A[i] is a
  !>     n by n symmetric matrices, for i = 1 , ... , batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of each matrix A.
  !>     @param[in]
  !>     alpha
  !>               device pointer or host pointer to scalar alpha.
  !>     @param[in]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex   [hipblasStride]
  !>               specifies the pointer increment between vectors (x_i) and (x_i+1).
  !>     @param[in]
  !>     y         device pointer to the first vector y_1.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     stridey   [hipblasStride]
  !>               specifies the pointer increment between vectors (y_i) and (y_i+1).
  !>     @param[inout]
  !>     AP         device pointer to the first matrix A_1.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     strideA   [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     batchCount [int]
  !>               number of instances in the batch
  !> 
  !>     
  interface hipblasSsyr2StridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsyr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="cublasSsyr2StridedBatched")
#else
    function hipblasSsyr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="hipblasSsyr2StridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2StridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSsyr2StridedBatched_rank_0,&
      
hipblasSsyr2StridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDsyr2StridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsyr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="cublasDsyr2StridedBatched")
#else
    function hipblasDsyr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="hipblasDsyr2StridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2StridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDsyr2StridedBatched_rank_0,&
      
hipblasDsyr2StridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCsyr2StridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsyr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="cublasCsyr2StridedBatched")
#else
    function hipblasCsyr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="hipblasCsyr2StridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2StridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsyr2StridedBatched_rank_0,&
      
hipblasCsyr2StridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZsyr2StridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsyr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="cublasZsyr2StridedBatched")
#else
    function hipblasZsyr2StridedBatched_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="hipblasZsyr2StridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2StridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZsyr2StridedBatched_rank_0,&
      
hipblasZsyr2StridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCsyr2StridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsyr2StridedBatched_v2_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="cublasCsyr2StridedBatched_v2")
#else
    function hipblasCsyr2StridedBatched_v2_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="hipblasCsyr2StridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2StridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCsyr2StridedBatched_v2_rank_0,&
      
hipblasCsyr2StridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZsyr2StridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZsyr2StridedBatched_v2_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="cublasZsyr2StridedBatched_v2")
#else
    function hipblasZsyr2StridedBatched_v2_(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount) bind(c, name="hipblasZsyr2StridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2StridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZsyr2StridedBatched_v2_rank_0,&
      
hipblasZsyr2StridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tbmv performs one of the matrix-vector operations
  !> 
  !>         x := Ax      or
  !>         x := ATx   or
  !>         x := AHx,
  !> 
  !>     x is a vectors and A is a banded n by n matrix (see description below).
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               HIPBLAS_FILL_MODE_UPPER: A is an upper banded triangular matrix.
  !>               HIPBLAS_FILL_MODE_LOWER: A is a  lower banded triangular matrix.
  !>     @param[in]
  !>     transA     [hipblasOperation_t]
  !>               indicates whether matrix A is tranposed (conjugated) or not.
  !>     @param[in]
  !>     diag      [hipblasDiagType_t]
  !>               HIPBLAS_DIAG_UNIT: The main diagonal of A is assumed to consist of only
  !>                                      1's and is not referenced.
  !>               HIPBLAS_DIAG_NON_UNIT: No assumptions are made of A's main diagonal.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of the matrix represented by A.
  !>     @param[in]
  !>     k         [int]
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER, k specifies the number of super-diagonals
  !>               of the matrix A.
  !>               if uplo == HIPBLAS_FILL_MODE_LOWER, k specifies the number of sub-diagonals
  !>               of the matrix A.
  !>               k must satisfy k > 0 && k < lda.
  !>     @param[in]
  !>     AP         device pointer storing banded triangular matrix A.
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The matrix represented is an upper banded triangular matrix
  !>                 with the main diagonal and k super-diagonals, everything
  !>                 else can be assumed to be 0.
  !>                 The matrix is compacted so that the main diagonal resides on the k'th
  !>                 row, the first super diagonal resides on the RHS of the k-1'th row, etc,
  !>                 with the k'th diagonal on the RHS of the 0'th row.
  !>                    Ex: (HIPBLAS_FILL_MODE_UPPER; n = 5; k = 2)
  !>                       1 6 9 0 0              0 0 9 8 7
  !>                       0 2 7 8 0              0 6 7 8 9
  !>                       0 0 3 8 7     ---->    1 2 3 4 5
  !>                       0 0 0 4 9              0 0 0 0 0
  !>                       0 0 0 0 5              0 0 0 0 0
  !>               if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The matrix represnted is a lower banded triangular matrix
  !>                 with the main diagonal and k sub-diagonals, everything else can be
  !>                 assumed to be 0.
  !>                 The matrix is compacted so that the main diagonal resides on the 0'th row,
  !>                 working up to the k'th diagonal residing on the LHS of the k'th row.
  !>                    Ex: (HIPBLAS_FILL_MODE_LOWER; n = 5; k = 2)
  !>                       1 0 0 0 0              1 2 3 4 5
  !>                       6 2 0 0 0              6 7 8 9 0
  !>                       9 7 3 0 0     ---->    9 8 7 0 0
  !>                       0 8 8 4 0              0 0 0 0 0
  !>                       0 0 7 9 5              0 0 0 0 0
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A. lda must satisfy lda > k.
  !>     @param[inout]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !> 
  !>     
  interface hipblasStbmv
#ifdef USE_CUDA_NAMES
    function hipblasStbmv_(handle,uplo,transA,diag,n,k,AP,lda,x,incx) bind(c, name="cublasStbmv_v2")
#else
    function hipblasStbmv_(handle,uplo,transA,diag,n,k,AP,lda,x,incx) bind(c, name="hipblasStbmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasStbmv_rank_0,&
      
hipblasStbmv_rank_1
#endif

  end interface
  
  interface hipblasDtbmv
#ifdef USE_CUDA_NAMES
    function hipblasDtbmv_(handle,uplo,transA,diag,n,k,AP,lda,x,incx) bind(c, name="cublasDtbmv_v2")
#else
    function hipblasDtbmv_(handle,uplo,transA,diag,n,k,AP,lda,x,incx) bind(c, name="hipblasDtbmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDtbmv_rank_0,&
      
hipblasDtbmv_rank_1
#endif

  end interface
  
  interface hipblasCtbmv
#ifdef USE_CUDA_NAMES
    function hipblasCtbmv_(handle,uplo,transA,diag,n,k,AP,lda,x,incx) bind(c, name="cublasCtbmv_v2")
#else
    function hipblasCtbmv_(handle,uplo,transA,diag,n,k,AP,lda,x,incx) bind(c, name="hipblasCtbmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtbmv_rank_0,&
      
hipblasCtbmv_rank_1
#endif

  end interface
  
  interface hipblasZtbmv
#ifdef USE_CUDA_NAMES
    function hipblasZtbmv_(handle,uplo,transA,diag,n,k,AP,lda,x,incx) bind(c, name="cublasZtbmv_v2")
#else
    function hipblasZtbmv_(handle,uplo,transA,diag,n,k,AP,lda,x,incx) bind(c, name="hipblasZtbmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtbmv_rank_0,&
      
hipblasZtbmv_rank_1
#endif

  end interface
  
  interface hipblasCtbmv_v2
#ifdef USE_CUDA_NAMES
    function hipblasCtbmv_v2_(handle,uplo,transA,diag,n,k,AP,lda,x,incx) bind(c, name="cublasCtbmv_v2")
#else
    function hipblasCtbmv_v2_(handle,uplo,transA,diag,n,k,AP,lda,x,incx) bind(c, name="hipblasCtbmv_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmv_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtbmv_v2_rank_0,&
      
hipblasCtbmv_v2_rank_1
#endif

  end interface
  
  interface hipblasZtbmv_v2
#ifdef USE_CUDA_NAMES
    function hipblasZtbmv_v2_(handle,uplo,transA,diag,n,k,AP,lda,x,incx) bind(c, name="cublasZtbmv_v2")
#else
    function hipblasZtbmv_v2_(handle,uplo,transA,diag,n,k,AP,lda,x,incx) bind(c, name="hipblasZtbmv_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmv_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtbmv_v2_rank_0,&
      
hipblasZtbmv_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tbmvBatched performs one of the matrix-vector operations
  !> 
  !>         x_i := A_ix_i      or
  !>         x_i := A_iTx_i   or
  !>         x_i := A_iHx_i,
  !> 
  !>     where (A_i, x_i) is the i-th instance of the batch.
  !>     x_i is a vector and A_i is an n by n matrix, for i = 1, ..., batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               HIPBLAS_FILL_MODE_UPPER: each A_i is an upper banded triangular matrix.
  !>               HIPBLAS_FILL_MODE_LOWER: each A_i is a  lower banded triangular matrix.
  !>     @param[in]
  !>     transA     [hipblasOperation_t]
  !>               indicates whether each matrix A_i is tranposed (conjugated) or not.
  !>     @param[in]
  !>     diag      [hipblasDiagType_t]
  !>               HIPBLAS_DIAG_UNIT: The main diagonal of each A_i is assumed to consist of only
  !>                                      1's and is not referenced.
  !>               HIPBLAS_DIAG_NON_UNIT: No assumptions are made of each A_i's main diagonal.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of the matrix represented by each A_i.
  !>     @param[in]
  !>     k         [int]
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER, k specifies the number of super-diagonals
  !>               of each matrix A_i.
  !>               if uplo == HIPBLAS_FILL_MODE_LOWER, k specifies the number of sub-diagonals
  !>               of each matrix A_i.
  !>               k must satisfy k > 0 && k < lda.
  !>     @param[in]
  !>     AP         device array of device pointers storing each banded triangular matrix A_i.
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The matrix represented is an upper banded triangular matrix
  !>                 with the main diagonal and k super-diagonals, everything
  !>                 else can be assumed to be 0.
  !>                 The matrix is compacted so that the main diagonal resides on the k'th
  !>                 row, the first super diagonal resides on the RHS of the k-1'th row, etc,
  !>                 with the k'th diagonal on the RHS of the 0'th row.
  !>                    Ex: (HIPBLAS_FILL_MODE_UPPER; n = 5; k = 2)
  !>                       1 6 9 0 0              0 0 9 8 7
  !>                       0 2 7 8 0              0 6 7 8 9
  !>                       0 0 3 8 7     ---->    1 2 3 4 5
  !>                       0 0 0 4 9              0 0 0 0 0
  !>                       0 0 0 0 5              0 0 0 0 0
  !>               if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The matrix represnted is a lower banded triangular matrix
  !>                 with the main diagonal and k sub-diagonals, everything else can be
  !>                 assumed to be 0.
  !>                 The matrix is compacted so that the main diagonal resides on the 0'th row,
  !>                 working up to the k'th diagonal residing on the LHS of the k'th row.
  !>                    Ex: (HIPBLAS_FILL_MODE_LOWER; n = 5; k = 2)
  !>                       1 0 0 0 0              1 2 3 4 5
  !>                       6 2 0 0 0              6 7 8 9 0
  !>                       9 7 3 0 0     ---->    9 8 7 0 0
  !>                       0 8 8 4 0              0 0 0 0 0
  !>                       0 0 7 9 5              0 0 0 0 0
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i. lda must satisfy lda > k.
  !>     @param[inout]
  !>     x         device array of device pointer storing each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface hipblasStbmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasStbmvBatched_(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount) bind(c, name="cublasStbmvBatched")
#else
    function hipblasStbmvBatched_(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount) bind(c, name="hipblasStbmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasStbmvBatched_full_rank,&
      
hipblasStbmvBatched_rank_0,&
      
hipblasStbmvBatched_rank_1
#endif

  end interface
  
  interface hipblasDtbmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtbmvBatched_(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount) bind(c, name="cublasDtbmvBatched")
#else
    function hipblasDtbmvBatched_(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount) bind(c, name="hipblasDtbmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDtbmvBatched_full_rank,&
      
hipblasDtbmvBatched_rank_0,&
      
hipblasDtbmvBatched_rank_1
#endif

  end interface
  
  interface hipblasCtbmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtbmvBatched_(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount) bind(c, name="cublasCtbmvBatched")
#else
    function hipblasCtbmvBatched_(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount) bind(c, name="hipblasCtbmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtbmvBatched_full_rank,&
      
hipblasCtbmvBatched_rank_0,&
      
hipblasCtbmvBatched_rank_1
#endif

  end interface
  
  interface hipblasZtbmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtbmvBatched_(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount) bind(c, name="cublasZtbmvBatched")
#else
    function hipblasZtbmvBatched_(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount) bind(c, name="hipblasZtbmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtbmvBatched_full_rank,&
      
hipblasZtbmvBatched_rank_0,&
      
hipblasZtbmvBatched_rank_1
#endif

  end interface
  
  interface hipblasCtbmvBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCtbmvBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount) bind(c, name="cublasCtbmvBatched_v2")
#else
    function hipblasCtbmvBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount) bind(c, name="hipblasCtbmvBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmvBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtbmvBatched_v2_full_rank,&
      
hipblasCtbmvBatched_v2_rank_0,&
      
hipblasCtbmvBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZtbmvBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZtbmvBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount) bind(c, name="cublasZtbmvBatched_v2")
#else
    function hipblasZtbmvBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount) bind(c, name="hipblasZtbmvBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmvBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtbmvBatched_v2_full_rank,&
      
hipblasZtbmvBatched_v2_rank_0,&
      
hipblasZtbmvBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tbmvStridedBatched performs one of the matrix-vector operations
  !> 
  !>         x_i := A_ix_i      or
  !>         x_i := A_iTx_i   or
  !>         x_i := A_iHx_i,
  !> 
  !>     where (A_i, x_i) is the i-th instance of the batch.
  !>     x_i is a vector and A_i is an n by n matrix, for i = 1, ..., batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               HIPBLAS_FILL_MODE_UPPER: each A_i is an upper banded triangular matrix.
  !>               HIPBLAS_FILL_MODE_LOWER: each A_i is a  lower banded triangular matrix.
  !>     @param[in]
  !>     transA     [hipblasOperation_t]
  !>               indicates whether each matrix A_i is tranposed (conjugated) or not.
  !>     @param[in]
  !>     diag      [hipblasDiagType_t]
  !>               HIPBLAS_DIAG_UNIT: The main diagonal of each A_i is assumed to consist of only
  !>                                      1's and is not referenced.
  !>               HIPBLAS_DIAG_NON_UNIT: No assumptions are made of each A_i's main diagonal.
  !>     @param[in]
  !>     n         [int]
  !>               the number of rows and columns of the matrix represented by each A_i.
  !>     @param[in]
  !>     k         [int]
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER, k specifies the number of super-diagonals
  !>               of each matrix A_i.
  !>               if uplo == HIPBLAS_FILL_MODE_LOWER, k specifies the number of sub-diagonals
  !>               of each matrix A_i.
  !>               k must satisfy k > 0 && k < lda.
  !>     @param[in]
  !>     AP         device array to the first matrix A_i of the batch. Stores each banded triangular matrix A_i.
  !>               if uplo == HIPBLAS_FILL_MODE_UPPER:
  !>                 The matrix represented is an upper banded triangular matrix
  !>                 with the main diagonal and k super-diagonals, everything
  !>                 else can be assumed to be 0.
  !>                 The matrix is compacted so that the main diagonal resides on the k'th
  !>                 row, the first super diagonal resides on the RHS of the k-1'th row, etc,
  !>                 with the k'th diagonal on the RHS of the 0'th row.
  !>                    Ex: (HIPBLAS_FILL_MODE_UPPER; n = 5; k = 2)
  !>                       1 6 9 0 0              0 0 9 8 7
  !>                       0 2 7 8 0              0 6 7 8 9
  !>                       0 0 3 8 7     ---->    1 2 3 4 5
  !>                       0 0 0 4 9              0 0 0 0 0
  !>                       0 0 0 0 5              0 0 0 0 0
  !>               if uplo == HIPBLAS_FILL_MODE_LOWER:
  !>                 The matrix represnted is a lower banded triangular matrix
  !>                 with the main diagonal and k sub-diagonals, everything else can be
  !>                 assumed to be 0.
  !>                 The matrix is compacted so that the main diagonal resides on the 0'th row,
  !>                 working up to the k'th diagonal residing on the LHS of the k'th row.
  !>                    Ex: (HIPBLAS_FILL_MODE_LOWER; n = 5; k = 2)
  !>                       1 0 0 0 0              1 2 3 4 5
  !>                       6 2 0 0 0              6 7 8 9 0
  !>                       9 7 3 0 0     ---->    9 8 7 0 0
  !>                       0 8 8 4 0              0 0 0 0 0
  !>                       0 0 7 9 5              0 0 0 0 0
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i. lda must satisfy lda > k.
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one A_i matrix to the next A_(i + 1).
  !>     @param[inout]
  !>     x         device array to the first vector x_i of the batch.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               stride from the start of one x_i matrix to the next x_(i + 1).
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface hipblasStbmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasStbmvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasStbmvStridedBatched")
#else
    function hipblasStbmvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasStbmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasStbmvStridedBatched_rank_0,&
      
hipblasStbmvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDtbmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtbmvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasDtbmvStridedBatched")
#else
    function hipblasDtbmvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasDtbmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDtbmvStridedBatched_rank_0,&
      
hipblasDtbmvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCtbmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtbmvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasCtbmvStridedBatched")
#else
    function hipblasCtbmvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasCtbmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtbmvStridedBatched_rank_0,&
      
hipblasCtbmvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZtbmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtbmvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasZtbmvStridedBatched")
#else
    function hipblasZtbmvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasZtbmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtbmvStridedBatched_rank_0,&
      
hipblasZtbmvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCtbmvStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCtbmvStridedBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasCtbmvStridedBatched_v2")
#else
    function hipblasCtbmvStridedBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasCtbmvStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmvStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtbmvStridedBatched_v2_rank_0,&
      
hipblasCtbmvStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZtbmvStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZtbmvStridedBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasZtbmvStridedBatched_v2")
#else
    function hipblasZtbmvStridedBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasZtbmvStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmvStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtbmvStridedBatched_v2_rank_0,&
      
hipblasZtbmvStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tbsv solves
  !> 
  !>          Ax = b or ATx = b or AHx = b,
  !> 
  !>     where x and b are vectors and A is a banded triangular matrix.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [hipblasOperation_t]
  !>                HIPBLAS_OP_N: Solves Ax = b
  !>                HIPBLAS_OP_T: Solves ATx = b
  !>                HIPBLAS_OP_C: Solves AHx = b
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular (i.e. the diagonal elements
  !>                                        of A are not used in computations).
  !>             HIPBLAS_DIAG_NON_UNIT: A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [int]
  !>               n specifies the number of rows of b. n >= 0.
  !>     @param[in]
  !>     k         [int]
  !>               if(uplo == HIPBLAS_FILL_MODE_UPPER)
  !>                 k specifies the number of super-diagonals of A.
  !>               if(uplo == HIPBLAS_FILL_MODE_LOWER)
  !>                 k specifies the number of sub-diagonals of A.
  !>               k >= 0.
  !> 
  !>     @param[in]
  !>     AP         device pointer storing the matrix A in banded format.
  !> 
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A.
  !>               lda >= (k + 1).
  !> 
  !>     @param[inout]
  !>     x         device pointer storing input vector b. Overwritten by the output vector x.
  !> 
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !> 
  !>     
  interface hipblasStbsv
#ifdef USE_CUDA_NAMES
    function hipblasStbsv_(handle,uplo,transA,diag,n,k,AP,lda,x,incx) bind(c, name="cublasStbsv_v2")
#else
    function hipblasStbsv_(handle,uplo,transA,diag,n,k,AP,lda,x,incx) bind(c, name="hipblasStbsv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbsv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasStbsv_rank_0,&
      
hipblasStbsv_rank_1
#endif

  end interface
  
  interface hipblasDtbsv
#ifdef USE_CUDA_NAMES
    function hipblasDtbsv_(handle,uplo,transA,diag,n,k,AP,lda,x,incx) bind(c, name="cublasDtbsv_v2")
#else
    function hipblasDtbsv_(handle,uplo,transA,diag,n,k,AP,lda,x,incx) bind(c, name="hipblasDtbsv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbsv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDtbsv_rank_0,&
      
hipblasDtbsv_rank_1
#endif

  end interface
  
  interface hipblasCtbsv
#ifdef USE_CUDA_NAMES
    function hipblasCtbsv_(handle,uplo,transA,diag,n,k,AP,lda,x,incx) bind(c, name="cublasCtbsv_v2")
#else
    function hipblasCtbsv_(handle,uplo,transA,diag,n,k,AP,lda,x,incx) bind(c, name="hipblasCtbsv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtbsv_rank_0,&
      
hipblasCtbsv_rank_1
#endif

  end interface
  
  interface hipblasZtbsv
#ifdef USE_CUDA_NAMES
    function hipblasZtbsv_(handle,uplo,transA,diag,n,k,AP,lda,x,incx) bind(c, name="cublasZtbsv_v2")
#else
    function hipblasZtbsv_(handle,uplo,transA,diag,n,k,AP,lda,x,incx) bind(c, name="hipblasZtbsv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtbsv_rank_0,&
      
hipblasZtbsv_rank_1
#endif

  end interface
  
  interface hipblasCtbsv_v2
#ifdef USE_CUDA_NAMES
    function hipblasCtbsv_v2_(handle,uplo,transA,diag,n,k,AP,lda,x,incx) bind(c, name="cublasCtbsv_v2")
#else
    function hipblasCtbsv_v2_(handle,uplo,transA,diag,n,k,AP,lda,x,incx) bind(c, name="hipblasCtbsv_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsv_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtbsv_v2_rank_0,&
      
hipblasCtbsv_v2_rank_1
#endif

  end interface
  
  interface hipblasZtbsv_v2
#ifdef USE_CUDA_NAMES
    function hipblasZtbsv_v2_(handle,uplo,transA,diag,n,k,AP,lda,x,incx) bind(c, name="cublasZtbsv_v2")
#else
    function hipblasZtbsv_v2_(handle,uplo,transA,diag,n,k,AP,lda,x,incx) bind(c, name="hipblasZtbsv_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsv_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtbsv_v2_rank_0,&
      
hipblasZtbsv_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tbsvBatched solves
  !> 
  !>          A_ix_i = b_i or A_iTx_i = b_i or A_iHx_i = b_i,
  !> 
  !>     where x_i and b_i are vectors and A_i is a banded triangular matrix,
  !>     for i = [1, batchCount].
  !> 
  !>     The input vectors b_i are overwritten by the output vectors x_i.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [hipblasOperation_t]
  !>                HIPBLAS_OP_N: Solves A_ix_i = b_i
  !>                HIPBLAS_OP_T: Solves A_iTx_i = b_i
  !>                HIPBLAS_OP_C: Solves A_iHx_i = b_i
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular (i.e. the diagonal elements
  !>                                        of each A_i are not used in computations).
  !>             HIPBLAS_DIAG_NON_UNIT: each A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [int]
  !>               n specifies the number of rows of each b_i. n >= 0.
  !>     @param[in]
  !>     k         [int]
  !>               if(uplo == HIPBLAS_FILL_MODE_UPPER)
  !>                 k specifies the number of super-diagonals of each A_i.
  !>               if(uplo == HIPBLAS_FILL_MODE_LOWER)
  !>                 k specifies the number of sub-diagonals of each A_i.
  !>               k >= 0.
  !> 
  !>     @param[in]
  !>     AP         device vector of device pointers storing each matrix A_i in banded format.
  !> 
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i.
  !>               lda >= (k + 1).
  !> 
  !>     @param[inout]
  !>     x         device vector of device pointers storing each input vector b_i. Overwritten by each output
  !>               vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface hipblasStbsvBatched
#ifdef USE_CUDA_NAMES
    function hipblasStbsvBatched_(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount) bind(c, name="cublasStbsvBatched")
#else
    function hipblasStbsvBatched_(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount) bind(c, name="hipblasStbsvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbsvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasStbsvBatched_full_rank,&
      
hipblasStbsvBatched_rank_0,&
      
hipblasStbsvBatched_rank_1
#endif

  end interface
  
  interface hipblasDtbsvBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtbsvBatched_(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount) bind(c, name="cublasDtbsvBatched")
#else
    function hipblasDtbsvBatched_(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount) bind(c, name="hipblasDtbsvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbsvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDtbsvBatched_full_rank,&
      
hipblasDtbsvBatched_rank_0,&
      
hipblasDtbsvBatched_rank_1
#endif

  end interface
  
  interface hipblasCtbsvBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtbsvBatched_(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount) bind(c, name="cublasCtbsvBatched")
#else
    function hipblasCtbsvBatched_(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount) bind(c, name="hipblasCtbsvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtbsvBatched_full_rank,&
      
hipblasCtbsvBatched_rank_0,&
      
hipblasCtbsvBatched_rank_1
#endif

  end interface
  
  interface hipblasZtbsvBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtbsvBatched_(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount) bind(c, name="cublasZtbsvBatched")
#else
    function hipblasZtbsvBatched_(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount) bind(c, name="hipblasZtbsvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtbsvBatched_full_rank,&
      
hipblasZtbsvBatched_rank_0,&
      
hipblasZtbsvBatched_rank_1
#endif

  end interface
  
  interface hipblasCtbsvBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCtbsvBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount) bind(c, name="cublasCtbsvBatched_v2")
#else
    function hipblasCtbsvBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount) bind(c, name="hipblasCtbsvBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsvBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtbsvBatched_v2_full_rank,&
      
hipblasCtbsvBatched_v2_rank_0,&
      
hipblasCtbsvBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZtbsvBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZtbsvBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount) bind(c, name="cublasZtbsvBatched_v2")
#else
    function hipblasZtbsvBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount) bind(c, name="hipblasZtbsvBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsvBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtbsvBatched_v2_full_rank,&
      
hipblasZtbsvBatched_v2_rank_0,&
      
hipblasZtbsvBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tbsvStridedBatched solves
  !> 
  !>          A_ix_i = b_i or A_iTx_i = b_i or A_iHx_i = b_i,
  !> 
  !>     where x_i and b_i are vectors and A_i is a banded triangular matrix,
  !>     for i = [1, batchCount].
  !> 
  !>     The input vectors b_i are overwritten by the output vectors x_i.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [hipblasOperation_t]
  !>                HIPBLAS_OP_N: Solves A_ix_i = b_i
  !>                HIPBLAS_OP_T: Solves A_iTx_i = b_i
  !>                HIPBLAS_OP_C: Solves A_iHx_i = b_i
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular (i.e. the diagonal elements
  !>                                        of each A_i are not used in computations).
  !>             HIPBLAS_DIAG_NON_UNIT: each A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [int]
  !>               n specifies the number of rows of each b_i. n >= 0.
  !>     @param[in]
  !>     k         [int]
  !>               if(uplo == HIPBLAS_FILL_MODE_UPPER)
  !>                 k specifies the number of super-diagonals of each A_i.
  !>               if(uplo == HIPBLAS_FILL_MODE_LOWER)
  !>                 k specifies the number of sub-diagonals of each A_i.
  !>               k >= 0.
  !> 
  !>     @param[in]
  !>     AP         device pointer pointing to the first banded matrix A_1.
  !> 
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i.
  !>               lda >= (k + 1).
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               specifies the distance between the start of one matrix (A_i) and the next (A_i+1).
  !> 
  !>     @param[inout]
  !>     x         device pointer pointing to the first input vector b_1. Overwritten by output vectors x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               specifies the distance between the start of one vector (x_i) and the next (x_i+1).
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface hipblasStbsvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasStbsvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasStbsvStridedBatched")
#else
    function hipblasStbsvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasStbsvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbsvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasStbsvStridedBatched_rank_0,&
      
hipblasStbsvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDtbsvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtbsvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasDtbsvStridedBatched")
#else
    function hipblasDtbsvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasDtbsvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbsvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDtbsvStridedBatched_rank_0,&
      
hipblasDtbsvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCtbsvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtbsvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasCtbsvStridedBatched")
#else
    function hipblasCtbsvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasCtbsvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtbsvStridedBatched_rank_0,&
      
hipblasCtbsvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZtbsvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtbsvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasZtbsvStridedBatched")
#else
    function hipblasZtbsvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasZtbsvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtbsvStridedBatched_rank_0,&
      
hipblasZtbsvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCtbsvStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCtbsvStridedBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasCtbsvStridedBatched_v2")
#else
    function hipblasCtbsvStridedBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasCtbsvStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsvStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtbsvStridedBatched_v2_rank_0,&
      
hipblasCtbsvStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZtbsvStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZtbsvStridedBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasZtbsvStridedBatched_v2")
#else
    function hipblasZtbsvStridedBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasZtbsvStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsvStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtbsvStridedBatched_v2_rank_0,&
      
hipblasZtbsvStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tpmv performs one of the matrix-vector operations
  !> 
  !>          x = Ax or x = ATx,
  !> 
  !>     where x is an n element vector and A is an n by n unit, or non-unit, upper or lower triangular matrix, supplied in the pack form.
  !> 
  !>     The vector x is overwritten.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [hipblasOperation_t]
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows of A. n >= 0.
  !> 
  !>     @param[in]
  !>     AP       device pointer storing matrix A,
  !>             of dimension at least ( n  ( n + 1 )  2 ).
  !>           Before entry with uplo = HIPBLAS_FILL_MODE_UPPER, the array A
  !>           must contain the upper triangular matrix packed sequentially,
  !>           column by column, so that A[0] contains a_{0,0}, A[1] and A[2] contain
  !>           a_{0,1} and a_{1, 1} respectively, and so on.
  !>           Before entry with uplo = HIPBLAS_FILL_MODE_LOWER, the array A
  !>           must contain the lower triangular matrix packed sequentially,
  !>           column by column, so that A[0] contains a_{0,0}, A[1] and A[2] contain
  !>           a_{1,0} and a_{2,0} respectively, and so on.
  !>           Note that when DIAG = HIPBLAS_DIAG_UNIT, the diagonal elements of A are
  !>           not referenced, but are assumed to be unity.
  !> 
  !>     @param[in]
  !>     x       device pointer storing vector x.
  !> 
  !>     @param[in]
  !>     incx    [int]
  !>             specifies the increment for the elements of x. incx must not be zero.
  !> 
  !>     
  interface hipblasStpmv
#ifdef USE_CUDA_NAMES
    function hipblasStpmv_(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="cublasStpmv_v2")
#else
    function hipblasStpmv_(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="hipblasStpmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasStpmv_rank_0,&
      
hipblasStpmv_rank_1
#endif

  end interface
  
  interface hipblasDtpmv
#ifdef USE_CUDA_NAMES
    function hipblasDtpmv_(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="cublasDtpmv_v2")
#else
    function hipblasDtpmv_(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="hipblasDtpmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDtpmv_rank_0,&
      
hipblasDtpmv_rank_1
#endif

  end interface
  
  interface hipblasCtpmv
#ifdef USE_CUDA_NAMES
    function hipblasCtpmv_(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="cublasCtpmv_v2")
#else
    function hipblasCtpmv_(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="hipblasCtpmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtpmv_rank_0,&
      
hipblasCtpmv_rank_1
#endif

  end interface
  
  interface hipblasZtpmv
#ifdef USE_CUDA_NAMES
    function hipblasZtpmv_(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="cublasZtpmv_v2")
#else
    function hipblasZtpmv_(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="hipblasZtpmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtpmv_rank_0,&
      
hipblasZtpmv_rank_1
#endif

  end interface
  
  interface hipblasCtpmv_v2
#ifdef USE_CUDA_NAMES
    function hipblasCtpmv_v2_(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="cublasCtpmv_v2")
#else
    function hipblasCtpmv_v2_(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="hipblasCtpmv_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmv_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtpmv_v2_rank_0,&
      
hipblasCtpmv_v2_rank_1
#endif

  end interface
  
  interface hipblasZtpmv_v2
#ifdef USE_CUDA_NAMES
    function hipblasZtpmv_v2_(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="cublasZtpmv_v2")
#else
    function hipblasZtpmv_v2_(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="hipblasZtpmv_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmv_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtpmv_v2_rank_0,&
      
hipblasZtpmv_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tpmvBatched performs one of the matrix-vector operations
  !> 
  !>          x_i = A_ix_i or x_i = ATx_i, 0 \le i < batchCount
  !> 
  !>     where x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)
  !> 
  !>     The vectors x_i are overwritten.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [hipblasOperation_t]
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     A_i is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [int]
  !>               n specifies the number of rows of matrices A_i. n >= 0.
  !> 
  !>     @param[in]
  !>     AP         device pointer storing pointer of matrices A_i,
  !>               of dimension ( lda, n )
  !> 
  !>     @param[in]
  !>     x         device pointer storing vectors x_i.
  !> 
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of vectors x_i.
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>               The number of batched matricesvectors.
  !> 
  !> 
  !>     
  interface hipblasStpmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasStpmvBatched_(handle,uplo,transA,diag,n,AP,x,incx,batchCount) bind(c, name="cublasStpmvBatched")
#else
    function hipblasStpmvBatched_(handle,uplo,transA,diag,n,AP,x,incx,batchCount) bind(c, name="hipblasStpmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasStpmvBatched_full_rank,&
      
hipblasStpmvBatched_rank_0,&
      
hipblasStpmvBatched_rank_1
#endif

  end interface
  
  interface hipblasDtpmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtpmvBatched_(handle,uplo,transA,diag,n,AP,x,incx,batchCount) bind(c, name="cublasDtpmvBatched")
#else
    function hipblasDtpmvBatched_(handle,uplo,transA,diag,n,AP,x,incx,batchCount) bind(c, name="hipblasDtpmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDtpmvBatched_full_rank,&
      
hipblasDtpmvBatched_rank_0,&
      
hipblasDtpmvBatched_rank_1
#endif

  end interface
  
  interface hipblasCtpmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtpmvBatched_(handle,uplo,transA,diag,n,AP,x,incx,batchCount) bind(c, name="cublasCtpmvBatched")
#else
    function hipblasCtpmvBatched_(handle,uplo,transA,diag,n,AP,x,incx,batchCount) bind(c, name="hipblasCtpmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtpmvBatched_full_rank,&
      
hipblasCtpmvBatched_rank_0,&
      
hipblasCtpmvBatched_rank_1
#endif

  end interface
  
  interface hipblasZtpmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtpmvBatched_(handle,uplo,transA,diag,n,AP,x,incx,batchCount) bind(c, name="cublasZtpmvBatched")
#else
    function hipblasZtpmvBatched_(handle,uplo,transA,diag,n,AP,x,incx,batchCount) bind(c, name="hipblasZtpmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtpmvBatched_full_rank,&
      
hipblasZtpmvBatched_rank_0,&
      
hipblasZtpmvBatched_rank_1
#endif

  end interface
  
  interface hipblasCtpmvBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCtpmvBatched_v2_(handle,uplo,transA,diag,n,AP,x,incx,batchCount) bind(c, name="cublasCtpmvBatched_v2")
#else
    function hipblasCtpmvBatched_v2_(handle,uplo,transA,diag,n,AP,x,incx,batchCount) bind(c, name="hipblasCtpmvBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmvBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtpmvBatched_v2_full_rank,&
      
hipblasCtpmvBatched_v2_rank_0,&
      
hipblasCtpmvBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZtpmvBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZtpmvBatched_v2_(handle,uplo,transA,diag,n,AP,x,incx,batchCount) bind(c, name="cublasZtpmvBatched_v2")
#else
    function hipblasZtpmvBatched_v2_(handle,uplo,transA,diag,n,AP,x,incx,batchCount) bind(c, name="hipblasZtpmvBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmvBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtpmvBatched_v2_full_rank,&
      
hipblasZtpmvBatched_v2_rank_0,&
      
hipblasZtpmvBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tpmvStridedBatched performs one of the matrix-vector operations
  !> 
  !>          x_i = A_ix_i or x_i = ATx_i, 0 \le i < batchCount
  !> 
  !>     where x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)
  !>     with strides specifying how to retrieve $x_i$ (resp. $A_i$) from $x_{i-1}$ (resp. $A_i$).
  !> 
  !>     The vectors x_i are overwritten.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [hipblasOperation_t]
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     A_i is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [int]
  !>               n specifies the number of rows of matrices A_i. n >= 0.
  !> 
  !>     @param[in]
  !>     AP         device pointer of the matrix A_0,
  !>               of dimension ( lda, n )
  !> 
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one A_i matrix to the next A_{i + 1}
  !> 
  !>     @param[in]
  !>     x         device pointer storing the vector x_0.
  !> 
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of one vector x.
  !> 
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               stride from the start of one x_i vector to the next x_{i + 1}
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>               The number of batched matricesvectors.
  !> 
  !> 
  !>     
  interface hipblasStpmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasStpmvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount) bind(c, name="cublasStpmvStridedBatched")
#else
    function hipblasStpmvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasStpmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasStpmvStridedBatched_rank_0,&
      
hipblasStpmvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDtpmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtpmvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount) bind(c, name="cublasDtpmvStridedBatched")
#else
    function hipblasDtpmvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasDtpmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDtpmvStridedBatched_rank_0,&
      
hipblasDtpmvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCtpmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtpmvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount) bind(c, name="cublasCtpmvStridedBatched")
#else
    function hipblasCtpmvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasCtpmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtpmvStridedBatched_rank_0,&
      
hipblasCtpmvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZtpmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtpmvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount) bind(c, name="cublasZtpmvStridedBatched")
#else
    function hipblasZtpmvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasZtpmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtpmvStridedBatched_rank_0,&
      
hipblasZtpmvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCtpmvStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCtpmvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount) bind(c, name="cublasCtpmvStridedBatched_v2")
#else
    function hipblasCtpmvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasCtpmvStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmvStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtpmvStridedBatched_v2_rank_0,&
      
hipblasCtpmvStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZtpmvStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZtpmvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount) bind(c, name="cublasZtpmvStridedBatched_v2")
#else
    function hipblasZtpmvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasZtpmvStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmvStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtpmvStridedBatched_v2_rank_0,&
      
hipblasZtpmvStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tpsv solves
  !> 
  !>          Ax = b or ATx = b, or AHx = b,
  !> 
  !>     where x and b are vectors and A is a triangular matrix stored in the packed format.
  !> 
  !>     The input vector b is overwritten by the output vector x.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_N: Solves Ax = b
  !>             HIPBLAS_OP_T: Solves ATx = b
  !>             HIPBLAS_OP_C: Solves AHx = b
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular (i.e. the diagonal elements
  !>                                        of A are not used in computations).
  !>             HIPBLAS_DIAG_NON_UNIT: A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [int]
  !>               n specifies the number of rows of b. n >= 0.
  !> 
  !>     @param[in]
  !>     AP        device pointer storing the packed version of matrix A,
  !>               of dimension >= (n  (n + 1)  2)
  !> 
  !>     @param[inout]
  !>     x         device pointer storing vector b on input, overwritten by x on output.
  !> 
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !> 
  !>     
  interface hipblasStpsv
#ifdef USE_CUDA_NAMES
    function hipblasStpsv_(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="cublasStpsv_v2")
#else
    function hipblasStpsv_(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="hipblasStpsv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpsv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasStpsv_rank_0,&
      
hipblasStpsv_rank_1
#endif

  end interface
  
  interface hipblasDtpsv
#ifdef USE_CUDA_NAMES
    function hipblasDtpsv_(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="cublasDtpsv_v2")
#else
    function hipblasDtpsv_(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="hipblasDtpsv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpsv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDtpsv_rank_0,&
      
hipblasDtpsv_rank_1
#endif

  end interface
  
  interface hipblasCtpsv
#ifdef USE_CUDA_NAMES
    function hipblasCtpsv_(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="cublasCtpsv_v2")
#else
    function hipblasCtpsv_(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="hipblasCtpsv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtpsv_rank_0,&
      
hipblasCtpsv_rank_1
#endif

  end interface
  
  interface hipblasZtpsv
#ifdef USE_CUDA_NAMES
    function hipblasZtpsv_(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="cublasZtpsv_v2")
#else
    function hipblasZtpsv_(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="hipblasZtpsv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtpsv_rank_0,&
      
hipblasZtpsv_rank_1
#endif

  end interface
  
  interface hipblasCtpsv_v2
#ifdef USE_CUDA_NAMES
    function hipblasCtpsv_v2_(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="cublasCtpsv_v2")
#else
    function hipblasCtpsv_v2_(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="hipblasCtpsv_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsv_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtpsv_v2_rank_0,&
      
hipblasCtpsv_v2_rank_1
#endif

  end interface
  
  interface hipblasZtpsv_v2
#ifdef USE_CUDA_NAMES
    function hipblasZtpsv_v2_(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="cublasZtpsv_v2")
#else
    function hipblasZtpsv_v2_(handle,uplo,transA,diag,n,AP,x,incx) bind(c, name="hipblasZtpsv_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsv_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtpsv_v2_rank_0,&
      
hipblasZtpsv_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tpsvBatched solves
  !> 
  !>          A_ix_i = b_i or A_iTx_i = b_i, or A_iHx_i = b_i,
  !> 
  !>     where x_i and b_i are vectors and A_i is a triangular matrix stored in the packed format,
  !>     for i in [1, batchCount].
  !> 
  !>     The input vectors b_i are overwritten by the output vectors x_i.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  each A_i is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_N: Solves Ax = b
  !>             HIPBLAS_OP_T: Solves ATx = b
  !>             HIPBLAS_OP_C: Solves AHx = b
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular (i.e. the diagonal elements
  !>                                        of each A_i are not used in computations).
  !>             HIPBLAS_DIAG_NON_UNIT: each A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [int]
  !>               n specifies the number of rows of each b_i. n >= 0.
  !> 
  !>     @param[in]
  !>     AP        device array of device pointers storing the packed versions of each matrix A_i,
  !>               of dimension >= (n  (n + 1)  2)
  !> 
  !>     @param[inout]
  !>     x         device array of device pointers storing each input vector b_i, overwritten by x_i on output.
  !> 
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     batchCount [int]
  !>                 specifies the number of instances in the batch.
  !> 
  !>     
  interface hipblasStpsvBatched
#ifdef USE_CUDA_NAMES
    function hipblasStpsvBatched_(handle,uplo,transA,diag,n,AP,x,incx,batchCount) bind(c, name="cublasStpsvBatched")
#else
    function hipblasStpsvBatched_(handle,uplo,transA,diag,n,AP,x,incx,batchCount) bind(c, name="hipblasStpsvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpsvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasStpsvBatched_full_rank,&
      
hipblasStpsvBatched_rank_0,&
      
hipblasStpsvBatched_rank_1
#endif

  end interface
  
  interface hipblasDtpsvBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtpsvBatched_(handle,uplo,transA,diag,n,AP,x,incx,batchCount) bind(c, name="cublasDtpsvBatched")
#else
    function hipblasDtpsvBatched_(handle,uplo,transA,diag,n,AP,x,incx,batchCount) bind(c, name="hipblasDtpsvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpsvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDtpsvBatched_full_rank,&
      
hipblasDtpsvBatched_rank_0,&
      
hipblasDtpsvBatched_rank_1
#endif

  end interface
  
  interface hipblasCtpsvBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtpsvBatched_(handle,uplo,transA,diag,n,AP,x,incx,batchCount) bind(c, name="cublasCtpsvBatched")
#else
    function hipblasCtpsvBatched_(handle,uplo,transA,diag,n,AP,x,incx,batchCount) bind(c, name="hipblasCtpsvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtpsvBatched_full_rank,&
      
hipblasCtpsvBatched_rank_0,&
      
hipblasCtpsvBatched_rank_1
#endif

  end interface
  
  interface hipblasZtpsvBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtpsvBatched_(handle,uplo,transA,diag,n,AP,x,incx,batchCount) bind(c, name="cublasZtpsvBatched")
#else
    function hipblasZtpsvBatched_(handle,uplo,transA,diag,n,AP,x,incx,batchCount) bind(c, name="hipblasZtpsvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtpsvBatched_full_rank,&
      
hipblasZtpsvBatched_rank_0,&
      
hipblasZtpsvBatched_rank_1
#endif

  end interface
  
  interface hipblasCtpsvBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCtpsvBatched_v2_(handle,uplo,transA,diag,n,AP,x,incx,batchCount) bind(c, name="cublasCtpsvBatched_v2")
#else
    function hipblasCtpsvBatched_v2_(handle,uplo,transA,diag,n,AP,x,incx,batchCount) bind(c, name="hipblasCtpsvBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsvBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtpsvBatched_v2_full_rank,&
      
hipblasCtpsvBatched_v2_rank_0,&
      
hipblasCtpsvBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZtpsvBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZtpsvBatched_v2_(handle,uplo,transA,diag,n,AP,x,incx,batchCount) bind(c, name="cublasZtpsvBatched_v2")
#else
    function hipblasZtpsvBatched_v2_(handle,uplo,transA,diag,n,AP,x,incx,batchCount) bind(c, name="hipblasZtpsvBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsvBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtpsvBatched_v2_full_rank,&
      
hipblasZtpsvBatched_v2_rank_0,&
      
hipblasZtpsvBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     tpsvStridedBatched solves
  !> 
  !>          A_ix_i = b_i or A_iTx_i = b_i, or A_iHx_i = b_i,
  !> 
  !>     where x_i and b_i are vectors and A_i is a triangular matrix stored in the packed format,
  !>     for i in [1, batchCount].
  !> 
  !>     The input vectors b_i are overwritten by the output vectors x_i.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  each A_i is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_N: Solves Ax = b
  !>             HIPBLAS_OP_T: Solves ATx = b
  !>             HIPBLAS_OP_C: Solves AHx = b
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular (i.e. the diagonal elements
  !>                                        of each A_i are not used in computations).
  !>             HIPBLAS_DIAG_NON_UNIT: each A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [int]
  !>               n specifies the number of rows of each b_i. n >= 0.
  !> 
  !>     @param[in]
  !>     AP        device pointer pointing to the first packed matrix A_1,
  !>               of dimension >= (n  (n + 1)  2)
  !> 
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the beginning of one packed matrix (AP_i) and the next (AP_i+1).
  !> 
  !>     @param[inout]
  !>     x         device pointer pointing to the first input vector b_1. Overwritten by each x_i on output.
  !> 
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               stride from the beginning of one vector (x_i) and the next (x_i+1).
  !>     @param[in]
  !>     batchCount [int]
  !>                 specifies the number of instances in the batch.
  !> 
  !>     
  interface hipblasStpsvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasStpsvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount) bind(c, name="cublasStpsvStridedBatched")
#else
    function hipblasStpsvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasStpsvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpsvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasStpsvStridedBatched_rank_0,&
      
hipblasStpsvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDtpsvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtpsvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount) bind(c, name="cublasDtpsvStridedBatched")
#else
    function hipblasDtpsvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasDtpsvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpsvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDtpsvStridedBatched_rank_0,&
      
hipblasDtpsvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCtpsvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtpsvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount) bind(c, name="cublasCtpsvStridedBatched")
#else
    function hipblasCtpsvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasCtpsvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtpsvStridedBatched_rank_0,&
      
hipblasCtpsvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZtpsvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtpsvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount) bind(c, name="cublasZtpsvStridedBatched")
#else
    function hipblasZtpsvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasZtpsvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtpsvStridedBatched_rank_0,&
      
hipblasZtpsvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCtpsvStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCtpsvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount) bind(c, name="cublasCtpsvStridedBatched_v2")
#else
    function hipblasCtpsvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasCtpsvStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsvStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtpsvStridedBatched_v2_rank_0,&
      
hipblasCtpsvStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZtpsvStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZtpsvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount) bind(c, name="cublasZtpsvStridedBatched_v2")
#else
    function hipblasZtpsvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasZtpsvStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsvStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtpsvStridedBatched_v2_rank_0,&
      
hipblasZtpsvStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     trmv performs one of the matrix-vector operations
  !> 
  !>          x = Ax or x = ATx,
  !> 
  !>     where x is an n element vector and A is an n by n unit, or non-unit, upper or lower triangular matrix.
  !> 
  !>     The vector x is overwritten.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [hipblasOperation_t]
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [int]
  !>               n specifies the number of rows of A. n >= 0.
  !> 
  !>     @param[in]
  !>     AP        device pointer storing matrix A,
  !>               of dimension ( lda, n )
  !> 
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A.
  !>               lda = max( 1, n ).
  !> 
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !> 
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !> 
  !>     
  interface hipblasStrmv
#ifdef USE_CUDA_NAMES
    function hipblasStrmv_(handle,uplo,transA,diag,n,AP,lda,x,incx) bind(c, name="cublasStrmv_v2")
#else
    function hipblasStrmv_(handle,uplo,transA,diag,n,AP,lda,x,incx) bind(c, name="hipblasStrmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasStrmv_rank_0,&
      
hipblasStrmv_rank_1
#endif

  end interface
  
  interface hipblasDtrmv
#ifdef USE_CUDA_NAMES
    function hipblasDtrmv_(handle,uplo,transA,diag,n,AP,lda,x,incx) bind(c, name="cublasDtrmv_v2")
#else
    function hipblasDtrmv_(handle,uplo,transA,diag,n,AP,lda,x,incx) bind(c, name="hipblasDtrmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDtrmv_rank_0,&
      
hipblasDtrmv_rank_1
#endif

  end interface
  
  interface hipblasCtrmv
#ifdef USE_CUDA_NAMES
    function hipblasCtrmv_(handle,uplo,transA,diag,n,AP,lda,x,incx) bind(c, name="cublasCtrmv_v2")
#else
    function hipblasCtrmv_(handle,uplo,transA,diag,n,AP,lda,x,incx) bind(c, name="hipblasCtrmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtrmv_rank_0,&
      
hipblasCtrmv_rank_1
#endif

  end interface
  
  interface hipblasZtrmv
#ifdef USE_CUDA_NAMES
    function hipblasZtrmv_(handle,uplo,transA,diag,n,AP,lda,x,incx) bind(c, name="cublasZtrmv_v2")
#else
    function hipblasZtrmv_(handle,uplo,transA,diag,n,AP,lda,x,incx) bind(c, name="hipblasZtrmv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtrmv_rank_0,&
      
hipblasZtrmv_rank_1
#endif

  end interface
  
  interface hipblasCtrmv_v2
#ifdef USE_CUDA_NAMES
    function hipblasCtrmv_v2_(handle,uplo,transA,diag,n,AP,lda,x,incx) bind(c, name="cublasCtrmv_v2")
#else
    function hipblasCtrmv_v2_(handle,uplo,transA,diag,n,AP,lda,x,incx) bind(c, name="hipblasCtrmv_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmv_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtrmv_v2_rank_0,&
      
hipblasCtrmv_v2_rank_1
#endif

  end interface
  
  interface hipblasZtrmv_v2
#ifdef USE_CUDA_NAMES
    function hipblasZtrmv_v2_(handle,uplo,transA,diag,n,AP,lda,x,incx) bind(c, name="cublasZtrmv_v2")
#else
    function hipblasZtrmv_v2_(handle,uplo,transA,diag,n,AP,lda,x,incx) bind(c, name="hipblasZtrmv_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmv_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtrmv_v2_rank_0,&
      
hipblasZtrmv_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     trmvBatched performs one of the matrix-vector operations
  !> 
  !>          x_i = A_ix_i or x_i = ATx_i, 0 \le i < batchCount
  !> 
  !>     where x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)
  !> 
  !>     The vectors x_i are overwritten.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [hipblasOperation_t]
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     A_i is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [int]
  !>               n specifies the number of rows of matrices A_i. n >= 0.
  !> 
  !>     @param[in]
  !>     AP        device pointer storing pointer of matrices A_i,
  !>               of dimension ( lda, n )
  !> 
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A_i.
  !>               lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     x         device pointer storing vectors x_i.
  !> 
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of vectors x_i.
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>               The number of batched matricesvectors.
  !> 
  !> 
  !>     
  interface hipblasStrmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasStrmvBatched_(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount) bind(c, name="cublasStrmvBatched")
#else
    function hipblasStrmvBatched_(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount) bind(c, name="hipblasStrmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasStrmvBatched_full_rank,&
      
hipblasStrmvBatched_rank_0,&
      
hipblasStrmvBatched_rank_1
#endif

  end interface
  
  interface hipblasDtrmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtrmvBatched_(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount) bind(c, name="cublasDtrmvBatched")
#else
    function hipblasDtrmvBatched_(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount) bind(c, name="hipblasDtrmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDtrmvBatched_full_rank,&
      
hipblasDtrmvBatched_rank_0,&
      
hipblasDtrmvBatched_rank_1
#endif

  end interface
  
  interface hipblasCtrmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtrmvBatched_(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount) bind(c, name="cublasCtrmvBatched")
#else
    function hipblasCtrmvBatched_(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount) bind(c, name="hipblasCtrmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtrmvBatched_full_rank,&
      
hipblasCtrmvBatched_rank_0,&
      
hipblasCtrmvBatched_rank_1
#endif

  end interface
  
  interface hipblasZtrmvBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtrmvBatched_(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount) bind(c, name="cublasZtrmvBatched")
#else
    function hipblasZtrmvBatched_(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount) bind(c, name="hipblasZtrmvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtrmvBatched_full_rank,&
      
hipblasZtrmvBatched_rank_0,&
      
hipblasZtrmvBatched_rank_1
#endif

  end interface
  
  interface hipblasCtrmvBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCtrmvBatched_v2_(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount) bind(c, name="cublasCtrmvBatched_v2")
#else
    function hipblasCtrmvBatched_v2_(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount) bind(c, name="hipblasCtrmvBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmvBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtrmvBatched_v2_full_rank,&
      
hipblasCtrmvBatched_v2_rank_0,&
      
hipblasCtrmvBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZtrmvBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZtrmvBatched_v2_(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount) bind(c, name="cublasZtrmvBatched_v2")
#else
    function hipblasZtrmvBatched_v2_(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount) bind(c, name="hipblasZtrmvBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmvBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtrmvBatched_v2_full_rank,&
      
hipblasZtrmvBatched_v2_rank_0,&
      
hipblasZtrmvBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     trmvStridedBatched performs one of the matrix-vector operations
  !> 
  !>          x_i = A_ix_i or x_i = ATx_i, 0 \le i < batchCount
  !> 
  !>     where x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)
  !>     with strides specifying how to retrieve $x_i$ (resp. $A_i$) from $x_{i-1}$ (resp. $A_i$).
  !> 
  !>     The vectors x_i are overwritten.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [hipblasOperation_t]
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     A_i is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [int]
  !>               n specifies the number of rows of matrices A_i. n >= 0.
  !> 
  !>     @param[in]
  !>     AP        device pointer of the matrix A_0,
  !>               of dimension ( lda, n )
  !> 
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A_i.
  !>               lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one A_i matrix to the next A_{i + 1}
  !> 
  !>     @param[in]
  !>     x         device pointer storing the vector x_0.
  !> 
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of one vector x.
  !> 
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               stride from the start of one x_i vector to the next x_{i + 1}
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>               The number of batched matricesvectors.
  !> 
  !> 
  !>     
  interface hipblasStrmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasStrmvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasStrmvStridedBatched")
#else
    function hipblasStrmvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasStrmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasStrmvStridedBatched_rank_0,&
      
hipblasStrmvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDtrmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtrmvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasDtrmvStridedBatched")
#else
    function hipblasDtrmvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasDtrmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDtrmvStridedBatched_rank_0,&
      
hipblasDtrmvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCtrmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtrmvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasCtrmvStridedBatched")
#else
    function hipblasCtrmvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasCtrmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtrmvStridedBatched_rank_0,&
      
hipblasCtrmvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZtrmvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtrmvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasZtrmvStridedBatched")
#else
    function hipblasZtrmvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasZtrmvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtrmvStridedBatched_rank_0,&
      
hipblasZtrmvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCtrmvStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCtrmvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasCtrmvStridedBatched_v2")
#else
    function hipblasCtrmvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasCtrmvStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmvStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtrmvStridedBatched_v2_rank_0,&
      
hipblasCtrmvStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZtrmvStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZtrmvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasZtrmvStridedBatched_v2")
#else
    function hipblasZtrmvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasZtrmvStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmvStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtrmvStridedBatched_v2_rank_0,&
      
hipblasZtrmvStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     trsv solves
  !> 
  !>          Ax = b or ATx = b,
  !> 
  !>     where x and b are vectors and A is a triangular matrix.
  !> 
  !>     The vector x is overwritten on b.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [hipblasOperation_t]
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [int]
  !>               n specifies the number of rows of b. n >= 0.
  !> 
  !>     @param[in]
  !>     AP        device pointer storing matrix A,
  !>               of dimension ( lda, n )
  !> 
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A.
  !>               lda = max( 1, n ).
  !> 
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !> 
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !> 
  !>     
  interface hipblasStrsv
#ifdef USE_CUDA_NAMES
    function hipblasStrsv_(handle,uplo,transA,diag,n,AP,lda,x,incx) bind(c, name="cublasStrsv_v2")
#else
    function hipblasStrsv_(handle,uplo,transA,diag,n,AP,lda,x,incx) bind(c, name="hipblasStrsv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasStrsv_rank_0,&
      
hipblasStrsv_rank_1
#endif

  end interface
  
  interface hipblasDtrsv
#ifdef USE_CUDA_NAMES
    function hipblasDtrsv_(handle,uplo,transA,diag,n,AP,lda,x,incx) bind(c, name="cublasDtrsv_v2")
#else
    function hipblasDtrsv_(handle,uplo,transA,diag,n,AP,lda,x,incx) bind(c, name="hipblasDtrsv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDtrsv_rank_0,&
      
hipblasDtrsv_rank_1
#endif

  end interface
  
  interface hipblasCtrsv
#ifdef USE_CUDA_NAMES
    function hipblasCtrsv_(handle,uplo,transA,diag,n,AP,lda,x,incx) bind(c, name="cublasCtrsv_v2")
#else
    function hipblasCtrsv_(handle,uplo,transA,diag,n,AP,lda,x,incx) bind(c, name="hipblasCtrsv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtrsv_rank_0,&
      
hipblasCtrsv_rank_1
#endif

  end interface
  
  interface hipblasZtrsv
#ifdef USE_CUDA_NAMES
    function hipblasZtrsv_(handle,uplo,transA,diag,n,AP,lda,x,incx) bind(c, name="cublasZtrsv_v2")
#else
    function hipblasZtrsv_(handle,uplo,transA,diag,n,AP,lda,x,incx) bind(c, name="hipblasZtrsv")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsv_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtrsv_rank_0,&
      
hipblasZtrsv_rank_1
#endif

  end interface
  
  interface hipblasCtrsv_v2
#ifdef USE_CUDA_NAMES
    function hipblasCtrsv_v2_(handle,uplo,transA,diag,n,AP,lda,x,incx) bind(c, name="cublasCtrsv_v2")
#else
    function hipblasCtrsv_v2_(handle,uplo,transA,diag,n,AP,lda,x,incx) bind(c, name="hipblasCtrsv_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsv_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtrsv_v2_rank_0,&
      
hipblasCtrsv_v2_rank_1
#endif

  end interface
  
  interface hipblasZtrsv_v2
#ifdef USE_CUDA_NAMES
    function hipblasZtrsv_v2_(handle,uplo,transA,diag,n,AP,lda,x,incx) bind(c, name="cublasZtrsv_v2")
#else
    function hipblasZtrsv_v2_(handle,uplo,transA,diag,n,AP,lda,x,incx) bind(c, name="hipblasZtrsv_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsv_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtrsv_v2_rank_0,&
      
hipblasZtrsv_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     trsvBatched solves
  !> 
  !>          A_ix_i = b_i or A_iTx_i = b_i,
  !> 
  !>     where (A_i, x_i, b_i) is the i-th instance of the batch.
  !>     x_i and b_i are vectors and A_i is an
  !>     n by n triangular matrix.
  !> 
  !>     The vector x is overwritten on b.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [hipblasOperation_t]
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [int]
  !>               n specifies the number of rows of b. n >= 0.
  !> 
  !>     @param[in]
  !>     AP         device array of device pointers storing each matrix A_i.
  !> 
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i.
  !>               lda = max(1, n)
  !> 
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !> 
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface hipblasStrsvBatched
#ifdef USE_CUDA_NAMES
    function hipblasStrsvBatched_(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount) bind(c, name="cublasStrsvBatched")
#else
    function hipblasStrsvBatched_(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount) bind(c, name="hipblasStrsvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasStrsvBatched_full_rank,&
      
hipblasStrsvBatched_rank_0,&
      
hipblasStrsvBatched_rank_1
#endif

  end interface
  
  interface hipblasDtrsvBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtrsvBatched_(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount) bind(c, name="cublasDtrsvBatched")
#else
    function hipblasDtrsvBatched_(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount) bind(c, name="hipblasDtrsvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDtrsvBatched_full_rank,&
      
hipblasDtrsvBatched_rank_0,&
      
hipblasDtrsvBatched_rank_1
#endif

  end interface
  
  interface hipblasCtrsvBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtrsvBatched_(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount) bind(c, name="cublasCtrsvBatched")
#else
    function hipblasCtrsvBatched_(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount) bind(c, name="hipblasCtrsvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtrsvBatched_full_rank,&
      
hipblasCtrsvBatched_rank_0,&
      
hipblasCtrsvBatched_rank_1
#endif

  end interface
  
  interface hipblasZtrsvBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtrsvBatched_(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount) bind(c, name="cublasZtrsvBatched")
#else
    function hipblasZtrsvBatched_(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount) bind(c, name="hipblasZtrsvBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsvBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtrsvBatched_full_rank,&
      
hipblasZtrsvBatched_rank_0,&
      
hipblasZtrsvBatched_rank_1
#endif

  end interface
  
  interface hipblasCtrsvBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCtrsvBatched_v2_(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount) bind(c, name="cublasCtrsvBatched_v2")
#else
    function hipblasCtrsvBatched_v2_(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount) bind(c, name="hipblasCtrsvBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsvBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtrsvBatched_v2_full_rank,&
      
hipblasCtrsvBatched_v2_rank_0,&
      
hipblasCtrsvBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZtrsvBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZtrsvBatched_v2_(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount) bind(c, name="cublasZtrsvBatched_v2")
#else
    function hipblasZtrsvBatched_v2_(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount) bind(c, name="hipblasZtrsvBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsvBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtrsvBatched_v2_full_rank,&
      
hipblasZtrsvBatched_v2_rank_0,&
      
hipblasZtrsvBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 2 API
  !> 
  !>     \details
  !>     trsvStridedBatched solves
  !> 
  !>          A_ix_i = b_i or A_iTx_i = b_i,
  !> 
  !>     where (A_i, x_i, b_i) is the i-th instance of the batch.
  !>     x_i and b_i are vectors and A_i is an n by n triangular matrix, for i = 1, ..., batchCount.
  !> 
  !>     The vector x is overwritten on b.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA     [hipblasOperation_t]
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     n         [int]
  !>               n specifies the number of rows of each b_i. n >= 0.
  !> 
  !>     @param[in]
  !>     AP         device pointer to the first matrix (A_1) in the batch, of dimension ( lda, n )
  !> 
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one A_i matrix to the next A_(i + 1)
  !> 
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i.
  !>               lda = max( 1, n ).
  !> 
  !>     @param[in, out]
  !>     x         device pointer to the first vector (x_1) in the batch.
  !> 
  !>     @param[in]
  !>     stridex [hipblasStride]
  !>              stride from the start of one x_i vector to the next x_(i + 1)
  !> 
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface hipblasStrsvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasStrsvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasStrsvStridedBatched")
#else
    function hipblasStrsvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasStrsvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasStrsvStridedBatched_rank_0,&
      
hipblasStrsvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDtrsvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtrsvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasDtrsvStridedBatched")
#else
    function hipblasDtrsvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasDtrsvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDtrsvStridedBatched_rank_0,&
      
hipblasDtrsvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCtrsvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtrsvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasCtrsvStridedBatched")
#else
    function hipblasCtrsvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasCtrsvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtrsvStridedBatched_rank_0,&
      
hipblasCtrsvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZtrsvStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtrsvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasZtrsvStridedBatched")
#else
    function hipblasZtrsvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasZtrsvStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsvStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtrsvStridedBatched_rank_0,&
      
hipblasZtrsvStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCtrsvStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCtrsvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasCtrsvStridedBatched_v2")
#else
    function hipblasCtrsvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasCtrsvStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsvStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtrsvStridedBatched_v2_rank_0,&
      
hipblasCtrsvStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZtrsvStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZtrsvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="cublasZtrsvStridedBatched_v2")
#else
    function hipblasZtrsvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount) bind(c, name="hipblasZtrsvStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsvStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtrsvStridedBatched_v2_rank_0,&
      
hipblasZtrsvStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasSgemm
#ifdef USE_CUDA_NAMES
    function hipblasSgemm_(handle,transA,transB,m,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasSgemm_v2")
#else
    function hipblasSgemm_(handle,transA,transB,m,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasSgemm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasDgemm
#ifdef USE_CUDA_NAMES
    function hipblasDgemm_(handle,transA,transB,m,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasDgemm_v2")
#else
    function hipblasDgemm_(handle,transA,transB,m,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasDgemm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasCgemm
#ifdef USE_CUDA_NAMES
    function hipblasCgemm_(handle,transA,transB,m,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasCgemm_v2")
#else
    function hipblasCgemm_(handle,transA,transB,m,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasCgemm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasZgemm
#ifdef USE_CUDA_NAMES
    function hipblasZgemm_(handle,transA,transB,m,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasZgemm_v2")
#else
    function hipblasZgemm_(handle,transA,transB,m,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasZgemm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasCgemm_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgemm_v2_(handle,transA,transB,m,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasCgemm_v2")
#else
    function hipblasCgemm_v2_(handle,transA,transB,m,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasCgemm_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemm_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasZgemm_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgemm_v2_(handle,transA,transB,m,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasZgemm_v2")
#else
    function hipblasZgemm_v2_(handle,transA,transB,m,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasZgemm_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemm_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasSgemmBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgemmBatched_(handle,transA,transB,m,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasSgemmBatched")
#else
    function hipblasSgemmBatched_(handle,transA,transB,m,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasSgemmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasDgemmBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgemmBatched_(handle,transA,transB,m,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasDgemmBatched")
#else
    function hipblasDgemmBatched_(handle,transA,transB,m,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasDgemmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCgemmBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgemmBatched_(handle,transA,transB,m,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasCgemmBatched")
#else
    function hipblasCgemmBatched_(handle,transA,transB,m,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasCgemmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZgemmBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgemmBatched_(handle,transA,transB,m,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasZgemmBatched")
#else
    function hipblasZgemmBatched_(handle,transA,transB,m,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasZgemmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCgemmBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgemmBatched_v2_(handle,transA,transB,m,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasCgemmBatched_v2")
#else
    function hipblasCgemmBatched_v2_(handle,transA,transB,m,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasCgemmBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemmBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZgemmBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgemmBatched_v2_(handle,transA,transB,m,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasZgemmBatched_v2")
#else
    function hipblasZgemmBatched_v2_(handle,transA,transB,m,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasZgemmBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemmBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasSgemmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgemmStridedBatched_(handle,transA,transB,m,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasSgemmStridedBatched")
#else
    function hipblasSgemmStridedBatched_(handle,transA,transB,m,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasSgemmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_long_long),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_long_long),value :: strideB
      real(c_float) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_long_long),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasDgemmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgemmStridedBatched_(handle,transA,transB,m,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasDgemmStridedBatched")
#else
    function hipblasDgemmStridedBatched_(handle,transA,transB,m,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasDgemmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_long_long),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_long_long),value :: strideB
      real(c_double) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_long_long),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCgemmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgemmStridedBatched_(handle,transA,transB,m,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasCgemmStridedBatched")
#else
    function hipblasCgemmStridedBatched_(handle,transA,transB,m,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasCgemmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_long_long),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_long_long),value :: strideB
      complex(c_float_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_long_long),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZgemmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgemmStridedBatched_(handle,transA,transB,m,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasZgemmStridedBatched")
#else
    function hipblasZgemmStridedBatched_(handle,transA,transB,m,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasZgemmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_long_long),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_long_long),value :: strideB
      complex(c_double_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_long_long),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCgemmStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgemmStridedBatched_v2_(handle,transA,transB,m,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasCgemmStridedBatched_v2")
#else
    function hipblasCgemmStridedBatched_v2_(handle,transA,transB,m,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasCgemmStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemmStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_long_long),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_long_long),value :: strideB
      complex(c_float_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_long_long),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZgemmStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgemmStridedBatched_v2_(handle,transA,transB,m,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasZgemmStridedBatched_v2")
#else
    function hipblasZgemmStridedBatched_v2_(handle,transA,transB,m,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasZgemmStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemmStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_long_long),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_long_long),value :: strideB
      complex(c_double_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_long_long),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     herk performs one of the matrix-matrix operations for a Hermitian rank-k update
  !> 
  !>     C := alphaop( A )op( A )^H + betaC
  !> 
  !>     where  alpha and beta are scalars, op(A) is an n by k matrix, and
  !>     C is a n x n Hermitian matrix stored as either upper or lower.
  !> 
  !>         op( A ) = A,  and A is n by k if transA == HIPBLAS_OP_N
  !>         op( A ) = A^H and A is k by n if transA == HIPBLAS_OP_C
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_C:  op(A) = A^H
  !>             HIPBLAS_ON_N:  op(A) = A
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     AP       pointer storing matrix A on the GPU.
  !>             Martrix dimension is ( lda, k ) when if transA = HIPBLAS_OP_N, otherwise (lda, n)
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A.
  !>             if transA = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     CP       pointer storing matrix C on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     
  interface hipblasCherk
#ifdef USE_CUDA_NAMES
    function hipblasCherk_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc) bind(c, name="cublasCherk_v2")
#else
    function hipblasCherk_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc) bind(c, name="hipblasCherk")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherk_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      real(c_float) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasZherk
#ifdef USE_CUDA_NAMES
    function hipblasZherk_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc) bind(c, name="cublasZherk_v2")
#else
    function hipblasZherk_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc) bind(c, name="hipblasZherk")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherk_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      real(c_double) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasCherk_v2
#ifdef USE_CUDA_NAMES
    function hipblasCherk_v2_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc) bind(c, name="cublasCherk_v2")
#else
    function hipblasCherk_v2_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc) bind(c, name="hipblasCherk_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherk_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      real(c_float) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasZherk_v2
#ifdef USE_CUDA_NAMES
    function hipblasZherk_v2_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc) bind(c, name="cublasZherk_v2")
#else
    function hipblasZherk_v2_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc) bind(c, name="hipblasZherk_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherk_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      real(c_double) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     herkBatched performs a batch of the matrix-matrix operations for a Hermitian rank-k update
  !> 
  !>     C_i := alphaop( A_i )op( A_i )^H + betaC_i
  !> 
  !>     where  alpha and beta are scalars, op(A) is an n by k matrix, and
  !>     C_i is a n x n Hermitian matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, and A_i is n by k if transA == HIPBLAS_OP_N
  !>         op( A_i ) = A_i^H and A_i is k by n if transA == HIPBLAS_OP_C
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_C: op(A) = A^H
  !>             HIPBLAS_OP_N: op(A) = A
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     AP       device array of device pointers storing each matrix_i A of dimension (lda, k)
  !>             when transA is HIPBLAS_OP_N, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if transA = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     CP       device array of device pointers storing each matrix C_i on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface hipblasCherkBatched
#ifdef USE_CUDA_NAMES
    function hipblasCherkBatched_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc,batchCount) bind(c, name="cublasCherkBatched")
#else
    function hipblasCherkBatched_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc,batchCount) bind(c, name="hipblasCherkBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      real(c_float) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZherkBatched
#ifdef USE_CUDA_NAMES
    function hipblasZherkBatched_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc,batchCount) bind(c, name="cublasZherkBatched")
#else
    function hipblasZherkBatched_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc,batchCount) bind(c, name="hipblasZherkBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      real(c_double) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCherkBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCherkBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc,batchCount) bind(c, name="cublasCherkBatched_v2")
#else
    function hipblasCherkBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc,batchCount) bind(c, name="hipblasCherkBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      real(c_float) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZherkBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZherkBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc,batchCount) bind(c, name="cublasZherkBatched_v2")
#else
    function hipblasZherkBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc,batchCount) bind(c, name="hipblasZherkBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      real(c_double) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     herkStridedBatched performs a batch of the matrix-matrix operations for a Hermitian rank-k update
  !> 
  !>     C_i := alphaop( A_i )op( A_i )^H + betaC_i
  !> 
  !>     where  alpha and beta are scalars, op(A) is an n by k matrix, and
  !>     C_i is a n x n Hermitian matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, and A_i is n by k if transA == HIPBLAS_OP_N
  !>         op( A_i ) = A_i^H and A_i is k by n if transA == HIPBLAS_OP_C
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_C: op(A) = A^H
  !>             HIPBLAS_OP_N: op(A) = A
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     AP       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
  !>             when transA is HIPBLAS_OP_N, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if transA = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     CP       Device pointer to the first matrix C_1 on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     strideC  [hipblasStride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface hipblasCherkStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCherkStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasCherkStridedBatched")
#else
    function hipblasCherkStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasCherkStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_float) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZherkStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZherkStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasZherkStridedBatched")
#else
    function hipblasZherkStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasZherkStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_double) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCherkStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCherkStridedBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasCherkStridedBatched_v2")
#else
    function hipblasCherkStridedBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasCherkStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_float) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZherkStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZherkStridedBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasZherkStridedBatched_v2")
#else
    function hipblasZherkStridedBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasZherkStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_double) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     herkx performs one of the matrix-matrix operations for a Hermitian rank-k update
  !> 
  !>     C := alphaop( A )op( B )^H + betaC
  !> 
  !>     where  alpha and beta are scalars, op(A) and op(B) are n by k matrices, and
  !>     C is a n x n Hermitian matrix stored as either upper or lower.
  !>     This routine should only be used when the caller can guarantee that the result of op( A )op( B )^T will be Hermitian.
  !> 
  !> 
  !>         op( A ) = A, op( B ) = B, and A and B are n by k if trans == HIPBLAS_OP_N
  !>         op( A ) = A^H, op( B ) = B^H,  and A and B are k by n if trans == HIPBLAS_OP_C
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_C:  op( A ) = A^H, op( B ) = B^H
  !>             HIPBLAS_OP_N:  op( A ) = A, op( B ) = B
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     AP      pointer storing matrix A on the GPU.
  !>             Martrix dimension is ( lda, k ) when if trans = HIPBLAS_OP_N, otherwise (lda, n)
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A.
  !>             if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !>     @param[in]
  !>     BP       pointer storing matrix B on the GPU.
  !>             Martrix dimension is ( ldb, k ) when if trans = HIPBLAS_OP_N, otherwise (ldb, n)
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B.
  !>             if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     CP       pointer storing matrix C on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     
  interface hipblasCherkx
#ifdef USE_CUDA_NAMES
    function hipblasCherkx_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasCherkx")
#else
    function hipblasCherkx_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasCherkx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkx_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasZherkx
#ifdef USE_CUDA_NAMES
    function hipblasZherkx_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasZherkx")
#else
    function hipblasZherkx_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasZherkx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkx_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasCherkx_v2
#ifdef USE_CUDA_NAMES
    function hipblasCherkx_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasCherkx_v2")
#else
    function hipblasCherkx_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasCherkx_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkx_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasZherkx_v2
#ifdef USE_CUDA_NAMES
    function hipblasZherkx_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasZherkx_v2")
#else
    function hipblasZherkx_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasZherkx_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkx_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     herkxBatched performs a batch of the matrix-matrix operations for a Hermitian rank-k update
  !> 
  !>     C_i := alphaop( A_i )op( B_i )^H + betaC_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and
  !>     C_i is a n x n Hermitian matrix stored as either upper or lower.
  !>     This routine should only be used when the caller can guarantee that the result of op( A )op( B )^T will be Hermitian.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
  !>         op( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == HIPBLAS_OP_C
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_C: op(A) = A^H
  !>             HIPBLAS_OP_N: op(A) = A
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     AP       device array of device pointers storing each matrix_i A of dimension (lda, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     BP       device array of device pointers storing each matrix_i B of dimension (ldb, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B_i.
  !>             if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     CP       device array of device pointers storing each matrix C_i on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface hipblasCherkxBatched
#ifdef USE_CUDA_NAMES
    function hipblasCherkxBatched_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasCherkxBatched")
#else
    function hipblasCherkxBatched_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasCherkxBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkxBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZherkxBatched
#ifdef USE_CUDA_NAMES
    function hipblasZherkxBatched_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasZherkxBatched")
#else
    function hipblasZherkxBatched_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasZherkxBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkxBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCherkxBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCherkxBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasCherkxBatched_v2")
#else
    function hipblasCherkxBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasCherkxBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkxBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZherkxBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZherkxBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasZherkxBatched_v2")
#else
    function hipblasZherkxBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasZherkxBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkxBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     herkxStridedBatched performs a batch of the matrix-matrix operations for a Hermitian rank-k update
  !> 
  !>     C_i := alphaop( A_i )op( B_i )^H + betaC_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and
  !>     C_i is a n x n Hermitian matrix stored as either upper or lower.
  !>     This routine should only be used when the caller can guarantee that the result of op( A )op( B )^T will be Hermitian.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
  !>         op( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == HIPBLAS_OP_C
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_C: op( A_i ) = A_i^H, op( B_i ) = B_i^H
  !>             HIPBLAS_OP_N: op( A_i ) = A_i, op( B_i ) = B_i
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     AP       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     BP       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B_i.
  !>             if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     strideB  [hipblasStride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     CP       Device pointer to the first matrix C_1 on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     strideC  [hipblasStride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface hipblasCherkxStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCherkxStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasCherkxStridedBatched")
#else
    function hipblasCherkxStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasCherkxStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkxStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_float) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZherkxStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZherkxStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasZherkxStridedBatched")
#else
    function hipblasZherkxStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasZherkxStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkxStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_double) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCherkxStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCherkxStridedBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasCherkxStridedBatched_v2")
#else
    function hipblasCherkxStridedBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasCherkxStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherkxStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_float) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZherkxStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZherkxStridedBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasZherkxStridedBatched_v2")
#else
    function hipblasZherkxStridedBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasZherkxStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherkxStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_double) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     her2k performs one of the matrix-matrix operations for a Hermitian rank-2k update
  !> 
  !>     C := alphaop( A )op( B )^H + conj(alpha)op( B )op( A )^H + betaC
  !> 
  !>     where  alpha and beta are scalars, op(A) and op(B) are n by k matrices, and
  !>     C is a n x n Hermitian matrix stored as either upper or lower.
  !> 
  !>         op( A ) = A, op( B ) = B, and A and B are n by k if trans == HIPBLAS_OP_N
  !>         op( A ) = A^H, op( B ) = B^H,  and A and B are k by n if trans == HIPBLAS_OP_C
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_C:  op( A ) = A^H, op( B ) = B^H
  !>             HIPBLAS_OP_N:  op( A ) = A, op( B ) = B
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     AP       pointer storing matrix A on the GPU.
  !>             Martrix dimension is ( lda, k ) when if trans = HIPBLAS_OP_N, otherwise (lda, n)
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A.
  !>             if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !>     @param[in]
  !>     BP       pointer storing matrix B on the GPU.
  !>             Martrix dimension is ( ldb, k ) when if trans = HIPBLAS_OP_N, otherwise (ldb, n)
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B.
  !>             if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     CP       pointer storing matrix C on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     
  interface hipblasCher2k
#ifdef USE_CUDA_NAMES
    function hipblasCher2k_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasCher2k_v2")
#else
    function hipblasCher2k_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasCher2k")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2k_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasZher2k
#ifdef USE_CUDA_NAMES
    function hipblasZher2k_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasZher2k_v2")
#else
    function hipblasZher2k_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasZher2k")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2k_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasCher2k_v2
#ifdef USE_CUDA_NAMES
    function hipblasCher2k_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasCher2k_v2")
#else
    function hipblasCher2k_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasCher2k_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2k_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasZher2k_v2
#ifdef USE_CUDA_NAMES
    function hipblasZher2k_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasZher2k_v2")
#else
    function hipblasZher2k_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasZher2k_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2k_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     her2kBatched performs a batch of the matrix-matrix operations for a Hermitian rank-2k update
  !> 
  !>     C_i := alphaop( A_i )op( B_i )^H + conj(alpha)op( B_i )op( A_i )^H + betaC_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and
  !>     C_i is a n x n Hermitian matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
  !>         op( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == HIPBLAS_OP_C
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_C: op(A) = A^H
  !>             HIPBLAS_OP_N: op(A) = A
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     AP       device array of device pointers storing each matrix_i A of dimension (lda, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !>     @param[in]
  !>     BP       device array of device pointers storing each matrix_i B of dimension (ldb, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B_i.
  !>             if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     CP       device array of device pointers storing each matrix C_i on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface hipblasCher2kBatched
#ifdef USE_CUDA_NAMES
    function hipblasCher2kBatched_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasCher2kBatched")
#else
    function hipblasCher2kBatched_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasCher2kBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2kBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZher2kBatched
#ifdef USE_CUDA_NAMES
    function hipblasZher2kBatched_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasZher2kBatched")
#else
    function hipblasZher2kBatched_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasZher2kBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2kBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCher2kBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCher2kBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasCher2kBatched_v2")
#else
    function hipblasCher2kBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasCher2kBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2kBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZher2kBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZher2kBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasZher2kBatched_v2")
#else
    function hipblasZher2kBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasZher2kBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2kBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     her2kStridedBatched performs a batch of the matrix-matrix operations for a Hermitian rank-2k update
  !> 
  !>     C_i := alphaop( A_i )op( B_i )^H + conj(alpha)op( B_i )op( A_i )^H + betaC_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and
  !>     C_i is a n x n Hermitian matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
  !>         op( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == HIPBLAS_OP_C
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_C: op( A_i ) = A_i^H, op( B_i ) = B_i^H
  !>             HIPBLAS_OP_N: op( A_i ) = A_i, op( B_i ) = B_i
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     AP       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     BP       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B_i.
  !>             if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     strideB  [hipblasStride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     CP       Device pointer to the first matrix C_1 on the GPU.
  !>             The imaginary component of the diagonal elements are not used but are set to zero unless quick return.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     strideC  [hipblasStride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface hipblasCher2kStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCher2kStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasCher2kStridedBatched")
#else
    function hipblasCher2kStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasCher2kStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2kStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_float) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZher2kStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZher2kStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasZher2kStridedBatched")
#else
    function hipblasZher2kStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasZher2kStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2kStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_double) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCher2kStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCher2kStridedBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasCher2kStridedBatched_v2")
#else
    function hipblasCher2kStridedBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasCher2kStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2kStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_float) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZher2kStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZher2kStridedBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasZher2kStridedBatched_v2")
#else
    function hipblasZher2kStridedBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasZher2kStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2kStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_double) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     symm performs one of the matrix-matrix operations:
  !> 
  !>     C := alphaAB + betaC if side == HIPBLAS_SIDE_LEFT,
  !>     C := alphaBA + betaC if side == HIPBLAS_SIDE_RIGHT,
  !> 
  !>     where alpha and beta are scalars, B and C are m by n matrices, and
  !>     A is a symmetric matrix stored as either upper or lower.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     side  [hipblasSideMode_t]
  !>             HIPBLAS_SIDE_LEFT:      C := alphaAB + betaC
  !>             HIPBLAS_SIDE_RIGHT:     C := alphaBA + betaC
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     m       [int]
  !>             m specifies the number of rows of B and C. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of columns of B and C. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A and B are not referenced.
  !> 
  !>     @param[in]
  !>     AP       pointer storing matrix A on the GPU.
  !>             A is m by m if side == HIPBLAS_SIDE_LEFT
  !>             A is n by n if side == HIPBLAS_SIDE_RIGHT
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A.
  !>             if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
  !>             otherwise lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     BP       pointer storing matrix B on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B. ldb >= max( 1, m )
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     CP       pointer storing matrix C on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, m )
  !> 
  !>     
  interface hipblasSsymm
#ifdef USE_CUDA_NAMES
    function hipblasSsymm_(handle,side,uplo,m,n,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasSsymm_v2")
#else
    function hipblasSsymm_(handle,side,uplo,m,n,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasSsymm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasDsymm
#ifdef USE_CUDA_NAMES
    function hipblasDsymm_(handle,side,uplo,m,n,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasDsymm_v2")
#else
    function hipblasDsymm_(handle,side,uplo,m,n,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasDsymm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasCsymm
#ifdef USE_CUDA_NAMES
    function hipblasCsymm_(handle,side,uplo,m,n,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasCsymm_v2")
#else
    function hipblasCsymm_(handle,side,uplo,m,n,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasCsymm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasZsymm
#ifdef USE_CUDA_NAMES
    function hipblasZsymm_(handle,side,uplo,m,n,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasZsymm_v2")
#else
    function hipblasZsymm_(handle,side,uplo,m,n,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasZsymm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasCsymm_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsymm_v2_(handle,side,uplo,m,n,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasCsymm_v2")
#else
    function hipblasCsymm_v2_(handle,side,uplo,m,n,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasCsymm_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymm_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasZsymm_v2
#ifdef USE_CUDA_NAMES
    function hipblasZsymm_v2_(handle,side,uplo,m,n,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasZsymm_v2")
#else
    function hipblasZsymm_v2_(handle,side,uplo,m,n,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasZsymm_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymm_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     symmBatched performs a batch of the matrix-matrix operations:
  !> 
  !>     C_i := alphaA_iB_i + betaC_i if side == HIPBLAS_SIDE_LEFT,
  !>     C_i := alphaB_iA_i + betaC_i if side == HIPBLAS_SIDE_RIGHT,
  !> 
  !>     where alpha and beta are scalars, B_i and C_i are m by n matrices, and
  !>     A_i is a symmetric matrix stored as either upper or lower.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     side  [hipblasSideMode_t]
  !>             HIPBLAS_SIDE_LEFT:      C_i := alphaA_iB_i + betaC_i
  !>             HIPBLAS_SIDE_RIGHT:     C_i := alphaB_iA_i + betaC_i
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     m       [int]
  !>             m specifies the number of rows of B_i and C_i. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of columns of B_i and C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A_i and B_i are not referenced.
  !> 
  !>     @param[in]
  !>     AP      device array of device pointers storing each matrix A_i on the GPU.
  !>             A_i is m by m if side == HIPBLAS_SIDE_LEFT
  !>             A_i is n by n if side == HIPBLAS_SIDE_RIGHT
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
  !>             otherwise lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     BP       device array of device pointers storing each matrix B_i on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B_i. ldb >= max( 1, m )
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C_i need not be set before entry.
  !> 
  !>     @param[in]
  !>     CP       device array of device pointers storing each matrix C_i on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C_i. ldc >= max( 1, m )
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface hipblasSsymmBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsymmBatched_(handle,side,uplo,m,n,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasSsymmBatched")
#else
    function hipblasSsymmBatched_(handle,side,uplo,m,n,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasSsymmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasDsymmBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsymmBatched_(handle,side,uplo,m,n,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasDsymmBatched")
#else
    function hipblasDsymmBatched_(handle,side,uplo,m,n,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasDsymmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCsymmBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsymmBatched_(handle,side,uplo,m,n,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasCsymmBatched")
#else
    function hipblasCsymmBatched_(handle,side,uplo,m,n,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasCsymmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZsymmBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsymmBatched_(handle,side,uplo,m,n,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasZsymmBatched")
#else
    function hipblasZsymmBatched_(handle,side,uplo,m,n,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasZsymmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCsymmBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsymmBatched_v2_(handle,side,uplo,m,n,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasCsymmBatched_v2")
#else
    function hipblasCsymmBatched_v2_(handle,side,uplo,m,n,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasCsymmBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymmBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZsymmBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZsymmBatched_v2_(handle,side,uplo,m,n,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasZsymmBatched_v2")
#else
    function hipblasZsymmBatched_v2_(handle,side,uplo,m,n,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasZsymmBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymmBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     symmStridedBatched performs a batch of the matrix-matrix operations:
  !> 
  !>     C_i := alphaA_iB_i + betaC_i if side == HIPBLAS_SIDE_LEFT,
  !>     C_i := alphaB_iA_i + betaC_i if side == HIPBLAS_SIDE_RIGHT,
  !> 
  !>     where alpha and beta are scalars, B_i and C_i are m by n matrices, and
  !>     A_i is a symmetric matrix stored as either upper or lower.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     side  [hipblasSideMode_t]
  !>             HIPBLAS_SIDE_LEFT:      C_i := alphaA_iB_i + betaC_i
  !>             HIPBLAS_SIDE_RIGHT:     C_i := alphaB_iA_i + betaC_i
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     m       [int]
  !>             m specifies the number of rows of B_i and C_i. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of columns of B_i and C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A_i and B_i are not referenced.
  !> 
  !>     @param[in]
  !>     AP       device pointer to first matrix A_1
  !>             A_i is m by m if side == HIPBLAS_SIDE_LEFT
  !>             A_i is n by n if side == HIPBLAS_SIDE_RIGHT
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
  !>             otherwise lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     BP       device pointer to first matrix B_1 of dimension (ldb, n) on the GPU.
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B_i. ldb >= max( 1, m )
  !> 
  !>     @param[in]
  !>     strideB  [hipblasStride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     CP        device pointer to first matrix C_1 of dimension (ldc, n) on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, m ).
  !> 
  !>     @param[inout]
  !>     strideC  [hipblasStride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface hipblasSsymmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsymmStridedBatched_(handle,side,uplo,m,n,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasSsymmStridedBatched")
#else
    function hipblasSsymmStridedBatched_(handle,side,uplo,m,n,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasSsymmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_float) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasDsymmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsymmStridedBatched_(handle,side,uplo,m,n,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasDsymmStridedBatched")
#else
    function hipblasDsymmStridedBatched_(handle,side,uplo,m,n,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasDsymmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_double) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCsymmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsymmStridedBatched_(handle,side,uplo,m,n,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasCsymmStridedBatched")
#else
    function hipblasCsymmStridedBatched_(handle,side,uplo,m,n,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasCsymmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      complex(c_float_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZsymmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsymmStridedBatched_(handle,side,uplo,m,n,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasZsymmStridedBatched")
#else
    function hipblasZsymmStridedBatched_(handle,side,uplo,m,n,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasZsymmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      complex(c_double_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCsymmStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsymmStridedBatched_v2_(handle,side,uplo,m,n,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasCsymmStridedBatched_v2")
#else
    function hipblasCsymmStridedBatched_v2_(handle,side,uplo,m,n,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasCsymmStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymmStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      complex(c_float_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZsymmStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZsymmStridedBatched_v2_(handle,side,uplo,m,n,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasZsymmStridedBatched_v2")
#else
    function hipblasZsymmStridedBatched_v2_(handle,side,uplo,m,n,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasZsymmStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymmStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      complex(c_double_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syrk performs one of the matrix-matrix operations for a symmetric rank-k update
  !> 
  !>     C := alphaop( A )op( A )^T + betaC
  !> 
  !>     where  alpha and beta are scalars, op(A) is an n by k matrix, and
  !>     C is a symmetric n x n matrix stored as either upper or lower.
  !> 
  !>         op( A ) = A, and A is n by k if transA == HIPBLAS_OP_N
  !>         op( A ) = A^T and A is k by n if transA == HIPBLAS_OP_T
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_T: op(A) = A^T
  !>             HIPBLAS_OP_N: op(A) = A
  !>             HIPBLAS_OP_C: op(A) = A^T
  !> 
  !>             HIPBLAS_OP_C is not supported for complex types, see cherk
  !>             and zherk.
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     AP       pointer storing matrix A on the GPU.
  !>             Martrix dimension is ( lda, k ) when if transA = HIPBLAS_OP_N, otherwise (lda, n)
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A.
  !>             if transA = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     CP       pointer storing matrix C on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     
  interface hipblasSsyrk
#ifdef USE_CUDA_NAMES
    function hipblasSsyrk_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc) bind(c, name="cublasSsyrk_v2")
#else
    function hipblasSsyrk_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc) bind(c, name="hipblasSsyrk")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrk_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      real(c_float) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasDsyrk
#ifdef USE_CUDA_NAMES
    function hipblasDsyrk_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc) bind(c, name="cublasDsyrk_v2")
#else
    function hipblasDsyrk_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc) bind(c, name="hipblasDsyrk")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrk_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      real(c_double) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasCsyrk
#ifdef USE_CUDA_NAMES
    function hipblasCsyrk_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc) bind(c, name="cublasCsyrk_v2")
#else
    function hipblasCsyrk_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc) bind(c, name="hipblasCsyrk")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrk_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasZsyrk
#ifdef USE_CUDA_NAMES
    function hipblasZsyrk_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc) bind(c, name="cublasZsyrk_v2")
#else
    function hipblasZsyrk_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc) bind(c, name="hipblasZsyrk")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrk_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasCsyrk_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsyrk_v2_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc) bind(c, name="cublasCsyrk_v2")
#else
    function hipblasCsyrk_v2_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc) bind(c, name="hipblasCsyrk_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrk_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasZsyrk_v2
#ifdef USE_CUDA_NAMES
    function hipblasZsyrk_v2_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc) bind(c, name="cublasZsyrk_v2")
#else
    function hipblasZsyrk_v2_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc) bind(c, name="hipblasZsyrk_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrk_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syrkBatched performs a batch of the matrix-matrix operations for a symmetric rank-k update
  !> 
  !>     C_i := alphaop( A_i )op( A_i )^T + betaC_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) is an n by k matrix, and
  !>     C_i is a symmetric n x n matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, and A_i is n by k if transA == HIPBLAS_OP_N
  !>         op( A_i ) = A_i^T and A_i is k by n if transA == HIPBLAS_OP_T
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_T: op(A) = A^T
  !>             HIPBLAS_OP_N: op(A) = A
  !>             HIPBLAS_OP_C: op(A) = A^T
  !> 
  !>             HIPBLAS_OP_C is not supported for complex types, see cherk
  !>             and zherk.
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     AP       device array of device pointers storing each matrix_i A of dimension (lda, k)
  !>             when transA is HIPBLAS_OP_N, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if transA = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     CP       device array of device pointers storing each matrix C_i on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface hipblasSsyrkBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsyrkBatched_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc,batchCount) bind(c, name="cublasSsyrkBatched")
#else
    function hipblasSsyrkBatched_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc,batchCount) bind(c, name="hipblasSsyrkBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrkBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      real(c_float) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasDsyrkBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsyrkBatched_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc,batchCount) bind(c, name="cublasDsyrkBatched")
#else
    function hipblasDsyrkBatched_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc,batchCount) bind(c, name="hipblasDsyrkBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrkBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      real(c_double) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCsyrkBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsyrkBatched_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc,batchCount) bind(c, name="cublasCsyrkBatched")
#else
    function hipblasCsyrkBatched_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc,batchCount) bind(c, name="hipblasCsyrkBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZsyrkBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsyrkBatched_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc,batchCount) bind(c, name="cublasZsyrkBatched")
#else
    function hipblasZsyrkBatched_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc,batchCount) bind(c, name="hipblasZsyrkBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCsyrkBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsyrkBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc,batchCount) bind(c, name="cublasCsyrkBatched_v2")
#else
    function hipblasCsyrkBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc,batchCount) bind(c, name="hipblasCsyrkBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZsyrkBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZsyrkBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc,batchCount) bind(c, name="cublasZsyrkBatched_v2")
#else
    function hipblasZsyrkBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,beta,CP,ldc,batchCount) bind(c, name="hipblasZsyrkBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syrkStridedBatched performs a batch of the matrix-matrix operations for a symmetric rank-k update
  !> 
  !>     C_i := alphaop( A_i )op( A_i )^T + betaC_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) is an n by k matrix, and
  !>     C_i is a symmetric n x n matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, and A_i is n by k if transA == HIPBLAS_OP_N
  !>         op( A_i ) = A_i^T and A_i is k by n if transA == HIPBLAS_OP_T
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_T: op(A) = A^T
  !>             HIPBLAS_OP_N: op(A) = A
  !>             HIPBLAS_OP_C: op(A) = A^T
  !> 
  !>             HIPBLAS_OP_C is not supported for complex types, see cherk
  !>             and zherk.
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     AP       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
  !>             when transA is HIPBLAS_OP_N, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if transA = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     CP       Device pointer to the first matrix C_1 on the GPU. on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     strideC  [hipblasStride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface hipblasSsyrkStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsyrkStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasSsyrkStridedBatched")
#else
    function hipblasSsyrkStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasSsyrkStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrkStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_float) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasDsyrkStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsyrkStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasDsyrkStridedBatched")
#else
    function hipblasDsyrkStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasDsyrkStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrkStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_double) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCsyrkStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsyrkStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasCsyrkStridedBatched")
#else
    function hipblasCsyrkStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasCsyrkStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      complex(c_float_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZsyrkStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsyrkStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasZsyrkStridedBatched")
#else
    function hipblasZsyrkStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasZsyrkStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      complex(c_double_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCsyrkStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsyrkStridedBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasCsyrkStridedBatched_v2")
#else
    function hipblasCsyrkStridedBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasCsyrkStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      complex(c_float_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZsyrkStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZsyrkStridedBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasZsyrkStridedBatched_v2")
#else
    function hipblasZsyrkStridedBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasZsyrkStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      complex(c_double_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syr2k performs one of the matrix-matrix operations for a symmetric rank-2k update
  !> 
  !>     C := alpha(op( A )op( B )^T + op( B )op( A )^T) + betaC
  !> 
  !>     where  alpha and beta are scalars, op(A) and op(B) are n by k matrix, and
  !>     C is a symmetric n x n matrix stored as either upper or lower.
  !> 
  !>         op( A ) = A, op( B ) = B, and A and B are n by k if trans == HIPBLAS_OP_N
  !>         op( A ) = A^T, op( B ) = B^T,  and A and B are k by n if trans == HIPBLAS_OP_T
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_T:      op( A ) = A^T, op( B ) = B^T
  !>             HIPBLAS_OP_N:           op( A ) = A, op( B ) = B
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A) and op(B). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     AP       pointer storing matrix A on the GPU.
  !>             Martrix dimension is ( lda, k ) when if trans = HIPBLAS_OP_N, otherwise (lda, n)
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A.
  !>             if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !>     @param[in]
  !>     BP       pointer storing matrix B on the GPU.
  !>             Martrix dimension is ( ldb, k ) when if trans = HIPBLAS_OP_N, otherwise (ldb, n)
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B.
  !>             if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     CP       pointer storing matrix C on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     
  interface hipblasSsyr2k
#ifdef USE_CUDA_NAMES
    function hipblasSsyr2k_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasSsyr2k_v2")
#else
    function hipblasSsyr2k_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasSsyr2k")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2k_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasDsyr2k
#ifdef USE_CUDA_NAMES
    function hipblasDsyr2k_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasDsyr2k_v2")
#else
    function hipblasDsyr2k_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasDsyr2k")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2k_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasCsyr2k
#ifdef USE_CUDA_NAMES
    function hipblasCsyr2k_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasCsyr2k_v2")
#else
    function hipblasCsyr2k_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasCsyr2k")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2k_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasZsyr2k
#ifdef USE_CUDA_NAMES
    function hipblasZsyr2k_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasZsyr2k_v2")
#else
    function hipblasZsyr2k_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasZsyr2k")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2k_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasCsyr2k_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsyr2k_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasCsyr2k_v2")
#else
    function hipblasCsyr2k_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasCsyr2k_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2k_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasZsyr2k_v2
#ifdef USE_CUDA_NAMES
    function hipblasZsyr2k_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasZsyr2k_v2")
#else
    function hipblasZsyr2k_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasZsyr2k_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2k_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syr2kBatched performs a batch of the matrix-matrix operations for a symmetric rank-2k update
  !> 
  !>     C_i := alpha(op( A_i )op( B_i )^T + op( B_i )op( A_i )^T) + betaC_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and
  !>     C_i is a symmetric n x n matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
  !>         op( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == HIPBLAS_OP_T
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_T:      op( A_i ) = A_i^T, op( B_i ) = B_i^T
  !>             HIPBLAS_OP_N:           op( A_i ) = A_i, op( B_i ) = B_i
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     AP       device array of device pointers storing each matrix_i A of dimension (lda, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !>     @param[in]
  !>     BP      device array of device pointers storing each matrix_i B of dimension (ldb, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B.
  !>             if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     CP      device array of device pointers storing each matrix C_i on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface hipblasSsyr2kBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsyr2kBatched_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasSsyr2kBatched")
#else
    function hipblasSsyr2kBatched_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasSsyr2kBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2kBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasDsyr2kBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsyr2kBatched_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasDsyr2kBatched")
#else
    function hipblasDsyr2kBatched_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasDsyr2kBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2kBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCsyr2kBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsyr2kBatched_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasCsyr2kBatched")
#else
    function hipblasCsyr2kBatched_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasCsyr2kBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2kBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZsyr2kBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsyr2kBatched_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasZsyr2kBatched")
#else
    function hipblasZsyr2kBatched_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasZsyr2kBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2kBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCsyr2kBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsyr2kBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasCsyr2kBatched_v2")
#else
    function hipblasCsyr2kBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasCsyr2kBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2kBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZsyr2kBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZsyr2kBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasZsyr2kBatched_v2")
#else
    function hipblasZsyr2kBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasZsyr2kBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2kBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syr2kStridedBatched performs a batch of the matrix-matrix operations for a symmetric rank-2k update
  !> 
  !>     C_i := alpha(op( A_i )op( B_i )^T + op( B_i )op( A_i )^T) + betaC_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and
  !>     C_i is a symmetric n x n matrix stored as either upper or lower.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
  !>         op( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == HIPBLAS_OP_T
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_T:      op( A_i ) = A_i^T, op( B_i ) = B_i^T
  !>             HIPBLAS_OP_N:           op( A_i ) = A_i, op( B_i ) = B_i
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     AP       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     BP       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B_i.
  !>             if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     strideB  [hipblasStride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     CP       Device pointer to the first matrix C_1 on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     strideC  [hipblasStride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface hipblasSsyr2kStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsyr2kStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasSsyr2kStridedBatched")
#else
    function hipblasSsyr2kStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasSsyr2kStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2kStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_float) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasDsyr2kStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsyr2kStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasDsyr2kStridedBatched")
#else
    function hipblasDsyr2kStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasDsyr2kStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2kStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_double) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCsyr2kStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsyr2kStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasCsyr2kStridedBatched")
#else
    function hipblasCsyr2kStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasCsyr2kStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2kStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      complex(c_float_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZsyr2kStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsyr2kStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasZsyr2kStridedBatched")
#else
    function hipblasZsyr2kStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasZsyr2kStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2kStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      complex(c_double_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCsyr2kStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsyr2kStridedBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasCsyr2kStridedBatched_v2")
#else
    function hipblasCsyr2kStridedBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasCsyr2kStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2kStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      complex(c_float_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZsyr2kStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZsyr2kStridedBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasZsyr2kStridedBatched_v2")
#else
    function hipblasZsyr2kStridedBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasZsyr2kStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2kStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      complex(c_double_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syrkx performs one of the matrix-matrix operations for a symmetric rank-k update
  !> 
  !>     C := alphaop( A )op( B )^T + betaC
  !> 
  !>     where  alpha and beta are scalars, op(A) and op(B) are n by k matrix, and
  !>     C is a symmetric n x n matrix stored as either upper or lower.
  !>     This routine should only be used when the caller can guarantee that the result of op( A )op( B )^T will be symmetric.
  !> 
  !>         op( A ) = A, op( B ) = B, and A and B are n by k if trans == HIPBLAS_OP_N
  !>         op( A ) = A^T, op( B ) = B^T,  and A and B are k by n if trans == HIPBLAS_OP_T
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_T:      op( A ) = A^T, op( B ) = B^T
  !>             HIPBLAS_OP_N:           op( A ) = A, op( B ) = B
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A) and op(B). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     AP       pointer storing matrix A on the GPU.
  !>             Martrix dimension is ( lda, k ) when if trans = HIPBLAS_OP_N, otherwise (lda, n)
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A.
  !>             if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     BP       pointer storing matrix B on the GPU.
  !>             Martrix dimension is ( ldb, k ) when if trans = HIPBLAS_OP_N, otherwise (ldb, n)
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B.
  !>             if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     CP       pointer storing matrix C on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     
  interface hipblasSsyrkx
#ifdef USE_CUDA_NAMES
    function hipblasSsyrkx_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasSsyrkx")
#else
    function hipblasSsyrkx_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasSsyrkx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrkx_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasDsyrkx
#ifdef USE_CUDA_NAMES
    function hipblasDsyrkx_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasDsyrkx")
#else
    function hipblasDsyrkx_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasDsyrkx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrkx_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasCsyrkx
#ifdef USE_CUDA_NAMES
    function hipblasCsyrkx_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasCsyrkx")
#else
    function hipblasCsyrkx_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasCsyrkx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkx_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasZsyrkx
#ifdef USE_CUDA_NAMES
    function hipblasZsyrkx_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasZsyrkx")
#else
    function hipblasZsyrkx_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasZsyrkx")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkx_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasCsyrkx_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsyrkx_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasCsyrkx_v2")
#else
    function hipblasCsyrkx_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasCsyrkx_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkx_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasZsyrkx_v2
#ifdef USE_CUDA_NAMES
    function hipblasZsyrkx_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasZsyrkx_v2")
#else
    function hipblasZsyrkx_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasZsyrkx_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkx_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syrkxBatched performs a batch of the matrix-matrix operations for a symmetric rank-k update
  !> 
  !>     C_i := alphaop( A_i )op( B_i )^T + betaC_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and
  !>     C_i is a symmetric n x n matrix stored as either upper or lower.
  !>     This routine should only be used when the caller can guarantee that the result of op( A_i )op( B_i )^T will be symmetric.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
  !>         op( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == HIPBLAS_OP_T
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_T:      op( A_i ) = A_i^T, op( B_i ) = B_i^T
  !>             HIPBLAS_OP_N:           op( A_i ) = A_i, op( B_i ) = B_i
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     AP       device array of device pointers storing each matrix_i A of dimension (lda, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     BP       device array of device pointers storing each matrix_i B of dimension (ldb, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B.
  !>             if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     CP       device array of device pointers storing each matrix C_i on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>             number of instances in the batch.
  !> 
  !>     
  interface hipblasSsyrkxBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsyrkxBatched_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasSsyrkxBatched")
#else
    function hipblasSsyrkxBatched_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasSsyrkxBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrkxBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      real(c_float) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasDsyrkxBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsyrkxBatched_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasDsyrkxBatched")
#else
    function hipblasDsyrkxBatched_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasDsyrkxBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrkxBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      real(c_double) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCsyrkxBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsyrkxBatched_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasCsyrkxBatched")
#else
    function hipblasCsyrkxBatched_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasCsyrkxBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkxBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZsyrkxBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsyrkxBatched_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasZsyrkxBatched")
#else
    function hipblasZsyrkxBatched_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasZsyrkxBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkxBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCsyrkxBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsyrkxBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasCsyrkxBatched_v2")
#else
    function hipblasCsyrkxBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasCsyrkxBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkxBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZsyrkxBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZsyrkxBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasZsyrkxBatched_v2")
#else
    function hipblasZsyrkxBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasZsyrkxBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkxBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     syrkxStridedBatched performs a batch of the matrix-matrix operations for a symmetric rank-k update
  !> 
  !>     C_i := alphaop( A_i )op( B_i )^T + betaC_i
  !> 
  !>     where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and
  !>     C_i is a symmetric n x n matrix stored as either upper or lower.
  !>     This routine should only be used when the caller can guarantee that the result of op( A_i )op( B_i )^T will be symmetric.
  !> 
  !>         op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
  !>         op( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == HIPBLAS_OP_T
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_T:      op( A_i ) = A_i^T, op( B_i ) = B_i^T
  !>             HIPBLAS_OP_N:           op( A_i ) = A_i, op( B_i ) = B_i
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows and columns of C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of op(A). k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and A need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     AP       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
  !>             otherwise lda >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     BP       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)
  !>             when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B_i.
  !>             if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
  !>             otherwise ldb >= max( 1, k ).
  !> 
  !>     @param[in]
  !>     strideB  [hipblasStride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     CP       Device pointer to the first matrix C_1 on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     strideC  [hipblasStride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface hipblasSsyrkxStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSsyrkxStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasSsyrkxStridedBatched")
#else
    function hipblasSsyrkxStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasSsyrkxStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrkxStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_float) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasDsyrkxStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDsyrkxStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasDsyrkxStridedBatched")
#else
    function hipblasDsyrkxStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasDsyrkxStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrkxStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      real(c_double) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCsyrkxStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCsyrkxStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasCsyrkxStridedBatched")
#else
    function hipblasCsyrkxStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasCsyrkxStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkxStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      complex(c_float_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZsyrkxStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZsyrkxStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasZsyrkxStridedBatched")
#else
    function hipblasZsyrkxStridedBatched_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasZsyrkxStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkxStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      complex(c_double_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCsyrkxStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCsyrkxStridedBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasCsyrkxStridedBatched_v2")
#else
    function hipblasCsyrkxStridedBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasCsyrkxStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrkxStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      complex(c_float_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZsyrkxStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZsyrkxStridedBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasZsyrkxStridedBatched_v2")
#else
    function hipblasZsyrkxStridedBatched_v2_(handle,uplo,transA,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasZsyrkxStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrkxStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      complex(c_double_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     geam performs one of the matrix-matrix operations
  !> 
  !>         C = alphaop( A ) + betaop( B ),
  !> 
  !>     where op( X ) is one of
  !> 
  !>         op( X ) = X      or
  !>         op( X ) = XT   or
  !>         op( X ) = XH,
  !> 
  !>     alpha and beta are scalars, and A, B and C are matrices, with
  !>     op( A ) an m by n matrix, op( B ) an m by n matrix, and C an m by n matrix.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     transA    [hipblasOperation_t]
  !>               specifies the form of op( A )
  !>     @param[in]
  !>     transB    [hipblasOperation_t]
  !>               specifies the form of op( B )
  !>     @param[in]
  !>     m         [int]
  !>               matrix dimension m.
  !>     @param[in]
  !>     n         [int]
  !>               matrix dimension n.
  !>     @param[in]
  !>     alpha     device pointer or host pointer specifying the scalar alpha.
  !>     @param[in]
  !>     AP         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A.
  !>     @param[in]
  !>     beta      device pointer or host pointer specifying the scalar beta.
  !>     @param[in]
  !>     BP         device pointer storing matrix B.
  !>     @param[in]
  !>     ldb       [int]
  !>               specifies the leading dimension of B.
  !>     @param[in, out]
  !>     CP         device pointer storing matrix C.
  !>     @param[in]
  !>     ldc       [int]
  !>               specifies the leading dimension of C.
  !> 
  !>     
  interface hipblasSgeam
#ifdef USE_CUDA_NAMES
    function hipblasSgeam_(handle,transA,transB,m,n,alpha,AP,lda,beta,BP,ldb,CP,ldc) bind(c, name="cublasSgeam")
#else
    function hipblasSgeam_(handle,transA,transB,m,n,alpha,AP,lda,beta,BP,ldb,CP,ldc) bind(c, name="hipblasSgeam")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeam_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      real(c_float) :: beta
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasDgeam
#ifdef USE_CUDA_NAMES
    function hipblasDgeam_(handle,transA,transB,m,n,alpha,AP,lda,beta,BP,ldb,CP,ldc) bind(c, name="cublasDgeam")
#else
    function hipblasDgeam_(handle,transA,transB,m,n,alpha,AP,lda,beta,BP,ldb,CP,ldc) bind(c, name="hipblasDgeam")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeam_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      real(c_double) :: beta
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasCgeam
#ifdef USE_CUDA_NAMES
    function hipblasCgeam_(handle,transA,transB,m,n,alpha,AP,lda,beta,BP,ldb,CP,ldc) bind(c, name="cublasCgeam")
#else
    function hipblasCgeam_(handle,transA,transB,m,n,alpha,AP,lda,beta,BP,ldb,CP,ldc) bind(c, name="hipblasCgeam")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeam_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasZgeam
#ifdef USE_CUDA_NAMES
    function hipblasZgeam_(handle,transA,transB,m,n,alpha,AP,lda,beta,BP,ldb,CP,ldc) bind(c, name="cublasZgeam")
#else
    function hipblasZgeam_(handle,transA,transB,m,n,alpha,AP,lda,beta,BP,ldb,CP,ldc) bind(c, name="hipblasZgeam")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeam_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasCgeam_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgeam_v2_(handle,transA,transB,m,n,alpha,AP,lda,beta,BP,ldb,CP,ldc) bind(c, name="cublasCgeam_v2")
#else
    function hipblasCgeam_v2_(handle,transA,transB,m,n,alpha,AP,lda,beta,BP,ldb,CP,ldc) bind(c, name="hipblasCgeam_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeam_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasZgeam_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgeam_v2_(handle,transA,transB,m,n,alpha,AP,lda,beta,BP,ldb,CP,ldc) bind(c, name="cublasZgeam_v2")
#else
    function hipblasZgeam_v2_(handle,transA,transB,m,n,alpha,AP,lda,beta,BP,ldb,CP,ldc) bind(c, name="hipblasZgeam_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeam_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     geamBatched performs one of the batched matrix-matrix operations
  !> 
  !>         C_i = alphaop( A_i ) + betaop( B_i )  for i = 0, 1, ... batchCount - 1
  !> 
  !>     where alpha and beta are scalars, and op(A_i), op(B_i) and C_i are m by n matrices
  !>     and op( X ) is one of
  !> 
  !>         op( X ) = X      or
  !>         op( X ) = XT
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     transA    [hipblasOperation_t]
  !>               specifies the form of op( A )
  !>     @param[in]
  !>     transB    [hipblasOperation_t]
  !>               specifies the form of op( B )
  !>     @param[in]
  !>     m         [int]
  !>               matrix dimension m.
  !>     @param[in]
  !>     n         [int]
  !>               matrix dimension n.
  !>     @param[in]
  !>     alpha     device pointer or host pointer specifying the scalar alpha.
  !>     @param[in]
  !>     AP         device array of device pointers storing each matrix A_i on the GPU.
  !>               Each A_i is of dimension ( lda, k ), where k is m
  !>               when  transA == HIPBLAS_OP_N and
  !>               is  n  when  transA == HIPBLAS_OP_T.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A.
  !>     @param[in]
  !>     beta      device pointer or host pointer specifying the scalar beta.
  !>     @param[in]
  !>     BP         device array of device pointers storing each matrix B_i on the GPU.
  !>               Each B_i is of dimension ( ldb, k ), where k is m
  !>               when  transB == HIPBLAS_OP_N and
  !>               is  n  when  transB == HIPBLAS_OP_T.
  !>     @param[in]
  !>     ldb       [int]
  !>               specifies the leading dimension of B.
  !>     @param[in, out]
  !>     CP         device array of device pointers storing each matrix C_i on the GPU.
  !>               Each C_i is of dimension ( ldc, n ).
  !>     @param[in]
  !>     ldc       [int]
  !>               specifies the leading dimension of C.
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances i in the batch.
  !> 
  !>     
  interface hipblasSgeamBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgeamBatched_(handle,transA,transB,m,n,alpha,AP,lda,beta,BP,ldb,CP,ldc,batchCount) bind(c, name="cublasSgeamBatched")
#else
    function hipblasSgeamBatched_(handle,transA,transB,m,n,alpha,AP,lda,beta,BP,ldb,CP,ldc,batchCount) bind(c, name="hipblasSgeamBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeamBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      real(c_float) :: beta
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasDgeamBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgeamBatched_(handle,transA,transB,m,n,alpha,AP,lda,beta,BP,ldb,CP,ldc,batchCount) bind(c, name="cublasDgeamBatched")
#else
    function hipblasDgeamBatched_(handle,transA,transB,m,n,alpha,AP,lda,beta,BP,ldb,CP,ldc,batchCount) bind(c, name="hipblasDgeamBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeamBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      real(c_double) :: beta
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCgeamBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgeamBatched_(handle,transA,transB,m,n,alpha,AP,lda,beta,BP,ldb,CP,ldc,batchCount) bind(c, name="cublasCgeamBatched")
#else
    function hipblasCgeamBatched_(handle,transA,transB,m,n,alpha,AP,lda,beta,BP,ldb,CP,ldc,batchCount) bind(c, name="hipblasCgeamBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeamBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZgeamBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgeamBatched_(handle,transA,transB,m,n,alpha,AP,lda,beta,BP,ldb,CP,ldc,batchCount) bind(c, name="cublasZgeamBatched")
#else
    function hipblasZgeamBatched_(handle,transA,transB,m,n,alpha,AP,lda,beta,BP,ldb,CP,ldc,batchCount) bind(c, name="hipblasZgeamBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeamBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCgeamBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgeamBatched_v2_(handle,transA,transB,m,n,alpha,AP,lda,beta,BP,ldb,CP,ldc,batchCount) bind(c, name="cublasCgeamBatched_v2")
#else
    function hipblasCgeamBatched_v2_(handle,transA,transB,m,n,alpha,AP,lda,beta,BP,ldb,CP,ldc,batchCount) bind(c, name="hipblasCgeamBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeamBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      complex(c_float_complex) :: beta
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZgeamBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgeamBatched_v2_(handle,transA,transB,m,n,alpha,AP,lda,beta,BP,ldb,CP,ldc,batchCount) bind(c, name="cublasZgeamBatched_v2")
#else
    function hipblasZgeamBatched_v2_(handle,transA,transB,m,n,alpha,AP,lda,beta,BP,ldb,CP,ldc,batchCount) bind(c, name="hipblasZgeamBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeamBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      complex(c_double_complex) :: beta
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     geamStridedBatched performs one of the batched matrix-matrix operations
  !> 
  !>         C_i = alphaop( A_i ) + betaop( B_i )  for i = 0, 1, ... batchCount - 1
  !> 
  !>     where alpha and beta are scalars, and op(A_i), op(B_i) and C_i are m by n matrices
  !>     and op( X ) is one of
  !> 
  !>         op( X ) = X      or
  !>         op( X ) = XT
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     transA    [hipblasOperation_t]
  !>               specifies the form of op( A )
  !> 
  !>     @param[in]
  !>     transB    [hipblasOperation_t]
  !>               specifies the form of op( B )
  !> 
  !>     @param[in]
  !>     m         [int]
  !>               matrix dimension m.
  !> 
  !>     @param[in]
  !>     n         [int]
  !>               matrix dimension n.
  !> 
  !>     @param[in]
  !>     alpha     device pointer or host pointer specifying the scalar alpha.
  !> 
  !>     @param[in]
  !>     AP         device pointer to the first matrix A_0 on the GPU.
  !>               Each A_i is of dimension ( lda, k ), where k is m
  !>               when  transA == HIPBLAS_OP_N and
  !>               is  n  when  transA == HIPBLAS_OP_T.
  !> 
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A.
  !> 
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     beta      device pointer or host pointer specifying the scalar beta.
  !> 
  !>     @param[in]
  !>     BP         pointer to the first matrix B_0 on the GPU.
  !>               Each B_i is of dimension ( ldb, k ), where k is m
  !>               when  transB == HIPBLAS_OP_N and
  !>               is  n  when  transB == HIPBLAS_OP_T.
  !> 
  !>     @param[in]
  !>     ldb       [int]
  !>               specifies the leading dimension of B.
  !> 
  !>     @param[in]
  !>     strideB  [hipblasStride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !> 
  !>     @param[in, out]
  !>     CP         pointer to the first matrix C_0 on the GPU.
  !>               Each C_i is of dimension ( ldc, n ).
  !> 
  !>     @param[in]
  !>     ldc       [int]
  !>               specifies the leading dimension of C.
  !> 
  !>     @param[in]
  !>     strideC  [hipblasStride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances i in the batch.
  !> 
  !>     
  interface hipblasSgeamStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgeamStridedBatched_(handle,transA,transB,m,n,alpha,AP,lda,strideA,beta,BP,ldb,strideB,CP,ldc,strideC,batchCount) bind(c, name="cublasSgeamStridedBatched")
#else
    function hipblasSgeamStridedBatched_(handle,transA,transB,m,n,alpha,AP,lda,strideA,beta,BP,ldb,strideB,CP,ldc,strideC,batchCount) bind(c, name="hipblasSgeamStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeamStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_float) :: beta
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasDgeamStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgeamStridedBatched_(handle,transA,transB,m,n,alpha,AP,lda,strideA,beta,BP,ldb,strideB,CP,ldc,strideC,batchCount) bind(c, name="cublasDgeamStridedBatched")
#else
    function hipblasDgeamStridedBatched_(handle,transA,transB,m,n,alpha,AP,lda,strideA,beta,BP,ldb,strideB,CP,ldc,strideC,batchCount) bind(c, name="hipblasDgeamStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeamStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      real(c_double) :: beta
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCgeamStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgeamStridedBatched_(handle,transA,transB,m,n,alpha,AP,lda,strideA,beta,BP,ldb,strideB,CP,ldc,strideC,batchCount) bind(c, name="cublasCgeamStridedBatched")
#else
    function hipblasCgeamStridedBatched_(handle,transA,transB,m,n,alpha,AP,lda,strideA,beta,BP,ldb,strideB,CP,ldc,strideC,batchCount) bind(c, name="hipblasCgeamStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeamStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      complex(c_float_complex) :: beta
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZgeamStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgeamStridedBatched_(handle,transA,transB,m,n,alpha,AP,lda,strideA,beta,BP,ldb,strideB,CP,ldc,strideC,batchCount) bind(c, name="cublasZgeamStridedBatched")
#else
    function hipblasZgeamStridedBatched_(handle,transA,transB,m,n,alpha,AP,lda,strideA,beta,BP,ldb,strideB,CP,ldc,strideC,batchCount) bind(c, name="hipblasZgeamStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeamStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      complex(c_double_complex) :: beta
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCgeamStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgeamStridedBatched_v2_(handle,transA,transB,m,n,alpha,AP,lda,strideA,beta,BP,ldb,strideB,CP,ldc,strideC,batchCount) bind(c, name="cublasCgeamStridedBatched_v2")
#else
    function hipblasCgeamStridedBatched_v2_(handle,transA,transB,m,n,alpha,AP,lda,strideA,beta,BP,ldb,strideB,CP,ldc,strideC,batchCount) bind(c, name="hipblasCgeamStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeamStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      complex(c_float_complex) :: beta
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZgeamStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgeamStridedBatched_v2_(handle,transA,transB,m,n,alpha,AP,lda,strideA,beta,BP,ldb,strideB,CP,ldc,strideC,batchCount) bind(c, name="cublasZgeamStridedBatched_v2")
#else
    function hipblasZgeamStridedBatched_v2_(handle,transA,transB,m,n,alpha,AP,lda,strideA,beta,BP,ldb,strideB,CP,ldc,strideC,batchCount) bind(c, name="hipblasZgeamStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeamStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      complex(c_double_complex) :: beta
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     hemm performs one of the matrix-matrix operations:
  !> 
  !>     C := alphaAB + betaC if side == HIPBLAS_SIDE_LEFT,
  !>     C := alphaBA + betaC if side == HIPBLAS_SIDE_RIGHT,
  !> 
  !>     where alpha and beta are scalars, B and C are m by n matrices, and
  !>     A is a Hermitian matrix stored as either upper or lower.
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     side  [hipblasSideMode_t]
  !>             HIPBLAS_SIDE_LEFT:      C := alphaAB + betaC
  !>             HIPBLAS_SIDE_RIGHT:     C := alphaBA + betaC
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows of B and C. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             n specifies the number of columns of B and C. k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A and B are not referenced.
  !> 
  !>     @param[in]
  !>     AP       pointer storing matrix A on the GPU.
  !>             A is m by m if side == HIPBLAS_SIDE_LEFT
  !>             A is n by n if side == HIPBLAS_SIDE_RIGHT
  !>             Only the upperlower triangular part is accessed.
  !>             The imaginary component of the diagonal elements is not used.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A.
  !>             if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
  !>             otherwise lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     BP       pointer storing matrix B on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B. ldb >= max( 1, m )
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     CP       pointer storing matrix C on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, m )
  !> 
  !>     
  interface hipblasChemm
#ifdef USE_CUDA_NAMES
    function hipblasChemm_(handle,side,uplo,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasChemm_v2")
#else
    function hipblasChemm_(handle,side,uplo,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasChemm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasZhemm
#ifdef USE_CUDA_NAMES
    function hipblasZhemm_(handle,side,uplo,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasZhemm_v2")
#else
    function hipblasZhemm_(handle,side,uplo,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasZhemm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasChemm_v2
#ifdef USE_CUDA_NAMES
    function hipblasChemm_v2_(handle,side,uplo,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasChemm_v2")
#else
    function hipblasChemm_v2_(handle,side,uplo,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasChemm_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemm_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  
  interface hipblasZhemm_v2
#ifdef USE_CUDA_NAMES
    function hipblasZhemm_v2_(handle,side,uplo,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="cublasZhemm_v2")
#else
    function hipblasZhemm_v2_(handle,side,uplo,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc) bind(c, name="hipblasZhemm_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemm_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     hemmBatched performs a batch of the matrix-matrix operations:
  !> 
  !>     C_i := alphaA_iB_i + betaC_i if side == HIPBLAS_SIDE_LEFT,
  !>     C_i := alphaB_iA_i + betaC_i if side == HIPBLAS_SIDE_RIGHT,
  !> 
  !>     where alpha and beta are scalars, B_i and C_i are m by n matrices, and
  !>     A_i is a Hermitian matrix stored as either upper or lower.
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     side  [hipblasSideMode_t]
  !>             HIPBLAS_SIDE_LEFT:      C_i := alphaA_iB_i + betaC_i
  !>             HIPBLAS_SIDE_RIGHT:     C_i := alphaB_iA_i + betaC_i
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows of B_i and C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of B_i and C_i. k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A_i and B_i are not referenced.
  !> 
  !>     @param[in]
  !>     AP       device array of device pointers storing each matrix A_i on the GPU.
  !>             A_i is m by m if side == HIPBLAS_SIDE_LEFT
  !>             A_i is n by n if side == HIPBLAS_SIDE_RIGHT
  !>             Only the upperlower triangular part is accessed.
  !>             The imaginary component of the diagonal elements is not used.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
  !>             otherwise lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     BP       device array of device pointers storing each matrix B_i on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B_i. ldb >= max( 1, m )
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C_i need not be set before entry.
  !> 
  !>     @param[in]
  !>     CP       device array of device pointers storing each matrix C_i on the GPU.
  !>             Matrix dimension is m by n
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C_i. ldc >= max( 1, m )
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface hipblasChemmBatched
#ifdef USE_CUDA_NAMES
    function hipblasChemmBatched_(handle,side,uplo,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasChemmBatched")
#else
    function hipblasChemmBatched_(handle,side,uplo,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasChemmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZhemmBatched
#ifdef USE_CUDA_NAMES
    function hipblasZhemmBatched_(handle,side,uplo,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasZhemmBatched")
#else
    function hipblasZhemmBatched_(handle,side,uplo,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasZhemmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasChemmBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasChemmBatched_v2_(handle,side,uplo,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasChemmBatched_v2")
#else
    function hipblasChemmBatched_v2_(handle,side,uplo,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasChemmBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemmBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      complex(c_float_complex) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZhemmBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZhemmBatched_v2_(handle,side,uplo,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="cublasZhemmBatched_v2")
#else
    function hipblasZhemmBatched_v2_(handle,side,uplo,n,k,alpha,AP,lda,BP,ldb,beta,CP,ldc,batchCount) bind(c, name="hipblasZhemmBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemmBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      complex(c_double_complex) :: beta
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     hemmStridedBatched performs a batch of the matrix-matrix operations:
  !> 
  !>     C_i := alphaA_iB_i + betaC_i if side == HIPBLAS_SIDE_LEFT,
  !>     C_i := alphaB_iA_i + betaC_i if side == HIPBLAS_SIDE_RIGHT,
  !> 
  !>     where alpha and beta are scalars, B_i and C_i are m by n matrices, and
  !>     A_i is a Hermitian matrix stored as either upper or lower.
  !> 
  !>     - Supported precisions in rocBLAS : c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     side  [hipblasSideMode_t]
  !>             HIPBLAS_SIDE_LEFT:      C_i := alphaA_iB_i + betaC_i
  !>             HIPBLAS_SIDE_RIGHT:     C_i := alphaB_iA_i + betaC_i
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix
  !>             HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of rows of B_i and C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     k       [int]
  !>             k specifies the number of columns of B_i and C_i. k >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A_i and B_i are not referenced.
  !> 
  !>     @param[in]
  !>     AP       device pointer to first matrix A_1
  !>             A_i is m by m if side == HIPBLAS_SIDE_LEFT
  !>             A_i is n by n if side == HIPBLAS_SIDE_RIGHT
  !>             Only the upperlower triangular part is accessed.
  !>             The imaginary component of the diagonal elements is not used.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A_i.
  !>             if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
  !>             otherwise lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[in]
  !>     BP       device pointer to first matrix B_1 of dimension (ldb, n) on the GPU
  !> 
  !>     @param[in]
  !>     ldb     [int]
  !>             ldb specifies the first dimension of B_i.
  !>             if side = HIPBLAS_OP_N,  ldb >= max( 1, m ),
  !>             otherwise ldb >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     strideB  [hipblasStride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !> 
  !>     @param[in]
  !>     beta
  !>             beta specifies the scalar beta. When beta is
  !>             zero then C need not be set before entry.
  !> 
  !>     @param[in]
  !>     CP        device pointer to first matrix C_1 of dimension (ldc, n) on the GPU.
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, m )
  !> 
  !>     @param[inout]
  !>     strideC  [hipblasStride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch
  !> 
  !>     
  interface hipblasChemmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasChemmStridedBatched_(handle,side,uplo,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasChemmStridedBatched")
#else
    function hipblasChemmStridedBatched_(handle,side,uplo,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasChemmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      complex(c_float_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZhemmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZhemmStridedBatched_(handle,side,uplo,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasZhemmStridedBatched")
#else
    function hipblasZhemmStridedBatched_(handle,side,uplo,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasZhemmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      complex(c_double_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasChemmStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasChemmStridedBatched_v2_(handle,side,uplo,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasChemmStridedBatched_v2")
#else
    function hipblasChemmStridedBatched_v2_(handle,side,uplo,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasChemmStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemmStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      complex(c_float_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZhemmStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZhemmStridedBatched_v2_(handle,side,uplo,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="cublasZhemmStridedBatched_v2")
#else
    function hipblasZhemmStridedBatched_v2_(handle,side,uplo,n,k,alpha,AP,lda,strideA,BP,ldb,strideB,beta,CP,ldc,strideC,batchCount) bind(c, name="hipblasZhemmStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemmStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(c_int),value :: n
      integer(c_int),value :: k
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      complex(c_double_complex) :: beta
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     trmm performs one of the matrix-matrix operations
  !> 
  !>     C := alphaop( A )B,   or   C := alphaBop( A )
  !> 
  !>     where  alpha  is a scalar, B and C are an m by n matrices,  A  is a unit, or
  !>     non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
  !> 
  !>         op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.
  !> 
  !>     Note that trmm can provide in-place functionality by passing in the same address for both
  !>     matrices B and C and by setting ldb equal to ldc.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     side    [hipblasSideMode_t]
  !>             Specifies whether op(A) multiplies B from the left or right as follows:
  !>             HIPBLAS_SIDE_LEFT:       C := alphaop( A )B.
  !>             HIPBLAS_SIDE_RIGHT:      C := alphaBop( A ).
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             Specifies whether the matrix A is an upper or lower triangular matrix as follows:
  !>             HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             Specifies the form of op(A) to be used in the matrix multiplication as follows:
  !>             HIPBLAS_OP_N: op(A) = A.
  !>             HIPBLAS_OP_T: op(A) = A^T.
  !>             HIPBLAS_OP_C: op(A) = A^H.
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             Specifies whether or not A is unit triangular as follows:
  !>             HIPBLAS_DIAG_UNIT:      A is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m       [int]
  !>             m specifies the number of rows of B and C. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of columns of B and C. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A is not referenced and B need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device pointer to matrix A on the GPU.
  !>             A has dimension ( lda, k ), where k is m
  !>             when  side == HIPBLAS_SIDE_LEFT  and
  !>             is  n  when  side == HIPBLAS_SIDE_RIGHT.
  !> 
  !>         When uplo == HIPBLAS_FILL_MODE_UPPER the  leading  k by k
  !>         upper triangular part of the array  A must contain the upper
  !>         triangular matrix  and the strictly lower triangular part of
  !>         A is not referenced.
  !> 
  !>         When uplo == HIPBLAS_FILL_MODE_LOWER the  leading  k by k
  !>         lower triangular part of the array  A must contain the lower
  !>         triangular matrix  and the strictly upper triangular part of
  !>         A is not referenced.
  !> 
  !>         Note that when  diag == HIPBLAS_DIAG_UNIT  the diagonal elements of
  !>         A  are not referenced either,  but are assumed to be  unity.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A.
  !>             if side == HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
  !>             if side == HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     B       Device pointer to the matrix B of dimension (ldb, n) on the GPU.
  !> 
  !>     @param[in]
  !>     ldb    [int]
  !>            ldb specifies the first dimension of B. ldb >= max( 1, m ).
  !> 
  !>     @param[in]
  !>     C      Device pointer to the matrix C of dimension (ldc, n) on the GPU.
  !>            Users can pass in the same matrix B to parameter C to achieve
  !>            in-place functionality of trmm.
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C. ldc >= max( 1, m ).
  !> 
  !>     
  interface hipblasStrmm
#ifdef USE_CUDA_NAMES
    function hipblasStrmm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc) bind(c, name="cublasStrmm_v2")
#else
    function hipblasStrmm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc) bind(c, name="hipblasStrmm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasStrmm_full_rank,&
      
hipblasStrmm_rank_0,&
      
hipblasStrmm_rank_1
#endif

  end interface
  
  interface hipblasDtrmm
#ifdef USE_CUDA_NAMES
    function hipblasDtrmm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc) bind(c, name="cublasDtrmm_v2")
#else
    function hipblasDtrmm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc) bind(c, name="hipblasDtrmm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDtrmm_full_rank,&
      
hipblasDtrmm_rank_0,&
      
hipblasDtrmm_rank_1
#endif

  end interface
  
  interface hipblasCtrmm
#ifdef USE_CUDA_NAMES
    function hipblasCtrmm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc) bind(c, name="cublasCtrmm_v2")
#else
    function hipblasCtrmm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc) bind(c, name="hipblasCtrmm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtrmm_full_rank,&
      
hipblasCtrmm_rank_0,&
      
hipblasCtrmm_rank_1
#endif

  end interface
  
  interface hipblasZtrmm
#ifdef USE_CUDA_NAMES
    function hipblasZtrmm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc) bind(c, name="cublasZtrmm_v2")
#else
    function hipblasZtrmm_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc) bind(c, name="hipblasZtrmm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtrmm_full_rank,&
      
hipblasZtrmm_rank_0,&
      
hipblasZtrmm_rank_1
#endif

  end interface
  
  interface hipblasCtrmm_v2
#ifdef USE_CUDA_NAMES
    function hipblasCtrmm_v2_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc) bind(c, name="cublasCtrmm_v2")
#else
    function hipblasCtrmm_v2_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc) bind(c, name="hipblasCtrmm_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmm_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtrmm_v2_full_rank,&
      
hipblasCtrmm_v2_rank_0,&
      
hipblasCtrmm_v2_rank_1
#endif

  end interface
  
  interface hipblasZtrmm_v2
#ifdef USE_CUDA_NAMES
    function hipblasZtrmm_v2_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc) bind(c, name="cublasZtrmm_v2")
#else
    function hipblasZtrmm_v2_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc) bind(c, name="hipblasZtrmm_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmm_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtrmm_v2_full_rank,&
      
hipblasZtrmm_v2_rank_0,&
      
hipblasZtrmm_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     trmmBatched performs one of the batched matrix-matrix operations
  !> 
  !>     C_i := alphaop( A_i )B_i,   or   C_i := alphaB_iop( A_i )  for i = 0, 1, ... batchCount -1
  !> 
  !>     where alpha is a scalar, B_i and C_i are m by n matrices, A_i is a unit, or
  !>     non-unit, upper or lower triangular matrix and op( A_i ) is one of
  !> 
  !>         op( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.
  !> 
  !>     Note that trmmBatched can provide in-place functionality by passing in the same address for both
  !>     matrices B and C and by setting ldb equal to ldc.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     side    [hipblasSideMode_t]
  !>             Specifies whether op(A_i) multiplies B_i from the left or right as follows:
  !>             HIPBLAS_SIDE_LEFT:       B_i := alphaop( A_i )B_i.
  !>             HIPBLAS_SIDE_RIGHT:      B_i := alphaB_iop( A_i ).
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             Specifies whether the matrix A is an upper or lower triangular matrix as follows:
  !>             HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             Specifies the form of op(A_i) to be used in the matrix multiplication as follows:
  !>             HIPBLAS_OP_N:  op(A_i) = A_i.
  !>             HIPBLAS_OP_T:  op(A_i) = A_i^T.
  !>             HIPBLAS_OP_C:  op(A_i) = A_i^H.
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             Specifies whether or not A_i is unit triangular as follows:
  !>             HIPBLAS_DIAG_UNIT:      A_i is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m       [int]
  !>             m specifies the number of rows of B_i and C_i. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of columns of B_i and C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A_i is not referenced and B_i need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device array of device pointers storing each matrix A_i on the GPU.
  !>             Each A_i is of dimension ( lda, k ), where k is m
  !>             when  side == HIPBLAS_SIDE_LEFT  and
  !>             is  n  when  side == HIPBLAS_SIDE_RIGHT.
  !> 
  !>         When uplo == HIPBLAS_FILL_MODE_UPPER the  leading  k by k
  !>         upper triangular part of the array  A must contain the upper
  !>         triangular matrix  and the strictly lower triangular part of
  !>         A is not referenced.
  !> 
  !>         When uplo == HIPBLAS_FILL_MODE_LOWER the  leading  k by k
  !>         lower triangular part of the array  A must contain the lower
  !>         triangular matrix  and the strictly upper triangular part of
  !>         A is not referenced.
  !> 
  !>         Note that when  diag == HIPBLAS_DIAG_UNIT  the diagonal elements of
  !>         A_i  are not referenced either,  but are assumed to be  unity.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A.
  !>             if side == HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
  !>             if side == HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).
  !> 
  !>     @param[inout]
  !>     B       device array of device pointers storing each matrix B_i of
  !>             dimension (ldb, n) on the GPU.
  !> 
  !>     @param[in]
  !>     ldb    [int]
  !>            ldb specifies the first dimension of B_i. ldb >= max( 1, m ).
  !> 
  !>     @param[in]
  !>     C      device array of device pointers storing each matrix C_i of
  !>            dimension (ldc, n) on the GPU. Users can pass in the same
  !>            matrices B to parameter C to achieve in-place functionality of trmmBatched.
  !> 
  !>     @param[in]
  !>     ldc    lec specifies the first dimension of C_i. ldc >= max( 1, m ).
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances i in the batch.
  !>     
  interface hipblasStrmmBatched
#ifdef USE_CUDA_NAMES
    function hipblasStrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount) bind(c, name="cublasStrmmBatched")
#else
    function hipblasStrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount) bind(c, name="hipblasStrmmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasStrmmBatched_full_rank,&
      
hipblasStrmmBatched_rank_0,&
      
hipblasStrmmBatched_rank_1
#endif

  end interface
  
  interface hipblasDtrmmBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount) bind(c, name="cublasDtrmmBatched")
#else
    function hipblasDtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount) bind(c, name="hipblasDtrmmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDtrmmBatched_full_rank,&
      
hipblasDtrmmBatched_rank_0,&
      
hipblasDtrmmBatched_rank_1
#endif

  end interface
  
  interface hipblasCtrmmBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount) bind(c, name="cublasCtrmmBatched")
#else
    function hipblasCtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount) bind(c, name="hipblasCtrmmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtrmmBatched_full_rank,&
      
hipblasCtrmmBatched_rank_0,&
      
hipblasCtrmmBatched_rank_1
#endif

  end interface
  
  interface hipblasZtrmmBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount) bind(c, name="cublasZtrmmBatched")
#else
    function hipblasZtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount) bind(c, name="hipblasZtrmmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtrmmBatched_full_rank,&
      
hipblasZtrmmBatched_rank_0,&
      
hipblasZtrmmBatched_rank_1
#endif

  end interface
  
  interface hipblasCtrmmBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCtrmmBatched_v2_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount) bind(c, name="cublasCtrmmBatched_v2")
#else
    function hipblasCtrmmBatched_v2_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount) bind(c, name="hipblasCtrmmBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmmBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtrmmBatched_v2_full_rank,&
      
hipblasCtrmmBatched_v2_rank_0,&
      
hipblasCtrmmBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZtrmmBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZtrmmBatched_v2_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount) bind(c, name="cublasZtrmmBatched_v2")
#else
    function hipblasZtrmmBatched_v2_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount) bind(c, name="hipblasZtrmmBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmmBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtrmmBatched_v2_full_rank,&
      
hipblasZtrmmBatched_v2_rank_0,&
      
hipblasZtrmmBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     trmmStridedBatched performs one of the strided_batched matrix-matrix operations
  !> 
  !>     C_i := alphaop( A_i )B_i,   or   C_i := alphaB_iop( A_i )  for i = 0, 1, ... batchCount -1
  !> 
  !>     where alpha is a scalar,  B_i and C_i are m by n matrices, A_i is a unit, or
  !>     non-unit, upper or lower triangular matrix and op( A_i ) is one of
  !> 
  !>         op( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.
  !> 
  !>     Note that trmmStridedBatched can provide in-place functionality by passing
  !>     in the same address for both matrices B and C and by setting ldb equal to ldc.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     side    [hipblasSideMode_t]
  !>             Specifies whether op(A_i) multiplies B_i from the left or right as follows:
  !>             HIPBLAS_SIDE_LEFT:       C_i := alphaop( A_i )B_i.
  !>             HIPBLAS_SIDE_RIGHT:      C_i := alphaB_iop( A_i ).
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             Specifies whether the matrix A is an upper or lower triangular matrix as follows:
  !>             HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             Specifies the form of op(A_i) to be used in the matrix multiplication as follows:
  !>             HIPBLAS_OP_N:  op(A_i) = A_i.
  !>             HIPBLAS_OP_T:  op(A_i) = A_i^T.
  !>             HIPBLAS_OP_C:  op(A_i) = A_i^H.
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             Specifies whether or not A_i is unit triangular as follows:
  !>             HIPBLAS_DIAG_UNIT:      A_i is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m       [int]
  !>             m specifies the number of rows of B_i and C_i. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of columns of B_i and C_i. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             alpha specifies the scalar alpha. When alpha is
  !>             zero then A_i is not referenced and B_i need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       Device pointer to the first matrix A_0 on the GPU.
  !>             Each A_i is of dimension ( lda, k ), where k is m
  !>             when  side == HIPBLAS_SIDE_LEFT  and
  !>             is  n  when  side == HIPBLAS_SIDE_RIGHT.
  !> 
  !>         When uplo == HIPBLAS_FILL_MODE_UPPER the  leading  k by k
  !>         upper triangular part of the array  A must contain the upper
  !>         triangular matrix  and the strictly lower triangular part of
  !>         A is not referenced.
  !> 
  !>         When uplo == HIPBLAS_FILL_MODE_LOWER the  leading  k by k
  !>         lower triangular part of the array  A must contain the lower
  !>         triangular matrix  and the strictly upper triangular part of
  !>         A is not referenced.
  !> 
  !>         Note that when  diag == HIPBLAS_DIAG_UNIT  the diagonal elements of
  !>         A_i  are not referenced either,  but are assumed to be  unity.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A.
  !>             if side == HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
  !>             if side == HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !> 
  !>     @param[inout]
  !>     B      Device pointer to the first matrix B_0 on the GPU. Each B_i is of
  !>            dimension ( ldb, n )
  !> 
  !>     @param[in]
  !>     ldb    [int]
  !>            ldb specifies the first dimension of B_i. ldb >= max( 1, m ).
  !> 
  !>     @param[in]
  !>     strideB  [hipblasStride]
  !>               stride from the start of one matrix (B_i) and the next one (B_i+1)
  !> 
  !>     @param[in]
  !>     C      Device pointer to the first matrix C_0 on the GPU. Each C_i is of
  !>            dimension ( ldc, n ).
  !> 
  !>     @param[in]
  !>     ldc    [int]
  !>            ldc specifies the first dimension of C_i. ldc >= max( 1, m ).
  !> 
  !>     @param[in]
  !>     strideC [hipblasStride]
  !>             stride from the start of one matrix (C_i) and the next one (C_i+1)
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances i in the batch.
  !>     
  interface hipblasStrmmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasStrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount) bind(c, name="cublasStrmmStridedBatched")
#else
    function hipblasStrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount) bind(c, name="hipblasStrmmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasStrmmStridedBatched_full_rank,&
      
hipblasStrmmStridedBatched_rank_0,&
      
hipblasStrmmStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDtrmmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount) bind(c, name="cublasDtrmmStridedBatched")
#else
    function hipblasDtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount) bind(c, name="hipblasDtrmmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDtrmmStridedBatched_full_rank,&
      
hipblasDtrmmStridedBatched_rank_0,&
      
hipblasDtrmmStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCtrmmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount) bind(c, name="cublasCtrmmStridedBatched")
#else
    function hipblasCtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount) bind(c, name="hipblasCtrmmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtrmmStridedBatched_full_rank,&
      
hipblasCtrmmStridedBatched_rank_0,&
      
hipblasCtrmmStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZtrmmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount) bind(c, name="cublasZtrmmStridedBatched")
#else
    function hipblasZtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount) bind(c, name="hipblasZtrmmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtrmmStridedBatched_full_rank,&
      
hipblasZtrmmStridedBatched_rank_0,&
      
hipblasZtrmmStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCtrmmStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCtrmmStridedBatched_v2_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount) bind(c, name="cublasCtrmmStridedBatched_v2")
#else
    function hipblasCtrmmStridedBatched_v2_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount) bind(c, name="hipblasCtrmmStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmmStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtrmmStridedBatched_v2_full_rank,&
      
hipblasCtrmmStridedBatched_v2_rank_0,&
      
hipblasCtrmmStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZtrmmStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZtrmmStridedBatched_v2_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount) bind(c, name="cublasZtrmmStridedBatched_v2")
#else
    function hipblasZtrmmStridedBatched_v2_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount) bind(c, name="hipblasZtrmmStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmmStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: C
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtrmmStridedBatched_v2_full_rank,&
      
hipblasZtrmmStridedBatched_v2_rank_0,&
      
hipblasZtrmmStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !> 
  !>     trsm solves
  !> 
  !>         op(A)X = alphaB or  Xop(A) = alphaB,
  !> 
  !>     where alpha is a scalar, X and B are m by n matrices,
  !>     A is triangular matrix and op(A) is one of
  !> 
  !>         op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.
  !> 
  !>     The matrix X is overwritten on B.
  !> 
  !>     Note about memory allocation:
  !>     When trsm is launched with a k evenly divisible by the internal block size of 128,
  !>     and is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated
  !>     memory found in the handle to increase overall performance. This memory can be managed by using
  !>     the environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory
  !>     used for temporary storage will default to 1 MB and may result in chunking, which in turn may
  !>     reduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set
  !>     to the desired chunk of right hand sides to be used at a time.
  !> 
  !>     (where k is m when HIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT)
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     side    [hipblasSideMode_t]
  !>             HIPBLAS_SIDE_LEFT:       op(A)X = alphaB.
  !>             HIPBLAS_SIDE_RIGHT:      Xop(A) = alphaB.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_N: op(A) = A.
  !>             HIPBLAS_OP_T: op(A) = A^T.
  !>             HIPBLAS_OP_C: op(A) = A^H.
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m       [int]
  !>             m specifies the number of rows of B. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of columns of B. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha
  !>             device pointer or host pointer specifying the scalar alpha. When alpha is
  !>             &zero then A is not referenced and B need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     AP       device pointer storing matrix A.
  !>             of dimension ( lda, k ), where k is m
  !>             when  HIPBLAS_SIDE_LEFT  and
  !>             is  n  when  HIPBLAS_SIDE_RIGHT
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A.
  !>             if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
  !>             if side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).
  !> 
  !>     @param[in,out]
  !>     BP       device pointer storing matrix B.
  !> 
  !>     @param[in]
  !>     ldb    [int]
  !>            ldb specifies the first dimension of B. ldb >= max( 1, m ).
  !> 
  !>     
  interface hipblasStrsm
#ifdef USE_CUDA_NAMES
    function hipblasStrsm_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,BP,ldb) bind(c, name="cublasStrsm_v2")
#else
    function hipblasStrsm_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,BP,ldb) bind(c, name="hipblasStrsm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
    end function


  end interface
  
  interface hipblasDtrsm
#ifdef USE_CUDA_NAMES
    function hipblasDtrsm_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,BP,ldb) bind(c, name="cublasDtrsm_v2")
#else
    function hipblasDtrsm_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,BP,ldb) bind(c, name="hipblasDtrsm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
    end function


  end interface
  
  interface hipblasCtrsm
#ifdef USE_CUDA_NAMES
    function hipblasCtrsm_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,BP,ldb) bind(c, name="cublasCtrsm_v2")
#else
    function hipblasCtrsm_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,BP,ldb) bind(c, name="hipblasCtrsm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
    end function


  end interface
  
  interface hipblasZtrsm
#ifdef USE_CUDA_NAMES
    function hipblasZtrsm_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,BP,ldb) bind(c, name="cublasZtrsm_v2")
#else
    function hipblasZtrsm_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,BP,ldb) bind(c, name="hipblasZtrsm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
    end function


  end interface
  
  interface hipblasCtrsm_v2
#ifdef USE_CUDA_NAMES
    function hipblasCtrsm_v2_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,BP,ldb) bind(c, name="cublasCtrsm_v2")
#else
    function hipblasCtrsm_v2_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,BP,ldb) bind(c, name="hipblasCtrsm_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsm_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
    end function


  end interface
  
  interface hipblasZtrsm_v2
#ifdef USE_CUDA_NAMES
    function hipblasZtrsm_v2_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,BP,ldb) bind(c, name="cublasZtrsm_v2")
#else
    function hipblasZtrsm_v2_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,BP,ldb) bind(c, name="hipblasZtrsm_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsm_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !>     \details
  !>     trsmBatched performs the following batched operation:
  !> 
  !>         op(A_i)X_i = alphaB_i or  X_iop(A_i) = alphaB_i, for i = 1, ..., batchCount.
  !> 
  !>     where alpha is a scalar, X and B are batched m by n matrices,
  !>     A is triangular batched matrix and op(A) is one of
  !> 
  !>         op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.
  !> 
  !>     Each matrix X_i is overwritten on B_i for i = 1, ..., batchCount.
  !> 
  !>     Note about memory allocation:
  !>     When trsm is launched with a k evenly divisible by the internal block size of 128,
  !>     and is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated
  !>     memory found in the handle to increase overall performance. This memory can be managed by using
  !>     the environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory
  !>     used for temporary storage will default to 1 MB and may result in chunking, which in turn may
  !>     reduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set
  !>     to the desired chunk of right hand sides to be used at a time.
  !>     (where k is m when HIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT)
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     side    [hipblasSideMode_t]
  !>             HIPBLAS_SIDE_LEFT:       op(A)X = alphaB.
  !>             HIPBLAS_SIDE_RIGHT:      Xop(A) = alphaB.
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  each A_i is a  lower triangular matrix.
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_N: op(A) = A.
  !>             HIPBLAS_OP_T: op(A) = A^T.
  !>             HIPBLAS_OP_C: op(A) = A^H.
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  each A_i is not assumed to be unit triangular.
  !>     @param[in]
  !>     m       [int]
  !>             m specifies the number of rows of each B_i. m >= 0.
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of columns of each B_i. n >= 0.
  !>     @param[in]
  !>     alpha
  !>             device pointer or host pointer specifying the scalar alpha. When alpha is
  !>             &zero then A is not referenced and B need not be set before
  !>             entry.
  !>     @param[in]
  !>     AP       device array of device pointers storing each matrix A_i on the GPU.
  !>             Matricies are of dimension ( lda, k ), where k is m
  !>             when  HIPBLAS_SIDE_LEFT  and is  n  when  HIPBLAS_SIDE_RIGHT
  !>             only the upperlower triangular part is accessed.
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of each A_i.
  !>             if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
  !>             if side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).
  !>     @param[in,out]
  !>     BP       device array of device pointers storing each matrix B_i on the GPU.
  !>     @param[in]
  !>     ldb    [int]
  !>            ldb specifies the first dimension of each B_i. ldb >= max( 1, m ).
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of trsm operatons in the batch.
  !>     
  interface hipblasStrsmBatched
#ifdef USE_CUDA_NAMES
    function hipblasStrsmBatched_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,BP,ldb,batchCount) bind(c, name="cublasStrsmBatched")
#else
    function hipblasStrsmBatched_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,BP,ldb,batchCount) bind(c, name="hipblasStrsmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasDtrsmBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtrsmBatched_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,BP,ldb,batchCount) bind(c, name="cublasDtrsmBatched")
#else
    function hipblasDtrsmBatched_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,BP,ldb,batchCount) bind(c, name="hipblasDtrsmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCtrsmBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtrsmBatched_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,BP,ldb,batchCount) bind(c, name="cublasCtrsmBatched")
#else
    function hipblasCtrsmBatched_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,BP,ldb,batchCount) bind(c, name="hipblasCtrsmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZtrsmBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtrsmBatched_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,BP,ldb,batchCount) bind(c, name="cublasZtrsmBatched")
#else
    function hipblasZtrsmBatched_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,BP,ldb,batchCount) bind(c, name="hipblasZtrsmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCtrsmBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCtrsmBatched_v2_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,BP,ldb,batchCount) bind(c, name="cublasCtrsmBatched_v2")
#else
    function hipblasCtrsmBatched_v2_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,BP,ldb,batchCount) bind(c, name="hipblasCtrsmBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsmBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZtrsmBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZtrsmBatched_v2_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,BP,ldb,batchCount) bind(c, name="cublasZtrsmBatched_v2")
#else
    function hipblasZtrsmBatched_v2_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,BP,ldb,batchCount) bind(c, name="hipblasZtrsmBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsmBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: BP
      integer(c_int),value :: ldb
      integer(c_int),value :: batchCount
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !>     \details
  !>     trsmSridedBatched performs the following strided batched operation:
  !> 
  !>         op(A_i)X_i = alphaB_i or  X_iop(A_i) = alphaB_i, for i = 1, ..., batchCount.
  !> 
  !>     where alpha is a scalar, X and B are strided batched m by n matrices,
  !>     A is triangular strided batched matrix and op(A) is one of
  !> 
  !>         op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.
  !> 
  !>     Each matrix X_i is overwritten on B_i for i = 1, ..., batchCount.
  !> 
  !>     Note about memory allocation:
  !>     When trsm is launched with a k evenly divisible by the internal block size of 128,
  !>     and is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated
  !>     memory found in the handle to increase overall performance. This memory can be managed by using
  !>     the environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory
  !>     used for temporary storage will default to 1 MB and may result in chunking, which in turn may
  !>     reduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set
  !>     to the desired chunk of right hand sides to be used at a time.
  !>     (where k is m when HIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT)
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     side    [hipblasSideMode_t]
  !>             HIPBLAS_SIDE_LEFT:       op(A)X = alphaB.
  !>             HIPBLAS_SIDE_RIGHT:      Xop(A) = alphaB.
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  each A_i is a  lower triangular matrix.
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_N: op(A) = A.
  !>             HIPBLAS_OP_T: op(A) = A^T.
  !>             HIPBLAS_OP_C: op(A) = A^H.
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  each A_i is not assumed to be unit triangular.
  !>     @param[in]
  !>     m       [int]
  !>             m specifies the number of rows of each B_i. m >= 0.
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of columns of each B_i. n >= 0.
  !>     @param[in]
  !>     alpha
  !>             device pointer or host pointer specifying the scalar alpha. When alpha is
  !>             &zero then A is not referenced and B need not be set before
  !>             entry.
  !>     @param[in]
  !>     AP       device pointer pointing to the first matrix A_1.
  !>             of dimension ( lda, k ), where k is m
  !>             when  HIPBLAS_SIDE_LEFT  and
  !>             is  n  when  HIPBLAS_SIDE_RIGHT
  !>             only the upperlower triangular part is accessed.
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of each A_i.
  !>             if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
  !>             if side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).
  !>     @param[in]
  !>     strideA [hipblasStride]
  !>              stride from the start of one A_i matrix to the next A_(i + 1).
  !>     @param[in,out]
  !>     BP       device pointer pointing to the first matrix B_1.
  !>     @param[in]
  !>     ldb    [int]
  !>            ldb specifies the first dimension of each B_i. ldb >= max( 1, m ).
  !>     @param[in]
  !>     strideB [hipblasStride]
  !>              stride from the start of one B_i matrix to the next B_(i + 1).
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of trsm operatons in the batch.
  !>     
  interface hipblasStrsmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasStrsmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,strideA,BP,ldb,strideB,batchCount) bind(c, name="cublasStrsmStridedBatched")
#else
    function hipblasStrsmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,strideA,BP,ldb,strideB,batchCount) bind(c, name="hipblasStrsmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_float) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasDtrsmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtrsmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,strideA,BP,ldb,strideB,batchCount) bind(c, name="cublasDtrsmStridedBatched")
#else
    function hipblasDtrsmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,strideA,BP,ldb,strideB,batchCount) bind(c, name="hipblasDtrsmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      real(c_double) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCtrsmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtrsmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,strideA,BP,ldb,strideB,batchCount) bind(c, name="cublasCtrsmStridedBatched")
#else
    function hipblasCtrsmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,strideA,BP,ldb,strideB,batchCount) bind(c, name="hipblasCtrsmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZtrsmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtrsmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,strideA,BP,ldb,strideB,batchCount) bind(c, name="cublasZtrsmStridedBatched")
#else
    function hipblasZtrsmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,strideA,BP,ldb,strideB,batchCount) bind(c, name="hipblasZtrsmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasCtrsmStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCtrsmStridedBatched_v2_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,strideA,BP,ldb,strideB,batchCount) bind(c, name="cublasCtrsmStridedBatched_v2")
#else
    function hipblasCtrsmStridedBatched_v2_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,strideA,BP,ldb,strideB,batchCount) bind(c, name="hipblasCtrsmStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsmStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_float_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batchCount
    end function


  end interface
  
  interface hipblasZtrsmStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZtrsmStridedBatched_v2_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,strideA,BP,ldb,strideB,batchCount) bind(c, name="cublasZtrsmStridedBatched_v2")
#else
    function hipblasZtrsmStridedBatched_v2_(handle,side,uplo,transA,diag,m,n,alpha,AP,lda,strideA,BP,ldb,strideB,batchCount) bind(c, name="hipblasZtrsmStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsmStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      complex(c_double_complex) :: alpha
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: BP
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batchCount
    end function


  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     trtri  compute the inverse of a matrix A, namely, invA
  !> 
  !>         and write the result into invA;
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>               if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
  !>               if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
  !>     @param[in]
  !>     diag      [hipblasDiagType_t]
  !>               = 'HIPBLAS_DIAG_NON_UNIT', A is non-unit triangular;
  !>               = 'HIPBLAS_DIAG_UNIT', A is unit triangular;
  !>     @param[in]
  !>     n         [int]
  !>               size of matrix A and invA
  !>     @param[in]
  !>     AP         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A.
  !>     @param[out]
  !>     invA      device pointer storing matrix invA.
  !>     @param[in]
  !>     ldinvA    [int]
  !>               specifies the leading dimension of invA.
  !> 
  !> 
  interface hipblasStrtri
#ifdef USE_CUDA_NAMES
    function hipblasStrtri_(handle,uplo,diag,n,AP,lda,invA,ldinvA) bind(c, name="cublasStrtri")
#else
    function hipblasStrtri_(handle,uplo,diag,n,AP,lda,invA,ldinvA) bind(c, name="hipblasStrtri")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrtri_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasStrtri_full_rank,&
      
hipblasStrtri_rank_0,&
      
hipblasStrtri_rank_1
#endif

  end interface
  
  interface hipblasDtrtri
#ifdef USE_CUDA_NAMES
    function hipblasDtrtri_(handle,uplo,diag,n,AP,lda,invA,ldinvA) bind(c, name="cublasDtrtri")
#else
    function hipblasDtrtri_(handle,uplo,diag,n,AP,lda,invA,ldinvA) bind(c, name="hipblasDtrtri")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrtri_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDtrtri_full_rank,&
      
hipblasDtrtri_rank_0,&
      
hipblasDtrtri_rank_1
#endif

  end interface
  
  interface hipblasCtrtri
#ifdef USE_CUDA_NAMES
    function hipblasCtrtri_(handle,uplo,diag,n,AP,lda,invA,ldinvA) bind(c, name="cublasCtrtri")
#else
    function hipblasCtrtri_(handle,uplo,diag,n,AP,lda,invA,ldinvA) bind(c, name="hipblasCtrtri")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtri_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtrtri_full_rank,&
      
hipblasCtrtri_rank_0,&
      
hipblasCtrtri_rank_1
#endif

  end interface
  
  interface hipblasZtrtri
#ifdef USE_CUDA_NAMES
    function hipblasZtrtri_(handle,uplo,diag,n,AP,lda,invA,ldinvA) bind(c, name="cublasZtrtri")
#else
    function hipblasZtrtri_(handle,uplo,diag,n,AP,lda,invA,ldinvA) bind(c, name="hipblasZtrtri")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtri_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtrtri_full_rank,&
      
hipblasZtrtri_rank_0,&
      
hipblasZtrtri_rank_1
#endif

  end interface
  
  interface hipblasCtrtri_v2
#ifdef USE_CUDA_NAMES
    function hipblasCtrtri_v2_(handle,uplo,diag,n,AP,lda,invA,ldinvA) bind(c, name="cublasCtrtri_v2")
#else
    function hipblasCtrtri_v2_(handle,uplo,diag,n,AP,lda,invA,ldinvA) bind(c, name="hipblasCtrtri_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtri_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtrtri_v2_full_rank,&
      
hipblasCtrtri_v2_rank_0,&
      
hipblasCtrtri_v2_rank_1
#endif

  end interface
  
  interface hipblasZtrtri_v2
#ifdef USE_CUDA_NAMES
    function hipblasZtrtri_v2_(handle,uplo,diag,n,AP,lda,invA,ldinvA) bind(c, name="cublasZtrtri_v2")
#else
    function hipblasZtrtri_v2_(handle,uplo,diag,n,AP,lda,invA,ldinvA) bind(c, name="hipblasZtrtri_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtri_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtrtri_v2_full_rank,&
      
hipblasZtrtri_v2_rank_0,&
      
hipblasZtrtri_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     trtriBatched  compute the inverse of A_i and write into invA_i where
  !>                    A_i and invA_i are the i-th matrices in the batch,
  !>                    for i = 1, ..., batchCount.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>     @param[in]
  !>     diag      [hipblasDiagType_t]
  !>               = 'HIPBLAS_DIAG_NON_UNIT', A is non-unit triangular;
  !>               = 'HIPBLAS_DIAG_UNIT', A is unit triangular;
  !>     @param[in]
  !>     n         [int]
  !>     @param[in]
  !>     AP         device array of device pointers storing each matrix A_i.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[out]
  !>     invA      device array of device pointers storing the inverse of each matrix A_i.
  !>               Partial inplace operation is supported, see below.
  !>               If UPLO = 'U', the leading N-by-N upper triangular part of the invA will store
  !>               the inverse of the upper triangular matrix, and the strictly lower
  !>               triangular part of invA is cleared.
  !>               If UPLO = 'L', the leading N-by-N lower triangular part of the invA will store
  !>               the inverse of the lower triangular matrix, and the strictly upper
  !>               triangular part of invA is cleared.
  !>     @param[in]
  !>     ldinvA    [int]
  !>               specifies the leading dimension of each invA_i.
  !>     @param[in]
  !>     batchCount [int]
  !>               numbers of matrices in the batch
  !>     
  interface hipblasStrtriBatched
#ifdef USE_CUDA_NAMES
    function hipblasStrtriBatched_(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount) bind(c, name="cublasStrtriBatched")
#else
    function hipblasStrtriBatched_(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount) bind(c, name="hipblasStrtriBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrtriBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasStrtriBatched_full_rank,&
      
hipblasStrtriBatched_rank_0,&
      
hipblasStrtriBatched_rank_1
#endif

  end interface
  
  interface hipblasDtrtriBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtrtriBatched_(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount) bind(c, name="cublasDtrtriBatched")
#else
    function hipblasDtrtriBatched_(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount) bind(c, name="hipblasDtrtriBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrtriBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDtrtriBatched_full_rank,&
      
hipblasDtrtriBatched_rank_0,&
      
hipblasDtrtriBatched_rank_1
#endif

  end interface
  
  interface hipblasCtrtriBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtrtriBatched_(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount) bind(c, name="cublasCtrtriBatched")
#else
    function hipblasCtrtriBatched_(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount) bind(c, name="hipblasCtrtriBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtriBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtrtriBatched_full_rank,&
      
hipblasCtrtriBatched_rank_0,&
      
hipblasCtrtriBatched_rank_1
#endif

  end interface
  
  interface hipblasZtrtriBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtrtriBatched_(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount) bind(c, name="cublasZtrtriBatched")
#else
    function hipblasZtrtriBatched_(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount) bind(c, name="hipblasZtrtriBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtriBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtrtriBatched_full_rank,&
      
hipblasZtrtriBatched_rank_0,&
      
hipblasZtrtriBatched_rank_1
#endif

  end interface
  
  interface hipblasCtrtriBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCtrtriBatched_v2_(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount) bind(c, name="cublasCtrtriBatched_v2")
#else
    function hipblasCtrtriBatched_v2_(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount) bind(c, name="hipblasCtrtriBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtriBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtrtriBatched_v2_full_rank,&
      
hipblasCtrtriBatched_v2_rank_0,&
      
hipblasCtrtriBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZtrtriBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZtrtriBatched_v2_(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount) bind(c, name="cublasZtrtriBatched_v2")
#else
    function hipblasZtrtriBatched_v2_(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount) bind(c, name="hipblasZtrtriBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtriBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: invA
      integer(c_int),value :: ldinvA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtrtriBatched_v2_full_rank,&
      
hipblasZtrtriBatched_v2_rank_0,&
      
hipblasZtrtriBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     trtriStridedBatched compute the inverse of A_i and write into invA_i where
  !>                    A_i and invA_i are the i-th matrices in the batch,
  !>                    for i = 1, ..., batchCount
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     uplo      [hipblasFillMode_t]
  !>               specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
  !>     @param[in]
  !>     diag      [hipblasDiagType_t]
  !>               = 'HIPBLAS_DIAG_NON_UNIT', A is non-unit triangular;
  !>               = 'HIPBLAS_DIAG_UNIT', A is unit triangular;
  !>     @param[in]
  !>     n         [int]
  !>     @param[in]
  !>     AP         device pointer pointing to address of first matrix A_1.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A.
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>              "batch stride a": stride from the start of one A_i matrix to the next A_(i + 1).
  !>     @param[out]
  !>     invA      device pointer storing the inverses of each matrix A_i.
  !>               Partial inplace operation is supported, see below.
  !>               If UPLO = 'U', the leading N-by-N upper triangular part of the invA will store
  !>               the inverse of the upper triangular matrix, and the strictly lower
  !>               triangular part of invA is cleared.
  !>               If UPLO = 'L', the leading N-by-N lower triangular part of the invA will store
  !>               the inverse of the lower triangular matrix, and the strictly upper
  !>               triangular part of invA is cleared.
  !>     @param[in]
  !>     ldinvA    [int]
  !>               specifies the leading dimension of each invA_i.
  !>     @param[in]
  !>     stride_invA  [hipblasStride]
  !>                  "batch stride invA": stride from the start of one invA_i matrix to the next invA_(i + 1).
  !>     @param[in]
  !>     batchCount  [int]
  !>                  numbers of matrices in the batch
  !>     
  interface hipblasStrtriStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasStrtriStridedBatched_(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount) bind(c, name="cublasStrtriStridedBatched")
#else
    function hipblasStrtriStridedBatched_(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount) bind(c, name="hipblasStrtriStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrtriStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasStrtriStridedBatched_full_rank,&
      
hipblasStrtriStridedBatched_rank_0,&
      
hipblasStrtriStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDtrtriStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDtrtriStridedBatched_(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount) bind(c, name="cublasDtrtriStridedBatched")
#else
    function hipblasDtrtriStridedBatched_(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount) bind(c, name="hipblasDtrtriStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrtriStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDtrtriStridedBatched_full_rank,&
      
hipblasDtrtriStridedBatched_rank_0,&
      
hipblasDtrtriStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCtrtriStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCtrtriStridedBatched_(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount) bind(c, name="cublasCtrtriStridedBatched")
#else
    function hipblasCtrtriStridedBatched_(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount) bind(c, name="hipblasCtrtriStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtriStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtrtriStridedBatched_full_rank,&
      
hipblasCtrtriStridedBatched_rank_0,&
      
hipblasCtrtriStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZtrtriStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZtrtriStridedBatched_(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount) bind(c, name="cublasZtrtriStridedBatched")
#else
    function hipblasZtrtriStridedBatched_(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount) bind(c, name="hipblasZtrtriStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtriStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtrtriStridedBatched_full_rank,&
      
hipblasZtrtriStridedBatched_rank_0,&
      
hipblasZtrtriStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCtrtriStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCtrtriStridedBatched_v2_(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount) bind(c, name="cublasCtrtriStridedBatched_v2")
#else
    function hipblasCtrtriStridedBatched_v2_(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount) bind(c, name="hipblasCtrtriStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtriStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCtrtriStridedBatched_v2_full_rank,&
      
hipblasCtrtriStridedBatched_v2_rank_0,&
      
hipblasCtrtriStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZtrtriStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZtrtriStridedBatched_v2_(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount) bind(c, name="cublasZtrtriStridedBatched_v2")
#else
    function hipblasZtrtriStridedBatched_v2_(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount) bind(c, name="hipblasZtrtriStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtriStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: invA
      integer(c_int),value :: ldinvA
      integer(c_int64_t),value :: stride_invA
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZtrtriStridedBatched_v2_full_rank,&
      
hipblasZtrtriStridedBatched_v2_rank_0,&
      
hipblasZtrtriStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     dgmm performs one of the matrix-matrix operations
  !> 
  !>         C = A  diag(x) if side == HIPBLAS_SIDE_RIGHT
  !>         C = diag(x)  A if side == HIPBLAS_SIDE_LEFT
  !> 
  !>     where C and A are m by n dimensional matrices. diag( x ) is a diagonal matrix
  !>     and x is vector of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension m
  !>     if side == HIPBLAS_SIDE_LEFT.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     side      [hipblasSideMode_t]
  !>               specifies the side of diag(x)
  !>     @param[in]
  !>     m         [int]
  !>               matrix dimension m.
  !>     @param[in]
  !>     n         [int]
  !>               matrix dimension n.
  !>     @param[in]
  !>     AP         device pointer storing matrix A.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment between values of x
  !>     @param[in, out]
  !>     CP         device pointer storing matrix C.
  !>     @param[in]
  !>     ldc       [int]
  !>               specifies the leading dimension of C.
  !> 
  !>     
  interface hipblasSdgmm
#ifdef USE_CUDA_NAMES
    function hipblasSdgmm_(handle,side,m,n,AP,lda,x,incx,CP,ldc) bind(c, name="cublasSdgmm")
#else
    function hipblasSdgmm_(handle,side,m,n,AP,lda,x,incx,CP,ldc) bind(c, name="hipblasSdgmm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdgmm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSdgmm_rank_0,&
      
hipblasSdgmm_rank_1
#endif

  end interface
  
  interface hipblasDdgmm
#ifdef USE_CUDA_NAMES
    function hipblasDdgmm_(handle,side,m,n,AP,lda,x,incx,CP,ldc) bind(c, name="cublasDdgmm")
#else
    function hipblasDdgmm_(handle,side,m,n,AP,lda,x,incx,CP,ldc) bind(c, name="hipblasDdgmm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdgmm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDdgmm_rank_0,&
      
hipblasDdgmm_rank_1
#endif

  end interface
  
  interface hipblasCdgmm
#ifdef USE_CUDA_NAMES
    function hipblasCdgmm_(handle,side,m,n,AP,lda,x,incx,CP,ldc) bind(c, name="cublasCdgmm")
#else
    function hipblasCdgmm_(handle,side,m,n,AP,lda,x,incx,CP,ldc) bind(c, name="hipblasCdgmm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCdgmm_rank_0,&
      
hipblasCdgmm_rank_1
#endif

  end interface
  
  interface hipblasZdgmm
#ifdef USE_CUDA_NAMES
    function hipblasZdgmm_(handle,side,m,n,AP,lda,x,incx,CP,ldc) bind(c, name="cublasZdgmm")
#else
    function hipblasZdgmm_(handle,side,m,n,AP,lda,x,incx,CP,ldc) bind(c, name="hipblasZdgmm")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmm_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdgmm_rank_0,&
      
hipblasZdgmm_rank_1
#endif

  end interface
  
  interface hipblasCdgmm_v2
#ifdef USE_CUDA_NAMES
    function hipblasCdgmm_v2_(handle,side,m,n,AP,lda,x,incx,CP,ldc) bind(c, name="cublasCdgmm_v2")
#else
    function hipblasCdgmm_v2_(handle,side,m,n,AP,lda,x,incx,CP,ldc) bind(c, name="hipblasCdgmm_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmm_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCdgmm_v2_rank_0,&
      
hipblasCdgmm_v2_rank_1
#endif

  end interface
  
  interface hipblasZdgmm_v2
#ifdef USE_CUDA_NAMES
    function hipblasZdgmm_v2_(handle,side,m,n,AP,lda,x,incx,CP,ldc) bind(c, name="cublasZdgmm_v2")
#else
    function hipblasZdgmm_v2_(handle,side,m,n,AP,lda,x,incx,CP,ldc) bind(c, name="hipblasZdgmm_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmm_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdgmm_v2_rank_0,&
      
hipblasZdgmm_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     dgmmBatched performs one of the batched matrix-matrix operations
  !> 
  !>         C_i = A_i  diag(x_i) for i = 0, 1, ... batchCount-1 if side == HIPBLAS_SIDE_RIGHT
  !>         C_i = diag(x_i)  A_i for i = 0, 1, ... batchCount-1 if side == HIPBLAS_SIDE_LEFT
  !> 
  !>     where C_i and A_i are m by n dimensional matrices. diag(x_i) is a diagonal matrix
  !>     and x_i is vector of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension m
  !>     if side == HIPBLAS_SIDE_LEFT.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     side      [hipblasSideMode_t]
  !>               specifies the side of diag(x)
  !>     @param[in]
  !>     m         [int]
  !>               matrix dimension m.
  !>     @param[in]
  !>     n         [int]
  !>               matrix dimension n.
  !>     @param[in]
  !>     AP         device array of device pointers storing each matrix A_i on the GPU.
  !>               Each A_i is of dimension ( lda, n )
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A_i.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i on the GPU.
  !>               Each x_i is of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension
  !>               m if side == HIPBLAS_SIDE_LEFT
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment between values of x_i
  !>     @param[in, out]
  !>     CP         device array of device pointers storing each matrix C_i on the GPU.
  !>               Each C_i is of dimension ( ldc, n ).
  !>     @param[in]
  !>     ldc       [int]
  !>               specifies the leading dimension of C_i.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !> 
  !>     
  interface hipblasSdgmmBatched
#ifdef USE_CUDA_NAMES
    function hipblasSdgmmBatched_(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount) bind(c, name="cublasSdgmmBatched")
#else
    function hipblasSdgmmBatched_(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount) bind(c, name="hipblasSdgmmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdgmmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSdgmmBatched_full_rank,&
      
hipblasSdgmmBatched_rank_0,&
      
hipblasSdgmmBatched_rank_1
#endif

  end interface
  
  interface hipblasDdgmmBatched
#ifdef USE_CUDA_NAMES
    function hipblasDdgmmBatched_(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount) bind(c, name="cublasDdgmmBatched")
#else
    function hipblasDdgmmBatched_(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount) bind(c, name="hipblasDdgmmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdgmmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDdgmmBatched_full_rank,&
      
hipblasDdgmmBatched_rank_0,&
      
hipblasDdgmmBatched_rank_1
#endif

  end interface
  
  interface hipblasCdgmmBatched
#ifdef USE_CUDA_NAMES
    function hipblasCdgmmBatched_(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount) bind(c, name="cublasCdgmmBatched")
#else
    function hipblasCdgmmBatched_(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount) bind(c, name="hipblasCdgmmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCdgmmBatched_full_rank,&
      
hipblasCdgmmBatched_rank_0,&
      
hipblasCdgmmBatched_rank_1
#endif

  end interface
  
  interface hipblasZdgmmBatched
#ifdef USE_CUDA_NAMES
    function hipblasZdgmmBatched_(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount) bind(c, name="cublasZdgmmBatched")
#else
    function hipblasZdgmmBatched_(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount) bind(c, name="hipblasZdgmmBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmmBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdgmmBatched_full_rank,&
      
hipblasZdgmmBatched_rank_0,&
      
hipblasZdgmmBatched_rank_1
#endif

  end interface
  
  interface hipblasCdgmmBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCdgmmBatched_v2_(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount) bind(c, name="cublasCdgmmBatched_v2")
#else
    function hipblasCdgmmBatched_v2_(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount) bind(c, name="hipblasCdgmmBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmmBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCdgmmBatched_v2_full_rank,&
      
hipblasCdgmmBatched_v2_rank_0,&
      
hipblasCdgmmBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZdgmmBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZdgmmBatched_v2_(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount) bind(c, name="cublasZdgmmBatched_v2")
#else
    function hipblasZdgmmBatched_v2_(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount) bind(c, name="hipblasZdgmmBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmmBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: AP
      integer(c_int),value :: lda
      type(c_ptr) :: x
      integer(c_int),value :: incx
      type(c_ptr) :: CP
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdgmmBatched_v2_full_rank,&
      
hipblasZdgmmBatched_v2_rank_0,&
      
hipblasZdgmmBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief BLAS Level 3 API
  !> 
  !>     \details
  !>     dgmmStridedBatched performs one of the batched matrix-matrix operations
  !> 
  !>         C_i = A_i  diag(x_i)   if side == HIPBLAS_SIDE_RIGHT   for i = 0, 1, ... batchCount-1
  !>         C_i = diag(x_i)  A_i   if side == HIPBLAS_SIDE_LEFT    for i = 0, 1, ... batchCount-1
  !> 
  !>     where C_i and A_i are m by n dimensional matrices. diag(x_i) is a diagonal matrix
  !>     and x_i is vector of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension m
  !>     if side == HIPBLAS_SIDE_LEFT.
  !> 
  !>     - Supported precisions in rocBLAS : s,d,c,z
  !>     - Supported precisions in cuBLAS  : No support
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     side      [hipblasSideMode_t]
  !>               specifies the side of diag(x)
  !>     @param[in]
  !>     m         [int]
  !>               matrix dimension m.
  !>     @param[in]
  !>     n         [int]
  !>               matrix dimension n.
  !>     @param[in]
  !>     AP         device pointer to the first matrix A_0 on the GPU.
  !>               Each A_i is of dimension ( lda, n )
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A.
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               stride from the start of one matrix (A_i) and the next one (A_i+1)
  !>     @param[in]
  !>     x         pointer to the first vector x_0 on the GPU.
  !>               Each x_i is of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension
  !>               m if side == HIPBLAS_SIDE_LEFT
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment between values of x
  !>     @param[in]
  !>     stridex  [hipblasStride]
  !>               stride from the start of one vector(x_i) and the next one (x_i+1)
  !>     @param[in, out]
  !>     CP         device pointer to the first matrix C_0 on the GPU.
  !>               Each C_i is of dimension ( ldc, n ).
  !>     @param[in]
  !>     ldc       [int]
  !>               specifies the leading dimension of C.
  !>     @param[in]
  !>     strideC  [hipblasStride]
  !>               stride from the start of one matrix (C_i) and the next one (C_i+1)
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances i in the batch.
  !> 
  !>     
  interface hipblasSdgmmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSdgmmStridedBatched_(handle,side,m,n,AP,lda,strideA,x,incx,stridex,CP,ldc,strideC,batchCount) bind(c, name="cublasSdgmmStridedBatched")
#else
    function hipblasSdgmmStridedBatched_(handle,side,m,n,AP,lda,strideA,x,incx,stridex,CP,ldc,strideC,batchCount) bind(c, name="hipblasSdgmmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdgmmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSdgmmStridedBatched_rank_0,&
      
hipblasSdgmmStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDdgmmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDdgmmStridedBatched_(handle,side,m,n,AP,lda,strideA,x,incx,stridex,CP,ldc,strideC,batchCount) bind(c, name="cublasDdgmmStridedBatched")
#else
    function hipblasDdgmmStridedBatched_(handle,side,m,n,AP,lda,strideA,x,incx,stridex,CP,ldc,strideC,batchCount) bind(c, name="hipblasDdgmmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdgmmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDdgmmStridedBatched_rank_0,&
      
hipblasDdgmmStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCdgmmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCdgmmStridedBatched_(handle,side,m,n,AP,lda,strideA,x,incx,stridex,CP,ldc,strideC,batchCount) bind(c, name="cublasCdgmmStridedBatched")
#else
    function hipblasCdgmmStridedBatched_(handle,side,m,n,AP,lda,strideA,x,incx,stridex,CP,ldc,strideC,batchCount) bind(c, name="hipblasCdgmmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCdgmmStridedBatched_rank_0,&
      
hipblasCdgmmStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZdgmmStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZdgmmStridedBatched_(handle,side,m,n,AP,lda,strideA,x,incx,stridex,CP,ldc,strideC,batchCount) bind(c, name="cublasZdgmmStridedBatched")
#else
    function hipblasZdgmmStridedBatched_(handle,side,m,n,AP,lda,strideA,x,incx,stridex,CP,ldc,strideC,batchCount) bind(c, name="hipblasZdgmmStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmmStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdgmmStridedBatched_rank_0,&
      
hipblasZdgmmStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCdgmmStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCdgmmStridedBatched_v2_(handle,side,m,n,AP,lda,strideA,x,incx,stridex,CP,ldc,strideC,batchCount) bind(c, name="cublasCdgmmStridedBatched_v2")
#else
    function hipblasCdgmmStridedBatched_v2_(handle,side,m,n,AP,lda,strideA,x,incx,stridex,CP,ldc,strideC,batchCount) bind(c, name="hipblasCdgmmStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmmStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCdgmmStridedBatched_v2_rank_0,&
      
hipblasCdgmmStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZdgmmStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZdgmmStridedBatched_v2_(handle,side,m,n,AP,lda,strideA,x,incx,stridex,CP,ldc,strideC,batchCount) bind(c, name="cublasZdgmmStridedBatched_v2")
#else
    function hipblasZdgmmStridedBatched_v2_(handle,side,m,n,AP,lda,strideA,x,incx,stridex,CP,ldc,strideC,batchCount) bind(c, name="hipblasZdgmmStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmmStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: AP
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: x
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: CP
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZdgmmStridedBatched_v2_rank_0,&
      
hipblasZdgmmStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SOLVER API
  !> 
  !>     \details
  !>     getrf computes the LU factorization of a general n-by-n matrix A
  !>     using partial pivoting with row interchanges. The LU factorization can
  !>     be done without pivoting if ipiv is passed as a nullptr.
  !> 
  !>     In the case that ipiv is not null, the factorization has the form:
  !> 
  !>     \f[
  !>         A = PLU
  !>     \f]
  !> 
  !>     where P is a permutation matrix, L is lower triangular with unit
  !>     diagonal elements, and U is upper triangular.
  !> 
  !>     In the case that ipiv is null, the factorization is done without pivoting:
  !> 
  !>     \f[
  !>         A = LU
  !>     \f]
  !> 
  !>     - Supported precisions in rocSOLVER : s,d,c,z
  !>     - Supported precisions in cuBLAS    : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    hipblasHandle_t.
  !>     @param[in]
  !>     n         int. n >= 0.\n
  !>               The number of columns and rows of the matrix A.
  !>     @param[inout]
  !>     A         pointer to type. Array on the GPU of dimension ldan.\n
  !>               On entry, the n-by-n matrix A to be factored.
  !>               On exit, the factors L and U from the factorization.
  !>               The unit diagonal elements of L are not stored.
  !>     @param[in]
  !>     lda       int. lda >= n.\n
  !>               Specifies the leading dimension of A.
  !>     @param[out]
  !>     ipiv      pointer to int. Array on the GPU of dimension n.\n
  !>               The vector of pivot indices. Elements of ipiv are 1-based indices.
  !>               For 1 <= i <= n, the row i of the
  !>               matrix was interchanged with row ipiv[i].
  !>               Matrix P of the factorization can be derived from ipiv.
  !>               The factorization here can be done without pivoting if ipiv is passed
  !>               in as a nullptr.
  !>     @param[out]
  !>     info      pointer to a int on the GPU.\n
  !>               If info = 0, successful exit.
  !>               If info = j > 0, U is singular. U[j,j] is the first zero pivot.
  !>     
  interface hipblasSgetrf
#ifdef USE_CUDA_NAMES
    function hipblasSgetrf_(handle,n,A,lda,ipiv,myInfo) bind(c, name="cublasSgetrf")
#else
    function hipblasSgetrf_(handle,n,A,lda,ipiv,myInfo) bind(c, name="hipblasSgetrf")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrf_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSgetrf_full_rank,&
      
hipblasSgetrf_rank_0,&
      
hipblasSgetrf_rank_1
#endif

  end interface
  
  interface hipblasDgetrf
#ifdef USE_CUDA_NAMES
    function hipblasDgetrf_(handle,n,A,lda,ipiv,myInfo) bind(c, name="cublasDgetrf")
#else
    function hipblasDgetrf_(handle,n,A,lda,ipiv,myInfo) bind(c, name="hipblasDgetrf")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrf_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDgetrf_full_rank,&
      
hipblasDgetrf_rank_0,&
      
hipblasDgetrf_rank_1
#endif

  end interface
  
  interface hipblasCgetrf
#ifdef USE_CUDA_NAMES
    function hipblasCgetrf_(handle,n,A,lda,ipiv,myInfo) bind(c, name="cublasCgetrf")
#else
    function hipblasCgetrf_(handle,n,A,lda,ipiv,myInfo) bind(c, name="hipblasCgetrf")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrf_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgetrf_full_rank,&
      
hipblasCgetrf_rank_0,&
      
hipblasCgetrf_rank_1
#endif

  end interface
  
  interface hipblasZgetrf
#ifdef USE_CUDA_NAMES
    function hipblasZgetrf_(handle,n,A,lda,ipiv,myInfo) bind(c, name="cublasZgetrf")
#else
    function hipblasZgetrf_(handle,n,A,lda,ipiv,myInfo) bind(c, name="hipblasZgetrf")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrf_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgetrf_full_rank,&
      
hipblasZgetrf_rank_0,&
      
hipblasZgetrf_rank_1
#endif

  end interface
  
  interface hipblasCgetrf_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgetrf_v2_(handle,n,A,lda,ipiv,myInfo) bind(c, name="cublasCgetrf_v2")
#else
    function hipblasCgetrf_v2_(handle,n,A,lda,ipiv,myInfo) bind(c, name="hipblasCgetrf_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrf_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgetrf_v2_full_rank,&
      
hipblasCgetrf_v2_rank_0,&
      
hipblasCgetrf_v2_rank_1
#endif

  end interface
  
  interface hipblasZgetrf_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgetrf_v2_(handle,n,A,lda,ipiv,myInfo) bind(c, name="cublasZgetrf_v2")
#else
    function hipblasZgetrf_v2_(handle,n,A,lda,ipiv,myInfo) bind(c, name="hipblasZgetrf_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrf_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgetrf_v2_full_rank,&
      
hipblasZgetrf_v2_rank_0,&
      
hipblasZgetrf_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SOLVER API
  !> 
  !>     \details
  !>     getrfBatched computes the LU factorization of a batch of general
  !>     n-by-n matrices using partial pivoting with row interchanges. The LU factorization can
  !>     be done without pivoting if ipiv is passed as a nullptr.
  !> 
  !>     In the case that ipiv is not null, the factorization of matrix \f$A_i\f$ in the batch has the form:
  !> 
  !>     \f[
  !>         A_i = P_iL_iU_i
  !>     \f]
  !> 
  !>     where \f$P_i\f$ is a permutation matrix, \f$L_i\f$ is lower triangular with unit
  !>     diagonal elements, and \f$U_i\f$ is upper triangular.
  !> 
  !>     In the case that ipiv is null, the factorization is done without pivoting:
  !> 
  !>     \f[
  !>         A_i = L_iU_i
  !>     \f]
  !> 
  !>     - Supported precisions in rocSOLVER : s,d,c,z
  !>     - Supported precisions in cuBLAS    : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    hipblasHandle_t.
  !>     @param[in]
  !>     n         int. n >= 0.\n
  !>               The number of columns and rows of all matrices A_i in the batch.
  !>     @param[inout]
  !>     A         array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.\n
  !>               On entry, the n-by-n matrices A_i to be factored.
  !>               On exit, the factors L_i and U_i from the factorizations.
  !>               The unit diagonal elements of L_i are not stored.
  !>     @param[in]
  !>     lda       int. lda >= n.\n
  !>               Specifies the leading dimension of matrices A_i.
  !>     @param[out]
  !>     ipiv      pointer to int. Array on the GPU.\n
  !>               Contains the vectors of pivot indices ipiv_i (corresponding to A_i).
  !>               Dimension of ipiv_i is n.
  !>               Elements of ipiv_i are 1-based indices.
  !>               For each instance A_i in the batch and for 1 <= j <= n, the row j of the
  !>               matrix A_i was interchanged with row ipiv_i[j].
  !>               Matrix P_i of the factorization can be derived from ipiv_i.
  !>               The factorization here can be done without pivoting if ipiv is passed
  !>               in as a nullptr.
  !>     @param[out]
  !>     info      pointer to int. Array of batchCount integers on the GPU.\n
  !>               If info[i] = 0, successful exit for factorization of A_i.
  !>               If info[i] = j > 0, U_i is singular. U_i[j,j] is the first zero pivot.
  !>     @param[in]
  !>     batchCount int. batchCount >= 0.\n
  !>                 Number of matrices in the batch.
  !>     
  interface hipblasSgetrfBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgetrfBatched_(handle,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="cublasSgetrfBatched")
#else
    function hipblasSgetrfBatched_(handle,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="hipblasSgetrfBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrfBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSgetrfBatched_full_rank,&
      
hipblasSgetrfBatched_rank_0,&
      
hipblasSgetrfBatched_rank_1
#endif

  end interface
  
  interface hipblasDgetrfBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgetrfBatched_(handle,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="cublasDgetrfBatched")
#else
    function hipblasDgetrfBatched_(handle,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="hipblasDgetrfBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrfBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDgetrfBatched_full_rank,&
      
hipblasDgetrfBatched_rank_0,&
      
hipblasDgetrfBatched_rank_1
#endif

  end interface
  
  interface hipblasCgetrfBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgetrfBatched_(handle,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="cublasCgetrfBatched")
#else
    function hipblasCgetrfBatched_(handle,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="hipblasCgetrfBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrfBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgetrfBatched_full_rank,&
      
hipblasCgetrfBatched_rank_0,&
      
hipblasCgetrfBatched_rank_1
#endif

  end interface
  
  interface hipblasZgetrfBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgetrfBatched_(handle,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="cublasZgetrfBatched")
#else
    function hipblasZgetrfBatched_(handle,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="hipblasZgetrfBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrfBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgetrfBatched_full_rank,&
      
hipblasZgetrfBatched_rank_0,&
      
hipblasZgetrfBatched_rank_1
#endif

  end interface
  
  interface hipblasCgetrfBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgetrfBatched_v2_(handle,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="cublasCgetrfBatched_v2")
#else
    function hipblasCgetrfBatched_v2_(handle,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="hipblasCgetrfBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrfBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgetrfBatched_v2_full_rank,&
      
hipblasCgetrfBatched_v2_rank_0,&
      
hipblasCgetrfBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZgetrfBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgetrfBatched_v2_(handle,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="cublasZgetrfBatched_v2")
#else
    function hipblasZgetrfBatched_v2_(handle,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="hipblasZgetrfBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrfBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgetrfBatched_v2_full_rank,&
      
hipblasZgetrfBatched_v2_rank_0,&
      
hipblasZgetrfBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SOLVER API
  !> 
  !>     \details
  !>     getrfStridedBatched computes the LU factorization of a batch of
  !>     general n-by-n matrices using partial pivoting with row interchanges. The LU factorization can
  !>     be done without pivoting if ipiv is passed as a nullptr.
  !> 
  !>     In the case that ipiv is not null, the factorization of matrix \f$A_i\f$ in the batch has the form:
  !> 
  !>     \f[
  !>         A_i = P_iL_iU_i
  !>     \f]
  !> 
  !>     where \f$P_i\f$ is a permutation matrix, \f$L_i\f$ is lower triangular with unit
  !>     diagonal elements, and \f$U_i\f$ is upper triangular.
  !> 
  !>     In the case that ipiv is null, the factorization is done without pivoting:
  !> 
  !>     \f[
  !>         A_i = L_iU_i
  !>     \f]
  !> 
  !>     - Supported precisions in rocSOLVER : s,d,c,z
  !>     - Supported precisions in cuBLAS    : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    hipblasHandle_t.
  !>     @param[in]
  !>     n         int. n >= 0.\n
  !>               The number of columns and rows of all matrices A_i in the batch.
  !>     @param[inout]
  !>     A         pointer to type. Array on the GPU (the size depends on the value of strideA).\n
  !>               On entry, the n-by-n matrices A_i to be factored.
  !>               On exit, the factors L_i and U_i from the factorization.
  !>               The unit diagonal elements of L_i are not stored.
  !>     @param[in]
  !>     lda       int. lda >= n.\n
  !>               Specifies the leading dimension of matrices A_i.
  !>     @param[in]
  !>     strideA   hipblasStride.\n
  !>               Stride from the start of one matrix A_i to the next one A_(i+1).
  !>               There is no restriction for the value of strideA. Normal use case is strideA >= ldan
  !>     @param[out]
  !>     ipiv      pointer to int. Array on the GPU (the size depends on the value of strideP).\n
  !>               Contains the vectors of pivots indices ipiv_i (corresponding to A_i).
  !>               Dimension of ipiv_i is n.
  !>               Elements of ipiv_i are 1-based indices.
  !>               For each instance A_i in the batch and for 1 <= j <= n, the row j of the
  !>               matrix A_i was interchanged with row ipiv_i[j].
  !>               Matrix P_i of the factorization can be derived from ipiv_i.
  !>               The factorization here can be done without pivoting if ipiv is passed
  !>               in as a nullptr.
  !>     @param[in]
  !>     strideP   hipblasStride.\n
  !>               Stride from the start of one vector ipiv_i to the next one ipiv_(i+1).
  !>               There is no restriction for the value of strideP. Normal use case is strideP >= n.
  !>     @param[out]
  !>     info      pointer to int. Array of batchCount integers on the GPU.\n
  !>               If info[i] = 0, successful exit for factorization of A_i.
  !>               If info[i] = j > 0, U_i is singular. U_i[j,j] is the first zero pivot.
  !>     @param[in]
  !>     batchCount int. batchCount >= 0.\n
  !>                 Number of matrices in the batch.
  !>     
  interface hipblasSgetrfStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgetrfStridedBatched_(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="cublasSgetrfStridedBatched")
#else
    function hipblasSgetrfStridedBatched_(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="hipblasSgetrfStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrfStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSgetrfStridedBatched_full_rank,&
      
hipblasSgetrfStridedBatched_rank_0,&
      
hipblasSgetrfStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDgetrfStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgetrfStridedBatched_(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="cublasDgetrfStridedBatched")
#else
    function hipblasDgetrfStridedBatched_(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="hipblasDgetrfStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrfStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDgetrfStridedBatched_full_rank,&
      
hipblasDgetrfStridedBatched_rank_0,&
      
hipblasDgetrfStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCgetrfStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgetrfStridedBatched_(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="cublasCgetrfStridedBatched")
#else
    function hipblasCgetrfStridedBatched_(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="hipblasCgetrfStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrfStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgetrfStridedBatched_full_rank,&
      
hipblasCgetrfStridedBatched_rank_0,&
      
hipblasCgetrfStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZgetrfStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgetrfStridedBatched_(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="cublasZgetrfStridedBatched")
#else
    function hipblasZgetrfStridedBatched_(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="hipblasZgetrfStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrfStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgetrfStridedBatched_full_rank,&
      
hipblasZgetrfStridedBatched_rank_0,&
      
hipblasZgetrfStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCgetrfStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgetrfStridedBatched_v2_(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="cublasCgetrfStridedBatched_v2")
#else
    function hipblasCgetrfStridedBatched_v2_(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="hipblasCgetrfStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrfStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgetrfStridedBatched_v2_full_rank,&
      
hipblasCgetrfStridedBatched_v2_rank_0,&
      
hipblasCgetrfStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZgetrfStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgetrfStridedBatched_v2_(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="cublasZgetrfStridedBatched_v2")
#else
    function hipblasZgetrfStridedBatched_v2_(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="hipblasZgetrfStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrfStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgetrfStridedBatched_v2_full_rank,&
      
hipblasZgetrfStridedBatched_v2_rank_0,&
      
hipblasZgetrfStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SOLVER API
  !> 
  !>     \details
  !>     getrs solves a system of n linear equations on n variables in its factorized form.
  !> 
  !>     It solves one of the following systems, depending on the value of trans:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A X = B & \: \text{not transposed,}\\
  !>         A^T X = B & \: \text{transposed, or}\\
  !>         A^H X = B & \: \text{conjugate transposed.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Matrix A is defined by its triangular factors as returned by \ref hipblasSgetrf "getrf".
  !> 
  !>     - Supported precisions in rocSOLVER : s,d,c,z
  !>     - Supported precisions in cuBLAS    : s,d,c,z
  !> 
  !> 
  !>     @param[in]
  !>     handle      hipblasHandle_t.
  !>     @param[in]
  !>     trans       hipblasOperation_t.\n
  !>                 Specifies the form of the system of equations.
  !>     @param[in]
  !>     n           int. n >= 0.\n
  !>                 The order of the system, i.e. the number of columns and rows of A.
  !>     @param[in]
  !>     nrhs        int. nrhs >= 0.\n
  !>                 The number of right hand sides, i.e., the number of columns
  !>                 of the matrix B.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU of dimension ldan.\n
  !>                 The factors L and U of the factorization A = PLU returned by \ref hipblasSgetrf "getrf".
  !>     @param[in]
  !>     lda         int. lda >= n.\n
  !>                 The leading dimension of A.
  !>     @param[in]
  !>     ipiv        pointer to int. Array on the GPU of dimension n.\n
  !>                 The pivot indices returned by \ref hipblasSgetrf "getrf".
  !>     @param[in,out]
  !>     B           pointer to type. Array on the GPU of dimension ldbnrhs.\n
  !>                 On entry, the right hand side matrix B.
  !>                 On exit, the solution matrix X.
  !>     @param[in]
  !>     ldb         int. ldb >= n.\n
  !>                 The leading dimension of B.
  !>     @param[out]
  !>     info      pointer to a int on the host.\n
  !>               If info = 0, successful exit.
  !>               If info = j < 0, the argument at position -j is invalid.
  !>    
  interface hipblasSgetrs
#ifdef USE_CUDA_NAMES
    function hipblasSgetrs_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo) bind(c, name="cublasSgetrs")
#else
    function hipblasSgetrs_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo) bind(c, name="hipblasSgetrs")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrs_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSgetrs_full_rank,&
      
hipblasSgetrs_rank_0,&
      
hipblasSgetrs_rank_1
#endif

  end interface
  
  interface hipblasDgetrs
#ifdef USE_CUDA_NAMES
    function hipblasDgetrs_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo) bind(c, name="cublasDgetrs")
#else
    function hipblasDgetrs_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo) bind(c, name="hipblasDgetrs")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrs_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDgetrs_full_rank,&
      
hipblasDgetrs_rank_0,&
      
hipblasDgetrs_rank_1
#endif

  end interface
  
  interface hipblasCgetrs
#ifdef USE_CUDA_NAMES
    function hipblasCgetrs_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo) bind(c, name="cublasCgetrs")
#else
    function hipblasCgetrs_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo) bind(c, name="hipblasCgetrs")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrs_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgetrs_full_rank,&
      
hipblasCgetrs_rank_0,&
      
hipblasCgetrs_rank_1
#endif

  end interface
  
  interface hipblasZgetrs
#ifdef USE_CUDA_NAMES
    function hipblasZgetrs_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo) bind(c, name="cublasZgetrs")
#else
    function hipblasZgetrs_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo) bind(c, name="hipblasZgetrs")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrs_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgetrs_full_rank,&
      
hipblasZgetrs_rank_0,&
      
hipblasZgetrs_rank_1
#endif

  end interface
  
  interface hipblasCgetrs_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgetrs_v2_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo) bind(c, name="cublasCgetrs_v2")
#else
    function hipblasCgetrs_v2_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo) bind(c, name="hipblasCgetrs_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrs_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgetrs_v2_full_rank,&
      
hipblasCgetrs_v2_rank_0,&
      
hipblasCgetrs_v2_rank_1
#endif

  end interface
  
  interface hipblasZgetrs_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgetrs_v2_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo) bind(c, name="cublasZgetrs_v2")
#else
    function hipblasZgetrs_v2_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo) bind(c, name="hipblasZgetrs_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrs_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgetrs_v2_full_rank,&
      
hipblasZgetrs_v2_rank_0,&
      
hipblasZgetrs_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SOLVER API
  !> 
  !>     \details getrsBatched solves a batch of systems of n linear equations on n
  !>     variables in its factorized forms.
  !> 
  !>     For each instance i in the batch, it solves one of the following systems, depending on the value of trans:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_i X_i = B_i & \: \text{not transposed,}\\
  !>         A_i^T X_i = B_i & \: \text{transposed, or}\\
  !>         A_i^H X_i = B_i & \: \text{conjugate transposed.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Matrix \f$A_i\f$ is defined by its triangular factors as returned by \ref hipblasSgetrfBatched "getrfBatched".
  !> 
  !>     - Supported precisions in rocSOLVER : s,d,c,z
  !>     - Supported precisions in cuBLAS    : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle      hipblasHandle_t.
  !>     @param[in]
  !>     trans       hipblasOperation_t.\n
  !>                 Specifies the form of the system of equations of each instance in the batch.
  !>     @param[in]
  !>     n           int. n >= 0.\n
  !>                 The order of the system, i.e. the number of columns and rows of all A_i matrices.
  !>     @param[in]
  !>     nrhs        int. nrhs >= 0.\n
  !>                 The number of right hand sides, i.e., the number of columns
  !>                 of all the matrices B_i.
  !>     @param[in]
  !>     A           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.\n
  !>                 The factors L_i and U_i of the factorization A_i = P_iL_iU_i returned by \ref hipblasSgetrfBatched "getrfBatched".
  !>     @param[in]
  !>     lda         int. lda >= n.\n
  !>                 The leading dimension of matrices A_i.
  !>     @param[in]
  !>     ipiv        pointer to int. Array on the GPU.\n
  !>                 Contains the vectors ipiv_i of pivot indices returned by \ref hipblasSgetrfBatched "getrfBatched".
  !>     @param[in,out]
  !>     B           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldbnrhs.\n
  !>                 On entry, the right hand side matrices B_i.
  !>                 On exit, the solution matrix X_i of each system in the batch.
  !>     @param[in]
  !>     ldb         int. ldb >= n.\n
  !>                 The leading dimension of matrices B_i.
  !>     @param[out]
  !>     info      pointer to a int on the host.\n
  !>               If info = 0, successful exit.
  !>               If info = j < 0, the argument at position -j is invalid.
  !>     @param[in]
  !>     batchCount int. batchCount >= 0.\n
  !>                 Number of instances (systems) in the batch.
  !> 
  !>    
  interface hipblasSgetrsBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgetrsBatched_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount) bind(c, name="cublasSgetrsBatched")
#else
    function hipblasSgetrsBatched_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount) bind(c, name="hipblasSgetrsBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrsBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSgetrsBatched_full_rank,&
      
hipblasSgetrsBatched_rank_0,&
      
hipblasSgetrsBatched_rank_1
#endif

  end interface
  
  interface hipblasDgetrsBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgetrsBatched_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount) bind(c, name="cublasDgetrsBatched")
#else
    function hipblasDgetrsBatched_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount) bind(c, name="hipblasDgetrsBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrsBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDgetrsBatched_full_rank,&
      
hipblasDgetrsBatched_rank_0,&
      
hipblasDgetrsBatched_rank_1
#endif

  end interface
  
  interface hipblasCgetrsBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgetrsBatched_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount) bind(c, name="cublasCgetrsBatched")
#else
    function hipblasCgetrsBatched_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount) bind(c, name="hipblasCgetrsBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrsBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgetrsBatched_full_rank,&
      
hipblasCgetrsBatched_rank_0,&
      
hipblasCgetrsBatched_rank_1
#endif

  end interface
  
  interface hipblasZgetrsBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgetrsBatched_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount) bind(c, name="cublasZgetrsBatched")
#else
    function hipblasZgetrsBatched_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount) bind(c, name="hipblasZgetrsBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrsBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgetrsBatched_full_rank,&
      
hipblasZgetrsBatched_rank_0,&
      
hipblasZgetrsBatched_rank_1
#endif

  end interface
  
  interface hipblasCgetrsBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgetrsBatched_v2_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount) bind(c, name="cublasCgetrsBatched_v2")
#else
    function hipblasCgetrsBatched_v2_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount) bind(c, name="hipblasCgetrsBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrsBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgetrsBatched_v2_full_rank,&
      
hipblasCgetrsBatched_v2_rank_0,&
      
hipblasCgetrsBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZgetrsBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgetrsBatched_v2_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount) bind(c, name="cublasZgetrsBatched_v2")
#else
    function hipblasZgetrsBatched_v2_(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount) bind(c, name="hipblasZgetrsBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrsBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgetrsBatched_v2_full_rank,&
      
hipblasZgetrsBatched_v2_rank_0,&
      
hipblasZgetrsBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SOLVER API
  !> 
  !>     \details
  !>     getrsStridedBatched solves a batch of systems of n linear equations
  !>     on n variables in its factorized forms.
  !> 
  !>     For each instance i in the batch, it solves one of the following systems, depending on the value of trans:
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_i X_i = B_i & \: \text{not transposed,}\\
  !>         A_i^T X_i = B_i & \: \text{transposed, or}\\
  !>         A_i^H X_i = B_i & \: \text{conjugate transposed.}
  !>         \end{array}
  !>     \f]
  !> 
  !>     Matrix \f$A_i\f$ is defined by its triangular factors as returned by \ref hipblasSgetrfStridedBatched "getrfStridedBatched".
  !> 
  !>     - Supported precisions in rocSOLVER : s,d,c,z
  !>     - Supported precisions in cuBLAS    : No support
  !> 
  !>     @param[in]
  !>     handle      hipblasHandle_t.
  !>     @param[in]
  !>     trans       hipblasOperation_t.\n
  !>                 Specifies the form of the system of equations of each instance in the batch.
  !>     @param[in]
  !>     n           int. n >= 0.\n
  !>                 The order of the system, i.e. the number of columns and rows of all A_i matrices.
  !>     @param[in]
  !>     nrhs        int. nrhs >= 0.\n
  !>                 The number of right hand sides, i.e., the number of columns
  !>                 of all the matrices B_i.
  !>     @param[in]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).\n
  !>                 The factors L_i and U_i of the factorization A_i = P_iL_iU_i returned by \ref hipblasSgetrfStridedBatched "getrfStridedBatched".
  !>     @param[in]
  !>     lda         int. lda >= n.\n
  !>                 The leading dimension of matrices A_i.
  !>     @param[in]
  !>     strideA     hipblasStride.\n
  !>                 Stride from the start of one matrix A_i to the next one A_(i+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[in]
  !>     ipiv        pointer to int. Array on the GPU (the size depends on the value of strideP).\n
  !>                 Contains the vectors ipiv_i of pivot indices returned by \ref hipblasSgetrfStridedBatched "getrfStridedBatched".
  !>     @param[in]
  !>     strideP     hipblasStride.\n
  !>                 Stride from the start of one vector ipiv_i to the next one ipiv_(i+1).
  !>                 There is no restriction for the value of strideP. Normal use case is strideP >= n.
  !>     @param[in,out]
  !>     B           pointer to type. Array on the GPU (size depends on the value of strideB).\n
  !>                 On entry, the right hand side matrices B_i.
  !>                 On exit, the solution matrix X_i of each system in the batch.
  !>     @param[in]
  !>     ldb         int. ldb >= n.\n
  !>                 The leading dimension of matrices B_i.
  !>     @param[in]
  !>     strideB     hipblasStride.\n
  !>                 Stride from the start of one matrix B_i to the next one B_(i+1).
  !>                 There is no restriction for the value of strideB. Normal use case is strideB >= ldbnrhs.
  !>     @param[out]
  !>     info      pointer to a int on the host.\n
  !>               If info = 0, successful exit.
  !>               If info = j < 0, the argument at position -j is invalid.
  !>     @param[in]
  !>     batchCount int. batchCount >= 0.\n
  !>                 Number of instances (systems) in the batch.
  !> 
  !>    
  interface hipblasSgetrsStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgetrsStridedBatched_(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount) bind(c, name="cublasSgetrsStridedBatched")
#else
    function hipblasSgetrsStridedBatched_(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount) bind(c, name="hipblasSgetrsStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrsStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSgetrsStridedBatched_full_rank,&
      
hipblasSgetrsStridedBatched_rank_0,&
      
hipblasSgetrsStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDgetrsStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgetrsStridedBatched_(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount) bind(c, name="cublasDgetrsStridedBatched")
#else
    function hipblasDgetrsStridedBatched_(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount) bind(c, name="hipblasDgetrsStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrsStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDgetrsStridedBatched_full_rank,&
      
hipblasDgetrsStridedBatched_rank_0,&
      
hipblasDgetrsStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCgetrsStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgetrsStridedBatched_(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount) bind(c, name="cublasCgetrsStridedBatched")
#else
    function hipblasCgetrsStridedBatched_(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount) bind(c, name="hipblasCgetrsStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrsStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgetrsStridedBatched_full_rank,&
      
hipblasCgetrsStridedBatched_rank_0,&
      
hipblasCgetrsStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZgetrsStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgetrsStridedBatched_(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount) bind(c, name="cublasZgetrsStridedBatched")
#else
    function hipblasZgetrsStridedBatched_(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount) bind(c, name="hipblasZgetrsStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrsStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgetrsStridedBatched_full_rank,&
      
hipblasZgetrsStridedBatched_rank_0,&
      
hipblasZgetrsStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCgetrsStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgetrsStridedBatched_v2_(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount) bind(c, name="cublasCgetrsStridedBatched_v2")
#else
    function hipblasCgetrsStridedBatched_v2_(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount) bind(c, name="hipblasCgetrsStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrsStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgetrsStridedBatched_v2_full_rank,&
      
hipblasCgetrsStridedBatched_v2_rank_0,&
      
hipblasCgetrsStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZgetrsStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgetrsStridedBatched_v2_(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount) bind(c, name="cublasZgetrsStridedBatched_v2")
#else
    function hipblasZgetrsStridedBatched_v2_(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount) bind(c, name="hipblasZgetrsStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrsStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgetrsStridedBatched_v2_full_rank,&
      
hipblasZgetrsStridedBatched_v2_rank_0,&
      
hipblasZgetrsStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SOLVER API
  !> 
  !>     \details
  !>     getriBatched computes the inverse \f$C_i = A_i^{-1}\f$ of a batch of general n-by-n matrices \f$A_i\f$.
  !> 
  !>     The inverse is computed by solving the linear system
  !> 
  !>     \f[
  !>         A_i C_i = I
  !>     \f]
  !> 
  !>     where I is the identity matrix, and \f$A_i\f$ is factorized as \f$A_i = P_i  L_i  U_i\f$ as given by \ref hipblasSgetrfBatched "getrfBatched".
  !> 
  !>     - Supported precisions in rocSOLVER : s,d,c,z
  !>     - Supported precisions in cuBLAS    : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    hipblasHandle_t.
  !>     @param[in]
  !>     n         int. n >= 0.\n
  !>               The number of rows and columns of all matrices A_i in the batch.
  !>     @param[in]
  !>     A         array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.\n
  !>               The factors L_i and U_i of the factorization A_i = P_iL_iU_i returned by \ref hipblasSgetrfBatched "getrfBatched".
  !>     @param[in]
  !>     lda       int. lda >= n.\n
  !>               Specifies the leading dimension of matrices A_i.
  !>     @param[in]
  !>     ipiv      pointer to int. Array on the GPU (the size depends on the value of strideP).\n
  !>               The pivot indices returned by \ref hipblasSgetrfBatched "getrfBatched".
  !>               ipiv can be passed in as a nullptr, this will assume that getrfBatched was called without partial pivoting.
  !>     @param[out]
  !>     C         array of pointers to type. Each pointer points to an array on the GPU of dimension ldcn.\n
  !>               If info[i] = 0, the inverse of matrices A_i. Otherwise, undefined.
  !>     @param[in]
  !>     ldc       int. ldc >= n.\n
  !>               Specifies the leading dimension of C_i.
  !>     @param[out]
  !>     info      pointer to int. Array of batchCount integers on the GPU.\n
  !>               If info[i] = 0, successful exit for inversion of A_i.
  !>               If info[i] = j > 0, U_i is singular. U_i[j,j] is the first zero pivot.
  !>     @param[in]
  !>     batchCount int. batchCount >= 0.\n
  !>                 Number of matrices in the batch.
  !> 
  !>     
  interface hipblasSgetriBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgetriBatched_(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount) bind(c, name="cublasSgetriBatched")
#else
    function hipblasSgetriBatched_(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount) bind(c, name="hipblasSgetriBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetriBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSgetriBatched_full_rank,&
      
hipblasSgetriBatched_rank_0,&
      
hipblasSgetriBatched_rank_1
#endif

  end interface
  
  interface hipblasDgetriBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgetriBatched_(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount) bind(c, name="cublasDgetriBatched")
#else
    function hipblasDgetriBatched_(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount) bind(c, name="hipblasDgetriBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetriBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDgetriBatched_full_rank,&
      
hipblasDgetriBatched_rank_0,&
      
hipblasDgetriBatched_rank_1
#endif

  end interface
  
  interface hipblasCgetriBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgetriBatched_(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount) bind(c, name="cublasCgetriBatched")
#else
    function hipblasCgetriBatched_(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount) bind(c, name="hipblasCgetriBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetriBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgetriBatched_full_rank,&
      
hipblasCgetriBatched_rank_0,&
      
hipblasCgetriBatched_rank_1
#endif

  end interface
  
  interface hipblasZgetriBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgetriBatched_(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount) bind(c, name="cublasZgetriBatched")
#else
    function hipblasZgetriBatched_(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount) bind(c, name="hipblasZgetriBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetriBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgetriBatched_full_rank,&
      
hipblasZgetriBatched_rank_0,&
      
hipblasZgetriBatched_rank_1
#endif

  end interface
  
  interface hipblasCgetriBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgetriBatched_v2_(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount) bind(c, name="cublasCgetriBatched_v2")
#else
    function hipblasCgetriBatched_v2_(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount) bind(c, name="hipblasCgetriBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetriBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgetriBatched_v2_full_rank,&
      
hipblasCgetriBatched_v2_rank_0,&
      
hipblasCgetriBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZgetriBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgetriBatched_v2_(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount) bind(c, name="cublasZgetriBatched_v2")
#else
    function hipblasZgetriBatched_v2_(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount) bind(c, name="hipblasZgetriBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetriBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr) :: C
      integer(c_int),value :: ldc
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgetriBatched_v2_full_rank,&
      
hipblasZgetriBatched_v2_rank_0,&
      
hipblasZgetriBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief GELS solves an overdetermined (or underdetermined) linear system defined by an m-by-n
  !>     matrix A, and a corresponding matrix B, using the QR factorization computed by \ref hipblasSgeqrf "GEQRF" (or the LQ
  !>     factorization computed by "GELQF").
  !> 
  !>     \details
  !>     Depending on the value of trans, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A X = B & \: \text{not transposed, or}\\
  !>         A' X = B & \: \text{transposed if real, or conjugate transposed if complex}
  !>         \end{array}
  !>     \f]
  !> 
  !>     If m >= n (or m < n in the case of transposeconjugate transpose), the system is overdetermined
  !>     and a least-squares solution approximating X is found by minimizing
  !> 
  !>     \f[
  !>         || B - A  X || \quad \text{(or} \: || B - A' X ||\text{)}
  !>     \f]
  !> 
  !>     If m < n (or m >= n in the case of transposeconjugate transpose), the system is underdetermined
  !>     and a unique solution for X is chosen such that \f$|| X ||\f$ is minimal.
  !> 
  !>     - Supported precisions in rocSOLVER : s,d,c,z
  !>     - Supported precisions in cuBLAS    : currently unsupported
  !> 
  !>     @param[in]
  !>     handle      hipblasHandle_t.
  !>     @param[in]
  !>     trans       hipblasOperation_t.\n
  !>                 Specifies the form of the system of equations.
  !>     @param[in]
  !>     m           int. m >= 0.\n
  !>                 The number of rows of matrix A.
  !>     @param[in]
  !>     n           int. n >= 0.\n
  !>                 The number of columns of matrix A.
  !>     @param[in]
  !>     nrhs        int. nrhs >= 0.\n
  !>                 The number of columns of matrices B and X;
  !>                 i.e., the columns on the right hand side.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU of dimension ldan.\n
  !>                 On entry, the matrix A.
  !>                 On exit, the QR (or LQ) factorization of A as returned by "GEQRF" (or "GELQF").
  !>     @param[in]
  !>     lda         int. lda >= m.\n
  !>                 Specifies the leading dimension of matrix A.
  !>     @param[inout]
  !>     B           pointer to type. Array on the GPU of dimension ldbnrhs.\n
  !>                 On entry, the matrix B.
  !>                 On exit, when info = 0, B is overwritten by the solution vectors (and the residuals in
  !>                 the overdetermined cases) stored as columns.
  !>     @param[in]
  !>     ldb         int. ldb >= max(m,n).\n
  !>                 Specifies the leading dimension of matrix B.
  !>     @param[out]
  !>     info        pointer to an int on the host.\n
  !>                 If info = 0, successful exit.
  !>                 If info = j < 0, the argument at position -j is invalid.
  !>     @param[out]
  !>     deviceInfo  pointer to int on the GPU.\n
  !>                 If info = 0, successful exit.
  !>                 If info = i > 0, the solution could not be computed because input matrix A is
  !>                 rank deficient; the i-th diagonal element of its triangular factor is zero.
  !>     
  interface hipblasSgels
#ifdef USE_CUDA_NAMES
    function hipblasSgels_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo) bind(c, name="cublasSgels")
#else
    function hipblasSgels_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo) bind(c, name="hipblasSgels")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgels_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      type(c_ptr),value :: deviceInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSgels_full_rank,&
      
hipblasSgels_rank_0,&
      
hipblasSgels_rank_1
#endif

  end interface
  
  interface hipblasDgels
#ifdef USE_CUDA_NAMES
    function hipblasDgels_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo) bind(c, name="cublasDgels")
#else
    function hipblasDgels_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo) bind(c, name="hipblasDgels")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgels_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      type(c_ptr),value :: deviceInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDgels_full_rank,&
      
hipblasDgels_rank_0,&
      
hipblasDgels_rank_1
#endif

  end interface
  
  interface hipblasCgels
#ifdef USE_CUDA_NAMES
    function hipblasCgels_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo) bind(c, name="cublasCgels")
#else
    function hipblasCgels_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo) bind(c, name="hipblasCgels")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgels_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      type(c_ptr),value :: deviceInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgels_full_rank,&
      
hipblasCgels_rank_0,&
      
hipblasCgels_rank_1
#endif

  end interface
  
  interface hipblasZgels
#ifdef USE_CUDA_NAMES
    function hipblasZgels_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo) bind(c, name="cublasZgels")
#else
    function hipblasZgels_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo) bind(c, name="hipblasZgels")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgels_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      type(c_ptr),value :: deviceInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgels_full_rank,&
      
hipblasZgels_rank_0,&
      
hipblasZgels_rank_1
#endif

  end interface
  
  interface hipblasCgels_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgels_v2_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo) bind(c, name="cublasCgels_v2")
#else
    function hipblasCgels_v2_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo) bind(c, name="hipblasCgels_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgels_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      type(c_ptr),value :: deviceInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgels_v2_full_rank,&
      
hipblasCgels_v2_rank_0,&
      
hipblasCgels_v2_rank_1
#endif

  end interface
  
  interface hipblasZgels_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgels_v2_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo) bind(c, name="cublasZgels_v2")
#else
    function hipblasZgels_v2_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo) bind(c, name="hipblasZgels_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgels_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      type(c_ptr),value :: deviceInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgels_v2_full_rank,&
      
hipblasZgels_v2_rank_0,&
      
hipblasZgels_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief gelsBatched solves a batch of overdetermined (or underdetermined) linear systems
  !>     defined by a set of m-by-n matrices \f$A_j\f$, and corresponding matrices \f$B_j\f$, using the
  !>     QR factorizations computed by "GEQRF_BATCHED" (or the LQ factorizations computed by "GELQF_BATCHED").
  !> 
  !>     \details
  !>     For each instance in the batch, depending on the value of trans, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_j X_j = B_j & \: \text{not transposed, or}\\
  !>         A_j' X_j = B_j & \: \text{transposed if real, or conjugate transposed if complex}
  !>         \end{array}
  !>     \f]
  !> 
  !>     If m >= n (or m < n in the case of transposeconjugate transpose), the system is overdetermined
  !>     and a least-squares solution approximating X_j is found by minimizing
  !> 
  !>     \f[
  !>         || B_j - A_j  X_j || \quad \text{(or} \: || B_j - A_j' X_j ||\text{)}
  !>     \f]
  !> 
  !>     If m < n (or m >= n in the case of transposeconjugate transpose), the system is underdetermined
  !>     and a unique solution for X_j is chosen such that \f$|| X_j ||\f$ is minimal.
  !> 
  !>     - Supported precisions in rocSOLVER : s,d,c,z
  !>     - Supported precisions in cuBLAS    : s,d,c,z
  !>     Note that cuBLAS backend supports only the non-transpose operation and only solves over-determined systems (m >= n).
  !> 
  !>     @param[in]
  !>     handle      hipblasHandle_t.
  !>     @param[in]
  !>     trans       hipblasOperation_t.\n
  !>                 Specifies the form of the system of equations.
  !>     @param[in]
  !>     m           int. m >= 0.\n
  !>                 The number of rows of all matrices A_j in the batch.
  !>     @param[in]
  !>     n           int. n >= 0.\n
  !>                 The number of columns of all matrices A_j in the batch.
  !>     @param[in]
  !>     nrhs        int. nrhs >= 0.\n
  !>                 The number of columns of all matrices B_j and X_j in the batch;
  !>                 i.e., the columns on the right hand side.
  !>     @param[inout]
  !>     A           array of pointer to type. Each pointer points to an array on the GPU of dimension ldan.\n
  !>                 On entry, the matrices A_j.
  !>                 On exit, the QR (or LQ) factorizations of A_j as returned by "GEQRF_BATCHED"
  !>                 (or "GELQF_BATCHED").
  !>     @param[in]
  !>     lda         int. lda >= m.\n
  !>                 Specifies the leading dimension of matrices A_j.
  !>     @param[inout]
  !>     B           array of pointer to type. Each pointer points to an array on the GPU of dimension ldbnrhs.\n
  !>                 On entry, the matrices B_j.
  !>                 On exit, when info[j] = 0, B_j is overwritten by the solution vectors (and the residuals in
  !>                 the overdetermined cases) stored as columns.
  !>     @param[in]
  !>     ldb         int. ldb >= max(m,n).\n
  !>                 Specifies the leading dimension of matrices B_j.
  !>     @param[out]
  !>     info        pointer to an int on the host.\n
  !>                 If info = 0, successful exit.
  !>                 If info = j < 0, the argument at position -j is invalid.
  !>     @param[out]
  !>     deviceInfo  pointer to int. Array of batchCount integers on the GPU.\n
  !>                 If deviceInfo[j] = 0, successful exit for solution of A_j.
  !>                 If deviceInfo[j] = i > 0, the solution of A_j could not be computed because input
  !>                 matrix A_j is rank deficient; the i-th diagonal element of its triangular factor is zero.
  !>     @param[in]
  !>     batchCount  int. batchCount >= 0.\n
  !>                 Number of matrices in the batch.
  !>     
  interface hipblasSgelsBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgelsBatched_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount) bind(c, name="cublasSgelsBatched")
#else
    function hipblasSgelsBatched_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount) bind(c, name="hipblasSgelsBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgelsBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      type(c_ptr),value :: deviceInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSgelsBatched_full_rank,&
      
hipblasSgelsBatched_rank_0,&
      
hipblasSgelsBatched_rank_1
#endif

  end interface
  
  interface hipblasDgelsBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgelsBatched_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount) bind(c, name="cublasDgelsBatched")
#else
    function hipblasDgelsBatched_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount) bind(c, name="hipblasDgelsBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgelsBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      type(c_ptr),value :: deviceInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDgelsBatched_full_rank,&
      
hipblasDgelsBatched_rank_0,&
      
hipblasDgelsBatched_rank_1
#endif

  end interface
  
  interface hipblasCgelsBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgelsBatched_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount) bind(c, name="cublasCgelsBatched")
#else
    function hipblasCgelsBatched_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount) bind(c, name="hipblasCgelsBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgelsBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      type(c_ptr),value :: deviceInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgelsBatched_full_rank,&
      
hipblasCgelsBatched_rank_0,&
      
hipblasCgelsBatched_rank_1
#endif

  end interface
  
  interface hipblasZgelsBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgelsBatched_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount) bind(c, name="cublasZgelsBatched")
#else
    function hipblasZgelsBatched_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount) bind(c, name="hipblasZgelsBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgelsBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      type(c_ptr),value :: deviceInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgelsBatched_full_rank,&
      
hipblasZgelsBatched_rank_0,&
      
hipblasZgelsBatched_rank_1
#endif

  end interface
  
  interface hipblasCgelsBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgelsBatched_v2_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount) bind(c, name="cublasCgelsBatched_v2")
#else
    function hipblasCgelsBatched_v2_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount) bind(c, name="hipblasCgelsBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgelsBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      type(c_ptr),value :: deviceInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgelsBatched_v2_full_rank,&
      
hipblasCgelsBatched_v2_rank_0,&
      
hipblasCgelsBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZgelsBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgelsBatched_v2_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount) bind(c, name="cublasZgelsBatched_v2")
#else
    function hipblasZgelsBatched_v2_(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount) bind(c, name="hipblasZgelsBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgelsBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: myInfo
      type(c_ptr),value :: deviceInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgelsBatched_v2_full_rank,&
      
hipblasZgelsBatched_v2_rank_0,&
      
hipblasZgelsBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief gelsStridedBatched solves a batch of overdetermined (or underdetermined) linear
  !>     systems defined by a set of m-by-n matrices \f$A_j\f$, and corresponding matrices \f$B_j\f$,
  !>     using the QR factorizations computed by "GEQRF_STRIDED_BATCHED"
  !>     (or the LQ factorizations computed by "GELQF_STRIDED_BATCHED").
  !> 
  !>     \details
  !>     For each instance in the batch, depending on the value of trans, the problem solved by this function is either of the form
  !> 
  !>     \f[
  !>         \begin{array}{cl}
  !>         A_j X_j = B_j & \: \text{not transposed, or}\\
  !>         A_j' X_j = B_j & \: \text{transposed if real, or conjugate transposed if complex}
  !>         \end{array}
  !>     \f]
  !> 
  !>     If m >= n (or m < n in the case of transposeconjugate transpose), the system is overdetermined
  !>     and a least-squares solution approximating X_j is found by minimizing
  !> 
  !>     \f[
  !>         || B_j - A_j  X_j || \quad \text{(or} \: || B_j - A_j' X_j ||\text{)}
  !>     \f]
  !> 
  !>     If m < n (or m >= n in the case of transposeconjugate transpose), the system is underdetermined
  !>     and a unique solution for X_j is chosen such that \f$|| X_j ||\f$ is minimal.
  !> 
  !>     - Supported precisions in rocSOLVER : s,d,c,z
  !>     - Supported precisions in cuBLAS    : currently unsupported
  !> 
  !>     @param[in]
  !>     handle      hipblasHandle_t.
  !>     @param[in]
  !>     trans       hipblasOperation_t.\n
  !>                 Specifies the form of the system of equations.
  !>     @param[in]
  !>     m           int. m >= 0.\n
  !>                 The number of rows of all matrices A_j in the batch.
  !>     @param[in]
  !>     n           int. n >= 0.\n
  !>                 The number of columns of all matrices A_j in the batch.
  !>     @param[in]
  !>     nrhs        int. nrhs >= 0.\n
  !>                 The number of columns of all matrices B_j and X_j in the batch;
  !>                 i.e., the columns on the right hand side.
  !>     @param[inout]
  !>     A           pointer to type. Array on the GPU (the size depends on the value of strideA).\n
  !>                 On entry, the matrices A_j.
  !>                 On exit, the QR (or LQ) factorizations of A_j as returned by "GEQRF_STRIDED_BATCHED"
  !>                 (or "GELQF_STRIDED_BATCHED").
  !>     @param[in]
  !>     lda         int. lda >= m.\n
  !>                 Specifies the leading dimension of matrices A_j.
  !>     @param[in]
  !>     strideA     hipblasStride.\n
  !>                 Stride from the start of one matrix A_j to the next one A_(j+1).
  !>                 There is no restriction for the value of strideA. Normal use case is strideA >= ldan
  !>     @param[inout]
  !>     B           pointer to type. Array on the GPU (the size depends on the value of strideB).\n
  !>                 On entry, the matrices B_j.
  !>                 On exit, when info[j] = 0, each B_j is overwritten by the solution vectors (and the residuals in
  !>                 the overdetermined cases) stored as columns.
  !>     @param[in]
  !>     ldb         int. ldb >= max(m,n).\n
  !>                 Specifies the leading dimension of matrices B_j.
  !>     @param[in]
  !>     strideB     hipblasStride.\n
  !>                 Stride from the start of one matrix B_j to the next one B_(j+1).
  !>                 There is no restriction for the value of strideB. Normal use case is strideB >= ldbnrhs
  !>     @param[out]
  !>     info        pointer to an int on the host.\n
  !>                 If info = 0, successful exit.
  !>                 If info = j < 0, the argument at position -j is invalid.
  !>     @param[out]
  !>     deviceInfo  pointer to int. Array of batchCount integers on the GPU.\n
  !>                 If deviceInfo[j] = 0, successful exit for solution of A_j.
  !>                 If deviceInfo[j] = i > 0, the solution of A_j could not be computed because input
  !>                 matrix A_j is rank deficient; the i-th diagonal element of its triangular factor is zero.
  !>     @param[in]
  !>     batchCount  int. batchCount >= 0.\n
  !>                 Number of matrices in the batch.
  !>     
  interface hipblasSgelsStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgelsStridedBatched_(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount) bind(c, name="cublasSgelsStridedBatched")
#else
    function hipblasSgelsStridedBatched_(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount) bind(c, name="hipblasSgelsStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgelsStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: myInfo
      type(c_ptr),value :: deviceInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSgelsStridedBatched_full_rank,&
      
hipblasSgelsStridedBatched_rank_0,&
      
hipblasSgelsStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDgelsStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgelsStridedBatched_(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount) bind(c, name="cublasDgelsStridedBatched")
#else
    function hipblasDgelsStridedBatched_(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount) bind(c, name="hipblasDgelsStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgelsStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: myInfo
      type(c_ptr),value :: deviceInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDgelsStridedBatched_full_rank,&
      
hipblasDgelsStridedBatched_rank_0,&
      
hipblasDgelsStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCgelsStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgelsStridedBatched_(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount) bind(c, name="cublasCgelsStridedBatched")
#else
    function hipblasCgelsStridedBatched_(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount) bind(c, name="hipblasCgelsStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgelsStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: myInfo
      type(c_ptr),value :: deviceInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgelsStridedBatched_full_rank,&
      
hipblasCgelsStridedBatched_rank_0,&
      
hipblasCgelsStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZgelsStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgelsStridedBatched_(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount) bind(c, name="cublasZgelsStridedBatched")
#else
    function hipblasZgelsStridedBatched_(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount) bind(c, name="hipblasZgelsStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgelsStridedBatched_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: myInfo
      type(c_ptr),value :: deviceInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgelsStridedBatched_full_rank,&
      
hipblasZgelsStridedBatched_rank_0,&
      
hipblasZgelsStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCgelsStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgelsStridedBatched_v2_(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount) bind(c, name="cublasCgelsStridedBatched_v2")
#else
    function hipblasCgelsStridedBatched_v2_(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount) bind(c, name="hipblasCgelsStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgelsStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: myInfo
      type(c_ptr),value :: deviceInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgelsStridedBatched_v2_full_rank,&
      
hipblasCgelsStridedBatched_v2_rank_0,&
      
hipblasCgelsStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZgelsStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgelsStridedBatched_v2_(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount) bind(c, name="cublasZgelsStridedBatched_v2")
#else
    function hipblasZgelsStridedBatched_v2_(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount) bind(c, name="hipblasZgelsStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgelsStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: trans
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: nrhs
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: myInfo
      type(c_ptr),value :: deviceInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgelsStridedBatched_v2_full_rank,&
      
hipblasZgelsStridedBatched_v2_rank_0,&
      
hipblasZgelsStridedBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SOLVER API
  !> 
  !>     \details
  !>     geqrf computes a QR factorization of a general m-by-n matrix A.
  !> 
  !>     The factorization has the form
  !> 
  !>     \f[
  !>         A = Q\left[\begin{array}{c}
  !>         R\\
  !>         0
  !>         \end{array}\right]
  !>     \f]
  !> 
  !>     where R is upper triangular (upper trapezoidal if m < n), and Q is
  !>     a m-by-m orthogonalunitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q = H_1H_2\cdots H_k, \quad \text{with} \: k = \text{min}(m,n)
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H_i\f$ is given by
  !> 
  !>     \f[
  !>         H_i = I - \text{ipiv}[i] \cdot v_i v_i'
  !>     \f]
  !> 
  !>     where the first i-1 elements of the Householder vector \f$v_i\f$ are zero, and \f$v_i[i] = 1\f$.
  !> 
  !>     - Supported precisions in rocSOLVER : s,d,c,z
  !>     - Supported precisions in cuBLAS    : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    hipblasHandle_t.
  !>     @param[in]
  !>     m         int. m >= 0.\n
  !>               The number of rows of the matrix A.
  !>     @param[in]
  !>     n         int. n >= 0.\n
  !>               The number of columns of the matrix A.
  !>     @param[inout]
  !>     A         pointer to type. Array on the GPU of dimension ldan.\n
  !>               On entry, the m-by-n matrix to be factored.
  !>               On exit, the elements on and above the diagonal contain the
  !>               factor R; the elements below the diagonal are the last m - i elements
  !>               of Householder vector v_i.
  !>     @param[in]
  !>     lda       int. lda >= m.\n
  !>               Specifies the leading dimension of A.
  !>     @param[out]
  !>     ipiv      pointer to type. Array on the GPU of dimension min(m,n).\n
  !>               The Householder scalars.
  !>     @param[out]
  !>     info      pointer to a int on the host.\n
  !>               If info = 0, successful exit.
  !>               If info = j < 0, the argument at position -j is invalid.
  !> 
  !>     
  interface hipblasSgeqrf
#ifdef USE_CUDA_NAMES
    function hipblasSgeqrf_(handle,m,n,A,lda,ipiv,myInfo) bind(c, name="cublasSgeqrf")
#else
    function hipblasSgeqrf_(handle,m,n,A,lda,ipiv,myInfo) bind(c, name="hipblasSgeqrf")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeqrf_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSgeqrf_full_rank,&
      
hipblasSgeqrf_rank_0,&
      
hipblasSgeqrf_rank_1
#endif

  end interface
  
  interface hipblasDgeqrf
#ifdef USE_CUDA_NAMES
    function hipblasDgeqrf_(handle,m,n,A,lda,ipiv,myInfo) bind(c, name="cublasDgeqrf")
#else
    function hipblasDgeqrf_(handle,m,n,A,lda,ipiv,myInfo) bind(c, name="hipblasDgeqrf")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeqrf_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDgeqrf_full_rank,&
      
hipblasDgeqrf_rank_0,&
      
hipblasDgeqrf_rank_1
#endif

  end interface
  
  interface hipblasCgeqrf
#ifdef USE_CUDA_NAMES
    function hipblasCgeqrf_(handle,m,n,A,lda,ipiv,myInfo) bind(c, name="cublasCgeqrf")
#else
    function hipblasCgeqrf_(handle,m,n,A,lda,ipiv,myInfo) bind(c, name="hipblasCgeqrf")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrf_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgeqrf_full_rank,&
      
hipblasCgeqrf_rank_0,&
      
hipblasCgeqrf_rank_1
#endif

  end interface
  
  interface hipblasZgeqrf
#ifdef USE_CUDA_NAMES
    function hipblasZgeqrf_(handle,m,n,A,lda,ipiv,myInfo) bind(c, name="cublasZgeqrf")
#else
    function hipblasZgeqrf_(handle,m,n,A,lda,ipiv,myInfo) bind(c, name="hipblasZgeqrf")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrf_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgeqrf_full_rank,&
      
hipblasZgeqrf_rank_0,&
      
hipblasZgeqrf_rank_1
#endif

  end interface
  
  interface hipblasCgeqrf_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgeqrf_v2_(handle,m,n,A,lda,ipiv,myInfo) bind(c, name="cublasCgeqrf_v2")
#else
    function hipblasCgeqrf_v2_(handle,m,n,A,lda,ipiv,myInfo) bind(c, name="hipblasCgeqrf_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrf_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgeqrf_v2_full_rank,&
      
hipblasCgeqrf_v2_rank_0,&
      
hipblasCgeqrf_v2_rank_1
#endif

  end interface
  
  interface hipblasZgeqrf_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgeqrf_v2_(handle,m,n,A,lda,ipiv,myInfo) bind(c, name="cublasZgeqrf_v2")
#else
    function hipblasZgeqrf_v2_(handle,m,n,A,lda,ipiv,myInfo) bind(c, name="hipblasZgeqrf_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrf_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: ipiv
      type(c_ptr),value :: myInfo
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgeqrf_v2_full_rank,&
      
hipblasZgeqrf_v2_rank_0,&
      
hipblasZgeqrf_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SOLVER API
  !> 
  !>     \details
  !>     geqrfBatched computes the QR factorization of a batch of general
  !>     m-by-n matrices.
  !> 
  !>     The factorization of matrix \f$A_i\f$ in the batch has the form
  !> 
  !>     \f[
  !>         A_i = Q_i\left[\begin{array}{c}
  !>         R_i\\
  !>         0
  !>         \end{array}\right]
  !>     \f]
  !> 
  !>     where \f$R_i\f$ is upper triangular (upper trapezoidal if m < n), and \f$Q_i\f$ is
  !>     a m-by-m orthogonalunitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q_i = H_{i_1}H_{i_2}\cdots H_{i_k}, \quad \text{with} \: k = \text{min}(m,n)
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H_{i_j}\f$ is given by
  !> 
  !>     \f[
  !>         H_{i_j} = I - \text{ipiv}_i[j] \cdot v_{i_j} v_{i_j}'
  !>     \f]
  !> 
  !>     where the first j-1 elements of Householder vector \f$v_{i_j}\f$ are zero, and \f$v_{i_j}[j] = 1\f$.
  !> 
  !>     - Supported precisions in rocSOLVER : s,d,c,z
  !>     - Supported precisions in cuBLAS    : s,d,c,z
  !> 
  !>     @param[in]
  !>     handle    hipblasHandle_t.
  !>     @param[in]
  !>     m         int. m >= 0.\n
  !>               The number of rows of all the matrices A_i in the batch.
  !>     @param[in]
  !>     n         int. n >= 0.\n
  !>               The number of columns of all the matrices A_i in the batch.
  !>     @param[inout]
  !>     A         Array of pointers to type. Each pointer points to an array on the GPU of dimension ldan.\n
  !>               On entry, the m-by-n matrices A_i to be factored.
  !>               On exit, the elements on and above the diagonal contain the
  !>               factor R_i. The elements below the diagonal are the last m - j elements
  !>               of Householder vector v_(i_j).
  !>     @param[in]
  !>     lda       int. lda >= m.\n
  !>               Specifies the leading dimension of matrices A_i.
  !>     @param[out]
  !>     ipiv      array of pointers to type. Each pointer points to an array on the GPU
  !>               of dimension min(m, n).\n
  !>               Contains the vectors ipiv_i of corresponding Householder scalars.
  !>     @param[out]
  !>     info      pointer to a int on the host.\n
  !>               If info = 0, successful exit.
  !>               If info = j < 0, the argument at position -j is invalid.
  !>     @param[in]
  !>     batchCount  int. batchCount >= 0.\n
  !>                  Number of matrices in the batch.
  !>     
  interface hipblasSgeqrfBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgeqrfBatched_(handle,m,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="cublasSgeqrfBatched")
#else
    function hipblasSgeqrfBatched_(handle,m,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="hipblasSgeqrfBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeqrfBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: ipiv
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSgeqrfBatched_full_rank,&
      
hipblasSgeqrfBatched_rank_0,&
      
hipblasSgeqrfBatched_rank_1
#endif

  end interface
  
  interface hipblasDgeqrfBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgeqrfBatched_(handle,m,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="cublasDgeqrfBatched")
#else
    function hipblasDgeqrfBatched_(handle,m,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="hipblasDgeqrfBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeqrfBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: ipiv
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDgeqrfBatched_full_rank,&
      
hipblasDgeqrfBatched_rank_0,&
      
hipblasDgeqrfBatched_rank_1
#endif

  end interface
  
  interface hipblasCgeqrfBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgeqrfBatched_(handle,m,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="cublasCgeqrfBatched")
#else
    function hipblasCgeqrfBatched_(handle,m,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="hipblasCgeqrfBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrfBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: ipiv
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgeqrfBatched_full_rank,&
      
hipblasCgeqrfBatched_rank_0,&
      
hipblasCgeqrfBatched_rank_1
#endif

  end interface
  
  interface hipblasZgeqrfBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgeqrfBatched_(handle,m,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="cublasZgeqrfBatched")
#else
    function hipblasZgeqrfBatched_(handle,m,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="hipblasZgeqrfBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrfBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: ipiv
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgeqrfBatched_full_rank,&
      
hipblasZgeqrfBatched_rank_0,&
      
hipblasZgeqrfBatched_rank_1
#endif

  end interface
  
  interface hipblasCgeqrfBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgeqrfBatched_v2_(handle,m,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="cublasCgeqrfBatched_v2")
#else
    function hipblasCgeqrfBatched_v2_(handle,m,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="hipblasCgeqrfBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrfBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: ipiv
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgeqrfBatched_v2_full_rank,&
      
hipblasCgeqrfBatched_v2_rank_0,&
      
hipblasCgeqrfBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZgeqrfBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgeqrfBatched_v2_(handle,m,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="cublasZgeqrfBatched_v2")
#else
    function hipblasZgeqrfBatched_v2_(handle,m,n,A,lda,ipiv,myInfo,batchCount) bind(c, name="hipblasZgeqrfBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrfBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr) :: A
      integer(c_int),value :: lda
      type(c_ptr) :: ipiv
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgeqrfBatched_v2_full_rank,&
      
hipblasZgeqrfBatched_v2_rank_0,&
      
hipblasZgeqrfBatched_v2_rank_1
#endif

  end interface
  !> ! @{
  !>     \brief SOLVER API
  !> 
  !>     \details
  !>     geqrfStridedBatched computes the QR factorization of a batch of
  !>     general m-by-n matrices.
  !> 
  !>     The factorization of matrix \f$A_i\f$ in the batch has the form
  !> 
  !>     \f[
  !>         A_i = Q_i\left[\begin{array}{c}
  !>         R_i\\
  !>         0
  !>         \end{array}\right]
  !>     \f]
  !> 
  !>     where \f$R_i\f$ is upper triangular (upper trapezoidal if m < n), and \f$Q_i\f$ is
  !>     a m-by-m orthogonalunitary matrix represented as the product of Householder matrices
  !> 
  !>     \f[
  !>         Q_i = H_{i_1}H_{i_2}\cdots H_{i_k}, \quad \text{with} \: k = \text{min}(m,n)
  !>     \f]
  !> 
  !>     Each Householder matrix \f$H_{i_j}\f$ is given by
  !> 
  !>     \f[
  !>         H_{i_j} = I - \text{ipiv}_j[j] \cdot v_{i_j} v_{i_j}'
  !>     \f]
  !> 
  !>     where the first j-1 elements of Householder vector \f$v_{i_j}\f$ are zero, and \f$v_{i_j}[j] = 1\f$.
  !> 
  !>     - Supported precisions in rocSOLVER : s,d,c,z
  !>     - Supported precisions in cuBLAS    : No support
  !> 
  !>     @param[in]
  !>     handle    hipblasHandle_t.
  !>     @param[in]
  !>     m         int. m >= 0.\n
  !>               The number of rows of all the matrices A_i in the batch.
  !>     @param[in]
  !>     n         int. n >= 0.\n
  !>               The number of columns of all the matrices A_i in the batch.
  !>     @param[inout]
  !>     A         pointer to type. Array on the GPU (the size depends on the value of strideA).\n
  !>               On entry, the m-by-n matrices A_i to be factored.
  !>               On exit, the elements on and above the diagonal contain the
  !>               factor R_i. The elements below the diagonal are the last m - j elements
  !>               of Householder vector v_(i_j).
  !>     @param[in]
  !>     lda       int. lda >= m.\n
  !>               Specifies the leading dimension of matrices A_i.
  !>     @param[in]
  !>     strideA   hipblasStride.\n
  !>               Stride from the start of one matrix A_i to the next one A_(i+1).
  !>               There is no restriction for the value of strideA. Normal use case is strideA >= ldan.
  !>     @param[out]
  !>     ipiv      pointer to type. Array on the GPU (the size depends on the value of strideP).\n
  !>               Contains the vectors ipiv_i of corresponding Householder scalars.
  !>     @param[in]
  !>     strideP   hipblasStride.\n
  !>               Stride from the start of one vector ipiv_i to the next one ipiv_(i+1).
  !>               There is no restriction for the value
  !>               of strideP. Normal use is strideP >= min(m,n).
  !>     @param[out]
  !>     info      pointer to a int on the host.\n
  !>               If info = 0, successful exit.
  !>               If info = j < 0, the argument at position -j is invalid.
  !>     @param[in]
  !>     batchCount  int. batchCount >= 0.\n
  !>                  Number of matrices in the batch.
  !>     
  interface hipblasSgeqrfStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasSgeqrfStridedBatched_(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="cublasSgeqrfStridedBatched")
#else
    function hipblasSgeqrfStridedBatched_(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="hipblasSgeqrfStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeqrfStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasSgeqrfStridedBatched_full_rank,&
      
hipblasSgeqrfStridedBatched_rank_0,&
      
hipblasSgeqrfStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasDgeqrfStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasDgeqrfStridedBatched_(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="cublasDgeqrfStridedBatched")
#else
    function hipblasDgeqrfStridedBatched_(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="hipblasDgeqrfStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeqrfStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasDgeqrfStridedBatched_full_rank,&
      
hipblasDgeqrfStridedBatched_rank_0,&
      
hipblasDgeqrfStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCgeqrfStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasCgeqrfStridedBatched_(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="cublasCgeqrfStridedBatched")
#else
    function hipblasCgeqrfStridedBatched_(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="hipblasCgeqrfStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrfStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgeqrfStridedBatched_full_rank,&
      
hipblasCgeqrfStridedBatched_rank_0,&
      
hipblasCgeqrfStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasZgeqrfStridedBatched
#ifdef USE_CUDA_NAMES
    function hipblasZgeqrfStridedBatched_(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="cublasZgeqrfStridedBatched")
#else
    function hipblasZgeqrfStridedBatched_(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="hipblasZgeqrfStridedBatched")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrfStridedBatched_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgeqrfStridedBatched_full_rank,&
      
hipblasZgeqrfStridedBatched_rank_0,&
      
hipblasZgeqrfStridedBatched_rank_1
#endif

  end interface
  
  interface hipblasCgeqrfStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasCgeqrfStridedBatched_v2_(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="cublasCgeqrfStridedBatched_v2")
#else
    function hipblasCgeqrfStridedBatched_v2_(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="hipblasCgeqrfStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrfStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasCgeqrfStridedBatched_v2_full_rank,&
      
hipblasCgeqrfStridedBatched_v2_rank_0,&
      
hipblasCgeqrfStridedBatched_v2_rank_1
#endif

  end interface
  
  interface hipblasZgeqrfStridedBatched_v2
#ifdef USE_CUDA_NAMES
    function hipblasZgeqrfStridedBatched_v2_(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="cublasZgeqrfStridedBatched_v2")
#else
    function hipblasZgeqrfStridedBatched_v2_(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount) bind(c, name="hipblasZgeqrfStridedBatched_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrfStridedBatched_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: ipiv
      integer(c_int64_t),value :: strideP
      type(c_ptr),value :: myInfo
      integer(c_int),value :: batchCount
    end function

#ifdef USE_FPOINTER_INTERFACES
    module procedure hipblasZgeqrfStridedBatched_v2_full_rank,&
      
hipblasZgeqrfStridedBatched_v2_rank_0,&
      
hipblasZgeqrfStridedBatched_v2_rank_1
#endif

  end interface
  !> ! \brief BLAS EX API
  !> 
  !>     \details
  !>     gemmEx performs one of the matrix-matrix operations
  !> 
  !>         C = alphaop( A )op( B ) + betaC,
  !> 
  !>     where op( X ) is one of
  !> 
  !>         op( X ) = X      or
  !>         op( X ) = XT   or
  !>         op( X ) = XH,
  !> 
  !>     alpha and beta are scalars, and A, B, and C are matrices, with
  !>     op( A ) an m by k matrix, op( B ) a k by n matrix and C is a m by n matrix.
  !> 
  !>     - Supported types are determined by the backend. See cuBLAS documentation for cuBLAS backend.
  !>       For rocBLAS backend, conversion from hipblasComputeType_t to rocblas_datatype_t happens within hipBLAS.
  !>       Supported types are as follows:
  !> 
  !>       |   aType    |   bType    |   cType    |     computeType     |
  !>       | ---------- | ---------- | ---------- | ------------------- |
  !>       | HIP_R_16F  | HIP_R_16F  | HIP_R_16F  | HIPBLAS_COMPUTE_16F |
  !>       | HIP_R_16F  | HIP_R_16F  | HIP_R_16F  | HIPBLAS_COMPUTE_32F |
  !>       | HIP_R_16F  | HIP_R_16F  | HIP_R_32F  | HIPBLAS_COMPUTE_32F |
  !>       | HIP_R_16BF | HIP_R_16BF | HIP_R_16BF | HIPBLAS_COMPUTE_32F |
  !>       | HIP_R_16BF | HIP_R_16BF | HIP_R_32F  | HIPBLAS_COMPUTE_32F |
  !>       | HIP_R_32F  | HIP_R_32F  | HIP_R_32F  | HIPBLAS_COMPUTE_32F |
  !>       | HIP_R_64F  | HIP_R_64F  | HIP_R_64F  | HIPBLAS_COMPUTE_64F |
  !>       | HIP_R_8I   | HIP_R_8I   | HIP_R_32I  | HIPBLAS_COMPUTE_32I |
  !>       | HIP_C_32F  | HIP_C_32F  | HIP_C_32F  | HIPBLAS_COMPUTE_32F |
  !>       | HIP_C_64F  | HIP_C_64F  | HIP_C_64F  | HIPBLAS_COMPUTE_64F |
  !> 
  !>     hipblasGemmExWithFlags is also available which is identical to hipblasGemmEx
  !>     with the addition of a "flags" parameter which controls flags used in Tensile to control gemm algorithms with the
  !>     rocBLAS backend. When using a cuBLAS backend this parameter is ignored.
  !> 
  !>     With HIPBLAS_V2 define, hipblasGemmEx accepts hipDataType for aType, bType, and cType.
  !>     It also accepts hipblasComputeType_t for computeType. hipblasGemmEx will no
  !>     longer support hipblasDataType_t for these parameters in a future release. hipblasGemmEx follows
  !>     the same convention.
  !> 
  !>         #ifdef HIPBLAS_V2  available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2
  !> 
  !>             hipblasStatus_t hipblasGemmEx(hipblasHandle_t      handle,
  !>                                           hipblasOperation_t   transA,
  !>                                           hipblasOperation_t   transB,
  !>                                           int                  m,
  !>                                           int                  n,
  !>                                           int                  k,
  !>                                            void          alpha,
  !>                                            void          A,
  !>                                           hipDataType          aType,
  !>                                           int                  lda,
  !>                                            void          B,
  !>                                           hipDataType          bType,
  !>                                           int                  ldb,
  !>                                            void          beta,
  !>                                           void                C,
  !>                                           hipDataType          cType,
  !>                                           int                  ldc,
  !>                                           hipblasComputeType_t computeType,
  !>                                           hipblasGemmAlgo_t    algo)
  !> 
  !>             hipblasStatus_t hipblasGemmExWithFlags(hipblasHandle_t      handle,
  !>                                                    hipblasOperation_t   transA,
  !>                                                    hipblasOperation_t   transB,
  !>                                                    int                  m,
  !>                                                    int                  n,
  !>                                                    int                  k,
  !>                                                     void          alpha,
  !>                                                     void          A,
  !>                                                    hipDataType          aType,
  !>                                                    int                  lda,
  !>                                                     void          B,
  !>                                                    hipDataType          bType,
  !>                                                    int                  ldb,
  !>                                                     void          beta,
  !>                                                    void                C,
  !>                                                    hipDataType          cType,
  !>                                                    int                  ldc,
  !>                                                    hipblasComputeType_t computeType,
  !>                                                    hipblasGemmAlgo_t    algo,
  !>                                                    hipblasGemmFlags_t   flags)
  !> 
  !>         #else  [DEPRECATED]
  !> 
  !>             hipblasStatus_t hipblasGemmEx(hipblasHandle_t    handle,
  !>                                           hipblasOperation_t transA,
  !>                                           hipblasOperation_t transB,
  !>                                           int                m,
  !>                                           int                n,
  !>                                           int                k,
  !>                                            void        alpha,
  !>                                            void        A,
  !>                                           hipblasDatatype_t  aType,
  !>                                           int                lda,
  !>                                            void        B,
  !>                                           hipblasDatatype_t  bType,
  !>                                           int                ldb,
  !>                                            void        beta,
  !>                                           void              C,
  !>                                           hipblasDatatype_t  cType,
  !>                                           int                ldc,
  !>                                           hipblasDatatype_t  computeType,
  !>                                           hipblasGemmAlgo_t  algo)
  !> 
  !>             hipblasStatus_t hipblasGemmExWithFlags(hipblasHandle_t      handle,
  !>                                                    hipblasOperation_t   transA,
  !>                                                    hipblasOperation_t   transB,
  !>                                                    int                  m,
  !>                                                    int                  n,
  !>                                                    int                  k,
  !>                                                     void          alpha,
  !>                                                     void          A,
  !>                                                    hipblasDatatype_t    aType,
  !>                                                    int                  lda,
  !>                                                     void          B,
  !>                                                    hipblasDatatype_t    bType,
  !>                                                    int                  ldb,
  !>                                                     void          beta,
  !>                                                    void                C,
  !>                                                    hipblasDatatype_t    cType,
  !>                                                    int                  ldc,
  !>                                                    hipblasDatatype_t    computeType,
  !>                                                    hipblasGemmAlgo_t    algo,
  !>                                                    hipblasGemmFlags_t   flags)
  !> 
  !>         #endif
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     transA    [hipblasOperation_t]
  !>               specifies the form of op( A ).
  !>     @param[in]
  !>     transB    [hipblasOperation_t]
  !>               specifies the form of op( B ).
  !>     @param[in]
  !>     m         [int]
  !>               matrix dimension m.
  !>     @param[in]
  !>     n         [int]
  !>               matrix dimension n.
  !>     @param[in]
  !>     k         [int]
  !>               matrix dimension k.
  !>     @param[in]
  !>     alpha     [ void ]
  !>               device pointer or host pointer specifying the scalar alpha. Same datatype as computeType.
  !>     @param[in]
  !>     A         [void ]
  !>               device pointer storing matrix A.
  !>     @param[in]
  !>     aType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of matrix A.\n
  !>     [hipDataType]
  !>               specifies the datatype of matrix A.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of A.
  !>     @param[in]
  !>     B         [void ]
  !>               device pointer storing matrix B.
  !>     @param[in]
  !>     bType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of matrix B.\n
  !>     [hipDataType]
  !>               specifies the datatype of matrix B.
  !>     @param[in]
  !>     ldb       [int]
  !>               specifies the leading dimension of B.
  !>     @param[in]
  !>     beta      [ void ]
  !>               device pointer or host pointer specifying the scalar beta. Same datatype as computeType.
  !>     @param[in]
  !>     C         [void ]
  !>               device pointer storing matrix C.
  !>     @param[in]
  !>     cType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of matrix C.\n
  !>     [hipDataType]
  !>               specifies the datatype of matrix C.
  !>     @param[in]
  !>     ldc       [int]
  !>               specifies the leading dimension of C.
  !>     @param[in]
  !>     computeType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of computation.\n
  !>     [hipblasComputeType_t]
  !>               specifies the datatype of computation.
  !>     @param[in]
  !>     algo      [hipblasGemmAlgo_t]
  !>               enumerant specifying the algorithm type.
  !> 
  !>     
  interface hipblasGemmEx
#ifdef USE_CUDA_NAMES
    function hipblasGemmEx_(handle,transA,transB,m,n,k,alpha,A,aType,lda,B,bType,ldb,beta,C,cType,ldc,computeType,algo) bind(c, name="cublasGemmEx")
#else
    function hipblasGemmEx_(handle,transA,transB,m,n,k,alpha,A,aType,lda,B,bType,ldb,beta,C,cType,ldc,computeType,algo) bind(c, name="hipblasGemmEx")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasGemmEx_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: alpha
      type(c_ptr),value :: A
      integer(kind(HIP_R_16F)),value :: aType
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(kind(HIP_R_16F)),value :: bType
      integer(c_int),value :: ldb
      type(c_ptr),value :: beta
      type(c_ptr),value :: C
      integer(kind(HIP_R_16F)),value :: cType
      integer(c_int),value :: ldc
      integer(kind(HIP_R_16F)),value :: computeType
      integer(kind(HIPBLAS_GEMM_DEFAULT)),value :: algo
    end function


  end interface
  
  interface hipblasGemmEx_v2
#ifdef USE_CUDA_NAMES
    function hipblasGemmEx_v2_(handle,transA,transB,m,n,k,alpha,A,aType,lda,B,bType,ldb,beta,C,cType,ldc,computeType,algo) bind(c, name="cublasGemmEx_v2")
#else
    function hipblasGemmEx_v2_(handle,transA,transB,m,n,k,alpha,A,aType,lda,B,bType,ldb,beta,C,cType,ldc,computeType,algo) bind(c, name="hipblasGemmEx_v2")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasGemmEx_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: alpha
      type(c_ptr),value :: A
      integer(kind(HIP_R_32F)),value :: aType
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(kind(HIP_R_32F)),value :: bType
      integer(c_int),value :: ldb
      type(c_ptr),value :: beta
      type(c_ptr),value :: C
      integer(kind(HIP_R_32F)),value :: cType
      integer(c_int),value :: ldc
      integer(kind(HIPBLAS_COMPUTE_16F)),value :: computeType
      integer(kind(HIPBLAS_GEMM_DEFAULT)),value :: algo
    end function

  end interface
  
  interface hipblasGemmExWithFlags
#ifdef USE_CUDA_NAMES
    function hipblasGemmExWithFlags_(handle,transA,transB,m,n,k,alpha,A,aType,lda,B,bType,ldb,beta,C,cType,ldc,computeType,algo,flags) bind(c, name="cublasGemmExWithFlags")
#else
    function hipblasGemmExWithFlags_(handle,transA,transB,m,n,k,alpha,A,aType,lda,B,bType,ldb,beta,C,cType,ldc,computeType,algo,flags) bind(c, name="hipblasGemmExWithFlags")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasGemmExWithFlags_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: alpha
      type(c_ptr),value :: A
      integer(kind(HIP_R_16F)),value :: aType
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(kind(HIP_R_16F)),value :: bType
      integer(c_int),value :: ldb
      type(c_ptr),value :: beta
      type(c_ptr),value :: C
      integer(kind(HIP_R_16F)),value :: cType
      integer(c_int),value :: ldc
      integer(kind(HIP_R_16F)),value :: computeType
      integer(kind(HIPBLAS_GEMM_DEFAULT)),value :: algo
      integer(kind(HIPBLAS_GEMM_FLAGS_NONE)),value :: flags
    end function

  end interface
  
  interface hipblasGemmExWithFlags_v2
#ifdef USE_CUDA_NAMES
    function hipblasGemmExWithFlags_v2_(handle,transA,transB,m,n,k,alpha,A,aType,lda,B,bType,ldb,beta,C,cType,ldc,computeType,algo,flags) bind(c, name="cublasGemmExWithFlags_v2")
#else
    function hipblasGemmExWithFlags_v2_(handle,transA,transB,m,n,k,alpha,A,aType,lda,B,bType,ldb,beta,C,cType,ldc,computeType,algo,flags) bind(c, name="hipblasGemmExWithFlags_v2")
#endif
      use iso_c_binding
      use hipfort_hipblas_enums
      use hipfort_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasGemmExWithFlags_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: alpha
      type(c_ptr),value :: A
      integer(kind(HIP_R_32F)),value :: aType
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(kind(HIP_R_32F)),value :: bType
      integer(c_int),value :: ldb
      type(c_ptr),value :: beta
      type(c_ptr),value :: C
      integer(kind(HIP_R_32F)),value :: cType
      integer(c_int),value :: ldc
      integer(kind(HIPBLAS_COMPUTE_16F)),value :: computeType
      integer(kind(HIPBLAS_GEMM_DEFAULT)),value :: algo
      integer(kind(HIPBLAS_GEMM_FLAGS_NONE)),value :: flags
    end function

  end interface
  !> ! \brief BLAS EX API
  !>     \details
  !>     gemmBatchedEx performs one of the batched matrix-matrix operations
  !>         C_i = alphaop(A_i)op(B_i) + betaC_i, for i = 1, ..., batchCount.
  !>     where op( X ) is one of
  !>         op( X ) = X      or
  !>         op( X ) = XT   or
  !>         op( X ) = XH,
  !>     alpha and beta are scalars, and A, B, and C are batched pointers to matrices, with
  !>     op( A ) an m by k by batchCount batched matrix,
  !>     op( B ) a k by n by batchCount batched matrix and
  !>     C a m by n by batchCount batched matrix.
  !>     The batched matrices are an array of pointers to matrices.
  !>     The number of pointers to matrices is batchCount.
  !> 
  !>     - Supported types are determined by the backend. See rocBLAScuBLAS documentation.
  !> 
  !>     hipblasGemmBatchedExWithFlags is also available which is identical to hipblasGemmBatchedEx
  !>     with the addition of a "flags" parameter which controls flags used in Tensile to control gemm algorithms with the
  !>     rocBLAS backend. When using a cuBLAS backend this parameter is ignored.
  !> 
  !>     With HIPBLAS_V2 define, hipblasGemmBatchedEx accepts hipDataType for aType, bType, and cType.
  !>     It also accepts hipblasComputeType_t for computeType. hipblasGemmBatchedEx will no
  !>     longer support hipblasDataType_t for these parameters in a future release. hipblasGemmBatchedExWithFlags
  !>     follows the same convention.
  !> 
  !>         #ifdef HIPBLAS_V2  available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2
  !> 
  !>             hipblasStatus_t hipblasGemmBatchedEx(hipblasHandle_t      handle,
  !>                                                  hipblasOperation_t   transA,
  !>                                                  hipblasOperation_t   transB,
  !>                                                  int                  m,
  !>                                                  int                  n,
  !>                                                  int                  k,
  !>                                                   void          alpha,
  !>                                                   void          A[],
  !>                                                  hipDataType          aType,
  !>                                                  int                  lda,
  !>                                                   void          B[],
  !>                                                  hipDataType          bType,
  !>                                                  int                  ldb,
  !>                                                   void          beta,
  !>                                                  void                C[],
  !>                                                  hipDataType          cType,
  !>                                                  int                  ldc,
  !>                                                  int                  batchCount,
  !>                                                  hipblasComputeType_t computeType,
  !>                                                  hipblasGemmAlgo_t    algo)
  !> 
  !>             hipblasStatus_t hipblasGemmBatchedExWithFlags(hipblasHandle_t      handle,
  !>                                                           hipblasOperation_t   transA,
  !>                                                           hipblasOperation_t   transB,
  !>                                                           int                  m,
  !>                                                           int                  n,
  !>                                                           int                  k,
  !>                                                            void          alpha,
  !>                                                            void          A[],
  !>                                                           hipDataType          aType,
  !>                                                           int                  lda,
  !>                                                            void          B[],
  !>                                                           hipDataType          bType,
  !>                                                           int                  ldb,
  !>                                                            void          beta,
  !>                                                           void                C[],
  !>                                                           hipDataType          cType,
  !>                                                           int                  ldc,
  !>                                                           int                  batchCount,
  !>                                                           hipblasComputeType_t computeType,
  !>                                                           hipblasGemmAlgo_t    algo,
  !>                                                           hipblasGemmFlags_t   flags)
  !> 
  !>         #else  [DEPRECATED]
  !> 
  !>             hipblasStatus_t hipblasGemmBatchedEx(hipblasHandle_t    handle,
  !>                                                  hipblasOperation_t transA,
  !>                                                  hipblasOperation_t transB,
  !>                                                  int                m,
  !>                                                  int                n,
  !>                                                  int                k,
  !>                                                   void        alpha,
  !>                                                   void        A[],
  !>                                                  hipblasDatatype_t  aType,
  !>                                                  int                lda,
  !>                                                   void        B[],
  !>                                                  hipblasDatatype_t  bType,
  !>                                                  int                ldb,
  !>                                                   void        beta,
  !>                                                  void              C[],
  !>                                                  hipblasDatatype_t  cType,
  !>                                                  int                ldc,
  !>                                                  int                batchCount,
  !>                                                  hipblasDatatype_t  computeType,
  !>                                                  hipblasGemmAlgo_t  algo)
  !> 
  !>             hipblasStatus_t hipblasGemmBatchedExWithFlags(hipblasHandle_t      handle,
  !>                                                           hipblasOperation_t   transA,
  !>                                                           hipblasOperation_t   transB,
  !>                                                           int                  m,
  !>                                                           int                  n,
  !>                                                           int                  k,
  !>                                                            void          alpha,
  !>                                                            void          A[],
  !>                                                           hipblasDatatype_t    aType,
  !>                                                           int                  lda,
  !>                                                            void          B[],
  !>                                                           hipblasDatatype_t    bType,
  !>                                                           int                  ldb,
  !>                                                            void          beta,
  !>                                                           void                C[],
  !>                                                           hipblasDatatype_t    cType,
  !>                                                           int                  ldc,
  !>                                                           int                  batchCount,
  !>                                                           hipblasDatatype_t    computeType,
  !>                                                           hipblasGemmAlgo_t    algo,
  !>                                                           hipblasGemmFlags_t   flags)
  !> 
  !>         #endif
  !> 
  !> 
  !> 
  !> 
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     transA    [hipblasOperation_t]
  !>               specifies the form of op( A ).
  !>     @param[in]
  !>     transB    [hipblasOperation_t]
  !>               specifies the form of op( B ).
  !>     @param[in]
  !>     m         [int]
  !>               matrix dimension m.
  !>     @param[in]
  !>     n         [int]
  !>               matrix dimension n.
  !>     @param[in]
  !>     k         [int]
  !>               matrix dimension k.
  !>     @param[in]
  !>     alpha     [ void ]
  !>               device pointer or host pointer specifying the scalar alpha. Same datatype as computeType.
  !>     @param[in]
  !>     A         [void ]
  !>               device pointer storing array of pointers to each matrix A_i.
  !>     @param[in]
  !>     aType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of each matrix A_i.\n
  !>     [hipDataType]
  !>               specifies the datatype of each matrix A_i.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     B         [void ]
  !>               device pointer storing array of pointers to each matrix B_i.
  !>     @param[in]
  !>     bType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of each matrix B_i.\n
  !>     [hipDataType]
  !>               specifies the datatype of each matrix B_i.
  !>     @param[in]
  !>     ldb       [int]
  !>               specifies the leading dimension of each B_i.
  !>     @param[in]
  !>     beta      [ void ]
  !>               device pointer or host pointer specifying the scalar beta. Same datatype as computeType.
  !>     @param[in]
  !>     C         [void ]
  !>               device array of device pointers to each matrix C_i.
  !>     @param[in]
  !>     cType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of each matrix C_i.\n
  !>     [hipDataType]
  !>               specifies the datatype of each matrix C_i.
  !>     @param[in]
  !>     ldc       [int]
  !>               specifies the leading dimension of each C_i.
  !>     @param[in]
  !>     batchCount
  !>               [int]
  !>               number of gemm operations in the batch.
  !>     @param[in]
  !>     computeType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of computation.\n
  !>     [hipblasComputeType_t]
  !>               specifies the datatype of computation.
  !>     @param[in]
  !>     algo      [hipblasGemmAlgo_t]
  !>               enumerant specifying the algorithm type.
  !> 
  !>     
  interface hipblasGemmBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasGemmBatchedEx_(handle,transA,transB,m,n,k,alpha,A,aType,lda,B,bType,ldb,beta,C,cType,ldc,batchCount,computeType,algo) bind(c, name="cublasGemmBatchedEx")
#else
    function hipblasGemmBatchedEx_(handle,transA,transB,m,n,k,alpha,A,aType,lda,B,bType,ldb,beta,C,cType,ldc,batchCount,computeType,algo) bind(c, name="hipblasGemmBatchedEx")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasGemmBatchedEx_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: alpha
      type(c_ptr) :: A
      integer(kind(HIP_R_16F)),value :: aType
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(kind(HIP_R_16F)),value :: bType
      integer(c_int),value :: ldb
      type(c_ptr),value :: beta
      type(c_ptr) :: C
      integer(kind(HIP_R_16F)),value :: cType
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
      integer(kind(HIP_R_16F)),value :: computeType
      integer(kind(HIPBLAS_GEMM_DEFAULT)),value :: algo
    end function


  end interface
  
  interface hipblasGemmBatchedEx_v2
#ifdef USE_CUDA_NAMES
    function hipblasGemmBatchedEx_v2_(handle,transA,transB,m,n,k,alpha,A,aType,lda,B,bType,ldb,beta,C,cType,ldc,batchCount,computeType,algo) bind(c, name="cublasGemmBatchedEx_v2")
#else
    function hipblasGemmBatchedEx_v2_(handle,transA,transB,m,n,k,alpha,A,aType,lda,B,bType,ldb,beta,C,cType,ldc,batchCount,computeType,algo) bind(c, name="hipblasGemmBatchedEx_v2")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasGemmBatchedEx_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: alpha
      type(c_ptr) :: A
      integer(kind(HIP_R_32F)),value :: aType
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(kind(HIP_R_32F)),value :: bType
      integer(c_int),value :: ldb
      type(c_ptr),value :: beta
      type(c_ptr) :: C
      integer(kind(HIP_R_32F)),value :: cType
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
      integer(kind(HIPBLAS_COMPUTE_16F)),value :: computeType
      integer(kind(HIPBLAS_GEMM_DEFAULT)),value :: algo
    end function

  end interface
  
  interface hipblasGemmBatchedExWithFlags
#ifdef USE_CUDA_NAMES
    function hipblasGemmBatchedExWithFlags_(handle,transA,transB,m,n,k,alpha,A,aType,lda,B,bType,ldb,beta,C,cType,ldc,batchCount,computeType,algo,flags) bind(c, name="cublasGemmBatchedExWithFlags")
#else
    function hipblasGemmBatchedExWithFlags_(handle,transA,transB,m,n,k,alpha,A,aType,lda,B,bType,ldb,beta,C,cType,ldc,batchCount,computeType,algo,flags) bind(c, name="hipblasGemmBatchedExWithFlags")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasGemmBatchedExWithFlags_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: alpha
      type(c_ptr) :: A
      integer(kind(HIP_R_16F)),value :: aType
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(kind(HIP_R_16F)),value :: bType
      integer(c_int),value :: ldb
      type(c_ptr),value :: beta
      type(c_ptr) :: C
      integer(kind(HIP_R_16F)),value :: cType
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
      integer(kind(HIP_R_16F)),value :: computeType
      integer(kind(HIPBLAS_GEMM_DEFAULT)),value :: algo
      integer(kind(HIPBLAS_GEMM_FLAGS_NONE)),value :: flags
    end function

  end interface
  
  interface hipblasGemmBatchedExWithFlags_v2
#ifdef USE_CUDA_NAMES
    function hipblasGemmBatchedExWithFlags_v2_(handle,transA,transB,m,n,k,alpha,A,aType,lda,B,bType,ldb,beta,C,cType,ldc,batchCount,computeType,algo,flags) bind(c, name="cublasGemmBatchedExWithFlags_v2")
#else
    function hipblasGemmBatchedExWithFlags_v2_(handle,transA,transB,m,n,k,alpha,A,aType,lda,B,bType,ldb,beta,C,cType,ldc,batchCount,computeType,algo,flags) bind(c, name="hipblasGemmBatchedExWithFlags_v2")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasGemmBatchedExWithFlags_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: alpha
      type(c_ptr) :: A
      integer(kind(HIP_R_32F)),value :: aType
      integer(c_int),value :: lda
      type(c_ptr) :: B
      integer(kind(HIP_R_32F)),value :: bType
      integer(c_int),value :: ldb
      type(c_ptr),value :: beta
      type(c_ptr) :: C
      integer(kind(HIP_R_32F)),value :: cType
      integer(c_int),value :: ldc
      integer(c_int),value :: batchCount
      integer(kind(HIPBLAS_COMPUTE_16F)),value :: computeType
      integer(kind(HIPBLAS_GEMM_DEFAULT)),value :: algo
      integer(kind(HIPBLAS_GEMM_FLAGS_NONE)),value :: flags
    end function

  end interface
  !> ! \brief BLAS EX API
  !> 
  !>     \details
  !>     gemmStridedBatchedEx performs one of the strided_batched matrix-matrix operations
  !> 
  !>         C_i = alphaop(A_i)op(B_i) + betaC_i, for i = 1, ..., batchCount
  !> 
  !>     where op( X ) is one of
  !> 
  !>         op( X ) = X      or
  !>         op( X ) = XT   or
  !>         op( X ) = XH,
  !> 
  !>     alpha and beta are scalars, and A, B, and C are strided_batched matrices, with
  !>     op( A ) an m by k by batchCount strided_batched matrix,
  !>     op( B ) a k by n by batchCount strided_batched matrix and
  !>     C a m by n by batchCount strided_batched matrix.
  !> 
  !>     The strided_batched matrices are multiple matrices separated by a ant stride.
  !>     The number of matrices is batchCount.
  !> 
  !>     - Supported types are determined by the backend. See rocBLAScuBLAS documentation.
  !> 
  !>     hipblasGemmStridedBatchedExWithFlags is also available which is identical to hipblasStridedBatchedGemmEx
  !>     with the addition of a "flags" parameter which controls flags used in Tensile to control gemm algorithms with the
  !>     rocBLAS backend. When using a cuBLAS backend this parameter is ignored.
  !> 
  !>     With HIPBLAS_V2 define, hipblasGemmStridedBatchedEx accepts hipDataType for aType, bType, and cType.
  !>     It also accepts hipblasComputeType_t for computeType. hipblasGemmStridedBatchedEx will no
  !>     longer support hipblasDataType_t for these parameters in a future release. hipblasGemmStridedBatchedExWithFlags
  !>     follows the same convention.
  !> 
  !>         #ifdef HIPBLAS_V2  available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2
  !> 
  !>             hipblasStatus_t hipblasGemmStridedBatchedEx(hipblasHandle_t      handle,
  !>                                                         hipblasOperation_t   transA,
  !>                                                         hipblasOperation_t   transB,
  !>                                                         int                  m,
  !>                                                         int                  n,
  !>                                                         int                  k,
  !>                                                          void          alpha,
  !>                                                          void          A,
  !>                                                         hipDataType          aType,
  !>                                                         int                  lda,
  !>                                                         hipblasStride        strideA,
  !>                                                          void          B,
  !>                                                         hipDataType          bType,
  !>                                                         int                  ldb,
  !>                                                         hipblasStride        strideB,
  !>                                                          void          beta,
  !>                                                         void                C,
  !>                                                         hipDataType          cType,
  !>                                                         int                  ldc,
  !>                                                         hipblasStride        strideC,
  !>                                                         int                  batchCount,
  !>                                                         hipblasComputeType_t computeType,
  !>                                                         hipblasGemmAlgo_t    algo)
  !> 
  !>             hipblasStatus_t hipblasGemmStridedBatchedExWithFlags(hipblasHandle_t      handle,
  !>                                                                  hipblasOperation_t   transA,
  !>                                                                  hipblasOperation_t   transB,
  !>                                                                  int                  m,
  !>                                                                  int                  n,
  !>                                                                  int                  k,
  !>                                                                   void          alpha,
  !>                                                                   void          A,
  !>                                                                  hipDataType          aType,
  !>                                                                  int                  lda,
  !>                                                                  hipblasStride        strideA,
  !>                                                                   void          B,
  !>                                                                  hipDataType          bType,
  !>                                                                  int                  ldb,
  !>                                                                  hipblasStride        strideB,
  !>                                                                   void          beta,
  !>                                                                  void                C,
  !>                                                                  hipDataType          cType,
  !>                                                                  int                  ldc,
  !>                                                                  hipblasStride        strideC,
  !>                                                                  int                  batchCount,
  !>                                                                  hipblasComputeType_t computeType,
  !>                                                                  hipblasGemmAlgo_t    algo,
  !>                                                                  hipblasGemmFlags_t   flags)
  !> 
  !>         #else  [DEPRECATED]
  !> 
  !>             hipblasStatus_t hipblasGemmStridedBatchedEx(hipblasHandle_t    handle,
  !>                                                         hipblasOperation_t transA,
  !>                                                         hipblasOperation_t transB,
  !>                                                         int                m,
  !>                                                         int                n,
  !>                                                         int                k,
  !>                                                          void        alpha,
  !>                                                          void        A,
  !>                                                         hipblasDatatype_t  aType,
  !>                                                         int                lda,
  !>                                                         hipblasStride      strideA,
  !>                                                          void        B,
  !>                                                         hipblasDatatype_t  bType,
  !>                                                         int                ldb,
  !>                                                         hipblasStride      strideB,
  !>                                                          void        beta,
  !>                                                         void              C,
  !>                                                         hipblasDatatype_t  cType,
  !>                                                         int                ldc,
  !>                                                         hipblasStride      strideC,
  !>                                                         int                batchCount,
  !>                                                         hipblasDatatype_t  computeType,
  !>                                                         hipblasGemmAlgo_t  algo)
  !> 
  !>             hipblasStatus_t hipblasGemmStridedBatchedExWithFlags(hipblasHandle_t      handle,
  !>                                                                  hipblasOperation_t   transA,
  !>                                                                  hipblasOperation_t   transB,
  !>                                                                  int                  m,
  !>                                                                  int                  n,
  !>                                                                  int                  k,
  !>                                                                   void          alpha,
  !>                                                                   void          A,
  !>                                                                  hipblasDatatype_t    aType,
  !>                                                                  int                  lda,
  !>                                                                  hipblasStride        strideA,
  !>                                                                   void          B,
  !>                                                                  hipblasDatatype_t    bType,
  !>                                                                  int                  ldb,
  !>                                                                  hipblasStride        strideB,
  !>                                                                   void          beta,
  !>                                                                  void                C,
  !>                                                                  hipblasDatatype_t    cType,
  !>                                                                  int                  ldc,
  !>                                                                  hipblasStride        strideC,
  !>                                                                  int                  batchCount,
  !>                                                                  hipblasDatatype_t    computeType,
  !>                                                                  hipblasGemmAlgo_t    algo,
  !>                                                                  hipblasGemmFlags_t   flags)
  !> 
  !>         #endif
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     transA    [hipblasOperation_t]
  !>               specifies the form of op( A ).
  !>     @param[in]
  !>     transB    [hipblasOperation_t]
  !>               specifies the form of op( B ).
  !>     @param[in]
  !>     m         [int]
  !>               matrix dimension m.
  !>     @param[in]
  !>     n         [int]
  !>               matrix dimension n.
  !>     @param[in]
  !>     k         [int]
  !>               matrix dimension k.
  !>     @param[in]
  !>     alpha     [ void ]
  !>               device pointer or host pointer specifying the scalar alpha. Same datatype as computeType.
  !>     @param[in]
  !>     A         [void ]
  !>               device pointer pointing to first matrix A_1.
  !>     @param[in]
  !>     aType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of each matrix A_i.\n
  !>     [hipDataType]
  !>               specifies the datatype of each matrix A_i.
  !>     @param[in]
  !>     lda       [int]
  !>               specifies the leading dimension of each A_i.
  !>     @param[in]
  !>     strideA  [hipblasStride]
  !>               specifies stride from start of one A_i matrix to the next A_(i + 1).
  !>     @param[in]
  !>     B         [void ]
  !>               device pointer pointing to first matrix B_1.
  !>     @param[in]
  !>     bType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of each matrix B_i.\n
  !>     [hipDataType]
  !>               specifies the datatype of each matrix B_i.
  !>     @param[in]
  !>     ldb       [int]
  !>               specifies the leading dimension of each B_i.
  !>     @param[in]
  !>     strideB  [hipblasStride]
  !>               specifies stride from start of one B_i matrix to the next B_(i + 1).
  !>     @param[in]
  !>     beta      [ void ]
  !>               device pointer or host pointer specifying the scalar beta. Same datatype as computeType.
  !>     @param[in]
  !>     C         [void ]
  !>               device pointer pointing to first matrix C_1.
  !>     @param[in]
  !>     cType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of each matrix C_i.\n
  !>     [hipDataType]
  !>               specifies the datatype of each matrix C_i.
  !>     @param[in]
  !>     ldc       [int]
  !>               specifies the leading dimension of each C_i.
  !>     @param[in]
  !>     strideC  [hipblasStride]
  !>               specifies stride from start of one C_i matrix to the next C_(i + 1).
  !>     @param[in]
  !>     batchCount
  !>               [int]
  !>               number of gemm operations in the batch.
  !>     @param[in]
  !>     computeType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of computation.\n
  !>     [hipblasComputeType_t]
  !>               specifies the datatype of computation.
  !>     @param[in]
  !>     algo      [hipblasGemmAlgo_t]
  !>               enumerant specifying the algorithm type.
  !> 
  !>     
  interface hipblasGemmStridedBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasGemmStridedBatchedEx_(handle,transA,transB,m,n,k,alpha,A,aType,lda,strideA,B,bType,ldb,strideB,beta,C,cType,ldc,strideC,batchCount,computeType,algo) bind(c, name="cublasGemmStridedBatchedEx")
#else
    function hipblasGemmStridedBatchedEx_(handle,transA,transB,m,n,k,alpha,A,aType,lda,strideA,B,bType,ldb,strideB,beta,C,cType,ldc,strideC,batchCount,computeType,algo) bind(c, name="hipblasGemmStridedBatchedEx")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasGemmStridedBatchedEx_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: alpha
      type(c_ptr),value :: A
      integer(kind(HIP_R_16F)),value :: aType
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(kind(HIP_R_16F)),value :: bType
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: beta
      type(c_ptr),value :: C
      integer(kind(HIP_R_16F)),value :: cType
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
      integer(kind(HIP_R_16F)),value :: computeType
      integer(kind(HIPBLAS_GEMM_DEFAULT)),value :: algo
    end function


  end interface
  
  interface hipblasGemmStridedBatchedEx_v2
#ifdef USE_CUDA_NAMES
    function hipblasGemmStridedBatchedEx_v2_(handle,transA,transB,m,n,k,alpha,A,aType,lda,strideA,B,bType,ldb,strideB,beta,C,cType,ldc,strideC,batchCount,computeType,algo) bind(c, name="cublasGemmStridedBatchedEx_v2")
#else
    function hipblasGemmStridedBatchedEx_v2_(handle,transA,transB,m,n,k,alpha,A,aType,lda,strideA,B,bType,ldb,strideB,beta,C,cType,ldc,strideC,batchCount,computeType,algo) bind(c, name="hipblasGemmStridedBatchedEx_v2")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasGemmStridedBatchedEx_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: alpha
      type(c_ptr),value :: A
      integer(kind(HIP_R_32F)),value :: aType
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(kind(HIP_R_32F)),value :: bType
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: beta
      type(c_ptr),value :: C
      integer(kind(HIP_R_32F)),value :: cType
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
      integer(kind(HIPBLAS_COMPUTE_16F)),value :: computeType
      integer(kind(HIPBLAS_GEMM_DEFAULT)),value :: algo
    end function

  end interface
  
  interface hipblasGemmStridedBatchedExWithFlags
#ifdef USE_CUDA_NAMES
    function hipblasGemmStridedBatchedExWithFlags_(handle,transA,transB,m,n,k,alpha,A,aType,lda,strideA,B,bType,ldb,strideB,beta,C,cType,ldc,strideC,batchCount,computeType,algo,flags) bind(c, name="cublasGemmStridedBatchedExWithFlags")
#else
    function hipblasGemmStridedBatchedExWithFlags_(handle,transA,transB,m,n,k,alpha,A,aType,lda,strideA,B,bType,ldb,strideB,beta,C,cType,ldc,strideC,batchCount,computeType,algo,flags) bind(c, name="hipblasGemmStridedBatchedExWithFlags")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasGemmStridedBatchedExWithFlags_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: alpha
      type(c_ptr),value :: A
      integer(kind(HIP_R_16F)),value :: aType
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(kind(HIP_R_16F)),value :: bType
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: beta
      type(c_ptr),value :: C
      integer(kind(HIP_R_16F)),value :: cType
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
      integer(kind(HIP_R_16F)),value :: computeType
      integer(kind(HIPBLAS_GEMM_DEFAULT)),value :: algo
      integer(kind(HIPBLAS_GEMM_FLAGS_NONE)),value :: flags
    end function

  end interface
  
  interface hipblasGemmStridedBatchedExWithFlags_v2
#ifdef USE_CUDA_NAMES
    function hipblasGemmStridedBatchedExWithFlags_v2_(handle,transA,transB,m,n,k,alpha,A,aType,lda,strideA,B,bType,ldb,strideB,beta,C,cType,ldc,strideC,batchCount,computeType,algo,flags) bind(c, name="cublasGemmStridedBatchedExWithFlags_v2")
#else
    function hipblasGemmStridedBatchedExWithFlags_v2_(handle,transA,transB,m,n,k,alpha,A,aType,lda,strideA,B,bType,ldb,strideB,beta,C,cType,ldc,strideC,batchCount,computeType,algo,flags) bind(c, name="hipblasGemmStridedBatchedExWithFlags_v2")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasGemmStridedBatchedExWithFlags_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_OP_N)),value :: transB
      integer(c_int),value :: m
      integer(c_int),value :: n
      integer(c_int),value :: k
      type(c_ptr),value :: alpha
      type(c_ptr),value :: A
      integer(kind(HIP_R_32F)),value :: aType
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(kind(HIP_R_32F)),value :: bType
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      type(c_ptr),value :: beta
      type(c_ptr),value :: C
      integer(kind(HIP_R_32F)),value :: cType
      integer(c_int),value :: ldc
      integer(c_int64_t),value :: strideC
      integer(c_int),value :: batchCount
      integer(kind(HIPBLAS_COMPUTE_16F)),value :: computeType
      integer(kind(HIPBLAS_GEMM_DEFAULT)),value :: algo
      integer(kind(HIPBLAS_GEMM_FLAGS_NONE)),value :: flags
    end function

  end interface
  !> ! BLAS EX API
  !> 
  !>     \details
  !>     trsmEx solves
  !> 
  !>         op(A)X = alphaB or Xop(A) = alphaB,
  !> 
  !>     where alpha is a scalar, X and B are m by n matrices,
  !>     A is triangular matrix and op(A) is one of
  !> 
  !>         op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.
  !> 
  !>     The matrix X is overwritten on B.
  !> 
  !>     This function gives the user the ability to reuse the invA matrix between runs.
  !>     If invA == NULL, hipblasTrsmEx will automatically calculate invA on every run.
  !> 
  !>     Setting up invA:
  !>     The accepted invA matrix consists of the packed 128x128 inverses of the diagonal blocks of
  !>     matrix A, followed by any smaller diagonal block that remains.
  !>     To set up invA it is recommended that hipblasTrtriBatched be used with matrix A as the input.
  !> 
  !>     Device memory of size 128 x k should be allocated for invA ahead of time, where k is m when
  !>     HIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT. The actual number of elements in invA
  !>     should be passed as invAsize.
  !> 
  !>     To begin, hipblasTrtriBatched must be called on the full 128x128 sized diagonal blocks of
  !>     matrix A. Below are the restricted parameters:
  !>       - n = 128
  !>       - ldinvA = 128
  !>       - stride_invA = 128x128
  !>       - batchCount = k  128,
  !> 
  !>     Then any remaining block may be added:
  !>       - n = k % 128
  !>       - invA = invA + stride_invA  previousBatchCount
  !>       - ldinvA = 128
  !>       - batchCount = 1
  !> 
  !>     With HIPBLAS_V2 define, hipblasTrsmEx accepts hipDataType for computeType rather than
  !>     hipblasDatatype_t. hipblasTrsmEx will only accept hipDataType in a future release.
  !> 
  !>         #ifdef HIPBLAS_V2  available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2
  !> 
  !>             hipblasStatus_t hipblasTrsmEx(hipblasHandle_t    handle,
  !>                                           hipblasSideMode_t  side,
  !>                                           hipblasFillMode_t  uplo,
  !>                                           hipblasOperation_t transA,
  !>                                           hipblasDiagType_t  diag,
  !>                                           int                m,
  !>                                           int                n,
  !>                                            void        alpha,
  !>                                           void              A,
  !>                                           int                lda,
  !>                                           void              B,
  !>                                           int                ldb,
  !>                                            void        invA,
  !>                                           int                invAsize,
  !>                                           hipDataType        computeType)
  !> 
  !>         #else  [DEPRECATED]
  !> 
  !>             hipblasStatus_t hipblasTrsmEx(hipblasHandle_t    handle,
  !>                                           hipblasSideMode_t  side,
  !>                                           hipblasFillMode_t  uplo,
  !>                                           hipblasOperation_t transA,
  !>                                           hipblasDiagType_t  diag,
  !>                                           int                m,
  !>                                           int                n,
  !>                                            void        alpha,
  !>                                           void              A,
  !>                                           int                lda,
  !>                                           void              B,
  !>                                           int                ldb,
  !>                                            void        invA,
  !>                                           int                invAsize,
  !>                                           hipblasDatatype_t  computeType)
  !> 
  !>         #endif
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     side    [hipblasSideMode_t]
  !>             HIPBLAS_SIDE_LEFT:       op(A)X = alphaB.
  !>             HIPBLAS_SIDE_RIGHT:      Xop(A) = alphaB.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  A is a lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_N: op(A) = A.
  !>             HIPBLAS_OP_T: op(A) = A^T.
  !>             HIPBLAS_ON_C: op(A) = A^H.
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m       [int]
  !>             m specifies the number of rows of B. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of columns of B. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha   [void ]
  !>             device pointer or host pointer specifying the scalar alpha. When alpha is
  !>             &zero then A is not referenced, and B need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       [void ]
  !>             device pointer storing matrix A.
  !>             of dimension ( lda, k ), where k is m
  !>             when HIPBLAS_SIDE_LEFT and
  !>             is n when HIPBLAS_SIDE_RIGHT
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A.
  !>             if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
  !>             if side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).
  !> 
  !>     @param[in, out]
  !>     B       [void ]
  !>             device pointer storing matrix B.
  !>             B is of dimension ( ldb, n ).
  !>             Before entry, the leading m by n part of the array B must
  !>             contain the right-hand side matrix B, and on exit is
  !>             overwritten by the solution matrix X.
  !> 
  !>     @param[in]
  !>     ldb    [int]
  !>            ldb specifies the first dimension of B. ldb >= max( 1, m ).
  !> 
  !>     @param[in]
  !>     invA    [void ]
  !>             device pointer storing the inverse diagonal blocks of A.
  !>             invA is of dimension ( ld_invA, k ), where k is m
  !>             when HIPBLAS_SIDE_LEFT and
  !>             is n when HIPBLAS_SIDE_RIGHT.
  !>             ld_invA must be equal to 128.
  !> 
  !>     @param[in]
  !>     invAsize [int]
  !>             invAsize specifies the number of elements of device memory in invA.
  !> 
  !>     @param[in]
  !>     computeType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>             specifies the datatype of computation.\n
  !>     [hipDataType]
  !>             specifies the datatype of computation.
  !> 
  !>     
  interface hipblasTrsmEx
#ifdef USE_CUDA_NAMES
    function hipblasTrsmEx_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,invA,invAsize,computeType) bind(c, name="cublasTrsmEx")
#else
    function hipblasTrsmEx_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,invA,invAsize,computeType) bind(c, name="hipblasTrsmEx")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasTrsmEx_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: invA
      integer(c_int),value :: invAsize
      integer(kind(HIP_R_16F)),value :: computeType
    end function


  end interface
  
  interface hipblasTrsmEx_v2
#ifdef USE_CUDA_NAMES
    function hipblasTrsmEx_v2_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,invA,invAsize,computeType) bind(c, name="cublasTrsmEx_v2")
#else
    function hipblasTrsmEx_v2_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,invA,invAsize,computeType) bind(c, name="hipblasTrsmEx_v2")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasTrsmEx_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      type(c_ptr),value :: invA
      integer(c_int),value :: invAsize
      integer(kind(HIP_R_32F)),value :: computeType
    end function

  end interface
  !> ! BLAS EX API
  !> 
  !>     \details
  !>     trsmBatchedEx solves
  !> 
  !>         op(A_i)X_i = alphaB_i or X_iop(A_i) = alphaB_i,
  !> 
  !>     for i = 1, ..., batchCount; and where alpha is a scalar, X and B are arrays of m by n matrices,
  !>     A is an array of triangular matrix and each op(A_i) is one of
  !> 
  !>         op( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.
  !> 
  !>     Each matrix X_i is overwritten on B_i.
  !> 
  !>     This function gives the user the ability to reuse the invA matrix between runs.
  !>     If invA == NULL, hipblasTrsmBatchedEx will automatically calculate each invA_i on every run.
  !> 
  !>     Setting up invA:
  !>     Each accepted invA_i matrix consists of the packed 128x128 inverses of the diagonal blocks of
  !>     matrix A_i, followed by any smaller diagonal block that remains.
  !>     To set up each invA_i it is recommended that hipblasTrtriBatched be used with matrix A_i as the input.
  !>     invA is an array of pointers of batchCount length holding each invA_i.
  !> 
  !>     Device memory of size 128 x k should be allocated for each invA_i ahead of time, where k is m when
  !>     HIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT. The actual number of elements in each invA_i
  !>     should be passed as invAsize.
  !> 
  !>     To begin, hipblasTrtriBatched must be called on the full 128x128 sized diagonal blocks of each
  !>     matrix A_i. Below are the restricted parameters:
  !>       - n = 128
  !>       - ldinvA = 128
  !>       - stride_invA = 128x128
  !>       - batchCount = k  128,
  !> 
  !>     Then any remaining block may be added:
  !>       - n = k % 128
  !>       - invA = invA + stride_invA  previousBatchCount
  !>       - ldinvA = 128
  !>       - batchCount = 1
  !> 
  !>     With HIPBLAS_V2 define, hipblasTrsmBatchedEx accepts hipDataType for computeType rather than
  !>     hipblasDatatype_t. hipblasTrsmBatchedEx will only accept hipDataType in a future release.
  !> 
  !>         #ifdef HIPBLAS_V2  available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2
  !> 
  !>             hipblasStatus_t hipblasTrsmBatchedEx(hipblasHandle_t    handle,
  !>                                                  hipblasSideMode_t  side,
  !>                                                  hipblasFillMode_t  uplo,
  !>                                                  hipblasOperation_t transA,
  !>                                                  hipblasDiagType_t  diag,
  !>                                                  int                m,
  !>                                                  int                n,
  !>                                                   void        alpha,
  !>                                                  void              A,
  !>                                                  int                lda,
  !>                                                  void              B,
  !>                                                  int                ldb,
  !>                                                  int                batchCount,
  !>                                                   void        invA,
  !>                                                  int                invAsize,
  !>                                                  hipDataType        computeType)
  !> 
  !>         #else  [DEPRECATED]
  !> 
  !>             hipblasStatus_t hipblasTrsmBatchedEx(hipblasHandle_t    handle,
  !>                                                  hipblasSideMode_t  side,
  !>                                                  hipblasFillMode_t  uplo,
  !>                                                  hipblasOperation_t transA,
  !>                                                  hipblasDiagType_t  diag,
  !>                                                  int                m,
  !>                                                  int                n,
  !>                                                   void        alpha,
  !>                                                  void              A,
  !>                                                  int                lda,
  !>                                                  void              B,
  !>                                                  int                ldb,
  !>                                                  int                batchCount,
  !>                                                   void        invA,
  !>                                                  int                invAsize,
  !>                                                  hipblasDatatype_t  computeType)
  !> 
  !>         #endif
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     side    [hipblasSideMode_t]
  !>             HIPBLAS_SIDE_LEFT:       op(A)X = alphaB.
  !>             HIPBLAS_SIDE_RIGHT:      Xop(A) = alphaB.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  each A_i is a lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_N: op(A) = A.
  !>             HIPBLAS_OP_T: op(A) = A^T.
  !>             HIPBLAS_OP_C: op(A) = A^H.
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  each A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m       [int]
  !>             m specifies the number of rows of each B_i. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of columns of each B_i. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha   [void ]
  !>             device pointer or host pointer alpha specifying the scalar alpha. When alpha is
  !>             &zero then A is not referenced, and B need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       [void ]
  !>             device array of device pointers storing each matrix A_i.
  !>             each A_i is of dimension ( lda, k ), where k is m
  !>             when HIPBLAS_SIDE_LEFT and
  !>             is n when HIPBLAS_SIDE_RIGHT
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of each A_i.
  !>             if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
  !>             if side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).
  !> 
  !>     @param[in, out]
  !>     B       [void ]
  !>             device array of device pointers storing each matrix B_i.
  !>             each B_i is of dimension ( ldb, n ).
  !>             Before entry, the leading m by n part of the array B_i must
  !>             contain the right-hand side matrix B_i, and on exit is
  !>             overwritten by the solution matrix X_i
  !> 
  !>     @param[in]
  !>     ldb    [int]
  !>            ldb specifies the first dimension of each B_i. ldb >= max( 1, m ).
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>             specifies how many batches.
  !> 
  !>     @param[in]
  !>     invA    [void ]
  !>             device array of device pointers storing the inverse diagonal blocks of each A_i.
  !>             each invA_i is of dimension ( ld_invA, k ), where k is m
  !>             when HIPBLAS_SIDE_LEFT and
  !>             is n when HIPBLAS_SIDE_RIGHT.
  !>             ld_invA must be equal to 128.
  !> 
  !>     @param[in]
  !>     invAsize [int]
  !>             invAsize specifies the number of elements of device memory in each invA_i.
  !> 
  !>     @param[in]
  !>     computeType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>             specifies the datatype of computation.\n
  !>     [hipDataType]
  !>             specifies the datatype of computation.
  !> 
  !>     
  interface hipblasTrsmBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasTrsmBatchedEx_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount,invA,invAsize,computeType) bind(c, name="cublasTrsmBatchedEx")
#else
    function hipblasTrsmBatchedEx_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount,invA,invAsize,computeType) bind(c, name="hipblasTrsmBatchedEx")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasTrsmBatchedEx_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batchCount
      type(c_ptr),value :: invA
      integer(c_int),value :: invAsize
      integer(kind(HIP_R_16F)),value :: computeType
    end function


  end interface
  
  interface hipblasTrsmBatchedEx_v2
#ifdef USE_CUDA_NAMES
    function hipblasTrsmBatchedEx_v2_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount,invA,invAsize,computeType) bind(c, name="cublasTrsmBatchedEx_v2")
#else
    function hipblasTrsmBatchedEx_v2_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,batchCount,invA,invAsize,computeType) bind(c, name="hipblasTrsmBatchedEx_v2")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasTrsmBatchedEx_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int),value :: batchCount
      type(c_ptr),value :: invA
      integer(c_int),value :: invAsize
      integer(kind(HIP_R_32F)),value :: computeType
    end function

  end interface
  !> ! BLAS EX API
  !> 
  !>     \details
  !>     trsmStridedBatchedEx solves
  !> 
  !>         op(A_i)X_i = alphaB_i or X_iop(A_i) = alphaB_i,
  !> 
  !>     for i = 1, ..., batchCount; and where alpha is a scalar, X and B are strided batched m by n matrices,
  !>     A is a strided batched triangular matrix and op(A_i) is one of
  !> 
  !>         op( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.
  !> 
  !>     Each matrix X_i is overwritten on B_i.
  !> 
  !>     This function gives the user the ability to reuse each invA_i matrix between runs.
  !>     If invA == NULL, hipblasTrsmStridedBatchedEx will automatically calculate each invA_i on every run.
  !> 
  !>     Setting up invA:
  !>     Each accepted invA_i matrix consists of the packed 128x128 inverses of the diagonal blocks of
  !>     matrix A_i, followed by any smaller diagonal block that remains.
  !>     To set up invA_i it is recommended that hipblasTrtriBatched be used with matrix A_i as the input.
  !>     invA is a contiguous piece of memory holding each invA_i.
  !> 
  !>     Device memory of size 128 x k should be allocated for each invA_i ahead of time, where k is m when
  !>     HIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT. The actual number of elements in each invA_i
  !>     should be passed as invAsize.
  !> 
  !>     To begin, hipblasTrtriBatched must be called on the full 128x128 sized diagonal blocks of each
  !>     matrix A_i. Below are the restricted parameters:
  !>       - n = 128
  !>       - ldinvA = 128
  !>       - stride_invA = 128x128
  !>       - batchCount = k  128,
  !> 
  !>     Then any remaining block may be added:
  !>       - n = k % 128
  !>       - invA = invA + stride_invA  previousBatchCount
  !>       - ldinvA = 128
  !>       - batchCount = 1
  !> 
  !>     With HIPBLAS_V2 define, hipblasStridedBatchedTrsmEx accepts hipDataType for computeType rather than
  !>     hipblasDatatype_t. hipblasTrsmStridedBatchedEx will only accept hipDataType in a future release.
  !> 
  !>         #ifdef HIPBLAS_V2  available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2
  !> 
  !>             hipblasStatus_t hipblasTrsmStridedBatchedEx(hipblasHandle_t    handle,
  !>                                                         hipblasSideMode_t  side,
  !>                                                         hipblasFillMode_t  uplo,
  !>                                                         hipblasOperation_t transA,
  !>                                                         hipblasDiagType_t  diag,
  !>                                                         int                m,
  !>                                                         int                n,
  !>                                                          void        alpha,
  !>                                                         void              A,
  !>                                                         int                lda,
  !>                                                         hipblasStride      strideA,
  !>                                                         void              B,
  !>                                                         int                ldb,
  !>                                                         hipblasStride      strideB,
  !>                                                         int                batchCount,
  !>                                                          void        invA,
  !>                                                         int                invAsize,
  !>                                                         hipblasStride      strideInvA,
  !>                                                         hipDataType        computeType);
  !> 
  !>         #else  [DEPRECATED]
  !> 
  !>             hipblasStatus_t hipblasTrsmStridedBatchedEx(hipblasHandle_t    handle,
  !>                                                         hipblasSideMode_t  side,
  !>                                                         hipblasFillMode_t  uplo,
  !>                                                         hipblasOperation_t transA,
  !>                                                         hipblasDiagType_t  diag,
  !>                                                         int                m,
  !>                                                         int                n,
  !>                                                          void        alpha,
  !>                                                         void              A,
  !>                                                         int                lda,
  !>                                                         hipblasStride      strideA,
  !>                                                         void              B,
  !>                                                         int                ldb,
  !>                                                         hipblasStride      strideB,
  !>                                                         int                batchCount,
  !>                                                          void        invA,
  !>                                                         int                invAsize,
  !>                                                         hipblasStride      strideInvA,
  !>                                                         hipblasDatatype_t  computeType)
  !> 
  !>         #endif
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !> 
  !>     @param[in]
  !>     side    [hipblasSideMode_t]
  !>             HIPBLAS_SIDE_LEFT:       op(A)X = alphaB.
  !>             HIPBLAS_SIDE_RIGHT:      Xop(A) = alphaB.
  !> 
  !>     @param[in]
  !>     uplo    [hipblasFillMode_t]
  !>             HIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.
  !>             HIPBLAS_FILL_MODE_LOWER:  each A_i is a lower triangular matrix.
  !> 
  !>     @param[in]
  !>     transA  [hipblasOperation_t]
  !>             HIPBLAS_OP_N: op(A) = A.
  !>             HIPBLAS_OP_T: op(A) = A^T.
  !>             HIPBLAS_OP_C: op(A) = A^H.
  !> 
  !>     @param[in]
  !>     diag    [hipblasDiagType_t]
  !>             HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular.
  !>             HIPBLAS_DIAG_NON_UNIT:  each A_i is not assumed to be unit triangular.
  !> 
  !>     @param[in]
  !>     m       [int]
  !>             m specifies the number of rows of each B_i. m >= 0.
  !> 
  !>     @param[in]
  !>     n       [int]
  !>             n specifies the number of columns of each B_i. n >= 0.
  !> 
  !>     @param[in]
  !>     alpha   [void ]
  !>             device pointer or host pointer specifying the scalar alpha. When alpha is
  !>             &zero then A is not referenced, and B need not be set before
  !>             entry.
  !> 
  !>     @param[in]
  !>     A       [void ]
  !>             device pointer storing matrix A.
  !>             of dimension ( lda, k ), where k is m
  !>             when HIPBLAS_SIDE_LEFT and
  !>             is n when HIPBLAS_SIDE_RIGHT
  !>             only the upperlower triangular part is accessed.
  !> 
  !>     @param[in]
  !>     lda     [int]
  !>             lda specifies the first dimension of A.
  !>             if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
  !>             if side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).
  !> 
  !>     @param[in]
  !>     strideA [hipblasStride]
  !>             The stride between each A matrix.
  !> 
  !>     @param[in, out]
  !>     B       [void ]
  !>             device pointer pointing to first matrix B_i.
  !>             each B_i is of dimension ( ldb, n ).
  !>             Before entry, the leading m by n part of each array B_i must
  !>             contain the right-hand side of matrix B_i, and on exit is
  !>             overwritten by the solution matrix X_i.
  !> 
  !>     @param[in]
  !>     ldb    [int]
  !>            ldb specifies the first dimension of each B_i. ldb >= max( 1, m ).
  !> 
  !>     @param[in]
  !>     strideB [hipblasStride]
  !>             The stride between each B_i matrix.
  !> 
  !>     @param[in]
  !>     batchCount [int]
  !>             specifies how many batches.
  !> 
  !>     @param[in]
  !>     invA    [void ]
  !>             device pointer storing the inverse diagonal blocks of each A_i.
  !>             invA points to the first invA_1.
  !>             each invA_i is of dimension ( ld_invA, k ), where k is m
  !>             when HIPBLAS_SIDE_LEFT and
  !>             is n when HIPBLAS_SIDE_RIGHT.
  !>             ld_invA must be equal to 128.
  !> 
  !>     @param[in]
  !>     invAsize [int]
  !>             invAsize specifies the number of elements of device memory in each invA_i.
  !> 
  !>     @param[in]
  !>     strideInvA [hipblasStride]
  !>             The stride between each invA matrix.
  !> 
  !>     @param[in]
  !>     computeType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>             specifies the datatype of computation.\n
  !>     [hipDataType]
  !>             specifies the datatype of computation.
  !> 
  !>     
  interface hipblasTrsmStridedBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasTrsmStridedBatchedEx_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount,invA,invAsize,strideInvA,computeType) bind(c, name="cublasTrsmStridedBatchedEx")
#else
    function hipblasTrsmStridedBatchedEx_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount,invA,invAsize,strideInvA,computeType) bind(c, name="hipblasTrsmStridedBatchedEx")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasTrsmStridedBatchedEx_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batchCount
      type(c_ptr),value :: invA
      integer(c_int),value :: invAsize
      integer(c_int64_t),value :: strideInvA
      integer(kind(HIP_R_16F)),value :: computeType
    end function


  end interface
  
  interface hipblasTrsmStridedBatchedEx_v2
#ifdef USE_CUDA_NAMES
    function hipblasTrsmStridedBatchedEx_v2_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount,invA,invAsize,strideInvA,computeType) bind(c, name="cublasTrsmStridedBatchedEx_v2")
#else
    function hipblasTrsmStridedBatchedEx_v2_(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,batchCount,invA,invAsize,strideInvA,computeType) bind(c, name="hipblasTrsmStridedBatchedEx_v2")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasTrsmStridedBatchedEx_v2_
      type(c_ptr),value :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)),value :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)),value :: uplo
      integer(kind(HIPBLAS_OP_N)),value :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)),value :: diag
      integer(c_int),value :: m
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      type(c_ptr),value :: A
      integer(c_int),value :: lda
      integer(c_int64_t),value :: strideA
      type(c_ptr),value :: B
      integer(c_int),value :: ldb
      integer(c_int64_t),value :: strideB
      integer(c_int),value :: batchCount
      type(c_ptr),value :: invA
      integer(c_int),value :: invAsize
      integer(c_int64_t),value :: strideInvA
      integer(kind(HIP_R_32F)),value :: computeType
    end function

  end interface
  !> ! \brief BLAS EX API
  !> 
  !>     \details
  !>     axpyEx computes ant alpha multiplied by vector x, plus vector y
  !> 
  !>         y := alpha  x + y
  !> 
  !>         - Supported types are determined by the backend. See rocBLAScuBLAS documentation.
  !> 
  !>     With HIPBLAS_V2 define, hipblasAxpyEx accepts hipDataType for alphaType, xType, yType,
  !>     and executionType rather than hipblasDatatype_t. hipblasAxpyEx will only accept hipDataType
  !>     in a future release.
  !> 
  !>         #ifdef HIPBLAS_V2  available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2
  !> 
  !>             hipblasStatus_t hipblasAxpyEx(hipblasHandle_t handle,
  !>                                           int             n,
  !>                                            void     alpha,
  !>                                           hipDataType     alphaType,
  !>                                            void     x,
  !>                                           hipDataType     xType,
  !>                                           int             incx,
  !>                                           void           y,
  !>                                           hipDataType     yType,
  !>                                           int             incy,
  !>                                           hipDataType     executionType)
  !> 
  !>         #else  [DEPRECATED]
  !> 
  !>             hipblasStatus_t hipblasAxpyEx(hipblasHandle_t   handle,
  !>                                           int               n,
  !>                                            void       alpha,
  !>                                           hipblasDatatype_t alphaType,
  !>                                            void       x,
  !>                                           hipblasDatatype_t xType,
  !>                                           int               incx,
  !>                                           void             y,
  !>                                           hipblasDatatype_t yType,
  !>                                           int               incy,
  !>                                           hipblasDatatype_t executionType)
  !> 
  !>         #endif
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in x and y.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to specify the scalar alpha.
  !>     @param[in]
  !>     alphaType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of alpha.\n
  !>     [hipDataType]
  !>               specifies the datatype of alpha.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     xType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of vector x.\n
  !>     [hipDataType]
  !>               specifies the datatype of vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[inout]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     yType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of vector y.\n
  !>     [hipDataType]
  !>               specifies the datatype of vector y.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     executionType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of computation.\n
  !>     [hipDataType]
  !>               specifies the datatype of computation.
  !> 
  !>     
  interface hipblasAxpyEx
#ifdef USE_CUDA_NAMES
    function hipblasAxpyEx_(handle,n,alpha,alphaType,x,xType,incx,y,yType,incy,executionType) bind(c, name="cublasAxpyEx")
#else
    function hipblasAxpyEx_(handle,n,alpha,alphaType,x,xType,incx,y,yType,incy,executionType) bind(c, name="hipblasAxpyEx")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasAxpyEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      integer(kind(HIP_R_16F)),value :: alphaType
      type(c_ptr),value :: x
      integer(kind(HIP_R_16F)),value :: xType
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(HIP_R_16F)),value :: yType
      integer(c_int),value :: incy
      integer(kind(HIP_R_16F)),value :: executionType
    end function


  end interface
  
  interface hipblasAxpyEx_v2
#ifdef USE_CUDA_NAMES
    function hipblasAxpyEx_v2_(handle,n,alpha,alphaType,x,xType,incx,y,yType,incy,executionType) bind(c, name="cublasAxpyEx_v2")
#else
    function hipblasAxpyEx_v2_(handle,n,alpha,alphaType,x,xType,incx,y,yType,incy,executionType) bind(c, name="hipblasAxpyEx_v2")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasAxpyEx_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      integer(kind(HIP_R_32F)),value :: alphaType
      type(c_ptr),value :: x
      integer(kind(HIP_R_32F)),value :: xType
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(HIP_R_32F)),value :: yType
      integer(c_int),value :: incy
      integer(kind(HIP_R_32F)),value :: executionType
    end function

  end interface
  !> ! \brief BLAS EX API
  !> 
  !>     \details
  !>     axpyBatchedEx computes ant alpha multiplied by vector x, plus vector y over
  !>                       a set of batched vectors.
  !> 
  !>         y := alpha  x + y
  !> 
  !>         - Supported types are determined by the backend. See rocBLAScuBLAS documentation.
  !> 
  !>     With HIPBLAS_V2 define, hipblasAxpyBatchedEx accepts hipDataType for alphaType, xType, yType,
  !>     and executionType rather than hipblasDatatype_t. hipblasAxpyBatchedEx will only accept hipDataType
  !>     in a future release.
  !> 
  !>         #ifdef HIPBLAS_V2  available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2
  !> 
  !>             hipblasStatus_t hipblasAxpyBatchedEx(hipblasHandle_t handle,
  !>                                                  int             n,
  !>                                                   void     alpha,
  !>                                                  hipDataType     alphaType,
  !>                                                   void     x,
  !>                                                  hipDataType     xType,
  !>                                                  int             incx,
  !>                                                  void           y,
  !>                                                  hipDataType     yType,
  !>                                                  int             incy,
  !>                                                  int             batchCount,
  !>                                                  hipDataType     executionType)
  !> 
  !>         #else  [DEPRECATED]
  !> 
  !>             hipblasStatus_t hipblasAxpyBatchedEx(hipblasHandle_t   handle,
  !>                                                  int               n,
  !>                                                   void       alpha,
  !>                                                  hipblasDatatype_t alphaType,
  !>                                                   void       x,
  !>                                                  hipblasDatatype_t xType,
  !>                                                  int               incx,
  !>                                                  void             y,
  !>                                                  hipblasDatatype_t yType,
  !>                                                  int               incy,
  !>                                                  int               batchCount,
  !>                                                  hipblasDatatype_t executionType)
  !> 
  !>         #endif
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in each x_i and y_i.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to specify the scalar alpha.
  !>     @param[in]
  !>     alphaType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of alpha.\n
  !>     [hipDataType]
  !>               specifies the datatype of alpha.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     xType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of each vector x_i.\n
  !>     [hipDataType]
  !>               specifies the datatype of each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[inout]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     yType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of each vector y_i.\n
  !>     [hipDataType]
  !>               specifies the datatype of each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     batchCount [int]
  !>               number of instances in the batch.
  !>     @param[in]
  !>     executionType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of computation.\n
  !>     [hipDataType]
  !>               specifies the datatype of computation.
  !> 
  !>     
  interface hipblasAxpyBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasAxpyBatchedEx_(handle,n,alpha,alphaType,x,xType,incx,y,yType,incy,batchCount,executionType) bind(c, name="cublasAxpyBatchedEx")
#else
    function hipblasAxpyBatchedEx_(handle,n,alpha,alphaType,x,xType,incx,y,yType,incy,batchCount,executionType) bind(c, name="hipblasAxpyBatchedEx")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasAxpyBatchedEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      integer(kind(HIP_R_16F)),value :: alphaType
      type(c_ptr),value :: x
      integer(kind(HIP_R_16F)),value :: xType
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(HIP_R_16F)),value :: yType
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
      integer(kind(HIP_R_16F)),value :: executionType
    end function


  end interface
  
  interface hipblasAxpyBatchedEx_v2
#ifdef USE_CUDA_NAMES
    function hipblasAxpyBatchedEx_v2_(handle,n,alpha,alphaType,x,xType,incx,y,yType,incy,batchCount,executionType) bind(c, name="cublasAxpyBatchedEx_v2")
#else
    function hipblasAxpyBatchedEx_v2_(handle,n,alpha,alphaType,x,xType,incx,y,yType,incy,batchCount,executionType) bind(c, name="hipblasAxpyBatchedEx_v2")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasAxpyBatchedEx_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      integer(kind(HIP_R_32F)),value :: alphaType
      type(c_ptr),value :: x
      integer(kind(HIP_R_32F)),value :: xType
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(HIP_R_32F)),value :: yType
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
      integer(kind(HIP_R_32F)),value :: executionType
    end function

  end interface
  !> ! \brief BLAS EX API
  !> 
  !>     \details
  !>     axpyStridedBatchedEx computes ant alpha multiplied by vector x, plus vector y over
  !>                       a set of strided batched vectors.
  !> 
  !>         y := alpha  x + y
  !> 
  !>         - Supported types are determined by the backend. See rocBLAScuBLAS documentation.
  !> 
  !>     With HIPBLAS_V2 define, hipblasAxpyStridedBatchedEx accepts hipDataType for alphaType, xType, yType,
  !>     and executionType rather than hipblasDatatype_t. hipblasAxpyStridedBatchedEx will only accept hipDataType
  !>     in a future release.
  !> 
  !>         #ifdef HIPBLAS_V2  available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2
  !> 
  !>             hipblasStatus_t hipblasAxpyStridedBatchedEx(hipblasHandle_t handle,
  !>                                                         int             n,
  !>                                                          void     alpha,
  !>                                                         hipDataType     alphaType,
  !>                                                          void     x,
  !>                                                         hipDataType     xType,
  !>                                                         int             incx,
  !>                                                         hipblasStride   stridex,
  !>                                                         void           y,
  !>                                                         hipDataType     yType,
  !>                                                         int             incy,
  !>                                                         hipblasStride   stridey,
  !>                                                         int             batchCount,
  !>                                                         hipDataType     executionType)
  !> 
  !>         #else  [DEPRECATED]
  !> 
  !>             hipblasStatus_t hipblasAxpyStridedBatchedEx(hipblasHandle_t   handle,
  !>                                                         int               n,
  !>                                                          void       alpha,
  !>                                                         hipblasDatatype_t alphaType,
  !>                                                          void       x,
  !>                                                         hipblasDatatype_t xType,
  !>                                                         int               incx,
  !>                                                         hipblasStride     stridex,
  !>                                                         void             y,
  !>                                                         hipblasDatatype_t yType,
  !>                                                         int               incy,
  !>                                                         hipblasStride     stridey,
  !>                                                         int               batchCount,
  !>                                                         hipblasDatatype_t executionType)
  !> 
  !>         #endif
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in each x_i and y_i.
  !>     @param[in]
  !>     alpha     device pointer or host pointer to specify the scalar alpha.
  !>     @param[in]
  !>     alphaType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of alpha.\n
  !>     [hipDataType]
  !>               specifies the datatype of alpha.
  !>     @param[in]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     xType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of each vector x_i.\n
  !>     [hipDataType]
  !>               specifies the datatype of each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex   [hipblasStride]
  !>               stride from the start of one vector (x_i) to the next one (x_i+1).
  !>               There are no restrictions placed on stridex, however the user should
  !>               take care to ensure that stridex is of appropriate size, for a typical
  !>               case this means stridex >= n  incx.
  !>     @param[inout]
  !>     y         device pointer to the first vector y_1.
  !>     @param[in]
  !>     yType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of each vector y_i.\n
  !>     [hipDataType]
  !>               specifies the datatype of each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     stridey   [hipblasStride]
  !>               stride from the start of one vector (y_i) to the next one (y_i+1).
  !>               There are no restrictions placed on stridey, however the user should
  !>               take care to ensure that stridey is of appropriate size, for a typical
  !>               case this means stridey >= n  incy.
  !>     @param[in]
  !>     batchCount [int]
  !>               number of instances in the batch.
  !>     @param[in]
  !>     executionType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of computation.\n
  !>     [hipDataType]
  !>               specifies the datatype of computation.
  !> 
  !>     
  interface hipblasAxpyStridedBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasAxpyStridedBatchedEx_(handle,n,alpha,alphaType,x,xType,incx,stridex,y,yType,incy,stridey,batchCount,executionType) bind(c, name="cublasAxpyStridedBatchedEx")
#else
    function hipblasAxpyStridedBatchedEx_(handle,n,alpha,alphaType,x,xType,incx,stridex,y,yType,incy,stridey,batchCount,executionType) bind(c, name="hipblasAxpyStridedBatchedEx")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasAxpyStridedBatchedEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      integer(kind(HIP_R_16F)),value :: alphaType
      type(c_ptr),value :: x
      integer(kind(HIP_R_16F)),value :: xType
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(kind(HIP_R_16F)),value :: yType
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
      integer(kind(HIP_R_16F)),value :: executionType
    end function


  end interface
  
  interface hipblasAxpyStridedBatchedEx_v2
#ifdef USE_CUDA_NAMES
    function hipblasAxpyStridedBatchedEx_v2_(handle,n,alpha,alphaType,x,xType,incx,stridex,y,yType,incy,stridey,batchCount,executionType) bind(c, name="cublasAxpyStridedBatchedEx_v2")
#else
    function hipblasAxpyStridedBatchedEx_v2_(handle,n,alpha,alphaType,x,xType,incx,stridex,y,yType,incy,stridey,batchCount,executionType) bind(c, name="hipblasAxpyStridedBatchedEx_v2")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasAxpyStridedBatchedEx_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      integer(kind(HIP_R_32F)),value :: alphaType
      type(c_ptr),value :: x
      integer(kind(HIP_R_32F)),value :: xType
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(kind(HIP_R_32F)),value :: yType
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
      integer(kind(HIP_R_32F)),value :: executionType
    end function

  end interface
  !> ! @{
  !>     \brief BLAS EX API
  !> 
  !>     \details
  !>     dotEx  performs the dot product of vectors x and y
  !> 
  !>         result = x  y;
  !> 
  !>     dotcEx  performs the dot product of the conjugate of complex vector x and complex vector y
  !> 
  !>         result = conjugate (x)  y;
  !> 
  !>         - Supported types are determined by the backend. See rocBLAScuBLAS documentation.
  !> 
  !>     With HIPBLAS_V2 define, hipblasDot(c)Ex accepts hipDataType for xType, yType,
  !>     resultType, and executionType rather than hipblasDatatype_t. hipblasDot(c)Ex will only
  !>     accept hipDataType in a future release.
  !> 
  !>         #ifdef HIPBLAS_V2  available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2
  !> 
  !>             hipblasStatus_t hipblasDotEx(hipblasHandle_t handle,
  !>                                          int             n,
  !>                                           void     x,
  !>                                          hipDataType     xType,
  !>                                          int             incx,
  !>                                           void     y,
  !>                                          hipDataType     yType,
  !>                                          int             incy,
  !>                                          void           result,
  !>                                          hipDataType     resultType,
  !>                                          hipDataType     executionType)
  !> 
  !>         #else  [DEPRECATED]
  !> 
  !>             hipblasStatus_t hipblasDotEx(hipblasHandle_t   handle,
  !>                                          int               n,
  !>                                           void       x,
  !>                                          hipblasDatatype_t xType,
  !>                                          int               incx,
  !>                                           void       y,
  !>                                          hipblasDatatype_t yType,
  !>                                          int               incy,
  !>                                          void             result,
  !>                                          hipblasDatatype_t resultType,
  !>                                          hipblasDatatype_t executionType)
  !> 
  !>         #endif
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in x and y.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     xType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of vector x.\n
  !>     [hipDataType]
  !>               specifies the datatype of vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[in]
  !>     y         device pointer storing vector y.
  !>     @param[in]
  !>     yType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of vector y.\n
  !>     [hipDataType]
  !>               specifies the datatype of vector y.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     result
  !>               device pointer or host pointer to store the dot product.
  !>               return is 0.0 if n <= 0.
  !>     @param[in]
  !>     resultType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of the result.\n
  !>     [hipDataType]
  !>               specifies the datatype of the result.
  !>     @param[in]
  !>     executionType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of computation.\n
  !>     [hipDataType]
  !>               specifies the datatype of computation.
  !> 
  !>     
  interface hipblasDotEx
#ifdef USE_CUDA_NAMES
    function hipblasDotEx_(handle,n,x,xType,incx,y,yType,incy,myResult,resultType,executionType) bind(c, name="cublasDotEx")
#else
    function hipblasDotEx_(handle,n,x,xType,incx,y,yType,incy,myResult,resultType,executionType) bind(c, name="hipblasDotEx")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDotEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIP_R_16F)),value :: xType
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(HIP_R_16F)),value :: yType
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
      integer(kind(HIP_R_16F)),value :: resultType
      integer(kind(HIP_R_16F)),value :: executionType
    end function


  end interface
  
  interface hipblasDotcEx
#ifdef USE_CUDA_NAMES
    function hipblasDotcEx_(handle,n,x,xType,incx,y,yType,incy,myResult,resultType,executionType) bind(c, name="cublasDotcEx")
#else
    function hipblasDotcEx_(handle,n,x,xType,incx,y,yType,incy,myResult,resultType,executionType) bind(c, name="hipblasDotcEx")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDotcEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIP_R_16F)),value :: xType
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(HIP_R_16F)),value :: yType
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
      integer(kind(HIP_R_16F)),value :: resultType
      integer(kind(HIP_R_16F)),value :: executionType
    end function


  end interface
  
  interface hipblasDotEx_v2
#ifdef USE_CUDA_NAMES
    function hipblasDotEx_v2_(handle,n,x,xType,incx,y,yType,incy,myResult,resultType,executionType) bind(c, name="cublasDotEx_v2")
#else
    function hipblasDotEx_v2_(handle,n,x,xType,incx,y,yType,incy,myResult,resultType,executionType) bind(c, name="hipblasDotEx_v2")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDotEx_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIP_R_32F)),value :: xType
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(HIP_R_32F)),value :: yType
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
      integer(kind(HIP_R_32F)),value :: resultType
      integer(kind(HIP_R_32F)),value :: executionType
    end function

  end interface
  
  interface hipblasDotcEx_v2
#ifdef USE_CUDA_NAMES
    function hipblasDotcEx_v2_(handle,n,x,xType,incx,y,yType,incy,myResult,resultType,executionType) bind(c, name="cublasDotcEx_v2")
#else
    function hipblasDotcEx_v2_(handle,n,x,xType,incx,y,yType,incy,myResult,resultType,executionType) bind(c, name="hipblasDotcEx_v2")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDotcEx_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIP_R_32F)),value :: xType
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(HIP_R_32F)),value :: yType
      integer(c_int),value :: incy
      type(c_ptr),value :: myResult
      integer(kind(HIP_R_32F)),value :: resultType
      integer(kind(HIP_R_32F)),value :: executionType
    end function

  end interface
  !> ! @{
  !>     \brief BLAS EX API
  !> 
  !>     \details
  !>     dotBatchedEx performs a batch of dot products of vectors x and y
  !> 
  !>         result_i = x_i  y_i;
  !> 
  !>     dotcBatchedEx  performs a batch of dot products of the conjugate of complex vector x and complex vector y
  !> 
  !>         result_i = conjugate (x_i)  y_i;
  !> 
  !>     where (x_i, y_i) is the i-th instance of the batch.
  !>     x_i and y_i are vectors, for i = 1, ..., batchCount
  !> 
  !>         - Supported types are determined by the backend. See rocBLAScuBLAS documentation.
  !> 
  !>     With HIPBLAS_V2 define, hipblasDot(c)BatchedEx accepts hipDataType for xType, yType,
  !>     resultType, and executionType rather than hipblasDatatype_t. hipblasDot(c)BatchedEx will only
  !>     accept hipDataType in a future release.
  !> 
  !>         #ifdef HIPBLAS_V2  available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2
  !> 
  !>             hipblasStatus_t hipblasDotBatchedEx(hipblasHandle_t handle,
  !>                                                 int             n,
  !>                                                  void     x,
  !>                                                 hipDataType     xType,
  !>                                                 int             incx,
  !>                                                  void     y,
  !>                                                 hipDataType     yType,
  !>                                                 int             incy,
  !>                                                 int             batchCount,
  !>                                                 void           result,
  !>                                                 hipDataType     resultType,
  !>                                                 hipDataType     executionType)
  !> 
  !>         #else  [DEPRECATED]
  !> 
  !>             hipblasStatus_t hipblasDotBatchedEx(hipblasHandle_t   handle,
  !>                                                 int               n,
  !>                                                  void       x,
  !>                                                 hipblasDatatype_t xType,
  !>                                                 int               incx,
  !>                                                  void       y,
  !>                                                 hipblasDatatype_t yType,
  !>                                                 int               incy,
  !>                                                 int               batchCount,
  !>                                                 void             result,
  !>                                                 hipblasDatatype_t resultType,
  !>                                                 hipblasDatatype_t executionType)
  !> 
  !>         #endif
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in each x_i and y_i.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     xType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of each vector x_i.\n
  !>     [hipDataType]
  !>               specifies the datatype of each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     y         device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     yType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of each vector y_i.\n
  !>     [hipDataType]
  !>               specifies the datatype of each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     batchCount [int]
  !>               number of instances in the batch
  !>     @param[inout]
  !>     result
  !>               device array or host array of batchCount size to store the dot products of each batch.
  !>               return 0.0 for each element if n <= 0.
  !>     @param[in]
  !>     resultType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of the result.\n
  !>     [hipDataType]
  !>               specifies the datatype of the result.
  !>     @param[in]
  !>     executionType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of computation.\n
  !>     [hipDataType]
  !>               specifies the datatype of computation.
  !> 
  !>     
  interface hipblasDotBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasDotBatchedEx_(handle,n,x,xType,incx,y,yType,incy,batchCount,myResult,resultType,executionType) bind(c, name="cublasDotBatchedEx")
#else
    function hipblasDotBatchedEx_(handle,n,x,xType,incx,y,yType,incy,batchCount,myResult,resultType,executionType) bind(c, name="hipblasDotBatchedEx")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDotBatchedEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIP_R_16F)),value :: xType
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(HIP_R_16F)),value :: yType
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
      integer(kind(HIP_R_16F)),value :: resultType
      integer(kind(HIP_R_16F)),value :: executionType
    end function


  end interface
  
  interface hipblasDotcBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasDotcBatchedEx_(handle,n,x,xType,incx,y,yType,incy,batchCount,myResult,resultType,executionType) bind(c, name="cublasDotcBatchedEx")
#else
    function hipblasDotcBatchedEx_(handle,n,x,xType,incx,y,yType,incy,batchCount,myResult,resultType,executionType) bind(c, name="hipblasDotcBatchedEx")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDotcBatchedEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIP_R_16F)),value :: xType
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(HIP_R_16F)),value :: yType
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
      integer(kind(HIP_R_16F)),value :: resultType
      integer(kind(HIP_R_16F)),value :: executionType
    end function


  end interface
  
  interface hipblasDotBatchedEx_v2
#ifdef USE_CUDA_NAMES
    function hipblasDotBatchedEx_v2_(handle,n,x,xType,incx,y,yType,incy,batchCount,myResult,resultType,executionType) bind(c, name="cublasDotBatchedEx_v2")
#else
    function hipblasDotBatchedEx_v2_(handle,n,x,xType,incx,y,yType,incy,batchCount,myResult,resultType,executionType) bind(c, name="hipblasDotBatchedEx_v2")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDotBatchedEx_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIP_R_32F)),value :: xType
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(HIP_R_32F)),value :: yType
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
      integer(kind(HIP_R_32F)),value :: resultType
      integer(kind(HIP_R_32F)),value :: executionType
    end function

  end interface
  
  interface hipblasDotcBatchedEx_v2
#ifdef USE_CUDA_NAMES
    function hipblasDotcBatchedEx_v2_(handle,n,x,xType,incx,y,yType,incy,batchCount,myResult,resultType,executionType) bind(c, name="cublasDotcBatchedEx_v2")
#else
    function hipblasDotcBatchedEx_v2_(handle,n,x,xType,incx,y,yType,incy,batchCount,myResult,resultType,executionType) bind(c, name="hipblasDotcBatchedEx_v2")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDotcBatchedEx_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIP_R_32F)),value :: xType
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(HIP_R_32F)),value :: yType
      integer(c_int),value :: incy
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
      integer(kind(HIP_R_32F)),value :: resultType
      integer(kind(HIP_R_32F)),value :: executionType
    end function

  end interface
  !> ! @{
  !>     \brief BLAS EX API
  !> 
  !>     \details
  !>     dotStridedBatchedEx  performs a batch of dot products of vectors x and y
  !> 
  !>         result_i = x_i  y_i;
  !> 
  !>     dotc_strided_batched_ex  performs a batch of dot products of the conjugate of complex vector x and complex vector y
  !> 
  !>         result_i = conjugate (x_i)  y_i;
  !> 
  !>     where (x_i, y_i) is the i-th instance of the batch.
  !>     x_i and y_i are vectors, for i = 1, ..., batchCount
  !> 
  !>         - Supported types are determined by the backend. See rocBLAScuBLAS documentation.
  !> 
  !>     With HIPBLAS_V2 define, hipblasDot(c)StridedBatchedEx accepts hipDataType for xType, yType,
  !>     resultType, and executionType rather than hipblasDatatype_t. hipblasDot(c)StridedBatchedEx will only
  !>     accept hipDataType in a future release.
  !> 
  !>         #ifdef HIPBLAS_V2  available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2
  !> 
  !>             hipblasStatus_t hipblasDotStridedBatchedEx(hipblasHandle_t handle,
  !>                                                        int             n,
  !>                                                         void     x,
  !>                                                        hipDataType     xType,
  !>                                                        int             incx,
  !>                                                        hipblasStride   stridex,
  !>                                                         void     y,
  !>                                                        hipDataType     yType,
  !>                                                        int             incy,
  !>                                                        hipblasStride   stridey,
  !>                                                        int             batchCount,
  !>                                                        void           result,
  !>                                                        hipDataType     resultType,
  !>                                                        hipDataType     executionType)
  !> 
  !>         #else  [DEPRECATED]
  !> 
  !>             hipblasStatus_t hipblasDotStridedBatchedEx(hipblasHandle_t   handle,
  !>                                                        int               n,
  !>                                                         void       x,
  !>                                                        hipblasDatatype_t xType,
  !>                                                        int               incx,
  !>                                                        hipblasStride     stridex,
  !>                                                         void       y,
  !>                                                        hipblasDatatype_t yType,
  !>                                                        int               incy,
  !>                                                        hipblasStride     stridey,
  !>                                                        int               batchCount,
  !>                                                        void             result,
  !>                                                        hipblasDatatype_t resultType,
  !>                                                        hipblasDatatype_t executionType)
  !> 
  !>         #endif
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in each x_i and y_i.
  !>     @param[in]
  !>     x         device pointer to the first vector (x_1) in the batch.
  !>     @param[in]
  !>     xType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of each vector x_i.\n
  !>     [hipDataType]
  !>               specifies the datatype of each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex   [hipblasStride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1)
  !>     @param[in]
  !>     y         device pointer to the first vector (y_1) in the batch.
  !>     @param[in]
  !>     yType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of each vector y_i.\n
  !>     [hipDataType]
  !>               specifies the datatype of each vector y_i.
  !>     @param[in]
  !>     incy      [int]
  !>               specifies the increment for the elements of each y_i.
  !>     @param[in]
  !>     stridey   [hipblasStride]
  !>               stride from the start of one vector (y_i) and the next one (y_i+1)
  !>     @param[in]
  !>     batchCount [int]
  !>               number of instances in the batch
  !>     @param[inout]
  !>     result
  !>               device array or host array of batchCount size to store the dot products of each batch.
  !>               return 0.0 for each element if n <= 0.
  !>     @param[in]
  !>     resultType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of the result.\n
  !>     [hipDataType]
  !>               specifies the datatype of the result.
  !>     @param[in]
  !>     executionType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of computation.\n
  !>     [hipDataType]
  !>               specifies the datatype of computation.
  !> 
  !>     
  interface hipblasDotStridedBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasDotStridedBatchedEx_(handle,n,x,xType,incx,stridex,y,yType,incy,stridey,batchCount,myResult,resultType,executionType) bind(c, name="cublasDotStridedBatchedEx")
#else
    function hipblasDotStridedBatchedEx_(handle,n,x,xType,incx,stridex,y,yType,incy,stridey,batchCount,myResult,resultType,executionType) bind(c, name="hipblasDotStridedBatchedEx")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDotStridedBatchedEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIP_R_16F)),value :: xType
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(kind(HIP_R_16F)),value :: yType
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
      integer(kind(HIP_R_16F)),value :: resultType
      integer(kind(HIP_R_16F)),value :: executionType
    end function


  end interface
  
  interface hipblasDotcStridedBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasDotcStridedBatchedEx_(handle,n,x,xType,incx,stridex,y,yType,incy,stridey,batchCount,myResult,resultType,executionType) bind(c, name="cublasDotcStridedBatchedEx")
#else
    function hipblasDotcStridedBatchedEx_(handle,n,x,xType,incx,stridex,y,yType,incy,stridey,batchCount,myResult,resultType,executionType) bind(c, name="hipblasDotcStridedBatchedEx")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDotcStridedBatchedEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIP_R_16F)),value :: xType
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(kind(HIP_R_16F)),value :: yType
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
      integer(kind(HIP_R_16F)),value :: resultType
      integer(kind(HIP_R_16F)),value :: executionType
    end function


  end interface
  
  interface hipblasDotStridedBatchedEx_v2
#ifdef USE_CUDA_NAMES
    function hipblasDotStridedBatchedEx_v2_(handle,n,x,xType,incx,stridex,y,yType,incy,stridey,batchCount,myResult,resultType,executionType) bind(c, name="cublasDotStridedBatchedEx_v2")
#else
    function hipblasDotStridedBatchedEx_v2_(handle,n,x,xType,incx,stridex,y,yType,incy,stridey,batchCount,myResult,resultType,executionType) bind(c, name="hipblasDotStridedBatchedEx_v2")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDotStridedBatchedEx_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIP_R_32F)),value :: xType
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(kind(HIP_R_32F)),value :: yType
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
      integer(kind(HIP_R_32F)),value :: resultType
      integer(kind(HIP_R_32F)),value :: executionType
    end function

  end interface
  
  interface hipblasDotcStridedBatchedEx_v2
#ifdef USE_CUDA_NAMES
    function hipblasDotcStridedBatchedEx_v2_(handle,n,x,xType,incx,stridex,y,yType,incy,stridey,batchCount,myResult,resultType,executionType) bind(c, name="cublasDotcStridedBatchedEx_v2")
#else
    function hipblasDotcStridedBatchedEx_v2_(handle,n,x,xType,incx,stridex,y,yType,incy,stridey,batchCount,myResult,resultType,executionType) bind(c, name="hipblasDotcStridedBatchedEx_v2")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDotcStridedBatchedEx_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIP_R_32F)),value :: xType
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(kind(HIP_R_32F)),value :: yType
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
      integer(kind(HIP_R_32F)),value :: resultType
      integer(kind(HIP_R_32F)),value :: executionType
    end function

  end interface
  !> ! \brief BLAS_EX API
  !> 
  !>     \details
  !>     nrm2Ex computes the euclidean norm of a real or complex vector
  !> 
  !>               result := sqrt( x'x ) for real vectors
  !>               result := sqrt( xHx ) for complex vectors
  !> 
  !>     - Supported types are determined by the backend. See rocBLAScuBLAS documentation.
  !> 
  !>     With HIPBLAS_V2 define, hipblasNrm2Ex accepts hipDataType for xType, resultType,
  !>     and executionType rather than hipblasDatatype_t. hipblasNrm2Ex will only accept
  !>     hipDataType in a future release.
  !> 
  !>         #ifdef HIPBLAS_V2  available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2
  !> 
  !>             hipblasStatus_t hipblasNrm2Ex(hipblasHandle_t handle,
  !>                                           int             n,
  !>                                            void     x,
  !>                                           hipDataType     xType,
  !>                                           int             incx,
  !>                                           void           result,
  !>                                           hipDataType     resultType,
  !>                                           hipDataType     executionType)
  !> 
  !>         #else  [DEPRECATED]
  !> 
  !>             hipblasStatus_t hipblasNrm2Ex(hipblasHandle_t   handle,
  !>                                           int               n,
  !>                                            void       x,
  !>                                           hipblasDatatype_t xType,
  !>                                           int               incx,
  !>                                           void             result,
  !>                                           hipblasDatatype_t resultType,
  !>                                           hipblasDatatype_t executionType)
  !> 
  !>         #endif
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in x.
  !>     @param[in]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     xType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of the vector x.\n
  !>     [hipDataType]
  !>               specifies the datatype of the vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of y.
  !>     @param[inout]
  !>     result
  !>               device pointer or host pointer to store the nrm2 product.
  !>               return is 0.0 if n, incx<=0.
  !>     @param[in]
  !>     resultType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of the result.\n
  !>     [hipDataType]
  !>               specifies the datatype of the result.
  !>     @param[in]
  !>     executionType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of computation.\n
  !>     [hipDataType]
  !>               specifies the datatype of computation.
  !>     
  interface hipblasNrm2Ex
#ifdef USE_CUDA_NAMES
    function hipblasNrm2Ex_(handle,n,x,xType,incx,myResult,resultType,executionType) bind(c, name="cublasNrm2Ex")
#else
    function hipblasNrm2Ex_(handle,n,x,xType,incx,myResult,resultType,executionType) bind(c, name="hipblasNrm2Ex")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasNrm2Ex_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIP_R_16F)),value :: xType
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
      integer(kind(HIP_R_16F)),value :: resultType
      integer(kind(HIP_R_16F)),value :: executionType
    end function


  end interface
  
  interface hipblasNrm2Ex_v2
#ifdef USE_CUDA_NAMES
    function hipblasNrm2Ex_v2_(handle,n,x,xType,incx,myResult,resultType,executionType) bind(c, name="cublasNrm2Ex_v2")
#else
    function hipblasNrm2Ex_v2_(handle,n,x,xType,incx,myResult,resultType,executionType) bind(c, name="hipblasNrm2Ex_v2")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasNrm2Ex_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIP_R_32F)),value :: xType
      integer(c_int),value :: incx
      type(c_ptr),value :: myResult
      integer(kind(HIP_R_32F)),value :: resultType
      integer(kind(HIP_R_32F)),value :: executionType
    end function

  end interface
  !> ! \brief BLAS_EX API
  !> 
  !>     \details
  !>     nrm2BatchedEx computes the euclidean norm over a batch of real or complex vectors
  !> 
  !>               result := sqrt( x_i'x_i ) for real vectors x, for i = 1, ..., batchCount
  !>               result := sqrt( x_iHx_i ) for complex vectors x, for i = 1, ..., batchCount
  !> 
  !>     - Supported types are determined by the backend. See rocBLAScuBLAS documentation.
  !> 
  !>     With HIPBLAS_V2 define, hipblasNrm2BatchedEx accepts hipDataType for xType, resultType,
  !>     and executionType rather than hipblasDatatype_t. hipblasNrm2BatchedEx will only accept
  !>     hipDataType in a future release.
  !> 
  !>         #ifdef HIPBLAS_V2  available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2
  !> 
  !>             hipblasStatus_t hipblasNrm2BatchedEx(hipblasHandle_t handle,
  !>                                                  int             n,
  !>                                                   void     x,
  !>                                                  hipDataType     xType,
  !>                                                  int             incx,
  !>                                                  int             batchCount,
  !>                                                  void           result,
  !>                                                  hipDataType     resultType,
  !>                                                  hipDataType     executionType)
  !> 
  !>         #else  [DEPRECATED]
  !> 
  !>             hipblasStatus_t hipblasNrm2BatchedEx(hipblasHandle_t   handle,
  !>                                                  int               n,
  !>                                                   void       x,
  !>                                                  hipblasDatatype_t xType,
  !>                                                  int               incx,
  !>                                                  int               batchCount,
  !>                                                  void             result,
  !>                                                  hipblasDatatype_t resultType,
  !>                                                  hipblasDatatype_t executionType)
  !> 
  !>         #endif
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               number of elements in each x_i.
  !>     @param[in]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     xType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of each vector x_i.\n
  !>     [hipDataType]
  !>               specifies the datatype of each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     batchCount [int]
  !>               number of instances in the batch
  !>     @param[out]
  !>     result
  !>               device pointer or host pointer to array of batchCount size for nrm2 results.
  !>               return is 0.0 for each element if n <= 0, incx<=0.
  !>     @param[in]
  !>     resultType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of the result.\n
  !>     [hipDataType]
  !>               specifies the datatype of the result.
  !>     @param[in]
  !>     executionType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of computation.\n
  !>     [hipDataType]
  !>               specifies the datatype of computation.
  !> 
  !>     
  interface hipblasNrm2BatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasNrm2BatchedEx_(handle,n,x,xType,incx,batchCount,myResult,resultType,executionType) bind(c, name="cublasNrm2BatchedEx")
#else
    function hipblasNrm2BatchedEx_(handle,n,x,xType,incx,batchCount,myResult,resultType,executionType) bind(c, name="hipblasNrm2BatchedEx")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasNrm2BatchedEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIP_R_16F)),value :: xType
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
      integer(kind(HIP_R_16F)),value :: resultType
      integer(kind(HIP_R_16F)),value :: executionType
    end function


  end interface
  
  interface hipblasNrm2BatchedEx_v2
#ifdef USE_CUDA_NAMES
    function hipblasNrm2BatchedEx_v2_(handle,n,x,xType,incx,batchCount,myResult,resultType,executionType) bind(c, name="cublasNrm2BatchedEx_v2")
#else
    function hipblasNrm2BatchedEx_v2_(handle,n,x,xType,incx,batchCount,myResult,resultType,executionType) bind(c, name="hipblasNrm2BatchedEx_v2")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasNrm2BatchedEx_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIP_R_32F)),value :: xType
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
      integer(kind(HIP_R_32F)),value :: resultType
      integer(kind(HIP_R_32F)),value :: executionType
    end function

  end interface
  !> ! \brief BLAS_EX API
  !> 
  !>     \details
  !>     nrm2StridedBatchedEx computes the euclidean norm over a batch of real or complex vectors
  !> 
  !>               := sqrt( x_i'x_i ) for real vectors x, for i = 1, ..., batchCount
  !>               := sqrt( x_iHx_i ) for complex vectors, for i = 1, ..., batchCount
  !> 
  !>     - Supported types are determined by the backend. See rocBLAScuBLAS documentation.
  !> 
  !>     With HIPBLAS_V2 define, hipblasNrm2StridedBatchedEx accepts hipDataType for xType, resultType,
  !>     and executionType rather than hipblasDatatype_t. hipblasNrm2StridedBatchedEx will only accept
  !>     hipDataType in a future release.
  !> 
  !>         #ifdef HIPBLAS_V2  available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2
  !> 
  !>             hipblasStatus_t hipblasNrm2StridedBatchedEx(hipblasHandle_t handle,
  !>                                                         int             n,
  !>                                                          void     x,
  !>                                                         hipDataType     xType,
  !>                                                         int             incx,
  !>                                                         hipblasStride   stridex,
  !>                                                         int             batchCount,
  !>                                                         void           result,
  !>                                                         hipDataType     resultType,
  !>                                                         hipDataType     executionType)
  !> 
  !>         #else  [DEPRECATED]
  !> 
  !>             hipblasStatus_t hipblasNrm2StridedBatchedEx(hipblasHandle_t   handle,
  !>                                                         int               n,
  !>                                                          void       x,
  !>                                                         hipblasDatatype_t xType,
  !>                                                         int               incx,
  !>                                                         hipblasStride     stridex,
  !>                                                         int               batchCount,
  !>                                                         void             result,
  !>                                                         hipblasDatatype_t resultType,
  !>                                                         hipblasDatatype_t executionType)
  !> 
  !>         #endif
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               number of elements in each x_i.
  !>     @param[in]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     xType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of each vector x_i.\n
  !>     [hipDataType]
  !>               specifies the datatype of each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i. incx must be > 0.
  !>     @param[in]
  !>     stridex   [hipblasStride]
  !>               stride from the start of one vector (x_i) and the next one (x_i+1).
  !>               There are no restrictions placed on stride_x, however the user should
  !>               take care to ensure that stride_x is of appropriate size, for a typical
  !>               case this means stride_x >= n  incx.
  !>     @param[in]
  !>     batchCount [int]
  !>               number of instances in the batch
  !>     @param[out]
  !>     result
  !>               device pointer or host pointer to array for storing contiguous batchCount results.
  !>               return is 0.0 for each element if n <= 0, incx<=0.
  !>     @param[in]
  !>     resultType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of the result.\n
  !>     [hipDataType]
  !>               specifies the datatype of the result.
  !>     @param[in]
  !>     executionType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>               specifies the datatype of computation.\n
  !>     [hipDataType]
  !>               specifies the datatype of computation.
  !> 
  !>     
  interface hipblasNrm2StridedBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasNrm2StridedBatchedEx_(handle,n,x,xType,incx,stridex,batchCount,myResult,resultType,executionType) bind(c, name="cublasNrm2StridedBatchedEx")
#else
    function hipblasNrm2StridedBatchedEx_(handle,n,x,xType,incx,stridex,batchCount,myResult,resultType,executionType) bind(c, name="hipblasNrm2StridedBatchedEx")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasNrm2StridedBatchedEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIP_R_16F)),value :: xType
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
      integer(kind(HIP_R_16F)),value :: resultType
      integer(kind(HIP_R_16F)),value :: executionType
    end function


  end interface
  
  interface hipblasNrm2StridedBatchedEx_v2
#ifdef USE_CUDA_NAMES
    function hipblasNrm2StridedBatchedEx_v2_(handle,n,x,xType,incx,stridex,batchCount,myResult,resultType,executionType) bind(c, name="cublasNrm2StridedBatchedEx_v2")
#else
    function hipblasNrm2StridedBatchedEx_v2_(handle,n,x,xType,incx,stridex,batchCount,myResult,resultType,executionType) bind(c, name="hipblasNrm2StridedBatchedEx_v2")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasNrm2StridedBatchedEx_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIP_R_32F)),value :: xType
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      type(c_ptr),value :: myResult
      integer(kind(HIP_R_32F)),value :: resultType
      integer(kind(HIP_R_32F)),value :: executionType
    end function

  end interface
  !> ! \brief BLAS EX API
  !> 
  !>     \details
  !>     rotEx applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to vectors x and y.
  !>         Scalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !> 
  !>     In the case where cs_type is real:
  !>         x := c  x + s  y
  !>             y := c  y - s  x
  !> 
  !>     In the case where cs_type is complex, the imaginary part of c is ignored:
  !>         x := real(c)  x + s  y
  !>             y := real(c)  y - conj(s)  x
  !> 
  !>     - Supported types are determined by the backend. See rocBLAScuBLAS documentation.
  !> 
  !>     With HIPBLAS_V2 define, hipblasRotEx accepts hipDataType for xType, yType, csType,
  !>     and executionType rather than hipblasDatatype_t. hipblasRotEx will only accept
  !>     hipDataType in a future release.
  !> 
  !>         #ifdef HIPBLAS_V2  available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2
  !> 
  !>             hipblasStatus_t hipblasRotEx(hipblasHandle_t handle,
  !>                                          int             n,
  !>                                          void           x,
  !>                                          hipDataType     xType,
  !>                                          int             incx,
  !>                                          void           y,
  !>                                          hipDataType     yType,
  !>                                          int             incy,
  !>                                           void     c,
  !>                                           void     s,
  !>                                          hipDataType     csType,
  !>                                          hipDataType     executionType)
  !> 
  !>         #else  [DEPRECATED]
  !> 
  !>             hipblasStatus_t hipblasRotEx(hipblasHandle_t   handle,
  !>                                          int               n,
  !>                                          void             x,
  !>                                          hipblasDatatype_t xType,
  !>                                          int               incx,
  !>                                          void             y,
  !>                                          hipblasDatatype_t yType,
  !>                                          int               incy,
  !>                                           void       c,
  !>                                           void       s,
  !>                                          hipblasDatatype_t csType,
  !>                                          hipblasDatatype_t executionType)
  !> 
  !>         #endif
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !>     @param[in]
  !>     n       [int]
  !>             number of elements in the x and y vectors.
  !>     @param[inout]
  !>     x       device pointer storing vector x.
  !>     @param[in]
  !>     xType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>             specifies the datatype of vector x.\n
  !>     [hipDataType]
  !>             specifies the datatype of vector x.
  !>     @param[in]
  !>     incx    [int]
  !>             specifies the increment between elements of x.
  !>     @param[inout]
  !>     y       device pointer storing vector y.
  !>     @param[in]
  !>     yType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>             specifies the datatype of vector y.\n
  !>     [hipDataType]
  !>             specifies the datatype of vector y.
  !>     @param[in]
  !>     incy    [int]
  !>             specifies the increment between elements of y.
  !>     @param[in]
  !>     c       device pointer or host pointer storing scalar cosine component of the rotation matrix.
  !>     @param[in]
  !>     s       device pointer or host pointer storing scalar sine component of the rotation matrix.
  !>     @param[in]
  !>     csType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>             specifies the datatype of c and s.\n
  !>     [hipDataType]
  !>             specifies the datatype of c and s.
  !>     @param[in]
  !>     executionType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>             specifies the datatype of computation.\n
  !>     [hipDataType]
  !>             specifies the datatype of computation.
  !> 
  !>     
  interface hipblasRotEx
#ifdef USE_CUDA_NAMES
    function hipblasRotEx_(handle,n,x,xType,incx,y,yType,incy,c,s,csType,executionType) bind(c, name="cublasRotEx")
#else
    function hipblasRotEx_(handle,n,x,xType,incx,y,yType,incy,c,s,csType,executionType) bind(c, name="hipblasRotEx")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasRotEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIP_R_16F)),value :: xType
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(HIP_R_16F)),value :: yType
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(kind(HIP_R_16F)),value :: csType
      integer(kind(HIP_R_16F)),value :: executionType
    end function


  end interface
  
  interface hipblasRotEx_v2
#ifdef USE_CUDA_NAMES
    function hipblasRotEx_v2_(handle,n,x,xType,incx,y,yType,incy,c,s,csType,executionType) bind(c, name="cublasRotEx_v2")
#else
    function hipblasRotEx_v2_(handle,n,x,xType,incx,y,yType,incy,c,s,csType,executionType) bind(c, name="hipblasRotEx_v2")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasRotEx_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIP_R_32F)),value :: xType
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(HIP_R_32F)),value :: yType
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(kind(HIP_R_32F)),value :: csType
      integer(kind(HIP_R_32F)),value :: executionType
    end function

  end interface
  !> ! \brief BLAS EX API
  !> 
  !>     \details
  !>     rotBatchedEx applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to batched vectors x_i and y_i, for i = 1, ..., batchCount.
  !>         Scalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !> 
  !>     In the case where cs_type is real:
  !>             x := c  x + s  y
  !>             y := c  y - s  x
  !> 
  !>         In the case where cs_type is complex, the imaginary part of c is ignored:
  !>             x := real(c)  x + s  y
  !>             y := real(c)  y - conj(s)  x
  !> 
  !>     - Supported types are determined by the backend. See rocBLAScuBLAS documentation.
  !> 
  !>     With HIPBLAS_V2 define, hipblasRotBatchedEx accepts hipDataType for xType, yType, csType,
  !>     and executionType rather than hipblasDatatype_t. hipblasRotBatchedEx will only accept
  !>     hipDataType in a future release.
  !> 
  !>         #ifdef HIPBLAS_V2  available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2
  !> 
  !>             hipblasStatus_t hipblasRotBatchedEx(hipblasHandle_t handle,
  !>                                                 int             n,
  !>                                                 void           x,
  !>                                                 hipDataType     xType,
  !>                                                 int             incx,
  !>                                                 void           y,
  !>                                                 hipDataType     yType,
  !>                                                 int             incy,
  !>                                                  void     c,
  !>                                                  void     s,
  !>                                                 hipDataType     csType,
  !>                                                 int             batchCount,
  !>                                                 hipDataType     executionType)
  !> 
  !>         #else  [DEPRECATED]
  !> 
  !>             hipblasStatus_t hipblasRotBatchedEx(hipblasHandle_t   handle,
  !>                                                 int               n,
  !>                                                 void             x,
  !>                                                 hipblasDatatype_t xType,
  !>                                                 int               incx,
  !>                                                 void             y,
  !>                                                 hipblasDatatype_t yType,
  !>                                                 int               incy,
  !>                                                  void       c,
  !>                                                  void       s,
  !>                                                 hipblasDatatype_t csType,
  !>                                                 int               batchCount,
  !>                                                 hipblasDatatype_t executionType)
  !> 
  !>         #endif
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !>     @param[in]
  !>     n       [int]
  !>             number of elements in each x_i and y_i vectors.
  !>     @param[inout]
  !>     x       device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     xType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>             specifies the datatype of each vector x_i.\n
  !>     [hipDataType]
  !>             specifies the datatype of each vector x_i.
  !>     @param[in]
  !>     incx    [int]
  !>             specifies the increment between elements of each x_i.
  !>     @param[inout]
  !>     y       device array of device pointers storing each vector y_i.
  !>     @param[in]
  !>     yType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>             specifies the datatype of each vector y_i.\n
  !>     [hipDataType]
  !>             specifies the datatype of each vector y_i.
  !>     @param[in]
  !>     incy    [int]
  !>             specifies the increment between elements of each y_i.
  !>     @param[in]
  !>     c       device pointer or host pointer to scalar cosine component of the rotation matrix.
  !>     @param[in]
  !>     s       device pointer or host pointer to scalar sine component of the rotation matrix.
  !>     @param[in]
  !>     csType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>             specifies the datatype of c and s.\n
  !>     [hipDataType]
  !>             specifies the datatype of c and s.
  !>     @param[in]
  !>     batchCount [int]
  !>             the number of x and y arrays, i.e. the number of batches.
  !>     @param[in]
  !>     executionType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>             specifies the datatype of computation.\n
  !>     [hipDataType]
  !>             specifies the datatype of computation.
  !> 
  !>     
  interface hipblasRotBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasRotBatchedEx_(handle,n,x,xType,incx,y,yType,incy,c,s,csType,batchCount,executionType) bind(c, name="cublasRotBatchedEx")
#else
    function hipblasRotBatchedEx_(handle,n,x,xType,incx,y,yType,incy,c,s,csType,batchCount,executionType) bind(c, name="hipblasRotBatchedEx")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasRotBatchedEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIP_R_16F)),value :: xType
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(HIP_R_16F)),value :: yType
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(kind(HIP_R_16F)),value :: csType
      integer(c_int),value :: batchCount
      integer(kind(HIP_R_16F)),value :: executionType
    end function


  end interface
  
  interface hipblasRotBatchedEx_v2
#ifdef USE_CUDA_NAMES
    function hipblasRotBatchedEx_v2_(handle,n,x,xType,incx,y,yType,incy,c,s,csType,batchCount,executionType) bind(c, name="cublasRotBatchedEx_v2")
#else
    function hipblasRotBatchedEx_v2_(handle,n,x,xType,incx,y,yType,incy,c,s,csType,batchCount,executionType) bind(c, name="hipblasRotBatchedEx_v2")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasRotBatchedEx_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIP_R_32F)),value :: xType
      integer(c_int),value :: incx
      type(c_ptr),value :: y
      integer(kind(HIP_R_32F)),value :: yType
      integer(c_int),value :: incy
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(kind(HIP_R_32F)),value :: csType
      integer(c_int),value :: batchCount
      integer(kind(HIP_R_32F)),value :: executionType
    end function

  end interface
  !> ! \brief BLAS Level 1 API
  !> 
  !>     \details
  !>     rotStridedBatchedEx applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to strided batched vectors x_i and y_i, for i = 1, ..., batchCount.
  !>         Scalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
  !> 
  !>     In the case where cs_type is real:
  !>             x := c  x + s  y
  !>             y := c  y - s  x
  !> 
  !>         In the case where cs_type is complex, the imaginary part of c is ignored:
  !>             x := real(c)  x + s  y
  !>             y := real(c)  y - conj(s)  x
  !> 
  !>     - Supported types are determined by the backend. See rocBLAScuBLAS documentation.
  !> 
  !>     With HIPBLAS_V2 define, hipblasRotStridedBatchedEx accepts hipDataType for xType, yType, csType,
  !>     and executionType rather than hipblasDatatype_t. hipblasRotStridedBatchedEx will only accept
  !>     hipDataType in a future release.
  !> 
  !>          #ifdef HIPBLAS_V2  available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2
  !> 
  !>             hipblasStatus_t hipblasRotStridedBatchedEx(hipblasHandle_t handle,
  !>                                                        int             n,
  !>                                                        void           x,
  !>                                                        hipDataType     xType,
  !>                                                        int             incx,
  !>                                                        hipblasStride   stridex,
  !>                                                        void           y,
  !>                                                        hipDataType     yType,
  !>                                                        int             incy,
  !>                                                        hipblasStride   stridey,
  !>                                                         void     c,
  !>                                                         void     s,
  !>                                                        hipDataType     csType,
  !>                                                        int             batchCount,
  !>                                                        hipDataType     executionType)
  !> 
  !>         #else  [DEPRECATED]
  !> 
  !>             hipblasStatus_t hipblasRotStridedBatchedEx(hipblasHandle_t   handle,
  !>                                                        int               n,
  !>                                                        void             x,
  !>                                                        hipblasDatatype_t xType,
  !>                                                        int               incx,
  !>                                                        hipblasStride     stridex,
  !>                                                        void             y,
  !>                                                        hipblasDatatype_t yType,
  !>                                                        int               incy,
  !>                                                        hipblasStride     stridey,
  !>                                                         void       c,
  !>                                                         void       s,
  !>                                                        hipblasDatatype_t csType,
  !>                                                        int               batchCount,
  !>                                                        hipblasDatatype_t executionType)
  !> 
  !>         #endif
  !> 
  !>     @param[in]
  !>     handle  [hipblasHandle_t]
  !>             handle to the hipblas library context queue.
  !>     @param[in]
  !>     n       [int]
  !>             number of elements in each x_i and y_i vectors.
  !>     @param[inout]
  !>     x       device pointer to the first vector x_1.
  !>     @param[in]
  !>     xType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>             specifies the datatype of each vector x_i.\n
  !>     [hipDataType]
  !>             specifies the datatype of each vector x_i.
  !>     @param[in]
  !>     incx    [int]
  !>             specifies the increment between elements of each x_i.
  !>     @param[in]
  !>     stridex [hipblasStride]
  !>             specifies the increment from the beginning of x_i to the beginning of x_(i+1)
  !>     @param[inout]
  !>     y       device pointer to the first vector y_1.
  !>     @param[in]
  !>     yType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>             specifies the datatype of each vector y_i.\n
  !>     [hipDataType]
  !>             specifies the datatype of each vector y_i.
  !>     @param[in]
  !>     incy    [int]
  !>             specifies the increment between elements of each y_i.
  !>     @param[in]
  !>     stridey [hipblasStride]
  !>             specifies the increment from the beginning of y_i to the beginning of y_(i+1)
  !>     @param[in]
  !>     c       device pointer or host pointer to scalar cosine component of the rotation matrix.
  !>     @param[in]
  !>     s       device pointer or host pointer to scalar sine component of the rotation matrix.
  !>     @param[in]
  !>     csType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>             specifies the datatype of c and s.\n
  !>     [hipDataType]
  !>             specifies the datatype of c and s.
  !>     @param[in]
  !>     batchCount [int]
  !>             the number of x and y arrays, i.e. the number of batches.
  !>     @param[in]
  !>     executionType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>             specifies the datatype of computation.\n
  !>     [hipDataType]
  !>             specifies the datatype of computation.
  !> 
  !>     
  interface hipblasRotStridedBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasRotStridedBatchedEx_(handle,n,x,xType,incx,stridex,y,yType,incy,stridey,c,s,csType,batchCount,executionType) bind(c, name="cublasRotStridedBatchedEx")
#else
    function hipblasRotStridedBatchedEx_(handle,n,x,xType,incx,stridex,y,yType,incy,stridey,c,s,csType,batchCount,executionType) bind(c, name="hipblasRotStridedBatchedEx")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasRotStridedBatchedEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIP_R_16F)),value :: xType
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(kind(HIP_R_16F)),value :: yType
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(kind(HIP_R_16F)),value :: csType
      integer(c_int),value :: batchCount
      integer(kind(HIP_R_16F)),value :: executionType
    end function


  end interface
  
  interface hipblasRotStridedBatchedEx_v2
#ifdef USE_CUDA_NAMES
    function hipblasRotStridedBatchedEx_v2_(handle,n,x,xType,incx,stridex,y,yType,incy,stridey,c,s,csType,batchCount,executionType) bind(c, name="cublasRotStridedBatchedEx_v2")
#else
    function hipblasRotStridedBatchedEx_v2_(handle,n,x,xType,incx,stridex,y,yType,incy,stridey,c,s,csType,batchCount,executionType) bind(c, name="hipblasRotStridedBatchedEx_v2")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasRotStridedBatchedEx_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: x
      integer(kind(HIP_R_32F)),value :: xType
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      type(c_ptr),value :: y
      integer(kind(HIP_R_32F)),value :: yType
      integer(c_int),value :: incy
      integer(c_int64_t),value :: stridey
      type(c_ptr),value :: c
      type(c_ptr),value :: s
      integer(kind(HIP_R_32F)),value :: csType
      integer(c_int),value :: batchCount
      integer(kind(HIP_R_32F)),value :: executionType
    end function

  end interface
  !> ! \brief BLAS EX API
  !> 
  !>     \details
  !>     scalEx  scales each element of vector x with scalar alpha.
  !> 
  !>         x := alpha  x
  !> 
  !>     - Supported types are determined by the backend. See rocBLAScuBLAS documentation.
  !> 
  !>     With HIPBLAS_V2 define, hipblasScalEx accepts hipDataType for alphaType,
  !>     xType, and executionType rather than hipblasDatatype_t. hipblasScalEx will only
  !>     accept hipDataType in a future release.
  !> 
  !>         #ifdef HIPBLAS_V2  available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2
  !> 
  !>             hipblasStatus_t hipblasScalEx(hipblasHandle_t handle,a
  !>                                           int             n,
  !>                                            void     alpha,
  !>                                           hipDataType     alphaType,
  !>                                           void           x,
  !>                                           hipDataType     xType,
  !>                                           int             incx,
  !>                                           hipDataType     executionType)
  !> 
  !>         #else  [DEPRECATED]
  !> 
  !>             hipblasStatus_t hipblasScalEx(hipblasHandle_t   handle,
  !>                                           int               n,
  !>                                            void       alpha,
  !>                                           hipblasDatatype_t alphaType,
  !>                                           void             x,
  !>                                           hipblasDatatype_t xType,
  !>                                           int               incx,
  !>                                           hipblasDatatype_t executionType)
  !> 
  !>         #endif
  !> 
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in x.
  !>     @param[in]
  !>     alpha     device pointer or host pointer for the scalar alpha.
  !>     @param[in]
  !>     alphaType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>                specifies the datatype of alpha.\n
  !>     [hipDataType]
  !>                specifies the datatype of alpha.
  !>     @param[inout]
  !>     x         device pointer storing vector x.
  !>     @param[in]
  !>     xType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>            specifies the datatype of vector x.\n
  !>     [hipDataType]
  !>            specifies the datatype of vector x.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of x.
  !>     @param[in]
  !>     executionType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>                    specifies the datatype of computation.\n
  !>     [hipDataType]
  !>                    specifies the datatype of computation.
  !> 
  !>     
  interface hipblasScalEx
#ifdef USE_CUDA_NAMES
    function hipblasScalEx_(handle,n,alpha,alphaType,x,xType,incx,executionType) bind(c, name="cublasScalEx")
#else
    function hipblasScalEx_(handle,n,alpha,alphaType,x,xType,incx,executionType) bind(c, name="hipblasScalEx")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScalEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      integer(kind(HIP_R_16F)),value :: alphaType
      type(c_ptr),value :: x
      integer(kind(HIP_R_16F)),value :: xType
      integer(c_int),value :: incx
      integer(kind(HIP_R_16F)),value :: executionType
    end function


  end interface
  
  interface hipblasScalEx_v2
#ifdef USE_CUDA_NAMES
    function hipblasScalEx_v2_(handle,n,alpha,alphaType,x,xType,incx,executionType) bind(c, name="cublasScalEx_v2")
#else
    function hipblasScalEx_v2_(handle,n,alpha,alphaType,x,xType,incx,executionType) bind(c, name="hipblasScalEx_v2")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScalEx_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      integer(kind(HIP_R_32F)),value :: alphaType
      type(c_ptr),value :: x
      integer(kind(HIP_R_32F)),value :: xType
      integer(c_int),value :: incx
      integer(kind(HIP_R_32F)),value :: executionType
    end function

  end interface
  !> ! \brief BLAS EX API
  !> 
  !>     \details
  !>     scalBatchedEx  scales each element of each vector x_i with scalar alpha.
  !> 
  !>         x_i := alpha  x_i
  !> 
  !>     - Supported types are determined by the backend. See rocBLAScuBLAS documentation.
  !> 
  !>     With HIPBLAS_V2 define, hipblasScalBatchedEx accepts hipDataType for alphaType,
  !>     xType, and executionType rather than hipblasDatatype_t. hipblasScalBatchedEx will only
  !>     accept hipDataType in a future release.
  !>     \code{.cpp}
  !>         #ifdef HIPBLAS_V2  available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2
  !> 
  !>                 hipblasStatus_t hipblasScalBatchedEx(hipblasHandle_t handle,
  !>                                                     int             n,
  !>                                                      void     alpha,
  !>                                                     hipDataType     alphaType,
  !>                                                     void           x,
  !>                                                     hipDataType     xType,
  !>                                                     int             incx,
  !>                                                     int             batchCount,
  !>                                                     hipDataType     executionType)
  !> 
  !>             #else  [DEPRECATED]
  !> 
  !>                 hipblasStatus_t hipblasScalBatchedEx(hipblasHandle_t   handle,
  !>                                                     int               n,
  !>                                                      void       alpha,
  !>                                                     hipblasDatatype_t alphaType,
  !>                                                     void             x,
  !>                                                     hipblasDatatype_t xType,
  !>                                                     int               incx,
  !>                                                     int               batchCount,
  !>                                                     hipblasDatatype_t executionType)
  !> 
  !>             #endif
  !>     \endcode
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in x.
  !>     @param[in]
  !>     alpha     device pointer or host pointer for the scalar alpha.
  !>     @param[in]
  !>     alphaType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>                specifies the datatype of alpha.\n
  !>     [hipDataType]
  !>                specifies the datatype of alpha.
  !>     @param[inout]
  !>     x         device array of device pointers storing each vector x_i.
  !>     @param[in]
  !>     xType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>            specifies the datatype of each vector x_i.\n
  !>     [hipDataType]
  !>            specifies the datatype of each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>     @param[in]
  !>     executionType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>                    specifies the datatype of computation.\n
  !>     [hipDataType]
  !>                    specifies the datatype of computation.
  !> 
  !>     
  interface hipblasScalBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasScalBatchedEx_(handle,n,alpha,alphaType,x,xType,incx,batchCount,executionType) bind(c, name="cublasScalBatchedEx")
#else
    function hipblasScalBatchedEx_(handle,n,alpha,alphaType,x,xType,incx,batchCount,executionType) bind(c, name="hipblasScalBatchedEx")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScalBatchedEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      integer(kind(HIP_R_16F)),value :: alphaType
      type(c_ptr),value :: x
      integer(kind(HIP_R_16F)),value :: xType
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      integer(kind(HIP_R_16F)),value :: executionType
    end function


  end interface
  
  interface hipblasScalBatchedEx_v2
#ifdef USE_CUDA_NAMES
    function hipblasScalBatchedEx_v2_(handle,n,alpha,alphaType,x,xType,incx,batchCount,executionType) bind(c, name="cublasScalBatchedEx_v2")
#else
    function hipblasScalBatchedEx_v2_(handle,n,alpha,alphaType,x,xType,incx,batchCount,executionType) bind(c, name="hipblasScalBatchedEx_v2")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScalBatchedEx_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      integer(kind(HIP_R_32F)),value :: alphaType
      type(c_ptr),value :: x
      integer(kind(HIP_R_32F)),value :: xType
      integer(c_int),value :: incx
      integer(c_int),value :: batchCount
      integer(kind(HIP_R_32F)),value :: executionType
    end function

  end interface
  !> ! \brief BLAS EX API
  !> 
  !>     \details
  !>     scalStridedBatchedEx  scales each element of vector x with scalar alpha over a set
  !>                              of strided batched vectors.
  !> 
  !>         x := alpha  x
  !> 
  !>     - Supported types are determined by the backend. See rocBLAScuBLAS documentation.
  !> 
  !>     With HIPBLAS_V2 define, hipblasScalStridedBatchedEx accepts hipDataType for alphaType,
  !>     xType, and executionType rather than hipblasDatatype_t. hipblasScalStridedBatchedEx will only
  !>     accept hipDataType in a future release.
  !>     \code{.cpp}
  !>         #ifdef HIPBLAS_V2  available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2
  !> 
  !>                 hipblasStatus_t hipblasScalStridedBatchedEx(hipblasHandle_t handle,
  !>                                                             int             n,
  !>                                                              void     alpha,
  !>                                                             hipDataType     alphaType,
  !>                                                             void           x,
  !>                                                             hipDataType     xType,
  !>                                                             int             incx,
  !>                                                             hipblasStride   stridex,
  !>                                                             int             batchCount,
  !>                                                             hipDataType     executionType)
  !> 
  !>             #else  [DEPRECATED]
  !> 
  !>                 hipblasStatus_t hipblasScalStridedBatchedEx(hipblasHandle_t   handle,
  !>                                                             int               n,
  !>                                                              void       alpha,
  !>                                                             hipblasDatatype_t alphaType,
  !>                                                             void             x,
  !>                                                             hipblasDatatype_t xType,
  !>                                                             int               incx,
  !>                                                             hipblasStride     stridex,
  !>                                                             int               batchCount,
  !>                                                             hipblasDatatype_t executionType)
  !> 
  !>             #endif
  !>     \endcode
  !>     @param[in]
  !>     handle    [hipblasHandle_t]
  !>               handle to the hipblas library context queue.
  !>     @param[in]
  !>     n         [int]
  !>               the number of elements in x.
  !>     @param[in]
  !>     alpha     device pointer or host pointer for the scalar alpha.
  !>     @param[in]
  !>     alphaType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>                specifies the datatype of alpha.\n
  !>     [hipDataType]
  !>                specifies the datatype of alpha.
  !>     @param[inout]
  !>     x         device pointer to the first vector x_1.
  !>     @param[in]
  !>     xType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>            specifies the datatype of each vector x_i.\n
  !>     [hipDataType]
  !>            specifies the datatype of each vector x_i.
  !>     @param[in]
  !>     incx      [int]
  !>               specifies the increment for the elements of each x_i.
  !>     @param[in]
  !>     stridex   [hipblasStride]
  !>               stride from the start of one vector (x_i) to the next one (x_i+1).
  !>               There are no restrictions placed on stridex, however the user should
  !>               take care to ensure that stridex is of appropriate size, for a typical
  !>               case this means stridex >= n  incx.
  !>     @param[in]
  !>     batchCount [int]
  !>                 number of instances in the batch.
  !>     @param[in]
  !>     executionType
  !>     [hipblasDatatype_t] [DEPRECATED]
  !>                    specifies the datatype of computation.\n
  !>     [hipDataType]
  !>                    specifies the datatype of computation.
  !> 
  !>     
  interface hipblasScalStridedBatchedEx
#ifdef USE_CUDA_NAMES
    function hipblasScalStridedBatchedEx_(handle,n,alpha,alphaType,x,xType,incx,stridex,batchCount,executionType) bind(c, name="cublasScalStridedBatchedEx")
#else
    function hipblasScalStridedBatchedEx_(handle,n,alpha,alphaType,x,xType,incx,stridex,batchCount,executionType) bind(c, name="hipblasScalStridedBatchedEx")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScalStridedBatchedEx_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      integer(kind(HIP_R_16F)),value :: alphaType
      type(c_ptr),value :: x
      integer(kind(HIP_R_16F)),value :: xType
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      integer(kind(HIP_R_16F)),value :: executionType
    end function


  end interface
  
  interface hipblasScalStridedBatchedEx_v2
#ifdef USE_CUDA_NAMES
    function hipblasScalStridedBatchedEx_v2_(handle,n,alpha,alphaType,x,xType,incx,stridex,batchCount,executionType) bind(c, name="cublasScalStridedBatchedEx_v2")
#else
    function hipblasScalStridedBatchedEx_v2_(handle,n,alpha,alphaType,x,xType,incx,stridex,batchCount,executionType) bind(c, name="hipblasScalStridedBatchedEx_v2")
#endif
      use iso_c_binding
      use hipfort_enums
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScalStridedBatchedEx_v2_
      type(c_ptr),value :: handle
      integer(c_int),value :: n
      type(c_ptr),value :: alpha
      integer(kind(HIP_R_32F)),value :: alphaType
      type(c_ptr),value :: x
      integer(kind(HIP_R_32F)),value :: xType
      integer(c_int),value :: incx
      integer(c_int64_t),value :: stridex
      integer(c_int),value :: batchCount
      integer(kind(HIP_R_32F)),value :: executionType
    end function

  end interface

#ifdef USE_FPOINTER_INTERFACES
  contains
    function hipblasIsamax_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsamax_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIsamax_rank_0 = hipblasIsamax_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIsamax_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsamax_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIsamax_rank_1 = hipblasIsamax_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIdamax_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdamax_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIdamax_rank_0 = hipblasIdamax_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIdamax_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdamax_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIdamax_rank_1 = hipblasIdamax_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIcamax_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamax_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIcamax_rank_0 = hipblasIcamax_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIcamax_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamax_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIcamax_rank_1 = hipblasIcamax_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIzamax_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamax_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIzamax_rank_0 = hipblasIzamax_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIzamax_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamax_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIzamax_rank_1 = hipblasIzamax_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIcamax_v2_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamax_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIcamax_v2_rank_0 = hipblasIcamax_v2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIcamax_v2_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamax_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIcamax_v2_rank_1 = hipblasIcamax_v2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIzamax_v2_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamax_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIzamax_v2_rank_0 = hipblasIzamax_v2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIzamax_v2_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamax_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIzamax_v2_rank_1 = hipblasIzamax_v2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIsamaxBatched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsamaxBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIsamaxBatched_full_rank = hipblasIsamaxBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIsamaxBatched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsamaxBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIsamaxBatched_rank_0 = hipblasIsamaxBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIsamaxBatched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsamaxBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIsamaxBatched_rank_1 = hipblasIsamaxBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIdamaxBatched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdamaxBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIdamaxBatched_full_rank = hipblasIdamaxBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIdamaxBatched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdamaxBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIdamaxBatched_rank_0 = hipblasIdamaxBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIdamaxBatched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdamaxBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIdamaxBatched_rank_1 = hipblasIdamaxBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIcamaxBatched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamaxBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcamaxBatched_full_rank = hipblasIcamaxBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIcamaxBatched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamaxBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcamaxBatched_rank_0 = hipblasIcamaxBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIcamaxBatched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamaxBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcamaxBatched_rank_1 = hipblasIcamaxBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIzamaxBatched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamaxBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzamaxBatched_full_rank = hipblasIzamaxBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIzamaxBatched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamaxBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzamaxBatched_rank_0 = hipblasIzamaxBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIzamaxBatched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamaxBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzamaxBatched_rank_1 = hipblasIzamaxBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIcamaxBatched_v2_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamaxBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcamaxBatched_v2_full_rank = hipblasIcamaxBatched_v2_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIcamaxBatched_v2_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamaxBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcamaxBatched_v2_rank_0 = hipblasIcamaxBatched_v2_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIcamaxBatched_v2_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamaxBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcamaxBatched_v2_rank_1 = hipblasIcamaxBatched_v2_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIzamaxBatched_v2_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamaxBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzamaxBatched_v2_full_rank = hipblasIzamaxBatched_v2_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIzamaxBatched_v2_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamaxBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzamaxBatched_v2_rank_0 = hipblasIzamaxBatched_v2_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIzamaxBatched_v2_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamaxBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzamaxBatched_v2_rank_1 = hipblasIzamaxBatched_v2_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIsamaxStridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsamaxStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIsamaxStridedBatched_rank_0 = hipblasIsamaxStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIsamaxStridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsamaxStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIsamaxStridedBatched_rank_1 = hipblasIsamaxStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIdamaxStridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdamaxStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIdamaxStridedBatched_rank_0 = hipblasIdamaxStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIdamaxStridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdamaxStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIdamaxStridedBatched_rank_1 = hipblasIdamaxStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIcamaxStridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamaxStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcamaxStridedBatched_rank_0 = hipblasIcamaxStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIcamaxStridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamaxStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcamaxStridedBatched_rank_1 = hipblasIcamaxStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIzamaxStridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamaxStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzamaxStridedBatched_rank_0 = hipblasIzamaxStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIzamaxStridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamaxStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzamaxStridedBatched_rank_1 = hipblasIzamaxStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIcamaxStridedBatched_v2_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamaxStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcamaxStridedBatched_v2_rank_0 = hipblasIcamaxStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIcamaxStridedBatched_v2_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamaxStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcamaxStridedBatched_v2_rank_1 = hipblasIcamaxStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIzamaxStridedBatched_v2_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamaxStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzamaxStridedBatched_v2_rank_0 = hipblasIzamaxStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIzamaxStridedBatched_v2_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamaxStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzamaxStridedBatched_v2_rank_1 = hipblasIzamaxStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIsamin_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsamin_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIsamin_rank_0 = hipblasIsamin_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIsamin_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsamin_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIsamin_rank_1 = hipblasIsamin_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIdamin_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdamin_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIdamin_rank_0 = hipblasIdamin_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIdamin_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdamin_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIdamin_rank_1 = hipblasIdamin_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIcamin_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamin_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIcamin_rank_0 = hipblasIcamin_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIcamin_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamin_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIcamin_rank_1 = hipblasIcamin_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIzamin_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamin_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIzamin_rank_0 = hipblasIzamin_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIzamin_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamin_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIzamin_rank_1 = hipblasIzamin_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIcamin_v2_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamin_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIcamin_v2_rank_0 = hipblasIcamin_v2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIcamin_v2_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcamin_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIcamin_v2_rank_1 = hipblasIcamin_v2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIzamin_v2_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamin_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIzamin_v2_rank_0 = hipblasIzamin_v2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIzamin_v2_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzamin_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasIzamin_v2_rank_1 = hipblasIzamin_v2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasIsaminBatched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsaminBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIsaminBatched_full_rank = hipblasIsaminBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIsaminBatched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsaminBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIsaminBatched_rank_0 = hipblasIsaminBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIsaminBatched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsaminBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIsaminBatched_rank_1 = hipblasIsaminBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIdaminBatched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdaminBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIdaminBatched_full_rank = hipblasIdaminBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIdaminBatched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdaminBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIdaminBatched_rank_0 = hipblasIdaminBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIdaminBatched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdaminBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIdaminBatched_rank_1 = hipblasIdaminBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIcaminBatched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcaminBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcaminBatched_full_rank = hipblasIcaminBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIcaminBatched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcaminBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcaminBatched_rank_0 = hipblasIcaminBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIcaminBatched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcaminBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcaminBatched_rank_1 = hipblasIcaminBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIzaminBatched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzaminBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzaminBatched_full_rank = hipblasIzaminBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIzaminBatched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzaminBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzaminBatched_rank_0 = hipblasIzaminBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIzaminBatched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzaminBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzaminBatched_rank_1 = hipblasIzaminBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIcaminBatched_v2_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcaminBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcaminBatched_v2_full_rank = hipblasIcaminBatched_v2_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIcaminBatched_v2_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcaminBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcaminBatched_v2_rank_0 = hipblasIcaminBatched_v2_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIcaminBatched_v2_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcaminBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcaminBatched_v2_rank_1 = hipblasIcaminBatched_v2_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIzaminBatched_v2_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzaminBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzaminBatched_v2_full_rank = hipblasIzaminBatched_v2_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIzaminBatched_v2_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzaminBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzaminBatched_v2_rank_0 = hipblasIzaminBatched_v2_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIzaminBatched_v2_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzaminBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzaminBatched_v2_rank_1 = hipblasIzaminBatched_v2_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasIsaminStridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsaminStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIsaminStridedBatched_rank_0 = hipblasIsaminStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIsaminStridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIsaminStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIsaminStridedBatched_rank_1 = hipblasIsaminStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIdaminStridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdaminStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIdaminStridedBatched_rank_0 = hipblasIdaminStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIdaminStridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIdaminStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIdaminStridedBatched_rank_1 = hipblasIdaminStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIcaminStridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcaminStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcaminStridedBatched_rank_0 = hipblasIcaminStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIcaminStridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcaminStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcaminStridedBatched_rank_1 = hipblasIcaminStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIzaminStridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzaminStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzaminStridedBatched_rank_0 = hipblasIzaminStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIzaminStridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzaminStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzaminStridedBatched_rank_1 = hipblasIzaminStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIcaminStridedBatched_v2_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcaminStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcaminStridedBatched_v2_rank_0 = hipblasIcaminStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIcaminStridedBatched_v2_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIcaminStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIcaminStridedBatched_v2_rank_1 = hipblasIcaminStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIzaminStridedBatched_v2_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzaminStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzaminStridedBatched_v2_rank_0 = hipblasIzaminStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasIzaminStridedBatched_v2_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasIzaminStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasIzaminStridedBatched_v2_rank_1 = hipblasIzaminStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasSasum_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSasum_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasSasum_rank_0 = hipblasSasum_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasSasum_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSasum_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasSasum_rank_1 = hipblasSasum_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasDasum_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDasum_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasDasum_rank_0 = hipblasDasum_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasDasum_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDasum_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasDasum_rank_1 = hipblasDasum_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasScasum_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasum_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasScasum_rank_0 = hipblasScasum_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasScasum_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasum_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasScasum_rank_1 = hipblasScasum_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasDzasum_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasum_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasDzasum_rank_0 = hipblasDzasum_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasDzasum_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasum_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasDzasum_rank_1 = hipblasDzasum_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasScasum_v2_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasum_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasScasum_v2_rank_0 = hipblasScasum_v2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasScasum_v2_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasum_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasScasum_v2_rank_1 = hipblasScasum_v2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasDzasum_v2_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasum_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasDzasum_v2_rank_0 = hipblasDzasum_v2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasDzasum_v2_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasum_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasDzasum_v2_rank_1 = hipblasDzasum_v2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasSasumBatched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSasumBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSasumBatched_full_rank = hipblasSasumBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasSasumBatched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSasumBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSasumBatched_rank_0 = hipblasSasumBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasSasumBatched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSasumBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSasumBatched_rank_1 = hipblasSasumBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDasumBatched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDasumBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDasumBatched_full_rank = hipblasDasumBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDasumBatched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDasumBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDasumBatched_rank_0 = hipblasDasumBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDasumBatched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDasumBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDasumBatched_rank_1 = hipblasDasumBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasScasumBatched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasumBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScasumBatched_full_rank = hipblasScasumBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasScasumBatched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasumBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScasumBatched_rank_0 = hipblasScasumBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasScasumBatched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasumBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScasumBatched_rank_1 = hipblasScasumBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDzasumBatched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasumBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDzasumBatched_full_rank = hipblasDzasumBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDzasumBatched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasumBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDzasumBatched_rank_0 = hipblasDzasumBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDzasumBatched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasumBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDzasumBatched_rank_1 = hipblasDzasumBatched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasScasumBatched_v2_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasumBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScasumBatched_v2_full_rank = hipblasScasumBatched_v2_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasScasumBatched_v2_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasumBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScasumBatched_v2_rank_0 = hipblasScasumBatched_v2_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasScasumBatched_v2_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasumBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScasumBatched_v2_rank_1 = hipblasScasumBatched_v2_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDzasumBatched_v2_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasumBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDzasumBatched_v2_full_rank = hipblasDzasumBatched_v2_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDzasumBatched_v2_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasumBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDzasumBatched_v2_rank_0 = hipblasDzasumBatched_v2_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDzasumBatched_v2_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasumBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDzasumBatched_v2_rank_1 = hipblasDzasumBatched_v2_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasSasumStridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSasumStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSasumStridedBatched_rank_0 = hipblasSasumStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasSasumStridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSasumStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSasumStridedBatched_rank_1 = hipblasSasumStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasDasumStridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDasumStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDasumStridedBatched_rank_0 = hipblasDasumStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasDasumStridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDasumStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDasumStridedBatched_rank_1 = hipblasDasumStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasScasumStridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasumStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScasumStridedBatched_rank_0 = hipblasScasumStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasScasumStridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasumStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScasumStridedBatched_rank_1 = hipblasScasumStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasDzasumStridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasumStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDzasumStridedBatched_rank_0 = hipblasDzasumStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasDzasumStridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasumStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDzasumStridedBatched_rank_1 = hipblasDzasumStridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasScasumStridedBatched_v2_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasumStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScasumStridedBatched_v2_rank_0 = hipblasScasumStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasScasumStridedBatched_v2_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScasumStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScasumStridedBatched_v2_rank_1 = hipblasScasumStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasDzasumStridedBatched_v2_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasumStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDzasumStridedBatched_v2_rank_0 = hipblasDzasumStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasDzasumStridedBatched_v2_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDzasumStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDzasumStridedBatched_v2_rank_1 = hipblasDzasumStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasSaxpy_rank_0(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSaxpy_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      !
      hipblasSaxpy_rank_0 = hipblasSaxpy_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasSaxpy_rank_1(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSaxpy_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasSaxpy_rank_1 = hipblasSaxpy_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasDaxpy_rank_0(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDaxpy_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      !
      hipblasDaxpy_rank_0 = hipblasDaxpy_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasDaxpy_rank_1(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDaxpy_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasDaxpy_rank_1 = hipblasDaxpy_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasCaxpy_rank_0(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpy_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasCaxpy_rank_0 = hipblasCaxpy_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasCaxpy_rank_1(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpy_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasCaxpy_rank_1 = hipblasCaxpy_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasZaxpy_rank_0(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpy_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasZaxpy_rank_0 = hipblasZaxpy_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasZaxpy_rank_1(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpy_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZaxpy_rank_1 = hipblasZaxpy_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasCaxpy_v2_rank_0(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpy_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasCaxpy_v2_rank_0 = hipblasCaxpy_v2_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasCaxpy_v2_rank_1(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpy_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasCaxpy_v2_rank_1 = hipblasCaxpy_v2_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasZaxpy_v2_rank_0(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpy_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasZaxpy_v2_rank_0 = hipblasZaxpy_v2_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasZaxpy_v2_rank_1(handle,n,alpha,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpy_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZaxpy_v2_rank_1 = hipblasZaxpy_v2_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasSaxpyBatched_full_rank(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSaxpyBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSaxpyBatched_full_rank = hipblasSaxpyBatched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasSaxpyBatched_rank_0(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSaxpyBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSaxpyBatched_rank_0 = hipblasSaxpyBatched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasSaxpyBatched_rank_1(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSaxpyBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSaxpyBatched_rank_1 = hipblasSaxpyBatched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasDaxpyBatched_full_rank(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDaxpyBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDaxpyBatched_full_rank = hipblasDaxpyBatched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasDaxpyBatched_rank_0(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDaxpyBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDaxpyBatched_rank_0 = hipblasDaxpyBatched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasDaxpyBatched_rank_1(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDaxpyBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDaxpyBatched_rank_1 = hipblasDaxpyBatched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasCaxpyBatched_full_rank(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpyBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCaxpyBatched_full_rank = hipblasCaxpyBatched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasCaxpyBatched_rank_0(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpyBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCaxpyBatched_rank_0 = hipblasCaxpyBatched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasCaxpyBatched_rank_1(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpyBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCaxpyBatched_rank_1 = hipblasCaxpyBatched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasZaxpyBatched_full_rank(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpyBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZaxpyBatched_full_rank = hipblasZaxpyBatched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasZaxpyBatched_rank_0(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpyBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZaxpyBatched_rank_0 = hipblasZaxpyBatched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasZaxpyBatched_rank_1(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpyBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZaxpyBatched_rank_1 = hipblasZaxpyBatched_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasCaxpyBatched_v2_full_rank(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpyBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCaxpyBatched_v2_full_rank = hipblasCaxpyBatched_v2_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasCaxpyBatched_v2_rank_0(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpyBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCaxpyBatched_v2_rank_0 = hipblasCaxpyBatched_v2_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasCaxpyBatched_v2_rank_1(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpyBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCaxpyBatched_v2_rank_1 = hipblasCaxpyBatched_v2_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasZaxpyBatched_v2_full_rank(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpyBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZaxpyBatched_v2_full_rank = hipblasZaxpyBatched_v2_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasZaxpyBatched_v2_rank_0(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpyBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZaxpyBatched_v2_rank_0 = hipblasZaxpyBatched_v2_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasZaxpyBatched_v2_rank_1(handle,n,alpha,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpyBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZaxpyBatched_v2_rank_1 = hipblasZaxpyBatched_v2_(handle,n,alpha,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasSaxpyStridedBatched_rank_0(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSaxpyStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSaxpyStridedBatched_rank_0 = hipblasSaxpyStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSaxpyStridedBatched_rank_1(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSaxpyStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSaxpyStridedBatched_rank_1 = hipblasSaxpyStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDaxpyStridedBatched_rank_0(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDaxpyStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDaxpyStridedBatched_rank_0 = hipblasDaxpyStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDaxpyStridedBatched_rank_1(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDaxpyStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDaxpyStridedBatched_rank_1 = hipblasDaxpyStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCaxpyStridedBatched_rank_0(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpyStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCaxpyStridedBatched_rank_0 = hipblasCaxpyStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCaxpyStridedBatched_rank_1(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpyStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCaxpyStridedBatched_rank_1 = hipblasCaxpyStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZaxpyStridedBatched_rank_0(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpyStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZaxpyStridedBatched_rank_0 = hipblasZaxpyStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZaxpyStridedBatched_rank_1(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpyStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZaxpyStridedBatched_rank_1 = hipblasZaxpyStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCaxpyStridedBatched_v2_rank_0(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpyStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCaxpyStridedBatched_v2_rank_0 = hipblasCaxpyStridedBatched_v2_(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCaxpyStridedBatched_v2_rank_1(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCaxpyStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCaxpyStridedBatched_v2_rank_1 = hipblasCaxpyStridedBatched_v2_(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZaxpyStridedBatched_v2_rank_0(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpyStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZaxpyStridedBatched_v2_rank_0 = hipblasZaxpyStridedBatched_v2_(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZaxpyStridedBatched_v2_rank_1(handle,n,alpha,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZaxpyStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZaxpyStridedBatched_v2_rank_1 = hipblasZaxpyStridedBatched_v2_(handle,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasScopy_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScopy_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      !
      hipblasScopy_rank_0 = hipblasScopy_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasScopy_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScopy_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasScopy_rank_1 = hipblasScopy_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasDcopy_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDcopy_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      !
      hipblasDcopy_rank_0 = hipblasDcopy_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasDcopy_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDcopy_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasDcopy_rank_1 = hipblasDcopy_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasCcopy_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopy_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasCcopy_rank_0 = hipblasCcopy_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasCcopy_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopy_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasCcopy_rank_1 = hipblasCcopy_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasZcopy_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopy_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasZcopy_rank_0 = hipblasZcopy_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasZcopy_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopy_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZcopy_rank_1 = hipblasZcopy_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasCcopy_v2_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopy_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasCcopy_v2_rank_0 = hipblasCcopy_v2_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasCcopy_v2_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopy_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasCcopy_v2_rank_1 = hipblasCcopy_v2_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasZcopy_v2_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopy_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasZcopy_v2_rank_0 = hipblasZcopy_v2_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasZcopy_v2_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopy_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZcopy_v2_rank_1 = hipblasZcopy_v2_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasScopyBatched_full_rank(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScopyBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasScopyBatched_full_rank = hipblasScopyBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasScopyBatched_rank_0(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScopyBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasScopyBatched_rank_0 = hipblasScopyBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasScopyBatched_rank_1(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScopyBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasScopyBatched_rank_1 = hipblasScopyBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasDcopyBatched_full_rank(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDcopyBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDcopyBatched_full_rank = hipblasDcopyBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasDcopyBatched_rank_0(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDcopyBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDcopyBatched_rank_0 = hipblasDcopyBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasDcopyBatched_rank_1(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDcopyBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDcopyBatched_rank_1 = hipblasDcopyBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasCcopyBatched_full_rank(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopyBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCcopyBatched_full_rank = hipblasCcopyBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasCcopyBatched_rank_0(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopyBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCcopyBatched_rank_0 = hipblasCcopyBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasCcopyBatched_rank_1(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopyBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCcopyBatched_rank_1 = hipblasCcopyBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasZcopyBatched_full_rank(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopyBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZcopyBatched_full_rank = hipblasZcopyBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasZcopyBatched_rank_0(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopyBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZcopyBatched_rank_0 = hipblasZcopyBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasZcopyBatched_rank_1(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopyBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZcopyBatched_rank_1 = hipblasZcopyBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasCcopyBatched_v2_full_rank(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopyBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCcopyBatched_v2_full_rank = hipblasCcopyBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasCcopyBatched_v2_rank_0(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopyBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCcopyBatched_v2_rank_0 = hipblasCcopyBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasCcopyBatched_v2_rank_1(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopyBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCcopyBatched_v2_rank_1 = hipblasCcopyBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasZcopyBatched_v2_full_rank(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopyBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZcopyBatched_v2_full_rank = hipblasZcopyBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasZcopyBatched_v2_rank_0(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopyBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZcopyBatched_v2_rank_0 = hipblasZcopyBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasZcopyBatched_v2_rank_1(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopyBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZcopyBatched_v2_rank_1 = hipblasZcopyBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasScopyStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScopyStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasScopyStridedBatched_rank_0 = hipblasScopyStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasScopyStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScopyStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasScopyStridedBatched_rank_1 = hipblasScopyStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDcopyStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDcopyStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDcopyStridedBatched_rank_0 = hipblasDcopyStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDcopyStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDcopyStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDcopyStridedBatched_rank_1 = hipblasDcopyStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCcopyStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopyStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCcopyStridedBatched_rank_0 = hipblasCcopyStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCcopyStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopyStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCcopyStridedBatched_rank_1 = hipblasCcopyStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZcopyStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopyStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZcopyStridedBatched_rank_0 = hipblasZcopyStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZcopyStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopyStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZcopyStridedBatched_rank_1 = hipblasZcopyStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCcopyStridedBatched_v2_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopyStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCcopyStridedBatched_v2_rank_0 = hipblasCcopyStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCcopyStridedBatched_v2_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCcopyStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCcopyStridedBatched_v2_rank_1 = hipblasCcopyStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZcopyStridedBatched_v2_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopyStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZcopyStridedBatched_v2_rank_0 = hipblasZcopyStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZcopyStridedBatched_v2_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZcopyStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZcopyStridedBatched_v2_rank_1 = hipblasZcopyStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSdot_rank_0(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdot_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasSdot_rank_0 = hipblasSdot_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasSdot_rank_1(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdot_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasSdot_rank_1 = hipblasSdot_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasDdot_rank_0(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdot_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasDdot_rank_0 = hipblasDdot_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasDdot_rank_1(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdot_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasDdot_rank_1 = hipblasDdot_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasCdotc_rank_0(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotc_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasCdotc_rank_0 = hipblasCdotc_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasCdotc_rank_1(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotc_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasCdotc_rank_1 = hipblasCdotc_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasCdotu_rank_0(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotu_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasCdotu_rank_0 = hipblasCdotu_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasCdotu_rank_1(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotu_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasCdotu_rank_1 = hipblasCdotu_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasZdotc_rank_0(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotc_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasZdotc_rank_0 = hipblasZdotc_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasZdotc_rank_1(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotc_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasZdotc_rank_1 = hipblasZdotc_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasZdotu_rank_0(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotu_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasZdotu_rank_0 = hipblasZdotu_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasZdotu_rank_1(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotu_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasZdotu_rank_1 = hipblasZdotu_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasCdotc_v2_rank_0(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotc_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasCdotc_v2_rank_0 = hipblasCdotc_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasCdotc_v2_rank_1(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotc_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasCdotc_v2_rank_1 = hipblasCdotc_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasCdotu_v2_rank_0(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotu_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasCdotu_v2_rank_0 = hipblasCdotu_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasCdotu_v2_rank_1(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotu_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasCdotu_v2_rank_1 = hipblasCdotu_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasZdotc_v2_rank_0(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotc_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasZdotc_v2_rank_0 = hipblasZdotc_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasZdotc_v2_rank_1(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotc_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasZdotc_v2_rank_1 = hipblasZdotc_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasZdotu_v2_rank_0(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotu_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasZdotu_v2_rank_0 = hipblasZdotu_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasZdotu_v2_rank_1(handle,n,x,incx,y,incy,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotu_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: myResult
      !
      hipblasZdotu_v2_rank_1 = hipblasZdotu_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,myResult)
    end function

    function hipblasSdotBatched_full_rank(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdotBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSdotBatched_full_rank = hipblasSdotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasSdotBatched_rank_0(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdotBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSdotBatched_rank_0 = hipblasSdotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasSdotBatched_rank_1(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdotBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSdotBatched_rank_1 = hipblasSdotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasDdotBatched_full_rank(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdotBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDdotBatched_full_rank = hipblasDdotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasDdotBatched_rank_0(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdotBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDdotBatched_rank_0 = hipblasDdotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasDdotBatched_rank_1(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdotBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDdotBatched_rank_1 = hipblasDdotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasCdotcBatched_full_rank(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotcBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotcBatched_full_rank = hipblasCdotcBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasCdotcBatched_rank_0(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotcBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotcBatched_rank_0 = hipblasCdotcBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasCdotcBatched_rank_1(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotcBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotcBatched_rank_1 = hipblasCdotcBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasCdotuBatched_full_rank(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotuBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotuBatched_full_rank = hipblasCdotuBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasCdotuBatched_rank_0(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotuBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotuBatched_rank_0 = hipblasCdotuBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasCdotuBatched_rank_1(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotuBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotuBatched_rank_1 = hipblasCdotuBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasZdotcBatched_full_rank(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotcBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotcBatched_full_rank = hipblasZdotcBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasZdotcBatched_rank_0(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotcBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotcBatched_rank_0 = hipblasZdotcBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasZdotcBatched_rank_1(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotcBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotcBatched_rank_1 = hipblasZdotcBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasZdotuBatched_full_rank(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotuBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotuBatched_full_rank = hipblasZdotuBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasZdotuBatched_rank_0(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotuBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotuBatched_rank_0 = hipblasZdotuBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasZdotuBatched_rank_1(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotuBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotuBatched_rank_1 = hipblasZdotuBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasCdotcBatched_v2_full_rank(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotcBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotcBatched_v2_full_rank = hipblasCdotcBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasCdotcBatched_v2_rank_0(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotcBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotcBatched_v2_rank_0 = hipblasCdotcBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasCdotcBatched_v2_rank_1(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotcBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotcBatched_v2_rank_1 = hipblasCdotcBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasCdotuBatched_v2_full_rank(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotuBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotuBatched_v2_full_rank = hipblasCdotuBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasCdotuBatched_v2_rank_0(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotuBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotuBatched_v2_rank_0 = hipblasCdotuBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasCdotuBatched_v2_rank_1(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotuBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotuBatched_v2_rank_1 = hipblasCdotuBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasZdotcBatched_v2_full_rank(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotcBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotcBatched_v2_full_rank = hipblasZdotcBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasZdotcBatched_v2_rank_0(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotcBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotcBatched_v2_rank_0 = hipblasZdotcBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasZdotcBatched_v2_rank_1(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotcBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotcBatched_v2_rank_1 = hipblasZdotcBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasZdotuBatched_v2_full_rank(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotuBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotuBatched_v2_full_rank = hipblasZdotuBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasZdotuBatched_v2_rank_0(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotuBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotuBatched_v2_rank_0 = hipblasZdotuBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasZdotuBatched_v2_rank_1(handle,n,x,incx,y,incy,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotuBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotuBatched_v2_rank_1 = hipblasZdotuBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount,myResult)
    end function

    function hipblasSdotStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdotStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSdotStridedBatched_rank_0 = hipblasSdotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasSdotStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdotStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSdotStridedBatched_rank_1 = hipblasSdotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasDdotStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdotStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDdotStridedBatched_rank_0 = hipblasDdotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasDdotStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdotStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDdotStridedBatched_rank_1 = hipblasDdotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasCdotcStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotcStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotcStridedBatched_rank_0 = hipblasCdotcStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasCdotcStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotcStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotcStridedBatched_rank_1 = hipblasCdotcStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasCdotuStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotuStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotuStridedBatched_rank_0 = hipblasCdotuStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasCdotuStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotuStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotuStridedBatched_rank_1 = hipblasCdotuStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasZdotcStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotcStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotcStridedBatched_rank_0 = hipblasZdotcStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasZdotcStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotcStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotcStridedBatched_rank_1 = hipblasZdotcStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasZdotuStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotuStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotuStridedBatched_rank_0 = hipblasZdotuStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasZdotuStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotuStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotuStridedBatched_rank_1 = hipblasZdotuStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasCdotcStridedBatched_v2_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotcStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotcStridedBatched_v2_rank_0 = hipblasCdotcStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasCdotcStridedBatched_v2_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotcStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotcStridedBatched_v2_rank_1 = hipblasCdotcStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasCdotuStridedBatched_v2_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotuStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotuStridedBatched_v2_rank_0 = hipblasCdotuStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasCdotuStridedBatched_v2_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdotuStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasCdotuStridedBatched_v2_rank_1 = hipblasCdotuStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasZdotcStridedBatched_v2_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotcStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotcStridedBatched_v2_rank_0 = hipblasZdotcStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasZdotcStridedBatched_v2_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotcStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotcStridedBatched_v2_rank_1 = hipblasZdotcStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasZdotuStridedBatched_v2_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotuStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotuStridedBatched_v2_rank_0 = hipblasZdotuStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasZdotuStridedBatched_v2_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdotuStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasZdotuStridedBatched_v2_rank_1 = hipblasZdotuStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount,myResult)
    end function

    function hipblasSnrm2_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSnrm2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasSnrm2_rank_0 = hipblasSnrm2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasSnrm2_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSnrm2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasSnrm2_rank_1 = hipblasSnrm2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasDnrm2_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDnrm2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasDnrm2_rank_0 = hipblasDnrm2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasDnrm2_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDnrm2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasDnrm2_rank_1 = hipblasDnrm2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasScnrm2_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasScnrm2_rank_0 = hipblasScnrm2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasScnrm2_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasScnrm2_rank_1 = hipblasScnrm2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasDznrm2_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasDznrm2_rank_0 = hipblasDznrm2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasDznrm2_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasDznrm2_rank_1 = hipblasDznrm2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasScnrm2_v2_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasScnrm2_v2_rank_0 = hipblasScnrm2_v2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasScnrm2_v2_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasScnrm2_v2_rank_1 = hipblasScnrm2_v2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasDznrm2_v2_rank_0(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasDznrm2_v2_rank_0 = hipblasDznrm2_v2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasDznrm2_v2_rank_1(handle,n,x,incx,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: myResult
      !
      hipblasDznrm2_v2_rank_1 = hipblasDznrm2_v2_(handle,n,c_loc(x),incx,myResult)
    end function

    function hipblasSnrm2Batched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSnrm2Batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSnrm2Batched_full_rank = hipblasSnrm2Batched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasSnrm2Batched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSnrm2Batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSnrm2Batched_rank_0 = hipblasSnrm2Batched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasSnrm2Batched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSnrm2Batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSnrm2Batched_rank_1 = hipblasSnrm2Batched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDnrm2Batched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDnrm2Batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDnrm2Batched_full_rank = hipblasDnrm2Batched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDnrm2Batched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDnrm2Batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDnrm2Batched_rank_0 = hipblasDnrm2Batched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDnrm2Batched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDnrm2Batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDnrm2Batched_rank_1 = hipblasDnrm2Batched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasScnrm2Batched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2Batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScnrm2Batched_full_rank = hipblasScnrm2Batched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasScnrm2Batched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2Batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScnrm2Batched_rank_0 = hipblasScnrm2Batched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasScnrm2Batched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2Batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScnrm2Batched_rank_1 = hipblasScnrm2Batched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDznrm2Batched_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2Batched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDznrm2Batched_full_rank = hipblasDznrm2Batched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDznrm2Batched_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2Batched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDznrm2Batched_rank_0 = hipblasDznrm2Batched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDznrm2Batched_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2Batched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDznrm2Batched_rank_1 = hipblasDznrm2Batched_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasScnrm2Batched_v2_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2Batched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScnrm2Batched_v2_full_rank = hipblasScnrm2Batched_v2_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasScnrm2Batched_v2_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2Batched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScnrm2Batched_v2_rank_0 = hipblasScnrm2Batched_v2_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasScnrm2Batched_v2_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2Batched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScnrm2Batched_v2_rank_1 = hipblasScnrm2Batched_v2_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDznrm2Batched_v2_full_rank(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2Batched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDznrm2Batched_v2_full_rank = hipblasDznrm2Batched_v2_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDznrm2Batched_v2_rank_0(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2Batched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDznrm2Batched_v2_rank_0 = hipblasDznrm2Batched_v2_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasDznrm2Batched_v2_rank_1(handle,n,x,incx,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2Batched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDznrm2Batched_v2_rank_1 = hipblasDznrm2Batched_v2_(handle,n,c_loc(x),incx,batchCount,myResult)
    end function

    function hipblasSnrm2StridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSnrm2StridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSnrm2StridedBatched_rank_0 = hipblasSnrm2StridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasSnrm2StridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSnrm2StridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasSnrm2StridedBatched_rank_1 = hipblasSnrm2StridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasDnrm2StridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDnrm2StridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDnrm2StridedBatched_rank_0 = hipblasDnrm2StridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasDnrm2StridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDnrm2StridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDnrm2StridedBatched_rank_1 = hipblasDnrm2StridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasScnrm2StridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2StridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScnrm2StridedBatched_rank_0 = hipblasScnrm2StridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasScnrm2StridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2StridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScnrm2StridedBatched_rank_1 = hipblasScnrm2StridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasDznrm2StridedBatched_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2StridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDznrm2StridedBatched_rank_0 = hipblasDznrm2StridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasDznrm2StridedBatched_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2StridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDznrm2StridedBatched_rank_1 = hipblasDznrm2StridedBatched_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasScnrm2StridedBatched_v2_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2StridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScnrm2StridedBatched_v2_rank_0 = hipblasScnrm2StridedBatched_v2_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasScnrm2StridedBatched_v2_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasScnrm2StridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasScnrm2StridedBatched_v2_rank_1 = hipblasScnrm2StridedBatched_v2_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasDznrm2StridedBatched_v2_rank_0(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2StridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDznrm2StridedBatched_v2_rank_0 = hipblasDznrm2StridedBatched_v2_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasDznrm2StridedBatched_v2_rank_1(handle,n,x,incx,stridex,batchCount,myResult)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDznrm2StridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      type(c_ptr) :: myResult
      !
      hipblasDznrm2StridedBatched_v2_rank_1 = hipblasDznrm2StridedBatched_v2_(handle,n,c_loc(x),incx,stridex,batchCount,myResult)
    end function

    function hipblasSrot_rank_0(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrot_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasSrot_rank_0 = hipblasSrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasSrot_rank_1(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrot_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasSrot_rank_1 = hipblasSrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasDrot_rank_0(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrot_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasDrot_rank_0 = hipblasDrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasDrot_rank_1(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrot_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasDrot_rank_1 = hipblasDrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasCrot_rank_0(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrot_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasCrot_rank_0 = hipblasCrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasCrot_rank_1(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrot_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasCrot_rank_1 = hipblasCrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasCsrot_rank_0(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrot_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasCsrot_rank_0 = hipblasCsrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasCsrot_rank_1(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrot_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasCsrot_rank_1 = hipblasCsrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasZrot_rank_0(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrot_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasZrot_rank_0 = hipblasZrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasZrot_rank_1(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrot_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasZrot_rank_1 = hipblasZrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasZdrot_rank_0(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrot_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasZdrot_rank_0 = hipblasZdrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasZdrot_rank_1(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrot_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasZdrot_rank_1 = hipblasZdrot_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasCrot_v2_rank_0(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrot_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasCrot_v2_rank_0 = hipblasCrot_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasCrot_v2_rank_1(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrot_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasCrot_v2_rank_1 = hipblasCrot_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasCsrot_v2_rank_0(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrot_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasCsrot_v2_rank_0 = hipblasCsrot_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasCsrot_v2_rank_1(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrot_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasCsrot_v2_rank_1 = hipblasCsrot_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasZrot_v2_rank_0(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrot_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasZrot_v2_rank_0 = hipblasZrot_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasZrot_v2_rank_1(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrot_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasZrot_v2_rank_1 = hipblasZrot_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasZdrot_v2_rank_0(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrot_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasZdrot_v2_rank_0 = hipblasZdrot_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasZdrot_v2_rank_1(handle,n,x,incx,y,incy,c,s)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrot_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      !
      hipblasZdrot_v2_rank_1 = hipblasZdrot_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s)
    end function

    function hipblasSrotBatched_full_rank(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasSrotBatched_full_rank = hipblasSrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasSrotBatched_rank_0(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasSrotBatched_rank_0 = hipblasSrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasSrotBatched_rank_1(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasSrotBatched_rank_1 = hipblasSrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasDrotBatched_full_rank(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasDrotBatched_full_rank = hipblasDrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasDrotBatched_rank_0(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasDrotBatched_rank_0 = hipblasDrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasDrotBatched_rank_1(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasDrotBatched_rank_1 = hipblasDrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasCrotBatched_full_rank(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCrotBatched_full_rank = hipblasCrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasCrotBatched_rank_0(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCrotBatched_rank_0 = hipblasCrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasCrotBatched_rank_1(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCrotBatched_rank_1 = hipblasCrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasCsrotBatched_full_rank(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrotBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCsrotBatched_full_rank = hipblasCsrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasCsrotBatched_rank_0(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrotBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCsrotBatched_rank_0 = hipblasCsrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasCsrotBatched_rank_1(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrotBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCsrotBatched_rank_1 = hipblasCsrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasZrotBatched_full_rank(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZrotBatched_full_rank = hipblasZrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasZrotBatched_rank_0(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZrotBatched_rank_0 = hipblasZrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasZrotBatched_rank_1(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZrotBatched_rank_1 = hipblasZrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasZdrotBatched_full_rank(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrotBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZdrotBatched_full_rank = hipblasZdrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasZdrotBatched_rank_0(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrotBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZdrotBatched_rank_0 = hipblasZdrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasZdrotBatched_rank_1(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrotBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZdrotBatched_rank_1 = hipblasZdrotBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasCrotBatched_v2_full_rank(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCrotBatched_v2_full_rank = hipblasCrotBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasCrotBatched_v2_rank_0(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCrotBatched_v2_rank_0 = hipblasCrotBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasCrotBatched_v2_rank_1(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCrotBatched_v2_rank_1 = hipblasCrotBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasCsrotBatched_v2_full_rank(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrotBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCsrotBatched_v2_full_rank = hipblasCsrotBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasCsrotBatched_v2_rank_0(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrotBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCsrotBatched_v2_rank_0 = hipblasCsrotBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasCsrotBatched_v2_rank_1(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrotBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCsrotBatched_v2_rank_1 = hipblasCsrotBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasZrotBatched_v2_full_rank(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZrotBatched_v2_full_rank = hipblasZrotBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasZrotBatched_v2_rank_0(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZrotBatched_v2_rank_0 = hipblasZrotBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasZrotBatched_v2_rank_1(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZrotBatched_v2_rank_1 = hipblasZrotBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasZdrotBatched_v2_full_rank(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrotBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZdrotBatched_v2_full_rank = hipblasZdrotBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasZdrotBatched_v2_rank_0(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrotBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZdrotBatched_v2_rank_0 = hipblasZdrotBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasZdrotBatched_v2_rank_1(handle,n,x,incx,y,incy,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrotBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZdrotBatched_v2_rank_1 = hipblasZdrotBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,c,s,batchCount)
    end function

    function hipblasSrotStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasSrotStridedBatched_rank_0 = hipblasSrotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasSrotStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasSrotStridedBatched_rank_1 = hipblasSrotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasDrotStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasDrotStridedBatched_rank_0 = hipblasDrotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasDrotStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasDrotStridedBatched_rank_1 = hipblasDrotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasCrotStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCrotStridedBatched_rank_0 = hipblasCrotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasCrotStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCrotStridedBatched_rank_1 = hipblasCrotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasCsrotStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrotStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCsrotStridedBatched_rank_0 = hipblasCsrotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasCsrotStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrotStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCsrotStridedBatched_rank_1 = hipblasCsrotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasZrotStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZrotStridedBatched_rank_0 = hipblasZrotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasZrotStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZrotStridedBatched_rank_1 = hipblasZrotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasZdrotStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrotStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZdrotStridedBatched_rank_0 = hipblasZdrotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasZdrotStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrotStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZdrotStridedBatched_rank_1 = hipblasZdrotStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasCrotStridedBatched_v2_rank_0(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCrotStridedBatched_v2_rank_0 = hipblasCrotStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasCrotStridedBatched_v2_rank_1(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCrotStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCrotStridedBatched_v2_rank_1 = hipblasCrotStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasCsrotStridedBatched_v2_rank_0(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrotStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCsrotStridedBatched_v2_rank_0 = hipblasCsrotStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasCsrotStridedBatched_v2_rank_1(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsrotStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasCsrotStridedBatched_v2_rank_1 = hipblasCsrotStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasZrotStridedBatched_v2_rank_0(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZrotStridedBatched_v2_rank_0 = hipblasZrotStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasZrotStridedBatched_v2_rank_1(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZrotStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZrotStridedBatched_v2_rank_1 = hipblasZrotStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasZdrotStridedBatched_v2_rank_0(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrotStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZdrotStridedBatched_v2_rank_0 = hipblasZdrotStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasZdrotStridedBatched_v2_rank_1(handle,n,x,incx,stridex,y,incy,stridey,c,s,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdrotStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: c
      type(c_ptr) :: s
      integer(c_int) :: batchCount
      !
      hipblasZdrotStridedBatched_v2_rank_1 = hipblasZdrotStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,c,s,batchCount)
    end function

    function hipblasSrotm_rank_0(handle,n,x,incx,y,incy,param)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotm_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      !
      hipblasSrotm_rank_0 = hipblasSrotm_(handle,n,c_loc(x),incx,c_loc(y),incy,param)
    end function

    function hipblasSrotm_rank_1(handle,n,x,incx,y,incy,param)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotm_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      !
      hipblasSrotm_rank_1 = hipblasSrotm_(handle,n,c_loc(x),incx,c_loc(y),incy,param)
    end function

    function hipblasDrotm_rank_0(handle,n,x,incx,y,incy,param)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotm_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      !
      hipblasDrotm_rank_0 = hipblasDrotm_(handle,n,c_loc(x),incx,c_loc(y),incy,param)
    end function

    function hipblasDrotm_rank_1(handle,n,x,incx,y,incy,param)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotm_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      !
      hipblasDrotm_rank_1 = hipblasDrotm_(handle,n,c_loc(x),incx,c_loc(y),incy,param)
    end function

    function hipblasSrotmBatched_full_rank(handle,n,x,incx,y,incy,param,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotmBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      integer(c_int) :: batchCount
      !
      hipblasSrotmBatched_full_rank = hipblasSrotmBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,param,batchCount)
    end function

    function hipblasSrotmBatched_rank_0(handle,n,x,incx,y,incy,param,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotmBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      integer(c_int) :: batchCount
      !
      hipblasSrotmBatched_rank_0 = hipblasSrotmBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,param,batchCount)
    end function

    function hipblasSrotmBatched_rank_1(handle,n,x,incx,y,incy,param,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotmBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      integer(c_int) :: batchCount
      !
      hipblasSrotmBatched_rank_1 = hipblasSrotmBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,param,batchCount)
    end function

    function hipblasDrotmBatched_full_rank(handle,n,x,incx,y,incy,param,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotmBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      integer(c_int) :: batchCount
      !
      hipblasDrotmBatched_full_rank = hipblasDrotmBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,param,batchCount)
    end function

    function hipblasDrotmBatched_rank_0(handle,n,x,incx,y,incy,param,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotmBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      integer(c_int) :: batchCount
      !
      hipblasDrotmBatched_rank_0 = hipblasDrotmBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,param,batchCount)
    end function

    function hipblasDrotmBatched_rank_1(handle,n,x,incx,y,incy,param,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotmBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: param
      integer(c_int) :: batchCount
      !
      hipblasDrotmBatched_rank_1 = hipblasDrotmBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,param,batchCount)
    end function

    function hipblasSrotmStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,param,strideParam,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: param
      integer(c_int64_t) :: strideParam
      integer(c_int) :: batchCount
      !
      hipblasSrotmStridedBatched_rank_0 = hipblasSrotmStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,param,strideParam,batchCount)
    end function

    function hipblasSrotmStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,param,strideParam,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSrotmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: param
      integer(c_int64_t) :: strideParam
      integer(c_int) :: batchCount
      !
      hipblasSrotmStridedBatched_rank_1 = hipblasSrotmStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,param,strideParam,batchCount)
    end function

    function hipblasDrotmStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,param,strideParam,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: param
      integer(c_int64_t) :: strideParam
      integer(c_int) :: batchCount
      !
      hipblasDrotmStridedBatched_rank_0 = hipblasDrotmStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,param,strideParam,batchCount)
    end function

    function hipblasDrotmStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,param,strideParam,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDrotmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: param
      integer(c_int64_t) :: strideParam
      integer(c_int) :: batchCount
      !
      hipblasDrotmStridedBatched_rank_1 = hipblasDrotmStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,param,strideParam,batchCount)
    end function

    function hipblasSscal_rank_0(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSscal_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      !
      hipblasSscal_rank_0 = hipblasSscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasSscal_rank_1(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSscal_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasSscal_rank_1 = hipblasSscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasDscal_rank_0(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDscal_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      !
      hipblasDscal_rank_0 = hipblasDscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasDscal_rank_1(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDscal_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasDscal_rank_1 = hipblasDscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasCscal_rank_0(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscal_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasCscal_rank_0 = hipblasCscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasCscal_rank_1(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscal_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasCscal_rank_1 = hipblasCscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasCsscal_rank_0(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscal_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasCsscal_rank_0 = hipblasCsscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasCsscal_rank_1(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscal_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasCsscal_rank_1 = hipblasCsscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasZscal_rank_0(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscal_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasZscal_rank_0 = hipblasZscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasZscal_rank_1(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscal_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasZscal_rank_1 = hipblasZscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasZdscal_rank_0(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscal_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasZdscal_rank_0 = hipblasZdscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasZdscal_rank_1(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscal_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasZdscal_rank_1 = hipblasZdscal_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasCscal_v2_rank_0(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscal_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasCscal_v2_rank_0 = hipblasCscal_v2_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasCscal_v2_rank_1(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscal_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasCscal_v2_rank_1 = hipblasCscal_v2_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasCsscal_v2_rank_0(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscal_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasCsscal_v2_rank_0 = hipblasCsscal_v2_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasCsscal_v2_rank_1(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscal_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasCsscal_v2_rank_1 = hipblasCsscal_v2_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasZscal_v2_rank_0(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscal_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasZscal_v2_rank_0 = hipblasZscal_v2_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasZscal_v2_rank_1(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscal_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasZscal_v2_rank_1 = hipblasZscal_v2_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasZdscal_v2_rank_0(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscal_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasZdscal_v2_rank_0 = hipblasZdscal_v2_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasZdscal_v2_rank_1(handle,n,alpha,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscal_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasZdscal_v2_rank_1 = hipblasZdscal_v2_(handle,n,alpha,c_loc(x),incx)
    end function

    function hipblasSscalBatched_full_rank(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSscalBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasSscalBatched_full_rank = hipblasSscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasSscalBatched_rank_0(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSscalBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasSscalBatched_rank_0 = hipblasSscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasSscalBatched_rank_1(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSscalBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasSscalBatched_rank_1 = hipblasSscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasDscalBatched_full_rank(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDscalBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDscalBatched_full_rank = hipblasDscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasDscalBatched_rank_0(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDscalBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDscalBatched_rank_0 = hipblasDscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasDscalBatched_rank_1(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDscalBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDscalBatched_rank_1 = hipblasDscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasCscalBatched_full_rank(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscalBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCscalBatched_full_rank = hipblasCscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasCscalBatched_rank_0(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscalBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCscalBatched_rank_0 = hipblasCscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasCscalBatched_rank_1(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscalBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCscalBatched_rank_1 = hipblasCscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasZscalBatched_full_rank(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscalBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZscalBatched_full_rank = hipblasZscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasZscalBatched_rank_0(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscalBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZscalBatched_rank_0 = hipblasZscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasZscalBatched_rank_1(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscalBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZscalBatched_rank_1 = hipblasZscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasCsscalBatched_full_rank(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscalBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCsscalBatched_full_rank = hipblasCsscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasCsscalBatched_rank_0(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscalBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCsscalBatched_rank_0 = hipblasCsscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasCsscalBatched_rank_1(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscalBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCsscalBatched_rank_1 = hipblasCsscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasZdscalBatched_full_rank(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscalBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZdscalBatched_full_rank = hipblasZdscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasZdscalBatched_rank_0(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscalBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZdscalBatched_rank_0 = hipblasZdscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasZdscalBatched_rank_1(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscalBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZdscalBatched_rank_1 = hipblasZdscalBatched_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasCscalBatched_v2_full_rank(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscalBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCscalBatched_v2_full_rank = hipblasCscalBatched_v2_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasCscalBatched_v2_rank_0(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscalBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCscalBatched_v2_rank_0 = hipblasCscalBatched_v2_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasCscalBatched_v2_rank_1(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscalBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCscalBatched_v2_rank_1 = hipblasCscalBatched_v2_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasZscalBatched_v2_full_rank(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscalBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZscalBatched_v2_full_rank = hipblasZscalBatched_v2_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasZscalBatched_v2_rank_0(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscalBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZscalBatched_v2_rank_0 = hipblasZscalBatched_v2_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasZscalBatched_v2_rank_1(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscalBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZscalBatched_v2_rank_1 = hipblasZscalBatched_v2_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasCsscalBatched_v2_full_rank(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscalBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCsscalBatched_v2_full_rank = hipblasCsscalBatched_v2_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasCsscalBatched_v2_rank_0(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscalBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCsscalBatched_v2_rank_0 = hipblasCsscalBatched_v2_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasCsscalBatched_v2_rank_1(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscalBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCsscalBatched_v2_rank_1 = hipblasCsscalBatched_v2_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasZdscalBatched_v2_full_rank(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscalBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZdscalBatched_v2_full_rank = hipblasZdscalBatched_v2_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasZdscalBatched_v2_rank_0(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscalBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZdscalBatched_v2_rank_0 = hipblasZdscalBatched_v2_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasZdscalBatched_v2_rank_1(handle,n,alpha,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscalBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZdscalBatched_v2_rank_1 = hipblasZdscalBatched_v2_(handle,n,alpha,c_loc(x),incx,batchCount)
    end function

    function hipblasSscalStridedBatched_rank_0(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSscalStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasSscalStridedBatched_rank_0 = hipblasSscalStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasSscalStridedBatched_rank_1(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSscalStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasSscalStridedBatched_rank_1 = hipblasSscalStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDscalStridedBatched_rank_0(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDscalStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDscalStridedBatched_rank_0 = hipblasDscalStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDscalStridedBatched_rank_1(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDscalStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDscalStridedBatched_rank_1 = hipblasDscalStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCscalStridedBatched_rank_0(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscalStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCscalStridedBatched_rank_0 = hipblasCscalStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCscalStridedBatched_rank_1(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscalStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCscalStridedBatched_rank_1 = hipblasCscalStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZscalStridedBatched_rank_0(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscalStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZscalStridedBatched_rank_0 = hipblasZscalStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZscalStridedBatched_rank_1(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscalStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZscalStridedBatched_rank_1 = hipblasZscalStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCsscalStridedBatched_rank_0(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscalStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCsscalStridedBatched_rank_0 = hipblasCsscalStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCsscalStridedBatched_rank_1(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscalStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCsscalStridedBatched_rank_1 = hipblasCsscalStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZdscalStridedBatched_rank_0(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscalStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZdscalStridedBatched_rank_0 = hipblasZdscalStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZdscalStridedBatched_rank_1(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscalStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZdscalStridedBatched_rank_1 = hipblasZdscalStridedBatched_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCscalStridedBatched_v2_rank_0(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscalStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCscalStridedBatched_v2_rank_0 = hipblasCscalStridedBatched_v2_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCscalStridedBatched_v2_rank_1(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCscalStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCscalStridedBatched_v2_rank_1 = hipblasCscalStridedBatched_v2_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZscalStridedBatched_v2_rank_0(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscalStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZscalStridedBatched_v2_rank_0 = hipblasZscalStridedBatched_v2_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZscalStridedBatched_v2_rank_1(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZscalStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZscalStridedBatched_v2_rank_1 = hipblasZscalStridedBatched_v2_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCsscalStridedBatched_v2_rank_0(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscalStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCsscalStridedBatched_v2_rank_0 = hipblasCsscalStridedBatched_v2_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCsscalStridedBatched_v2_rank_1(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsscalStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCsscalStridedBatched_v2_rank_1 = hipblasCsscalStridedBatched_v2_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZdscalStridedBatched_v2_rank_0(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscalStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZdscalStridedBatched_v2_rank_0 = hipblasZdscalStridedBatched_v2_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZdscalStridedBatched_v2_rank_1(handle,n,alpha,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdscalStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZdscalStridedBatched_v2_rank_1 = hipblasZdscalStridedBatched_v2_(handle,n,alpha,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasSswap_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSswap_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      !
      hipblasSswap_rank_0 = hipblasSswap_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasSswap_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSswap_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasSswap_rank_1 = hipblasSswap_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasDswap_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDswap_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      !
      hipblasDswap_rank_0 = hipblasDswap_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasDswap_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDswap_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasDswap_rank_1 = hipblasDswap_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasCswap_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswap_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasCswap_rank_0 = hipblasCswap_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasCswap_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswap_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasCswap_rank_1 = hipblasCswap_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasZswap_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswap_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasZswap_rank_0 = hipblasZswap_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasZswap_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswap_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZswap_rank_1 = hipblasZswap_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasCswap_v2_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswap_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasCswap_v2_rank_0 = hipblasCswap_v2_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasCswap_v2_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswap_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasCswap_v2_rank_1 = hipblasCswap_v2_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasZswap_v2_rank_0(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswap_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasZswap_v2_rank_0 = hipblasZswap_v2_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasZswap_v2_rank_1(handle,n,x,incx,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswap_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZswap_v2_rank_1 = hipblasZswap_v2_(handle,n,c_loc(x),incx,c_loc(y),incy)
    end function

    function hipblasSswapBatched_full_rank(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSswapBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSswapBatched_full_rank = hipblasSswapBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasSswapBatched_rank_0(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSswapBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSswapBatched_rank_0 = hipblasSswapBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasSswapBatched_rank_1(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSswapBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSswapBatched_rank_1 = hipblasSswapBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasDswapBatched_full_rank(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDswapBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDswapBatched_full_rank = hipblasDswapBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasDswapBatched_rank_0(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDswapBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDswapBatched_rank_0 = hipblasDswapBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasDswapBatched_rank_1(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDswapBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDswapBatched_rank_1 = hipblasDswapBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasCswapBatched_full_rank(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswapBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCswapBatched_full_rank = hipblasCswapBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasCswapBatched_rank_0(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswapBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCswapBatched_rank_0 = hipblasCswapBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasCswapBatched_rank_1(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswapBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCswapBatched_rank_1 = hipblasCswapBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasZswapBatched_full_rank(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswapBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZswapBatched_full_rank = hipblasZswapBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasZswapBatched_rank_0(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswapBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZswapBatched_rank_0 = hipblasZswapBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasZswapBatched_rank_1(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswapBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZswapBatched_rank_1 = hipblasZswapBatched_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasCswapBatched_v2_full_rank(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswapBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCswapBatched_v2_full_rank = hipblasCswapBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasCswapBatched_v2_rank_0(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswapBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCswapBatched_v2_rank_0 = hipblasCswapBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasCswapBatched_v2_rank_1(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswapBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCswapBatched_v2_rank_1 = hipblasCswapBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasZswapBatched_v2_full_rank(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswapBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZswapBatched_v2_full_rank = hipblasZswapBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasZswapBatched_v2_rank_0(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswapBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZswapBatched_v2_rank_0 = hipblasZswapBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasZswapBatched_v2_rank_1(handle,n,x,incx,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswapBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZswapBatched_v2_rank_1 = hipblasZswapBatched_v2_(handle,n,c_loc(x),incx,c_loc(y),incy,batchCount)
    end function

    function hipblasSswapStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSswapStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSswapStridedBatched_rank_0 = hipblasSswapStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSswapStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSswapStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSswapStridedBatched_rank_1 = hipblasSswapStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDswapStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDswapStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDswapStridedBatched_rank_0 = hipblasDswapStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDswapStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDswapStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDswapStridedBatched_rank_1 = hipblasDswapStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCswapStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswapStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCswapStridedBatched_rank_0 = hipblasCswapStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCswapStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswapStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCswapStridedBatched_rank_1 = hipblasCswapStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZswapStridedBatched_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswapStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZswapStridedBatched_rank_0 = hipblasZswapStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZswapStridedBatched_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswapStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZswapStridedBatched_rank_1 = hipblasZswapStridedBatched_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCswapStridedBatched_v2_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswapStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCswapStridedBatched_v2_rank_0 = hipblasCswapStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCswapStridedBatched_v2_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCswapStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCswapStridedBatched_v2_rank_1 = hipblasCswapStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZswapStridedBatched_v2_rank_0(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswapStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZswapStridedBatched_v2_rank_0 = hipblasZswapStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZswapStridedBatched_v2_rank_1(handle,n,x,incx,stridex,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZswapStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZswapStridedBatched_v2_rank_1 = hipblasZswapStridedBatched_v2_(handle,n,c_loc(x),incx,stridex,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSgbmv_rank_0(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      !
      hipblasSgbmv_rank_0 = hipblasSgbmv_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasSgbmv_rank_1(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasSgbmv_rank_1 = hipblasSgbmv_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasDgbmv_rank_0(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      !
      hipblasDgbmv_rank_0 = hipblasDgbmv_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasDgbmv_rank_1(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasDgbmv_rank_1 = hipblasDgbmv_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasCgbmv_rank_0(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasCgbmv_rank_0 = hipblasCgbmv_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasCgbmv_rank_1(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasCgbmv_rank_1 = hipblasCgbmv_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZgbmv_rank_0(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasZgbmv_rank_0 = hipblasZgbmv_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZgbmv_rank_1(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZgbmv_rank_1 = hipblasZgbmv_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasCgbmv_v2_rank_0(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmv_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasCgbmv_v2_rank_0 = hipblasCgbmv_v2_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasCgbmv_v2_rank_1(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmv_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasCgbmv_v2_rank_1 = hipblasCgbmv_v2_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZgbmv_v2_rank_0(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmv_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasZgbmv_v2_rank_0 = hipblasZgbmv_v2_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZgbmv_v2_rank_1(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmv_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZgbmv_v2_rank_1 = hipblasZgbmv_v2_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasSgbmvBatched_full_rank(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgbmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSgbmvBatched_full_rank = hipblasSgbmvBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSgbmvBatched_rank_0(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgbmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSgbmvBatched_rank_0 = hipblasSgbmvBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSgbmvBatched_rank_1(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgbmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSgbmvBatched_rank_1 = hipblasSgbmvBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDgbmvBatched_full_rank(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgbmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDgbmvBatched_full_rank = hipblasDgbmvBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDgbmvBatched_rank_0(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgbmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDgbmvBatched_rank_0 = hipblasDgbmvBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDgbmvBatched_rank_1(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgbmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDgbmvBatched_rank_1 = hipblasDgbmvBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasCgbmvBatched_full_rank(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCgbmvBatched_full_rank = hipblasCgbmvBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasCgbmvBatched_rank_0(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCgbmvBatched_rank_0 = hipblasCgbmvBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasCgbmvBatched_rank_1(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCgbmvBatched_rank_1 = hipblasCgbmvBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZgbmvBatched_full_rank(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZgbmvBatched_full_rank = hipblasZgbmvBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZgbmvBatched_rank_0(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZgbmvBatched_rank_0 = hipblasZgbmvBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZgbmvBatched_rank_1(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZgbmvBatched_rank_1 = hipblasZgbmvBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasCgbmvBatched_v2_full_rank(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmvBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCgbmvBatched_v2_full_rank = hipblasCgbmvBatched_v2_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasCgbmvBatched_v2_rank_0(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmvBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCgbmvBatched_v2_rank_0 = hipblasCgbmvBatched_v2_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasCgbmvBatched_v2_rank_1(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmvBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCgbmvBatched_v2_rank_1 = hipblasCgbmvBatched_v2_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZgbmvBatched_v2_full_rank(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmvBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZgbmvBatched_v2_full_rank = hipblasZgbmvBatched_v2_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZgbmvBatched_v2_rank_0(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmvBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZgbmvBatched_v2_rank_0 = hipblasZgbmvBatched_v2_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZgbmvBatched_v2_rank_1(handle,trans,m,n,kl,ku,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmvBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZgbmvBatched_v2_rank_1 = hipblasZgbmvBatched_v2_(handle,trans,m,n,kl,ku,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSgbmvStridedBatched_rank_0(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgbmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSgbmvStridedBatched_rank_0 = hipblasSgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSgbmvStridedBatched_rank_1(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgbmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSgbmvStridedBatched_rank_1 = hipblasSgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDgbmvStridedBatched_rank_0(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgbmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDgbmvStridedBatched_rank_0 = hipblasDgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDgbmvStridedBatched_rank_1(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgbmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDgbmvStridedBatched_rank_1 = hipblasDgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCgbmvStridedBatched_rank_0(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCgbmvStridedBatched_rank_0 = hipblasCgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCgbmvStridedBatched_rank_1(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCgbmvStridedBatched_rank_1 = hipblasCgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZgbmvStridedBatched_rank_0(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZgbmvStridedBatched_rank_0 = hipblasZgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZgbmvStridedBatched_rank_1(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZgbmvStridedBatched_rank_1 = hipblasZgbmvStridedBatched_(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCgbmvStridedBatched_v2_rank_0(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmvStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCgbmvStridedBatched_v2_rank_0 = hipblasCgbmvStridedBatched_v2_(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCgbmvStridedBatched_v2_rank_1(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgbmvStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCgbmvStridedBatched_v2_rank_1 = hipblasCgbmvStridedBatched_v2_(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZgbmvStridedBatched_v2_rank_0(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmvStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZgbmvStridedBatched_v2_rank_0 = hipblasZgbmvStridedBatched_v2_(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZgbmvStridedBatched_v2_rank_1(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgbmvStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: kl
      integer(c_int) :: ku
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZgbmvStridedBatched_v2_rank_1 = hipblasZgbmvStridedBatched_v2_(handle,trans,m,n,kl,ku,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSgemv_rank_0(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      !
      hipblasSgemv_rank_0 = hipblasSgemv_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasSgemv_rank_1(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasSgemv_rank_1 = hipblasSgemv_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasDgemv_rank_0(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      !
      hipblasDgemv_rank_0 = hipblasDgemv_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasDgemv_rank_1(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasDgemv_rank_1 = hipblasDgemv_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasCgemv_rank_0(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasCgemv_rank_0 = hipblasCgemv_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasCgemv_rank_1(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasCgemv_rank_1 = hipblasCgemv_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZgemv_rank_0(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasZgemv_rank_0 = hipblasZgemv_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZgemv_rank_1(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZgemv_rank_1 = hipblasZgemv_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasCgemv_v2_rank_0(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemv_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasCgemv_v2_rank_0 = hipblasCgemv_v2_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasCgemv_v2_rank_1(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemv_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasCgemv_v2_rank_1 = hipblasCgemv_v2_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZgemv_v2_rank_0(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemv_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasZgemv_v2_rank_0 = hipblasZgemv_v2_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZgemv_v2_rank_1(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemv_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZgemv_v2_rank_1 = hipblasZgemv_v2_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasSgemvBatched_full_rank(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSgemvBatched_full_rank = hipblasSgemvBatched_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSgemvBatched_rank_0(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSgemvBatched_rank_0 = hipblasSgemvBatched_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSgemvBatched_rank_1(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSgemvBatched_rank_1 = hipblasSgemvBatched_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDgemvBatched_full_rank(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDgemvBatched_full_rank = hipblasDgemvBatched_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDgemvBatched_rank_0(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDgemvBatched_rank_0 = hipblasDgemvBatched_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDgemvBatched_rank_1(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDgemvBatched_rank_1 = hipblasDgemvBatched_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasCgemvBatched_full_rank(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCgemvBatched_full_rank = hipblasCgemvBatched_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasCgemvBatched_rank_0(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCgemvBatched_rank_0 = hipblasCgemvBatched_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasCgemvBatched_rank_1(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCgemvBatched_rank_1 = hipblasCgemvBatched_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZgemvBatched_full_rank(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZgemvBatched_full_rank = hipblasZgemvBatched_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZgemvBatched_rank_0(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZgemvBatched_rank_0 = hipblasZgemvBatched_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZgemvBatched_rank_1(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZgemvBatched_rank_1 = hipblasZgemvBatched_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasCgemvBatched_v2_full_rank(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemvBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCgemvBatched_v2_full_rank = hipblasCgemvBatched_v2_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasCgemvBatched_v2_rank_0(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemvBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCgemvBatched_v2_rank_0 = hipblasCgemvBatched_v2_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasCgemvBatched_v2_rank_1(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemvBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCgemvBatched_v2_rank_1 = hipblasCgemvBatched_v2_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZgemvBatched_v2_full_rank(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemvBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZgemvBatched_v2_full_rank = hipblasZgemvBatched_v2_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZgemvBatched_v2_rank_0(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemvBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZgemvBatched_v2_rank_0 = hipblasZgemvBatched_v2_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZgemvBatched_v2_rank_1(handle,trans,m,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemvBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZgemvBatched_v2_rank_1 = hipblasZgemvBatched_v2_(handle,trans,m,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSgemvStridedBatched_rank_0(handle,transA,m,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSgemvStridedBatched_rank_0 = hipblasSgemvStridedBatched_(handle,transA,m,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSgemvStridedBatched_rank_1(handle,transA,m,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgemvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSgemvStridedBatched_rank_1 = hipblasSgemvStridedBatched_(handle,transA,m,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDgemvStridedBatched_rank_0(handle,transA,m,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDgemvStridedBatched_rank_0 = hipblasDgemvStridedBatched_(handle,transA,m,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDgemvStridedBatched_rank_1(handle,transA,m,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgemvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDgemvStridedBatched_rank_1 = hipblasDgemvStridedBatched_(handle,transA,m,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCgemvStridedBatched_rank_0(handle,transA,m,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCgemvStridedBatched_rank_0 = hipblasCgemvStridedBatched_(handle,transA,m,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCgemvStridedBatched_rank_1(handle,transA,m,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCgemvStridedBatched_rank_1 = hipblasCgemvStridedBatched_(handle,transA,m,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZgemvStridedBatched_rank_0(handle,transA,m,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZgemvStridedBatched_rank_0 = hipblasZgemvStridedBatched_(handle,transA,m,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZgemvStridedBatched_rank_1(handle,transA,m,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZgemvStridedBatched_rank_1 = hipblasZgemvStridedBatched_(handle,transA,m,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCgemvStridedBatched_v2_rank_0(handle,transA,m,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemvStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCgemvStridedBatched_v2_rank_0 = hipblasCgemvStridedBatched_v2_(handle,transA,m,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCgemvStridedBatched_v2_rank_1(handle,transA,m,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgemvStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCgemvStridedBatched_v2_rank_1 = hipblasCgemvStridedBatched_v2_(handle,transA,m,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZgemvStridedBatched_v2_rank_0(handle,transA,m,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemvStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZgemvStridedBatched_v2_rank_0 = hipblasZgemvStridedBatched_v2_(handle,transA,m,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZgemvStridedBatched_v2_rank_1(handle,transA,m,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgemvStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZgemvStridedBatched_v2_rank_1 = hipblasZgemvStridedBatched_v2_(handle,transA,m,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSger_rank_0(handle,m,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSger_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasSger_rank_0 = hipblasSger_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasSger_rank_1(handle,m,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSger_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasSger_rank_1 = hipblasSger_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasDger_rank_0(handle,m,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDger_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasDger_rank_0 = hipblasDger_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasDger_rank_1(handle,m,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDger_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasDger_rank_1 = hipblasDger_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasCgeru_rank_0(handle,m,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeru_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasCgeru_rank_0 = hipblasCgeru_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasCgeru_rank_1(handle,m,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeru_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasCgeru_rank_1 = hipblasCgeru_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasCgerc_rank_0(handle,m,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgerc_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasCgerc_rank_0 = hipblasCgerc_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasCgerc_rank_1(handle,m,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgerc_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasCgerc_rank_1 = hipblasCgerc_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasZgeru_rank_0(handle,m,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeru_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasZgeru_rank_0 = hipblasZgeru_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasZgeru_rank_1(handle,m,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeru_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasZgeru_rank_1 = hipblasZgeru_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasZgerc_rank_0(handle,m,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgerc_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasZgerc_rank_0 = hipblasZgerc_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasZgerc_rank_1(handle,m,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgerc_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasZgerc_rank_1 = hipblasZgerc_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasCgeru_v2_rank_0(handle,m,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeru_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasCgeru_v2_rank_0 = hipblasCgeru_v2_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasCgeru_v2_rank_1(handle,m,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeru_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasCgeru_v2_rank_1 = hipblasCgeru_v2_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasCgerc_v2_rank_0(handle,m,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgerc_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasCgerc_v2_rank_0 = hipblasCgerc_v2_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasCgerc_v2_rank_1(handle,m,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgerc_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasCgerc_v2_rank_1 = hipblasCgerc_v2_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasZgeru_v2_rank_0(handle,m,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeru_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasZgeru_v2_rank_0 = hipblasZgeru_v2_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasZgeru_v2_rank_1(handle,m,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeru_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasZgeru_v2_rank_1 = hipblasZgeru_v2_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasZgerc_v2_rank_0(handle,m,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgerc_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasZgerc_v2_rank_0 = hipblasZgerc_v2_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasZgerc_v2_rank_1(handle,m,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgerc_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasZgerc_v2_rank_1 = hipblasZgerc_v2_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasSgerBatched_full_rank(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgerBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasSgerBatched_full_rank = hipblasSgerBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasSgerBatched_rank_0(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgerBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasSgerBatched_rank_0 = hipblasSgerBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasSgerBatched_rank_1(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgerBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasSgerBatched_rank_1 = hipblasSgerBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasDgerBatched_full_rank(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgerBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasDgerBatched_full_rank = hipblasDgerBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasDgerBatched_rank_0(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgerBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasDgerBatched_rank_0 = hipblasDgerBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasDgerBatched_rank_1(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgerBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasDgerBatched_rank_1 = hipblasDgerBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasCgeruBatched_full_rank(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeruBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCgeruBatched_full_rank = hipblasCgeruBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasCgeruBatched_rank_0(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeruBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCgeruBatched_rank_0 = hipblasCgeruBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasCgeruBatched_rank_1(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeruBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCgeruBatched_rank_1 = hipblasCgeruBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasCgercBatched_full_rank(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgercBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCgercBatched_full_rank = hipblasCgercBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasCgercBatched_rank_0(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgercBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCgercBatched_rank_0 = hipblasCgercBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasCgercBatched_rank_1(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgercBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCgercBatched_rank_1 = hipblasCgercBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasZgeruBatched_full_rank(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeruBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZgeruBatched_full_rank = hipblasZgeruBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasZgeruBatched_rank_0(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeruBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZgeruBatched_rank_0 = hipblasZgeruBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasZgeruBatched_rank_1(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeruBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZgeruBatched_rank_1 = hipblasZgeruBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasZgercBatched_full_rank(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgercBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZgercBatched_full_rank = hipblasZgercBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasZgercBatched_rank_0(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgercBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZgercBatched_rank_0 = hipblasZgercBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasZgercBatched_rank_1(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgercBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZgercBatched_rank_1 = hipblasZgercBatched_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasCgeruBatched_v2_full_rank(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeruBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCgeruBatched_v2_full_rank = hipblasCgeruBatched_v2_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasCgeruBatched_v2_rank_0(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeruBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCgeruBatched_v2_rank_0 = hipblasCgeruBatched_v2_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasCgeruBatched_v2_rank_1(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeruBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCgeruBatched_v2_rank_1 = hipblasCgeruBatched_v2_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasCgercBatched_v2_full_rank(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgercBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCgercBatched_v2_full_rank = hipblasCgercBatched_v2_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasCgercBatched_v2_rank_0(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgercBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCgercBatched_v2_rank_0 = hipblasCgercBatched_v2_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasCgercBatched_v2_rank_1(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgercBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCgercBatched_v2_rank_1 = hipblasCgercBatched_v2_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasZgeruBatched_v2_full_rank(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeruBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZgeruBatched_v2_full_rank = hipblasZgeruBatched_v2_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasZgeruBatched_v2_rank_0(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeruBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZgeruBatched_v2_rank_0 = hipblasZgeruBatched_v2_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasZgeruBatched_v2_rank_1(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeruBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZgeruBatched_v2_rank_1 = hipblasZgeruBatched_v2_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasZgercBatched_v2_full_rank(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgercBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZgercBatched_v2_full_rank = hipblasZgercBatched_v2_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasZgercBatched_v2_rank_0(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgercBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZgercBatched_v2_rank_0 = hipblasZgercBatched_v2_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasZgercBatched_v2_rank_1(handle,m,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgercBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZgercBatched_v2_rank_1 = hipblasZgercBatched_v2_(handle,m,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasSgerStridedBatched_rank_0(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgerStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasSgerStridedBatched_rank_0 = hipblasSgerStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasSgerStridedBatched_rank_1(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgerStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasSgerStridedBatched_rank_1 = hipblasSgerStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasDgerStridedBatched_rank_0(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgerStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasDgerStridedBatched_rank_0 = hipblasDgerStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasDgerStridedBatched_rank_1(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgerStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasDgerStridedBatched_rank_1 = hipblasDgerStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasCgeruStridedBatched_rank_0(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeruStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCgeruStridedBatched_rank_0 = hipblasCgeruStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasCgeruStridedBatched_rank_1(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeruStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCgeruStridedBatched_rank_1 = hipblasCgeruStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasCgercStridedBatched_rank_0(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgercStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCgercStridedBatched_rank_0 = hipblasCgercStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasCgercStridedBatched_rank_1(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgercStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCgercStridedBatched_rank_1 = hipblasCgercStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasZgeruStridedBatched_rank_0(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeruStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZgeruStridedBatched_rank_0 = hipblasZgeruStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasZgeruStridedBatched_rank_1(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeruStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZgeruStridedBatched_rank_1 = hipblasZgeruStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasZgercStridedBatched_rank_0(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgercStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZgercStridedBatched_rank_0 = hipblasZgercStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasZgercStridedBatched_rank_1(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgercStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZgercStridedBatched_rank_1 = hipblasZgercStridedBatched_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasCgeruStridedBatched_v2_rank_0(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeruStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCgeruStridedBatched_v2_rank_0 = hipblasCgeruStridedBatched_v2_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasCgeruStridedBatched_v2_rank_1(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeruStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCgeruStridedBatched_v2_rank_1 = hipblasCgeruStridedBatched_v2_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasCgercStridedBatched_v2_rank_0(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgercStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCgercStridedBatched_v2_rank_0 = hipblasCgercStridedBatched_v2_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasCgercStridedBatched_v2_rank_1(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgercStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCgercStridedBatched_v2_rank_1 = hipblasCgercStridedBatched_v2_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasZgeruStridedBatched_v2_rank_0(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeruStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZgeruStridedBatched_v2_rank_0 = hipblasZgeruStridedBatched_v2_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasZgeruStridedBatched_v2_rank_1(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeruStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZgeruStridedBatched_v2_rank_1 = hipblasZgeruStridedBatched_v2_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasZgercStridedBatched_v2_rank_0(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgercStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZgercStridedBatched_v2_rank_0 = hipblasZgercStridedBatched_v2_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasZgercStridedBatched_v2_rank_1(handle,m,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgercStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZgercStridedBatched_v2_rank_1 = hipblasZgercStridedBatched_v2_(handle,m,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasChbmv_rank_0(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasChbmv_rank_0 = hipblasChbmv_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasChbmv_rank_1(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasChbmv_rank_1 = hipblasChbmv_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZhbmv_rank_0(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasZhbmv_rank_0 = hipblasZhbmv_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZhbmv_rank_1(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZhbmv_rank_1 = hipblasZhbmv_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasChbmv_v2_rank_0(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmv_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasChbmv_v2_rank_0 = hipblasChbmv_v2_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasChbmv_v2_rank_1(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmv_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasChbmv_v2_rank_1 = hipblasChbmv_v2_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZhbmv_v2_rank_0(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmv_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasZhbmv_v2_rank_0 = hipblasZhbmv_v2_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZhbmv_v2_rank_1(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmv_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZhbmv_v2_rank_1 = hipblasZhbmv_v2_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasChbmvBatched_full_rank(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasChbmvBatched_full_rank = hipblasChbmvBatched_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasChbmvBatched_rank_0(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasChbmvBatched_rank_0 = hipblasChbmvBatched_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasChbmvBatched_rank_1(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasChbmvBatched_rank_1 = hipblasChbmvBatched_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZhbmvBatched_full_rank(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZhbmvBatched_full_rank = hipblasZhbmvBatched_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZhbmvBatched_rank_0(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZhbmvBatched_rank_0 = hipblasZhbmvBatched_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZhbmvBatched_rank_1(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZhbmvBatched_rank_1 = hipblasZhbmvBatched_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasChbmvBatched_v2_full_rank(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmvBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasChbmvBatched_v2_full_rank = hipblasChbmvBatched_v2_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasChbmvBatched_v2_rank_0(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmvBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasChbmvBatched_v2_rank_0 = hipblasChbmvBatched_v2_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasChbmvBatched_v2_rank_1(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmvBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasChbmvBatched_v2_rank_1 = hipblasChbmvBatched_v2_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZhbmvBatched_v2_full_rank(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmvBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZhbmvBatched_v2_full_rank = hipblasZhbmvBatched_v2_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZhbmvBatched_v2_rank_0(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmvBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZhbmvBatched_v2_rank_0 = hipblasZhbmvBatched_v2_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZhbmvBatched_v2_rank_1(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmvBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZhbmvBatched_v2_rank_1 = hipblasZhbmvBatched_v2_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasChbmvStridedBatched_rank_0(handle,uplo,n,k,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasChbmvStridedBatched_rank_0 = hipblasChbmvStridedBatched_(handle,uplo,n,k,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasChbmvStridedBatched_rank_1(handle,uplo,n,k,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasChbmvStridedBatched_rank_1 = hipblasChbmvStridedBatched_(handle,uplo,n,k,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZhbmvStridedBatched_rank_0(handle,uplo,n,k,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZhbmvStridedBatched_rank_0 = hipblasZhbmvStridedBatched_(handle,uplo,n,k,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZhbmvStridedBatched_rank_1(handle,uplo,n,k,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZhbmvStridedBatched_rank_1 = hipblasZhbmvStridedBatched_(handle,uplo,n,k,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasChbmvStridedBatched_v2_rank_0(handle,uplo,n,k,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmvStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasChbmvStridedBatched_v2_rank_0 = hipblasChbmvStridedBatched_v2_(handle,uplo,n,k,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasChbmvStridedBatched_v2_rank_1(handle,uplo,n,k,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChbmvStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasChbmvStridedBatched_v2_rank_1 = hipblasChbmvStridedBatched_v2_(handle,uplo,n,k,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZhbmvStridedBatched_v2_rank_0(handle,uplo,n,k,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmvStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZhbmvStridedBatched_v2_rank_0 = hipblasZhbmvStridedBatched_v2_(handle,uplo,n,k,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZhbmvStridedBatched_v2_rank_1(handle,uplo,n,k,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhbmvStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZhbmvStridedBatched_v2_rank_1 = hipblasZhbmvStridedBatched_v2_(handle,uplo,n,k,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasChemv_rank_0(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasChemv_rank_0 = hipblasChemv_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasChemv_rank_1(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasChemv_rank_1 = hipblasChemv_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZhemv_rank_0(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasZhemv_rank_0 = hipblasZhemv_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZhemv_rank_1(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZhemv_rank_1 = hipblasZhemv_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasChemv_v2_rank_0(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemv_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasChemv_v2_rank_0 = hipblasChemv_v2_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasChemv_v2_rank_1(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemv_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasChemv_v2_rank_1 = hipblasChemv_v2_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZhemv_v2_rank_0(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemv_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasZhemv_v2_rank_0 = hipblasZhemv_v2_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZhemv_v2_rank_1(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemv_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZhemv_v2_rank_1 = hipblasZhemv_v2_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasChemvBatched_full_rank(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasChemvBatched_full_rank = hipblasChemvBatched_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasChemvBatched_rank_0(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasChemvBatched_rank_0 = hipblasChemvBatched_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasChemvBatched_rank_1(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasChemvBatched_rank_1 = hipblasChemvBatched_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZhemvBatched_full_rank(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZhemvBatched_full_rank = hipblasZhemvBatched_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZhemvBatched_rank_0(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZhemvBatched_rank_0 = hipblasZhemvBatched_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZhemvBatched_rank_1(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZhemvBatched_rank_1 = hipblasZhemvBatched_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasChemvBatched_v2_full_rank(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemvBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasChemvBatched_v2_full_rank = hipblasChemvBatched_v2_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasChemvBatched_v2_rank_0(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemvBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasChemvBatched_v2_rank_0 = hipblasChemvBatched_v2_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasChemvBatched_v2_rank_1(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemvBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasChemvBatched_v2_rank_1 = hipblasChemvBatched_v2_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZhemvBatched_v2_full_rank(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemvBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZhemvBatched_v2_full_rank = hipblasZhemvBatched_v2_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZhemvBatched_v2_rank_0(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemvBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZhemvBatched_v2_rank_0 = hipblasZhemvBatched_v2_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZhemvBatched_v2_rank_1(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemvBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZhemvBatched_v2_rank_1 = hipblasZhemvBatched_v2_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasChemvStridedBatched_rank_0(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasChemvStridedBatched_rank_0 = hipblasChemvStridedBatched_(handle,uplo,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasChemvStridedBatched_rank_1(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasChemvStridedBatched_rank_1 = hipblasChemvStridedBatched_(handle,uplo,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZhemvStridedBatched_rank_0(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZhemvStridedBatched_rank_0 = hipblasZhemvStridedBatched_(handle,uplo,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZhemvStridedBatched_rank_1(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZhemvStridedBatched_rank_1 = hipblasZhemvStridedBatched_(handle,uplo,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasChemvStridedBatched_v2_rank_0(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemvStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasChemvStridedBatched_v2_rank_0 = hipblasChemvStridedBatched_v2_(handle,uplo,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasChemvStridedBatched_v2_rank_1(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChemvStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasChemvStridedBatched_v2_rank_1 = hipblasChemvStridedBatched_v2_(handle,uplo,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZhemvStridedBatched_v2_rank_0(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemvStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZhemvStridedBatched_v2_rank_0 = hipblasZhemvStridedBatched_v2_(handle,uplo,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZhemvStridedBatched_v2_rank_1(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhemvStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZhemvStridedBatched_v2_rank_1 = hipblasZhemvStridedBatched_v2_(handle,uplo,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCher_rank_0(handle,uplo,n,alpha,x,incx,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasCher_rank_0 = hipblasCher_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda)
    end function

    function hipblasCher_rank_1(handle,uplo,n,alpha,x,incx,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasCher_rank_1 = hipblasCher_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda)
    end function

    function hipblasZher_rank_0(handle,uplo,n,alpha,x,incx,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasZher_rank_0 = hipblasZher_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda)
    end function

    function hipblasZher_rank_1(handle,uplo,n,alpha,x,incx,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasZher_rank_1 = hipblasZher_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda)
    end function

    function hipblasCher_v2_rank_0(handle,uplo,n,alpha,x,incx,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasCher_v2_rank_0 = hipblasCher_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda)
    end function

    function hipblasCher_v2_rank_1(handle,uplo,n,alpha,x,incx,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasCher_v2_rank_1 = hipblasCher_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda)
    end function

    function hipblasZher_v2_rank_0(handle,uplo,n,alpha,x,incx,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasZher_v2_rank_0 = hipblasZher_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda)
    end function

    function hipblasZher_v2_rank_1(handle,uplo,n,alpha,x,incx,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasZher_v2_rank_1 = hipblasZher_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda)
    end function

    function hipblasCherBatched_full_rank(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCherBatched_full_rank = hipblasCherBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasCherBatched_rank_0(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCherBatched_rank_0 = hipblasCherBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasCherBatched_rank_1(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCherBatched_rank_1 = hipblasCherBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasZherBatched_full_rank(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZherBatched_full_rank = hipblasZherBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasZherBatched_rank_0(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZherBatched_rank_0 = hipblasZherBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasZherBatched_rank_1(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZherBatched_rank_1 = hipblasZherBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasCherBatched_v2_full_rank(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCherBatched_v2_full_rank = hipblasCherBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasCherBatched_v2_rank_0(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCherBatched_v2_rank_0 = hipblasCherBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasCherBatched_v2_rank_1(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCherBatched_v2_rank_1 = hipblasCherBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasZherBatched_v2_full_rank(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZherBatched_v2_full_rank = hipblasZherBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasZherBatched_v2_rank_0(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZherBatched_v2_rank_0 = hipblasZherBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasZherBatched_v2_rank_1(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZherBatched_v2_rank_1 = hipblasZherBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasCherStridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCherStridedBatched_rank_0 = hipblasCherStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,lda,strideA,batchCount)
    end function

    function hipblasCherStridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCherStridedBatched_rank_1 = hipblasCherStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,lda,strideA,batchCount)
    end function

    function hipblasZherStridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZherStridedBatched_rank_0 = hipblasZherStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,lda,strideA,batchCount)
    end function

    function hipblasZherStridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZherStridedBatched_rank_1 = hipblasZherStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,lda,strideA,batchCount)
    end function

    function hipblasCherStridedBatched_v2_rank_0(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCherStridedBatched_v2_rank_0 = hipblasCherStridedBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,lda,strideA,batchCount)
    end function

    function hipblasCherStridedBatched_v2_rank_1(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCherStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCherStridedBatched_v2_rank_1 = hipblasCherStridedBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,lda,strideA,batchCount)
    end function

    function hipblasZherStridedBatched_v2_rank_0(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZherStridedBatched_v2_rank_0 = hipblasZherStridedBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,lda,strideA,batchCount)
    end function

    function hipblasZherStridedBatched_v2_rank_1(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZherStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZherStridedBatched_v2_rank_1 = hipblasZherStridedBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,lda,strideA,batchCount)
    end function

    function hipblasCher2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasCher2_rank_0 = hipblasCher2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasCher2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasCher2_rank_1 = hipblasCher2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasZher2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasZher2_rank_0 = hipblasZher2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasZher2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasZher2_rank_1 = hipblasZher2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasCher2_v2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasCher2_v2_rank_0 = hipblasCher2_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasCher2_v2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasCher2_v2_rank_1 = hipblasCher2_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasZher2_v2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasZher2_v2_rank_0 = hipblasZher2_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasZher2_v2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasZher2_v2_rank_1 = hipblasZher2_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasCher2Batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2Batched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCher2Batched_full_rank = hipblasCher2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasCher2Batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2Batched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCher2Batched_rank_0 = hipblasCher2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasCher2Batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2Batched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCher2Batched_rank_1 = hipblasCher2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasZher2Batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2Batched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZher2Batched_full_rank = hipblasZher2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasZher2Batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2Batched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZher2Batched_rank_0 = hipblasZher2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasZher2Batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2Batched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZher2Batched_rank_1 = hipblasZher2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasCher2Batched_v2_full_rank(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2Batched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCher2Batched_v2_full_rank = hipblasCher2Batched_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasCher2Batched_v2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2Batched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCher2Batched_v2_rank_0 = hipblasCher2Batched_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasCher2Batched_v2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2Batched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCher2Batched_v2_rank_1 = hipblasCher2Batched_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasZher2Batched_v2_full_rank(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2Batched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZher2Batched_v2_full_rank = hipblasZher2Batched_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasZher2Batched_v2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2Batched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZher2Batched_v2_rank_0 = hipblasZher2Batched_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasZher2Batched_v2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2Batched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZher2Batched_v2_rank_1 = hipblasZher2Batched_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasCher2StridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2StridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCher2StridedBatched_rank_0 = hipblasCher2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasCher2StridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2StridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCher2StridedBatched_rank_1 = hipblasCher2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasZher2StridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2StridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZher2StridedBatched_rank_0 = hipblasZher2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasZher2StridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2StridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZher2StridedBatched_rank_1 = hipblasZher2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasCher2StridedBatched_v2_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2StridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCher2StridedBatched_v2_rank_0 = hipblasCher2StridedBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasCher2StridedBatched_v2_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCher2StridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCher2StridedBatched_v2_rank_1 = hipblasCher2StridedBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasZher2StridedBatched_v2_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2StridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZher2StridedBatched_v2_rank_0 = hipblasZher2StridedBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasZher2StridedBatched_v2_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZher2StridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZher2StridedBatched_v2_rank_1 = hipblasZher2StridedBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasChpmv_rank_0(handle,uplo,n,alpha,AP,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasChpmv_rank_0 = hipblasChpmv_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasChpmv_rank_1(handle,uplo,n,alpha,AP,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasChpmv_rank_1 = hipblasChpmv_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZhpmv_rank_0(handle,uplo,n,alpha,AP,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasZhpmv_rank_0 = hipblasZhpmv_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZhpmv_rank_1(handle,uplo,n,alpha,AP,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZhpmv_rank_1 = hipblasZhpmv_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasChpmv_v2_rank_0(handle,uplo,n,alpha,AP,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmv_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasChpmv_v2_rank_0 = hipblasChpmv_v2_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasChpmv_v2_rank_1(handle,uplo,n,alpha,AP,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmv_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasChpmv_v2_rank_1 = hipblasChpmv_v2_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZhpmv_v2_rank_0(handle,uplo,n,alpha,AP,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmv_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasZhpmv_v2_rank_0 = hipblasZhpmv_v2_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZhpmv_v2_rank_1(handle,uplo,n,alpha,AP,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmv_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZhpmv_v2_rank_1 = hipblasZhpmv_v2_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasChpmvBatched_full_rank(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasChpmvBatched_full_rank = hipblasChpmvBatched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasChpmvBatched_rank_0(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasChpmvBatched_rank_0 = hipblasChpmvBatched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasChpmvBatched_rank_1(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasChpmvBatched_rank_1 = hipblasChpmvBatched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZhpmvBatched_full_rank(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZhpmvBatched_full_rank = hipblasZhpmvBatched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZhpmvBatched_rank_0(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZhpmvBatched_rank_0 = hipblasZhpmvBatched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZhpmvBatched_rank_1(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZhpmvBatched_rank_1 = hipblasZhpmvBatched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasChpmvBatched_v2_full_rank(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmvBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasChpmvBatched_v2_full_rank = hipblasChpmvBatched_v2_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasChpmvBatched_v2_rank_0(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmvBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasChpmvBatched_v2_rank_0 = hipblasChpmvBatched_v2_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasChpmvBatched_v2_rank_1(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmvBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasChpmvBatched_v2_rank_1 = hipblasChpmvBatched_v2_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZhpmvBatched_v2_full_rank(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmvBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZhpmvBatched_v2_full_rank = hipblasZhpmvBatched_v2_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZhpmvBatched_v2_rank_0(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmvBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZhpmvBatched_v2_rank_0 = hipblasZhpmvBatched_v2_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZhpmvBatched_v2_rank_1(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmvBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZhpmvBatched_v2_rank_1 = hipblasZhpmvBatched_v2_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasChpmvStridedBatched_rank_0(handle,uplo,n,alpha,AP,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasChpmvStridedBatched_rank_0 = hipblasChpmvStridedBatched_(handle,uplo,n,alpha,AP,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasChpmvStridedBatched_rank_1(handle,uplo,n,alpha,AP,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasChpmvStridedBatched_rank_1 = hipblasChpmvStridedBatched_(handle,uplo,n,alpha,AP,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZhpmvStridedBatched_rank_0(handle,uplo,n,alpha,AP,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZhpmvStridedBatched_rank_0 = hipblasZhpmvStridedBatched_(handle,uplo,n,alpha,AP,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZhpmvStridedBatched_rank_1(handle,uplo,n,alpha,AP,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZhpmvStridedBatched_rank_1 = hipblasZhpmvStridedBatched_(handle,uplo,n,alpha,AP,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasChpmvStridedBatched_v2_rank_0(handle,uplo,n,alpha,AP,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmvStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasChpmvStridedBatched_v2_rank_0 = hipblasChpmvStridedBatched_v2_(handle,uplo,n,alpha,AP,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasChpmvStridedBatched_v2_rank_1(handle,uplo,n,alpha,AP,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpmvStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasChpmvStridedBatched_v2_rank_1 = hipblasChpmvStridedBatched_v2_(handle,uplo,n,alpha,AP,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZhpmvStridedBatched_v2_rank_0(handle,uplo,n,alpha,AP,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmvStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZhpmvStridedBatched_v2_rank_0 = hipblasZhpmvStridedBatched_v2_(handle,uplo,n,alpha,AP,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZhpmvStridedBatched_v2_rank_1(handle,uplo,n,alpha,AP,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpmvStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZhpmvStridedBatched_v2_rank_1 = hipblasZhpmvStridedBatched_v2_(handle,uplo,n,alpha,AP,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasChpr_rank_0(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasChpr_rank_0 = hipblasChpr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasChpr_rank_1(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasChpr_rank_1 = hipblasChpr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasZhpr_rank_0(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasZhpr_rank_0 = hipblasZhpr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasZhpr_rank_1(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasZhpr_rank_1 = hipblasZhpr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasChpr_v2_rank_0(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasChpr_v2_rank_0 = hipblasChpr_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasChpr_v2_rank_1(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasChpr_v2_rank_1 = hipblasChpr_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasZhpr_v2_rank_0(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasZhpr_v2_rank_0 = hipblasZhpr_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasZhpr_v2_rank_1(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasZhpr_v2_rank_1 = hipblasZhpr_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasChprBatched_full_rank(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChprBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasChprBatched_full_rank = hipblasChprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasChprBatched_rank_0(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChprBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasChprBatched_rank_0 = hipblasChprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasChprBatched_rank_1(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChprBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasChprBatched_rank_1 = hipblasChprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasZhprBatched_full_rank(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhprBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasZhprBatched_full_rank = hipblasZhprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasZhprBatched_rank_0(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhprBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasZhprBatched_rank_0 = hipblasZhprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasZhprBatched_rank_1(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhprBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasZhprBatched_rank_1 = hipblasZhprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasChprBatched_v2_full_rank(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChprBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasChprBatched_v2_full_rank = hipblasChprBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasChprBatched_v2_rank_0(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChprBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasChprBatched_v2_rank_0 = hipblasChprBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasChprBatched_v2_rank_1(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChprBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasChprBatched_v2_rank_1 = hipblasChprBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasZhprBatched_v2_full_rank(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhprBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasZhprBatched_v2_full_rank = hipblasZhprBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasZhprBatched_v2_rank_0(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhprBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasZhprBatched_v2_rank_0 = hipblasZhprBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasZhprBatched_v2_rank_1(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhprBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasZhprBatched_v2_rank_1 = hipblasZhprBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasChprStridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChprStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasChprStridedBatched_rank_0 = hipblasChprStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideA,batchCount)
    end function

    function hipblasChprStridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChprStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasChprStridedBatched_rank_1 = hipblasChprStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideA,batchCount)
    end function

    function hipblasZhprStridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhprStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZhprStridedBatched_rank_0 = hipblasZhprStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideA,batchCount)
    end function

    function hipblasZhprStridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhprStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZhprStridedBatched_rank_1 = hipblasZhprStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideA,batchCount)
    end function

    function hipblasChprStridedBatched_v2_rank_0(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChprStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasChprStridedBatched_v2_rank_0 = hipblasChprStridedBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideA,batchCount)
    end function

    function hipblasChprStridedBatched_v2_rank_1(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChprStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasChprStridedBatched_v2_rank_1 = hipblasChprStridedBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideA,batchCount)
    end function

    function hipblasZhprStridedBatched_v2_rank_0(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhprStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZhprStridedBatched_v2_rank_0 = hipblasZhprStridedBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideA,batchCount)
    end function

    function hipblasZhprStridedBatched_v2_rank_1(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhprStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZhprStridedBatched_v2_rank_1 = hipblasZhprStridedBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideA,batchCount)
    end function

    function hipblasChpr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      !
      hipblasChpr2_rank_0 = hipblasChpr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function hipblasChpr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      !
      hipblasChpr2_rank_1 = hipblasChpr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function hipblasZhpr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      !
      hipblasZhpr2_rank_0 = hipblasZhpr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function hipblasZhpr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      !
      hipblasZhpr2_rank_1 = hipblasZhpr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function hipblasChpr2_v2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      !
      hipblasChpr2_v2_rank_0 = hipblasChpr2_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function hipblasChpr2_v2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      !
      hipblasChpr2_v2_rank_1 = hipblasChpr2_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function hipblasZhpr2_v2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      !
      hipblasZhpr2_v2_rank_0 = hipblasZhpr2_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function hipblasZhpr2_v2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      !
      hipblasZhpr2_v2_rank_1 = hipblasZhpr2_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function hipblasChpr2Batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2Batched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasChpr2Batched_full_rank = hipblasChpr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasChpr2Batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2Batched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasChpr2Batched_rank_0 = hipblasChpr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasChpr2Batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2Batched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasChpr2Batched_rank_1 = hipblasChpr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasZhpr2Batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2Batched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasZhpr2Batched_full_rank = hipblasZhpr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasZhpr2Batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2Batched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasZhpr2Batched_rank_0 = hipblasZhpr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasZhpr2Batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2Batched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasZhpr2Batched_rank_1 = hipblasZhpr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasChpr2Batched_v2_full_rank(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2Batched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasChpr2Batched_v2_full_rank = hipblasChpr2Batched_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasChpr2Batched_v2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2Batched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasChpr2Batched_v2_rank_0 = hipblasChpr2Batched_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasChpr2Batched_v2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2Batched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasChpr2Batched_v2_rank_1 = hipblasChpr2Batched_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasZhpr2Batched_v2_full_rank(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2Batched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasZhpr2Batched_v2_full_rank = hipblasZhpr2Batched_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasZhpr2Batched_v2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2Batched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasZhpr2Batched_v2_rank_0 = hipblasZhpr2Batched_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasZhpr2Batched_v2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2Batched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasZhpr2Batched_v2_rank_1 = hipblasZhpr2Batched_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasChpr2StridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2StridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasChpr2StridedBatched_rank_0 = hipblasChpr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,strideA,batchCount)
    end function

    function hipblasChpr2StridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2StridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasChpr2StridedBatched_rank_1 = hipblasChpr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,strideA,batchCount)
    end function

    function hipblasZhpr2StridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2StridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZhpr2StridedBatched_rank_0 = hipblasZhpr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,strideA,batchCount)
    end function

    function hipblasZhpr2StridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2StridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZhpr2StridedBatched_rank_1 = hipblasZhpr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,strideA,batchCount)
    end function

    function hipblasChpr2StridedBatched_v2_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2StridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasChpr2StridedBatched_v2_rank_0 = hipblasChpr2StridedBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,strideA,batchCount)
    end function

    function hipblasChpr2StridedBatched_v2_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasChpr2StridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasChpr2StridedBatched_v2_rank_1 = hipblasChpr2StridedBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,strideA,batchCount)
    end function

    function hipblasZhpr2StridedBatched_v2_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2StridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZhpr2StridedBatched_v2_rank_0 = hipblasZhpr2StridedBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,strideA,batchCount)
    end function

    function hipblasZhpr2StridedBatched_v2_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZhpr2StridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZhpr2StridedBatched_v2_rank_1 = hipblasZhpr2StridedBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,strideA,batchCount)
    end function

    function hipblasSsbmv_rank_0(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      !
      hipblasSsbmv_rank_0 = hipblasSsbmv_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasSsbmv_rank_1(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasSsbmv_rank_1 = hipblasSsbmv_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasDsbmv_rank_0(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      !
      hipblasDsbmv_rank_0 = hipblasDsbmv_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasDsbmv_rank_1(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasDsbmv_rank_1 = hipblasDsbmv_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasSsbmvBatched_full_rank(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsbmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSsbmvBatched_full_rank = hipblasSsbmvBatched_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSsbmvBatched_rank_0(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsbmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSsbmvBatched_rank_0 = hipblasSsbmvBatched_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSsbmvBatched_rank_1(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsbmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSsbmvBatched_rank_1 = hipblasSsbmvBatched_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDsbmvBatched_full_rank(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsbmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDsbmvBatched_full_rank = hipblasDsbmvBatched_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDsbmvBatched_rank_0(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsbmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDsbmvBatched_rank_0 = hipblasDsbmvBatched_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDsbmvBatched_rank_1(handle,uplo,n,k,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsbmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDsbmvBatched_rank_1 = hipblasDsbmvBatched_(handle,uplo,n,k,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSsbmvStridedBatched_rank_0(handle,uplo,n,k,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsbmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSsbmvStridedBatched_rank_0 = hipblasSsbmvStridedBatched_(handle,uplo,n,k,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSsbmvStridedBatched_rank_1(handle,uplo,n,k,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsbmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSsbmvStridedBatched_rank_1 = hipblasSsbmvStridedBatched_(handle,uplo,n,k,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDsbmvStridedBatched_rank_0(handle,uplo,n,k,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsbmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDsbmvStridedBatched_rank_0 = hipblasDsbmvStridedBatched_(handle,uplo,n,k,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDsbmvStridedBatched_rank_1(handle,uplo,n,k,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsbmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      integer(c_int) :: k
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDsbmvStridedBatched_rank_1 = hipblasDsbmvStridedBatched_(handle,uplo,n,k,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSspmv_rank_0(handle,uplo,n,alpha,AP,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      !
      hipblasSspmv_rank_0 = hipblasSspmv_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasSspmv_rank_1(handle,uplo,n,alpha,AP,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasSspmv_rank_1 = hipblasSspmv_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasDspmv_rank_0(handle,uplo,n,alpha,AP,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      !
      hipblasDspmv_rank_0 = hipblasDspmv_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasDspmv_rank_1(handle,uplo,n,alpha,AP,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasDspmv_rank_1 = hipblasDspmv_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasSspmvBatched_full_rank(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSspmvBatched_full_rank = hipblasSspmvBatched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSspmvBatched_rank_0(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSspmvBatched_rank_0 = hipblasSspmvBatched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSspmvBatched_rank_1(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSspmvBatched_rank_1 = hipblasSspmvBatched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDspmvBatched_full_rank(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDspmvBatched_full_rank = hipblasDspmvBatched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDspmvBatched_rank_0(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDspmvBatched_rank_0 = hipblasDspmvBatched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDspmvBatched_rank_1(handle,uplo,n,alpha,AP,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDspmvBatched_rank_1 = hipblasDspmvBatched_(handle,uplo,n,alpha,AP,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSspmvStridedBatched_rank_0(handle,uplo,n,alpha,AP,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSspmvStridedBatched_rank_0 = hipblasSspmvStridedBatched_(handle,uplo,n,alpha,AP,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSspmvStridedBatched_rank_1(handle,uplo,n,alpha,AP,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSspmvStridedBatched_rank_1 = hipblasSspmvStridedBatched_(handle,uplo,n,alpha,AP,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDspmvStridedBatched_rank_0(handle,uplo,n,alpha,AP,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDspmvStridedBatched_rank_0 = hipblasDspmvStridedBatched_(handle,uplo,n,alpha,AP,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDspmvStridedBatched_rank_1(handle,uplo,n,alpha,AP,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDspmvStridedBatched_rank_1 = hipblasDspmvStridedBatched_(handle,uplo,n,alpha,AP,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSspr_rank_0(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspr_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasSspr_rank_0 = hipblasSspr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasSspr_rank_1(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspr_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasSspr_rank_1 = hipblasSspr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasDspr_rank_0(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspr_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasDspr_rank_0 = hipblasDspr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasDspr_rank_1(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspr_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasDspr_rank_1 = hipblasDspr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasCspr_rank_0(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCspr_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasCspr_rank_0 = hipblasCspr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasCspr_rank_1(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCspr_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasCspr_rank_1 = hipblasCspr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasZspr_rank_0(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZspr_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasZspr_rank_0 = hipblasZspr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasZspr_rank_1(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZspr_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasZspr_rank_1 = hipblasZspr_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasCspr_v2_rank_0(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCspr_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasCspr_v2_rank_0 = hipblasCspr_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasCspr_v2_rank_1(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCspr_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasCspr_v2_rank_1 = hipblasCspr_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasZspr_v2_rank_0(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZspr_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasZspr_v2_rank_0 = hipblasZspr_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasZspr_v2_rank_1(handle,uplo,n,alpha,x,incx,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZspr_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      !
      hipblasZspr_v2_rank_1 = hipblasZspr_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP)
    end function

    function hipblasSsprBatched_full_rank(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsprBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasSsprBatched_full_rank = hipblasSsprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasSsprBatched_rank_0(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsprBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasSsprBatched_rank_0 = hipblasSsprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasSsprBatched_rank_1(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsprBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasSsprBatched_rank_1 = hipblasSsprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasDsprBatched_full_rank(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsprBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasDsprBatched_full_rank = hipblasDsprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasDsprBatched_rank_0(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsprBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasDsprBatched_rank_0 = hipblasDsprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasDsprBatched_rank_1(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsprBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasDsprBatched_rank_1 = hipblasDsprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasCsprBatched_full_rank(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsprBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasCsprBatched_full_rank = hipblasCsprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasCsprBatched_rank_0(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsprBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasCsprBatched_rank_0 = hipblasCsprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasCsprBatched_rank_1(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsprBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasCsprBatched_rank_1 = hipblasCsprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasZsprBatched_full_rank(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsprBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasZsprBatched_full_rank = hipblasZsprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasZsprBatched_rank_0(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsprBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasZsprBatched_rank_0 = hipblasZsprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasZsprBatched_rank_1(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsprBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasZsprBatched_rank_1 = hipblasZsprBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasCsprBatched_v2_full_rank(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsprBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasCsprBatched_v2_full_rank = hipblasCsprBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasCsprBatched_v2_rank_0(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsprBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasCsprBatched_v2_rank_0 = hipblasCsprBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasCsprBatched_v2_rank_1(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsprBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasCsprBatched_v2_rank_1 = hipblasCsprBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasZsprBatched_v2_full_rank(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsprBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasZsprBatched_v2_full_rank = hipblasZsprBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasZsprBatched_v2_rank_0(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsprBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasZsprBatched_v2_rank_0 = hipblasZsprBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasZsprBatched_v2_rank_1(handle,uplo,n,alpha,x,incx,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsprBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasZsprBatched_v2_rank_1 = hipblasZsprBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,batchCount)
    end function

    function hipblasSsprStridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsprStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasSsprStridedBatched_rank_0 = hipblasSsprStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideA,batchCount)
    end function

    function hipblasSsprStridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsprStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasSsprStridedBatched_rank_1 = hipblasSsprStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideA,batchCount)
    end function

    function hipblasDsprStridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsprStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasDsprStridedBatched_rank_0 = hipblasDsprStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideA,batchCount)
    end function

    function hipblasDsprStridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsprStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasDsprStridedBatched_rank_1 = hipblasDsprStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideA,batchCount)
    end function

    function hipblasCsprStridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsprStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCsprStridedBatched_rank_0 = hipblasCsprStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideA,batchCount)
    end function

    function hipblasCsprStridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsprStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCsprStridedBatched_rank_1 = hipblasCsprStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideA,batchCount)
    end function

    function hipblasZsprStridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsprStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZsprStridedBatched_rank_0 = hipblasZsprStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideA,batchCount)
    end function

    function hipblasZsprStridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsprStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZsprStridedBatched_rank_1 = hipblasZsprStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideA,batchCount)
    end function

    function hipblasCsprStridedBatched_v2_rank_0(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsprStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCsprStridedBatched_v2_rank_0 = hipblasCsprStridedBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideA,batchCount)
    end function

    function hipblasCsprStridedBatched_v2_rank_1(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsprStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCsprStridedBatched_v2_rank_1 = hipblasCsprStridedBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideA,batchCount)
    end function

    function hipblasZsprStridedBatched_v2_rank_0(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsprStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZsprStridedBatched_v2_rank_0 = hipblasZsprStridedBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideA,batchCount)
    end function

    function hipblasZsprStridedBatched_v2_rank_1(handle,uplo,n,alpha,x,incx,stridex,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsprStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZsprStridedBatched_v2_rank_1 = hipblasZsprStridedBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,strideA,batchCount)
    end function

    function hipblasSspr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspr2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      !
      hipblasSspr2_rank_0 = hipblasSspr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function hipblasSspr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspr2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      !
      hipblasSspr2_rank_1 = hipblasSspr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function hipblasDspr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspr2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      !
      hipblasDspr2_rank_0 = hipblasDspr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function hipblasDspr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspr2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      !
      hipblasDspr2_rank_1 = hipblasDspr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP)
    end function

    function hipblasSspr2Batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspr2Batched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasSspr2Batched_full_rank = hipblasSspr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasSspr2Batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspr2Batched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasSspr2Batched_rank_0 = hipblasSspr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasSspr2Batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspr2Batched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasSspr2Batched_rank_1 = hipblasSspr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasDspr2Batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspr2Batched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasDspr2Batched_full_rank = hipblasDspr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasDspr2Batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspr2Batched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasDspr2Batched_rank_0 = hipblasDspr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasDspr2Batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspr2Batched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: batchCount
      !
      hipblasDspr2Batched_rank_1 = hipblasDspr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,batchCount)
    end function

    function hipblasSspr2StridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspr2StridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasSspr2StridedBatched_rank_0 = hipblasSspr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,strideA,batchCount)
    end function

    function hipblasSspr2StridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSspr2StridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasSspr2StridedBatched_rank_1 = hipblasSspr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,strideA,batchCount)
    end function

    function hipblasDspr2StridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspr2StridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasDspr2StridedBatched_rank_0 = hipblasDspr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,strideA,batchCount)
    end function

    function hipblasDspr2StridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDspr2StridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasDspr2StridedBatched_rank_1 = hipblasDspr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,strideA,batchCount)
    end function

    function hipblasSsymv_rank_0(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      !
      hipblasSsymv_rank_0 = hipblasSsymv_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasSsymv_rank_1(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasSsymv_rank_1 = hipblasSsymv_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasDsymv_rank_0(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      !
      hipblasDsymv_rank_0 = hipblasDsymv_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasDsymv_rank_1(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasDsymv_rank_1 = hipblasDsymv_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasCsymv_rank_0(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasCsymv_rank_0 = hipblasCsymv_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasCsymv_rank_1(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasCsymv_rank_1 = hipblasCsymv_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZsymv_rank_0(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasZsymv_rank_0 = hipblasZsymv_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZsymv_rank_1(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZsymv_rank_1 = hipblasZsymv_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasCsymv_v2_rank_0(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymv_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasCsymv_v2_rank_0 = hipblasCsymv_v2_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasCsymv_v2_rank_1(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymv_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasCsymv_v2_rank_1 = hipblasCsymv_v2_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZsymv_v2_rank_0(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymv_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      !
      hipblasZsymv_v2_rank_0 = hipblasZsymv_v2_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasZsymv_v2_rank_1(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymv_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      !
      hipblasZsymv_v2_rank_1 = hipblasZsymv_v2_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy)
    end function

    function hipblasSsymvBatched_full_rank(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSsymvBatched_full_rank = hipblasSsymvBatched_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSsymvBatched_rank_0(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSsymvBatched_rank_0 = hipblasSsymvBatched_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSsymvBatched_rank_1(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasSsymvBatched_rank_1 = hipblasSsymvBatched_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDsymvBatched_full_rank(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDsymvBatched_full_rank = hipblasDsymvBatched_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDsymvBatched_rank_0(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDsymvBatched_rank_0 = hipblasDsymvBatched_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasDsymvBatched_rank_1(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasDsymvBatched_rank_1 = hipblasDsymvBatched_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasCsymvBatched_full_rank(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCsymvBatched_full_rank = hipblasCsymvBatched_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasCsymvBatched_rank_0(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCsymvBatched_rank_0 = hipblasCsymvBatched_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasCsymvBatched_rank_1(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCsymvBatched_rank_1 = hipblasCsymvBatched_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZsymvBatched_full_rank(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZsymvBatched_full_rank = hipblasZsymvBatched_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZsymvBatched_rank_0(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZsymvBatched_rank_0 = hipblasZsymvBatched_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZsymvBatched_rank_1(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZsymvBatched_rank_1 = hipblasZsymvBatched_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasCsymvBatched_v2_full_rank(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymvBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCsymvBatched_v2_full_rank = hipblasCsymvBatched_v2_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasCsymvBatched_v2_rank_0(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymvBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCsymvBatched_v2_rank_0 = hipblasCsymvBatched_v2_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasCsymvBatched_v2_rank_1(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymvBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasCsymvBatched_v2_rank_1 = hipblasCsymvBatched_v2_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZsymvBatched_v2_full_rank(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymvBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZsymvBatched_v2_full_rank = hipblasZsymvBatched_v2_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZsymvBatched_v2_rank_0(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymvBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZsymvBatched_v2_rank_0 = hipblasZsymvBatched_v2_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasZsymvBatched_v2_rank_1(handle,uplo,n,alpha,AP,lda,x,incx,beta,y,incy,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymvBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int) :: batchCount
      !
      hipblasZsymvBatched_v2_rank_1 = hipblasZsymvBatched_v2_(handle,uplo,n,alpha,AP,lda,c_loc(x),incx,beta,c_loc(y),incy,batchCount)
    end function

    function hipblasSsymvStridedBatched_rank_0(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSsymvStridedBatched_rank_0 = hipblasSsymvStridedBatched_(handle,uplo,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSsymvStridedBatched_rank_1(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsymvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float) :: beta
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasSsymvStridedBatched_rank_1 = hipblasSsymvStridedBatched_(handle,uplo,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDsymvStridedBatched_rank_0(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDsymvStridedBatched_rank_0 = hipblasDsymvStridedBatched_(handle,uplo,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasDsymvStridedBatched_rank_1(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsymvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double) :: beta
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasDsymvStridedBatched_rank_1 = hipblasDsymvStridedBatched_(handle,uplo,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCsymvStridedBatched_rank_0(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCsymvStridedBatched_rank_0 = hipblasCsymvStridedBatched_(handle,uplo,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCsymvStridedBatched_rank_1(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCsymvStridedBatched_rank_1 = hipblasCsymvStridedBatched_(handle,uplo,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZsymvStridedBatched_rank_0(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZsymvStridedBatched_rank_0 = hipblasZsymvStridedBatched_(handle,uplo,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZsymvStridedBatched_rank_1(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZsymvStridedBatched_rank_1 = hipblasZsymvStridedBatched_(handle,uplo,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCsymvStridedBatched_v2_rank_0(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymvStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCsymvStridedBatched_v2_rank_0 = hipblasCsymvStridedBatched_v2_(handle,uplo,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasCsymvStridedBatched_v2_rank_1(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsymvStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex) :: beta
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasCsymvStridedBatched_v2_rank_1 = hipblasCsymvStridedBatched_v2_(handle,uplo,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZsymvStridedBatched_v2_rank_0(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymvStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZsymvStridedBatched_v2_rank_0 = hipblasZsymvStridedBatched_v2_(handle,uplo,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasZsymvStridedBatched_v2_rank_1(handle,uplo,n,alpha,AP,lda,strideA,x,incx,stridex,beta,y,incy,stridey,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsymvStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex) :: beta
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      integer(c_int) :: batchCount
      !
      hipblasZsymvStridedBatched_v2_rank_1 = hipblasZsymvStridedBatched_v2_(handle,uplo,n,alpha,AP,lda,strideA,c_loc(x),incx,stridex,beta,c_loc(y),incy,stridey,batchCount)
    end function

    function hipblasSsyr_rank_0(handle,uplo,n,alpha,x,incx,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasSsyr_rank_0 = hipblasSsyr_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda)
    end function

    function hipblasSsyr_rank_1(handle,uplo,n,alpha,x,incx,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasSsyr_rank_1 = hipblasSsyr_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda)
    end function

    function hipblasDsyr_rank_0(handle,uplo,n,alpha,x,incx,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasDsyr_rank_0 = hipblasDsyr_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda)
    end function

    function hipblasDsyr_rank_1(handle,uplo,n,alpha,x,incx,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasDsyr_rank_1 = hipblasDsyr_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda)
    end function

    function hipblasCsyr_rank_0(handle,uplo,n,alpha,x,incx,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasCsyr_rank_0 = hipblasCsyr_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda)
    end function

    function hipblasCsyr_rank_1(handle,uplo,n,alpha,x,incx,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasCsyr_rank_1 = hipblasCsyr_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda)
    end function

    function hipblasZsyr_rank_0(handle,uplo,n,alpha,x,incx,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasZsyr_rank_0 = hipblasZsyr_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda)
    end function

    function hipblasZsyr_rank_1(handle,uplo,n,alpha,x,incx,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasZsyr_rank_1 = hipblasZsyr_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda)
    end function

    function hipblasCsyr_v2_rank_0(handle,uplo,n,alpha,x,incx,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasCsyr_v2_rank_0 = hipblasCsyr_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda)
    end function

    function hipblasCsyr_v2_rank_1(handle,uplo,n,alpha,x,incx,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasCsyr_v2_rank_1 = hipblasCsyr_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda)
    end function

    function hipblasZsyr_v2_rank_0(handle,uplo,n,alpha,x,incx,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasZsyr_v2_rank_0 = hipblasZsyr_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda)
    end function

    function hipblasZsyr_v2_rank_1(handle,uplo,n,alpha,x,incx,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasZsyr_v2_rank_1 = hipblasZsyr_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda)
    end function

    function hipblasSsyrBatched_full_rank(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasSsyrBatched_full_rank = hipblasSsyrBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasSsyrBatched_rank_0(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasSsyrBatched_rank_0 = hipblasSsyrBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasSsyrBatched_rank_1(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasSsyrBatched_rank_1 = hipblasSsyrBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasDsyrBatched_full_rank(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasDsyrBatched_full_rank = hipblasDsyrBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasDsyrBatched_rank_0(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasDsyrBatched_rank_0 = hipblasDsyrBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasDsyrBatched_rank_1(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasDsyrBatched_rank_1 = hipblasDsyrBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasCsyrBatched_full_rank(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCsyrBatched_full_rank = hipblasCsyrBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasCsyrBatched_rank_0(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCsyrBatched_rank_0 = hipblasCsyrBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasCsyrBatched_rank_1(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCsyrBatched_rank_1 = hipblasCsyrBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasZsyrBatched_full_rank(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZsyrBatched_full_rank = hipblasZsyrBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasZsyrBatched_rank_0(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZsyrBatched_rank_0 = hipblasZsyrBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasZsyrBatched_rank_1(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZsyrBatched_rank_1 = hipblasZsyrBatched_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasCsyrBatched_v2_full_rank(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCsyrBatched_v2_full_rank = hipblasCsyrBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasCsyrBatched_v2_rank_0(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCsyrBatched_v2_rank_0 = hipblasCsyrBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasCsyrBatched_v2_rank_1(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCsyrBatched_v2_rank_1 = hipblasCsyrBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasZsyrBatched_v2_full_rank(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZsyrBatched_v2_full_rank = hipblasZsyrBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasZsyrBatched_v2_rank_0(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZsyrBatched_v2_rank_0 = hipblasZsyrBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasZsyrBatched_v2_rank_1(handle,uplo,n,alpha,x,incx,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZsyrBatched_v2_rank_1 = hipblasZsyrBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,AP,lda,batchCount)
    end function

    function hipblasSsyrStridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasSsyrStridedBatched_rank_0 = hipblasSsyrStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,lda,strideA,batchCount)
    end function

    function hipblasSsyrStridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyrStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasSsyrStridedBatched_rank_1 = hipblasSsyrStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,lda,strideA,batchCount)
    end function

    function hipblasDsyrStridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasDsyrStridedBatched_rank_0 = hipblasDsyrStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,lda,strideA,batchCount)
    end function

    function hipblasDsyrStridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyrStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasDsyrStridedBatched_rank_1 = hipblasDsyrStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,lda,strideA,batchCount)
    end function

    function hipblasCsyrStridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCsyrStridedBatched_rank_0 = hipblasCsyrStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,lda,strideA,batchCount)
    end function

    function hipblasCsyrStridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCsyrStridedBatched_rank_1 = hipblasCsyrStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,lda,strideA,batchCount)
    end function

    function hipblasZsyrStridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZsyrStridedBatched_rank_0 = hipblasZsyrStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,lda,strideA,batchCount)
    end function

    function hipblasZsyrStridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZsyrStridedBatched_rank_1 = hipblasZsyrStridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,lda,strideA,batchCount)
    end function

    function hipblasCsyrStridedBatched_v2_rank_0(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCsyrStridedBatched_v2_rank_0 = hipblasCsyrStridedBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,lda,strideA,batchCount)
    end function

    function hipblasCsyrStridedBatched_v2_rank_1(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyrStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCsyrStridedBatched_v2_rank_1 = hipblasCsyrStridedBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,lda,strideA,batchCount)
    end function

    function hipblasZsyrStridedBatched_v2_rank_0(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZsyrStridedBatched_v2_rank_0 = hipblasZsyrStridedBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,lda,strideA,batchCount)
    end function

    function hipblasZsyrStridedBatched_v2_rank_1(handle,uplo,n,alpha,x,incx,stridex,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyrStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZsyrStridedBatched_v2_rank_1 = hipblasZsyrStridedBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,stridex,AP,lda,strideA,batchCount)
    end function

    function hipblasSsyr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasSsyr2_rank_0 = hipblasSsyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasSsyr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasSsyr2_rank_1 = hipblasSsyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasDsyr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasDsyr2_rank_0 = hipblasDsyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasDsyr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasDsyr2_rank_1 = hipblasDsyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasCsyr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasCsyr2_rank_0 = hipblasCsyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasCsyr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasCsyr2_rank_1 = hipblasCsyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasZsyr2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasZsyr2_rank_0 = hipblasZsyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasZsyr2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasZsyr2_rank_1 = hipblasZsyr2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasCsyr2_v2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasCsyr2_v2_rank_0 = hipblasCsyr2_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasCsyr2_v2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasCsyr2_v2_rank_1 = hipblasCsyr2_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasZsyr2_v2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasZsyr2_v2_rank_0 = hipblasZsyr2_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasZsyr2_v2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,lda)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      !
      hipblasZsyr2_v2_rank_1 = hipblasZsyr2_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda)
    end function

    function hipblasSsyr2Batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2Batched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasSsyr2Batched_full_rank = hipblasSsyr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasSsyr2Batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2Batched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      real(c_float),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasSsyr2Batched_rank_0 = hipblasSsyr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasSsyr2Batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2Batched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasSsyr2Batched_rank_1 = hipblasSsyr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasDsyr2Batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2Batched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasDsyr2Batched_full_rank = hipblasDsyr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasDsyr2Batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2Batched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      real(c_double),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasDsyr2Batched_rank_0 = hipblasDsyr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasDsyr2Batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2Batched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasDsyr2Batched_rank_1 = hipblasDsyr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasCsyr2Batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2Batched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCsyr2Batched_full_rank = hipblasCsyr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasCsyr2Batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2Batched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCsyr2Batched_rank_0 = hipblasCsyr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasCsyr2Batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2Batched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCsyr2Batched_rank_1 = hipblasCsyr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasZsyr2Batched_full_rank(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2Batched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZsyr2Batched_full_rank = hipblasZsyr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasZsyr2Batched_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2Batched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZsyr2Batched_rank_0 = hipblasZsyr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasZsyr2Batched_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2Batched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZsyr2Batched_rank_1 = hipblasZsyr2Batched_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasCsyr2Batched_v2_full_rank(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2Batched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCsyr2Batched_v2_full_rank = hipblasCsyr2Batched_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasCsyr2Batched_v2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2Batched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCsyr2Batched_v2_rank_0 = hipblasCsyr2Batched_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasCsyr2Batched_v2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2Batched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasCsyr2Batched_v2_rank_1 = hipblasCsyr2Batched_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasZsyr2Batched_v2_full_rank(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2Batched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:,:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZsyr2Batched_v2_full_rank = hipblasZsyr2Batched_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasZsyr2Batched_v2_rank_0(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2Batched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZsyr2Batched_v2_rank_0 = hipblasZsyr2Batched_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasZsyr2Batched_v2_rank_1(handle,uplo,n,alpha,x,incx,y,incy,AP,lda,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2Batched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int) :: batchCount
      !
      hipblasZsyr2Batched_v2_rank_1 = hipblasZsyr2Batched_v2_(handle,uplo,n,alpha,c_loc(x),incx,c_loc(y),incy,AP,lda,batchCount)
    end function

    function hipblasSsyr2StridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2StridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasSsyr2StridedBatched_rank_0 = hipblasSsyr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasSsyr2StridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSsyr2StridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_float),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasSsyr2StridedBatched_rank_1 = hipblasSsyr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasDsyr2StridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2StridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasDsyr2StridedBatched_rank_0 = hipblasDsyr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasDsyr2StridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDsyr2StridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      real(c_double),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasDsyr2StridedBatched_rank_1 = hipblasDsyr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasCsyr2StridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2StridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCsyr2StridedBatched_rank_0 = hipblasCsyr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasCsyr2StridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2StridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCsyr2StridedBatched_rank_1 = hipblasCsyr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasZsyr2StridedBatched_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2StridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZsyr2StridedBatched_rank_0 = hipblasZsyr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasZsyr2StridedBatched_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2StridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZsyr2StridedBatched_rank_1 = hipblasZsyr2StridedBatched_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasCsyr2StridedBatched_v2_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2StridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCsyr2StridedBatched_v2_rank_0 = hipblasCsyr2StridedBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasCsyr2StridedBatched_v2_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCsyr2StridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_float_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasCsyr2StridedBatched_v2_rank_1 = hipblasCsyr2StridedBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasZsyr2StridedBatched_v2_rank_0(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2StridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZsyr2StridedBatched_v2_rank_0 = hipblasZsyr2StridedBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasZsyr2StridedBatched_v2_rank_1(handle,uplo,n,alpha,x,incx,stridex,y,incy,stridey,AP,lda,strideA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZsyr2StridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      complex(c_double_complex),target,dimension(:) :: y
      integer(c_int) :: incy
      integer(c_int64_t) :: stridey
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      integer(c_int) :: batchCount
      !
      hipblasZsyr2StridedBatched_v2_rank_1 = hipblasZsyr2StridedBatched_v2_(handle,uplo,n,alpha,c_loc(x),incx,stridex,c_loc(y),incy,stridey,AP,lda,strideA,batchCount)
    end function

    function hipblasStbmv_rank_0(handle,uplo,transA,diag,n,k,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      !
      hipblasStbmv_rank_0 = hipblasStbmv_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx)
    end function

    function hipblasStbmv_rank_1(handle,uplo,transA,diag,n,k,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasStbmv_rank_1 = hipblasStbmv_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx)
    end function

    function hipblasDtbmv_rank_0(handle,uplo,transA,diag,n,k,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      !
      hipblasDtbmv_rank_0 = hipblasDtbmv_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx)
    end function

    function hipblasDtbmv_rank_1(handle,uplo,transA,diag,n,k,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasDtbmv_rank_1 = hipblasDtbmv_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx)
    end function

    function hipblasCtbmv_rank_0(handle,uplo,transA,diag,n,k,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasCtbmv_rank_0 = hipblasCtbmv_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx)
    end function

    function hipblasCtbmv_rank_1(handle,uplo,transA,diag,n,k,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasCtbmv_rank_1 = hipblasCtbmv_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx)
    end function

    function hipblasZtbmv_rank_0(handle,uplo,transA,diag,n,k,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasZtbmv_rank_0 = hipblasZtbmv_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx)
    end function

    function hipblasZtbmv_rank_1(handle,uplo,transA,diag,n,k,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasZtbmv_rank_1 = hipblasZtbmv_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx)
    end function

    function hipblasCtbmv_v2_rank_0(handle,uplo,transA,diag,n,k,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmv_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasCtbmv_v2_rank_0 = hipblasCtbmv_v2_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx)
    end function

    function hipblasCtbmv_v2_rank_1(handle,uplo,transA,diag,n,k,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmv_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasCtbmv_v2_rank_1 = hipblasCtbmv_v2_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx)
    end function

    function hipblasZtbmv_v2_rank_0(handle,uplo,transA,diag,n,k,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmv_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasZtbmv_v2_rank_0 = hipblasZtbmv_v2_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx)
    end function

    function hipblasZtbmv_v2_rank_1(handle,uplo,transA,diag,n,k,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmv_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasZtbmv_v2_rank_1 = hipblasZtbmv_v2_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx)
    end function

    function hipblasStbmvBatched_full_rank(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStbmvBatched_full_rank = hipblasStbmvBatched_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasStbmvBatched_rank_0(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStbmvBatched_rank_0 = hipblasStbmvBatched_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasStbmvBatched_rank_1(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStbmvBatched_rank_1 = hipblasStbmvBatched_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasDtbmvBatched_full_rank(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtbmvBatched_full_rank = hipblasDtbmvBatched_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasDtbmvBatched_rank_0(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtbmvBatched_rank_0 = hipblasDtbmvBatched_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasDtbmvBatched_rank_1(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtbmvBatched_rank_1 = hipblasDtbmvBatched_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtbmvBatched_full_rank(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtbmvBatched_full_rank = hipblasCtbmvBatched_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtbmvBatched_rank_0(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtbmvBatched_rank_0 = hipblasCtbmvBatched_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtbmvBatched_rank_1(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtbmvBatched_rank_1 = hipblasCtbmvBatched_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtbmvBatched_full_rank(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtbmvBatched_full_rank = hipblasZtbmvBatched_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtbmvBatched_rank_0(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtbmvBatched_rank_0 = hipblasZtbmvBatched_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtbmvBatched_rank_1(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtbmvBatched_rank_1 = hipblasZtbmvBatched_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtbmvBatched_v2_full_rank(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmvBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtbmvBatched_v2_full_rank = hipblasCtbmvBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtbmvBatched_v2_rank_0(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmvBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtbmvBatched_v2_rank_0 = hipblasCtbmvBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtbmvBatched_v2_rank_1(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmvBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtbmvBatched_v2_rank_1 = hipblasCtbmvBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtbmvBatched_v2_full_rank(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmvBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtbmvBatched_v2_full_rank = hipblasZtbmvBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtbmvBatched_v2_rank_0(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmvBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtbmvBatched_v2_rank_0 = hipblasZtbmvBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtbmvBatched_v2_rank_1(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmvBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtbmvBatched_v2_rank_1 = hipblasZtbmvBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasStbmvStridedBatched_rank_0(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasStbmvStridedBatched_rank_0 = hipblasStbmvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasStbmvStridedBatched_rank_1(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasStbmvStridedBatched_rank_1 = hipblasStbmvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDtbmvStridedBatched_rank_0(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDtbmvStridedBatched_rank_0 = hipblasDtbmvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDtbmvStridedBatched_rank_1(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDtbmvStridedBatched_rank_1 = hipblasDtbmvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtbmvStridedBatched_rank_0(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtbmvStridedBatched_rank_0 = hipblasCtbmvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtbmvStridedBatched_rank_1(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtbmvStridedBatched_rank_1 = hipblasCtbmvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtbmvStridedBatched_rank_0(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtbmvStridedBatched_rank_0 = hipblasZtbmvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtbmvStridedBatched_rank_1(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtbmvStridedBatched_rank_1 = hipblasZtbmvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtbmvStridedBatched_v2_rank_0(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmvStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtbmvStridedBatched_v2_rank_0 = hipblasCtbmvStridedBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtbmvStridedBatched_v2_rank_1(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbmvStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtbmvStridedBatched_v2_rank_1 = hipblasCtbmvStridedBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtbmvStridedBatched_v2_rank_0(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmvStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtbmvStridedBatched_v2_rank_0 = hipblasZtbmvStridedBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtbmvStridedBatched_v2_rank_1(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbmvStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtbmvStridedBatched_v2_rank_1 = hipblasZtbmvStridedBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasStbsv_rank_0(handle,uplo,transA,diag,n,k,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbsv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      !
      hipblasStbsv_rank_0 = hipblasStbsv_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx)
    end function

    function hipblasStbsv_rank_1(handle,uplo,transA,diag,n,k,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbsv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasStbsv_rank_1 = hipblasStbsv_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx)
    end function

    function hipblasDtbsv_rank_0(handle,uplo,transA,diag,n,k,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbsv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      !
      hipblasDtbsv_rank_0 = hipblasDtbsv_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx)
    end function

    function hipblasDtbsv_rank_1(handle,uplo,transA,diag,n,k,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbsv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasDtbsv_rank_1 = hipblasDtbsv_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx)
    end function

    function hipblasCtbsv_rank_0(handle,uplo,transA,diag,n,k,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasCtbsv_rank_0 = hipblasCtbsv_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx)
    end function

    function hipblasCtbsv_rank_1(handle,uplo,transA,diag,n,k,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasCtbsv_rank_1 = hipblasCtbsv_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx)
    end function

    function hipblasZtbsv_rank_0(handle,uplo,transA,diag,n,k,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasZtbsv_rank_0 = hipblasZtbsv_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx)
    end function

    function hipblasZtbsv_rank_1(handle,uplo,transA,diag,n,k,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasZtbsv_rank_1 = hipblasZtbsv_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx)
    end function

    function hipblasCtbsv_v2_rank_0(handle,uplo,transA,diag,n,k,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsv_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasCtbsv_v2_rank_0 = hipblasCtbsv_v2_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx)
    end function

    function hipblasCtbsv_v2_rank_1(handle,uplo,transA,diag,n,k,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsv_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasCtbsv_v2_rank_1 = hipblasCtbsv_v2_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx)
    end function

    function hipblasZtbsv_v2_rank_0(handle,uplo,transA,diag,n,k,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsv_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasZtbsv_v2_rank_0 = hipblasZtbsv_v2_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx)
    end function

    function hipblasZtbsv_v2_rank_1(handle,uplo,transA,diag,n,k,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsv_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasZtbsv_v2_rank_1 = hipblasZtbsv_v2_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx)
    end function

    function hipblasStbsvBatched_full_rank(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbsvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStbsvBatched_full_rank = hipblasStbsvBatched_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasStbsvBatched_rank_0(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbsvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStbsvBatched_rank_0 = hipblasStbsvBatched_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasStbsvBatched_rank_1(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbsvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStbsvBatched_rank_1 = hipblasStbsvBatched_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasDtbsvBatched_full_rank(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbsvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtbsvBatched_full_rank = hipblasDtbsvBatched_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasDtbsvBatched_rank_0(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbsvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtbsvBatched_rank_0 = hipblasDtbsvBatched_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasDtbsvBatched_rank_1(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbsvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtbsvBatched_rank_1 = hipblasDtbsvBatched_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtbsvBatched_full_rank(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtbsvBatched_full_rank = hipblasCtbsvBatched_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtbsvBatched_rank_0(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtbsvBatched_rank_0 = hipblasCtbsvBatched_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtbsvBatched_rank_1(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtbsvBatched_rank_1 = hipblasCtbsvBatched_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtbsvBatched_full_rank(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtbsvBatched_full_rank = hipblasZtbsvBatched_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtbsvBatched_rank_0(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtbsvBatched_rank_0 = hipblasZtbsvBatched_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtbsvBatched_rank_1(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtbsvBatched_rank_1 = hipblasZtbsvBatched_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtbsvBatched_v2_full_rank(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsvBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtbsvBatched_v2_full_rank = hipblasCtbsvBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtbsvBatched_v2_rank_0(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsvBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtbsvBatched_v2_rank_0 = hipblasCtbsvBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtbsvBatched_v2_rank_1(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsvBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtbsvBatched_v2_rank_1 = hipblasCtbsvBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtbsvBatched_v2_full_rank(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsvBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtbsvBatched_v2_full_rank = hipblasZtbsvBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtbsvBatched_v2_rank_0(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsvBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtbsvBatched_v2_rank_0 = hipblasZtbsvBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtbsvBatched_v2_rank_1(handle,uplo,transA,diag,n,k,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsvBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtbsvBatched_v2_rank_1 = hipblasZtbsvBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasStbsvStridedBatched_rank_0(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbsvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasStbsvStridedBatched_rank_0 = hipblasStbsvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasStbsvStridedBatched_rank_1(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStbsvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasStbsvStridedBatched_rank_1 = hipblasStbsvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDtbsvStridedBatched_rank_0(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbsvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDtbsvStridedBatched_rank_0 = hipblasDtbsvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDtbsvStridedBatched_rank_1(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtbsvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDtbsvStridedBatched_rank_1 = hipblasDtbsvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtbsvStridedBatched_rank_0(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtbsvStridedBatched_rank_0 = hipblasCtbsvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtbsvStridedBatched_rank_1(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtbsvStridedBatched_rank_1 = hipblasCtbsvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtbsvStridedBatched_rank_0(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtbsvStridedBatched_rank_0 = hipblasZtbsvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtbsvStridedBatched_rank_1(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtbsvStridedBatched_rank_1 = hipblasZtbsvStridedBatched_(handle,uplo,transA,diag,n,k,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtbsvStridedBatched_v2_rank_0(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsvStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtbsvStridedBatched_v2_rank_0 = hipblasCtbsvStridedBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtbsvStridedBatched_v2_rank_1(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtbsvStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtbsvStridedBatched_v2_rank_1 = hipblasCtbsvStridedBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtbsvStridedBatched_v2_rank_0(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsvStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtbsvStridedBatched_v2_rank_0 = hipblasZtbsvStridedBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtbsvStridedBatched_v2_rank_1(handle,uplo,transA,diag,n,k,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtbsvStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      integer(c_int) :: k
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtbsvStridedBatched_v2_rank_1 = hipblasZtbsvStridedBatched_v2_(handle,uplo,transA,diag,n,k,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasStpmv_rank_0(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_float),target :: x
      integer(c_int) :: incx
      !
      hipblasStpmv_rank_0 = hipblasStpmv_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function hipblasStpmv_rank_1(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasStpmv_rank_1 = hipblasStpmv_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function hipblasDtpmv_rank_0(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_double),target :: x
      integer(c_int) :: incx
      !
      hipblasDtpmv_rank_0 = hipblasDtpmv_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function hipblasDtpmv_rank_1(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasDtpmv_rank_1 = hipblasDtpmv_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function hipblasCtpmv_rank_0(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasCtpmv_rank_0 = hipblasCtpmv_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function hipblasCtpmv_rank_1(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasCtpmv_rank_1 = hipblasCtpmv_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function hipblasZtpmv_rank_0(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasZtpmv_rank_0 = hipblasZtpmv_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function hipblasZtpmv_rank_1(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasZtpmv_rank_1 = hipblasZtpmv_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function hipblasCtpmv_v2_rank_0(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmv_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasCtpmv_v2_rank_0 = hipblasCtpmv_v2_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function hipblasCtpmv_v2_rank_1(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmv_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasCtpmv_v2_rank_1 = hipblasCtpmv_v2_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function hipblasZtpmv_v2_rank_0(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmv_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasZtpmv_v2_rank_0 = hipblasZtpmv_v2_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function hipblasZtpmv_v2_rank_1(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmv_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasZtpmv_v2_rank_1 = hipblasZtpmv_v2_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function hipblasStpmvBatched_full_rank(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStpmvBatched_full_rank = hipblasStpmvBatched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasStpmvBatched_rank_0(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStpmvBatched_rank_0 = hipblasStpmvBatched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasStpmvBatched_rank_1(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStpmvBatched_rank_1 = hipblasStpmvBatched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasDtpmvBatched_full_rank(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtpmvBatched_full_rank = hipblasDtpmvBatched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasDtpmvBatched_rank_0(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtpmvBatched_rank_0 = hipblasDtpmvBatched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasDtpmvBatched_rank_1(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtpmvBatched_rank_1 = hipblasDtpmvBatched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasCtpmvBatched_full_rank(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtpmvBatched_full_rank = hipblasCtpmvBatched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasCtpmvBatched_rank_0(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtpmvBatched_rank_0 = hipblasCtpmvBatched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasCtpmvBatched_rank_1(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtpmvBatched_rank_1 = hipblasCtpmvBatched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasZtpmvBatched_full_rank(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtpmvBatched_full_rank = hipblasZtpmvBatched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasZtpmvBatched_rank_0(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtpmvBatched_rank_0 = hipblasZtpmvBatched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasZtpmvBatched_rank_1(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtpmvBatched_rank_1 = hipblasZtpmvBatched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasCtpmvBatched_v2_full_rank(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmvBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtpmvBatched_v2_full_rank = hipblasCtpmvBatched_v2_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasCtpmvBatched_v2_rank_0(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmvBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtpmvBatched_v2_rank_0 = hipblasCtpmvBatched_v2_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasCtpmvBatched_v2_rank_1(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmvBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtpmvBatched_v2_rank_1 = hipblasCtpmvBatched_v2_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasZtpmvBatched_v2_full_rank(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmvBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtpmvBatched_v2_full_rank = hipblasZtpmvBatched_v2_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasZtpmvBatched_v2_rank_0(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmvBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtpmvBatched_v2_rank_0 = hipblasZtpmvBatched_v2_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasZtpmvBatched_v2_rank_1(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmvBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtpmvBatched_v2_rank_1 = hipblasZtpmvBatched_v2_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasStpmvStridedBatched_rank_0(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasStpmvStridedBatched_rank_0 = hipblasStpmvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasStpmvStridedBatched_rank_1(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasStpmvStridedBatched_rank_1 = hipblasStpmvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDtpmvStridedBatched_rank_0(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDtpmvStridedBatched_rank_0 = hipblasDtpmvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDtpmvStridedBatched_rank_1(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDtpmvStridedBatched_rank_1 = hipblasDtpmvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtpmvStridedBatched_rank_0(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtpmvStridedBatched_rank_0 = hipblasCtpmvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtpmvStridedBatched_rank_1(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtpmvStridedBatched_rank_1 = hipblasCtpmvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtpmvStridedBatched_rank_0(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtpmvStridedBatched_rank_0 = hipblasZtpmvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtpmvStridedBatched_rank_1(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtpmvStridedBatched_rank_1 = hipblasZtpmvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtpmvStridedBatched_v2_rank_0(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmvStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtpmvStridedBatched_v2_rank_0 = hipblasCtpmvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtpmvStridedBatched_v2_rank_1(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpmvStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtpmvStridedBatched_v2_rank_1 = hipblasCtpmvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtpmvStridedBatched_v2_rank_0(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmvStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtpmvStridedBatched_v2_rank_0 = hipblasZtpmvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtpmvStridedBatched_v2_rank_1(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpmvStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtpmvStridedBatched_v2_rank_1 = hipblasZtpmvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasStpsv_rank_0(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpsv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_float),target :: x
      integer(c_int) :: incx
      !
      hipblasStpsv_rank_0 = hipblasStpsv_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function hipblasStpsv_rank_1(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpsv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasStpsv_rank_1 = hipblasStpsv_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function hipblasDtpsv_rank_0(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpsv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_double),target :: x
      integer(c_int) :: incx
      !
      hipblasDtpsv_rank_0 = hipblasDtpsv_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function hipblasDtpsv_rank_1(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpsv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasDtpsv_rank_1 = hipblasDtpsv_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function hipblasCtpsv_rank_0(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasCtpsv_rank_0 = hipblasCtpsv_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function hipblasCtpsv_rank_1(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasCtpsv_rank_1 = hipblasCtpsv_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function hipblasZtpsv_rank_0(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasZtpsv_rank_0 = hipblasZtpsv_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function hipblasZtpsv_rank_1(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasZtpsv_rank_1 = hipblasZtpsv_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function hipblasCtpsv_v2_rank_0(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsv_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasCtpsv_v2_rank_0 = hipblasCtpsv_v2_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function hipblasCtpsv_v2_rank_1(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsv_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasCtpsv_v2_rank_1 = hipblasCtpsv_v2_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function hipblasZtpsv_v2_rank_0(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsv_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasZtpsv_v2_rank_0 = hipblasZtpsv_v2_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function hipblasZtpsv_v2_rank_1(handle,uplo,transA,diag,n,AP,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsv_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasZtpsv_v2_rank_1 = hipblasZtpsv_v2_(handle,uplo,transA,diag,n,AP,c_loc(x),incx)
    end function

    function hipblasStpsvBatched_full_rank(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpsvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStpsvBatched_full_rank = hipblasStpsvBatched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasStpsvBatched_rank_0(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpsvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStpsvBatched_rank_0 = hipblasStpsvBatched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasStpsvBatched_rank_1(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpsvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStpsvBatched_rank_1 = hipblasStpsvBatched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasDtpsvBatched_full_rank(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpsvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtpsvBatched_full_rank = hipblasDtpsvBatched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasDtpsvBatched_rank_0(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpsvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtpsvBatched_rank_0 = hipblasDtpsvBatched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasDtpsvBatched_rank_1(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpsvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtpsvBatched_rank_1 = hipblasDtpsvBatched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasCtpsvBatched_full_rank(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtpsvBatched_full_rank = hipblasCtpsvBatched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasCtpsvBatched_rank_0(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtpsvBatched_rank_0 = hipblasCtpsvBatched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasCtpsvBatched_rank_1(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtpsvBatched_rank_1 = hipblasCtpsvBatched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasZtpsvBatched_full_rank(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtpsvBatched_full_rank = hipblasZtpsvBatched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasZtpsvBatched_rank_0(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtpsvBatched_rank_0 = hipblasZtpsvBatched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasZtpsvBatched_rank_1(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtpsvBatched_rank_1 = hipblasZtpsvBatched_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasCtpsvBatched_v2_full_rank(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsvBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtpsvBatched_v2_full_rank = hipblasCtpsvBatched_v2_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasCtpsvBatched_v2_rank_0(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsvBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtpsvBatched_v2_rank_0 = hipblasCtpsvBatched_v2_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasCtpsvBatched_v2_rank_1(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsvBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtpsvBatched_v2_rank_1 = hipblasCtpsvBatched_v2_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasZtpsvBatched_v2_full_rank(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsvBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtpsvBatched_v2_full_rank = hipblasZtpsvBatched_v2_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasZtpsvBatched_v2_rank_0(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsvBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtpsvBatched_v2_rank_0 = hipblasZtpsvBatched_v2_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasZtpsvBatched_v2_rank_1(handle,uplo,transA,diag,n,AP,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsvBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtpsvBatched_v2_rank_1 = hipblasZtpsvBatched_v2_(handle,uplo,transA,diag,n,AP,c_loc(x),incx,batchCount)
    end function

    function hipblasStpsvStridedBatched_rank_0(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpsvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasStpsvStridedBatched_rank_0 = hipblasStpsvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasStpsvStridedBatched_rank_1(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStpsvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasStpsvStridedBatched_rank_1 = hipblasStpsvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDtpsvStridedBatched_rank_0(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpsvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDtpsvStridedBatched_rank_0 = hipblasDtpsvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDtpsvStridedBatched_rank_1(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtpsvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDtpsvStridedBatched_rank_1 = hipblasDtpsvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtpsvStridedBatched_rank_0(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtpsvStridedBatched_rank_0 = hipblasCtpsvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtpsvStridedBatched_rank_1(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtpsvStridedBatched_rank_1 = hipblasCtpsvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtpsvStridedBatched_rank_0(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtpsvStridedBatched_rank_0 = hipblasZtpsvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtpsvStridedBatched_rank_1(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtpsvStridedBatched_rank_1 = hipblasZtpsvStridedBatched_(handle,uplo,transA,diag,n,AP,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtpsvStridedBatched_v2_rank_0(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsvStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtpsvStridedBatched_v2_rank_0 = hipblasCtpsvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtpsvStridedBatched_v2_rank_1(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtpsvStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtpsvStridedBatched_v2_rank_1 = hipblasCtpsvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtpsvStridedBatched_v2_rank_0(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsvStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtpsvStridedBatched_v2_rank_0 = hipblasZtpsvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtpsvStridedBatched_v2_rank_1(handle,uplo,transA,diag,n,AP,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtpsvStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtpsvStridedBatched_v2_rank_1 = hipblasZtpsvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasStrmv_rank_0(handle,uplo,transA,diag,n,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      !
      hipblasStrmv_rank_0 = hipblasStrmv_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx)
    end function

    function hipblasStrmv_rank_1(handle,uplo,transA,diag,n,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasStrmv_rank_1 = hipblasStrmv_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx)
    end function

    function hipblasDtrmv_rank_0(handle,uplo,transA,diag,n,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      !
      hipblasDtrmv_rank_0 = hipblasDtrmv_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx)
    end function

    function hipblasDtrmv_rank_1(handle,uplo,transA,diag,n,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasDtrmv_rank_1 = hipblasDtrmv_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx)
    end function

    function hipblasCtrmv_rank_0(handle,uplo,transA,diag,n,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasCtrmv_rank_0 = hipblasCtrmv_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx)
    end function

    function hipblasCtrmv_rank_1(handle,uplo,transA,diag,n,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasCtrmv_rank_1 = hipblasCtrmv_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx)
    end function

    function hipblasZtrmv_rank_0(handle,uplo,transA,diag,n,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasZtrmv_rank_0 = hipblasZtrmv_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx)
    end function

    function hipblasZtrmv_rank_1(handle,uplo,transA,diag,n,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasZtrmv_rank_1 = hipblasZtrmv_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx)
    end function

    function hipblasCtrmv_v2_rank_0(handle,uplo,transA,diag,n,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmv_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasCtrmv_v2_rank_0 = hipblasCtrmv_v2_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx)
    end function

    function hipblasCtrmv_v2_rank_1(handle,uplo,transA,diag,n,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmv_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasCtrmv_v2_rank_1 = hipblasCtrmv_v2_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx)
    end function

    function hipblasZtrmv_v2_rank_0(handle,uplo,transA,diag,n,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmv_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasZtrmv_v2_rank_0 = hipblasZtrmv_v2_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx)
    end function

    function hipblasZtrmv_v2_rank_1(handle,uplo,transA,diag,n,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmv_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasZtrmv_v2_rank_1 = hipblasZtrmv_v2_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx)
    end function

    function hipblasStrmvBatched_full_rank(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStrmvBatched_full_rank = hipblasStrmvBatched_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasStrmvBatched_rank_0(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStrmvBatched_rank_0 = hipblasStrmvBatched_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasStrmvBatched_rank_1(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStrmvBatched_rank_1 = hipblasStrmvBatched_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasDtrmvBatched_full_rank(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtrmvBatched_full_rank = hipblasDtrmvBatched_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasDtrmvBatched_rank_0(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtrmvBatched_rank_0 = hipblasDtrmvBatched_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasDtrmvBatched_rank_1(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtrmvBatched_rank_1 = hipblasDtrmvBatched_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtrmvBatched_full_rank(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtrmvBatched_full_rank = hipblasCtrmvBatched_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtrmvBatched_rank_0(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtrmvBatched_rank_0 = hipblasCtrmvBatched_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtrmvBatched_rank_1(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtrmvBatched_rank_1 = hipblasCtrmvBatched_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtrmvBatched_full_rank(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtrmvBatched_full_rank = hipblasZtrmvBatched_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtrmvBatched_rank_0(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtrmvBatched_rank_0 = hipblasZtrmvBatched_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtrmvBatched_rank_1(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtrmvBatched_rank_1 = hipblasZtrmvBatched_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtrmvBatched_v2_full_rank(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmvBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtrmvBatched_v2_full_rank = hipblasCtrmvBatched_v2_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtrmvBatched_v2_rank_0(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmvBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtrmvBatched_v2_rank_0 = hipblasCtrmvBatched_v2_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtrmvBatched_v2_rank_1(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmvBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtrmvBatched_v2_rank_1 = hipblasCtrmvBatched_v2_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtrmvBatched_v2_full_rank(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmvBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtrmvBatched_v2_full_rank = hipblasZtrmvBatched_v2_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtrmvBatched_v2_rank_0(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmvBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtrmvBatched_v2_rank_0 = hipblasZtrmvBatched_v2_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtrmvBatched_v2_rank_1(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmvBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtrmvBatched_v2_rank_1 = hipblasZtrmvBatched_v2_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasStrmvStridedBatched_rank_0(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasStrmvStridedBatched_rank_0 = hipblasStrmvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasStrmvStridedBatched_rank_1(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasStrmvStridedBatched_rank_1 = hipblasStrmvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDtrmvStridedBatched_rank_0(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDtrmvStridedBatched_rank_0 = hipblasDtrmvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDtrmvStridedBatched_rank_1(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDtrmvStridedBatched_rank_1 = hipblasDtrmvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtrmvStridedBatched_rank_0(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtrmvStridedBatched_rank_0 = hipblasCtrmvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtrmvStridedBatched_rank_1(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtrmvStridedBatched_rank_1 = hipblasCtrmvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtrmvStridedBatched_rank_0(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtrmvStridedBatched_rank_0 = hipblasZtrmvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtrmvStridedBatched_rank_1(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtrmvStridedBatched_rank_1 = hipblasZtrmvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtrmvStridedBatched_v2_rank_0(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmvStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtrmvStridedBatched_v2_rank_0 = hipblasCtrmvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtrmvStridedBatched_v2_rank_1(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmvStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtrmvStridedBatched_v2_rank_1 = hipblasCtrmvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtrmvStridedBatched_v2_rank_0(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmvStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtrmvStridedBatched_v2_rank_0 = hipblasZtrmvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtrmvStridedBatched_v2_rank_1(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmvStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtrmvStridedBatched_v2_rank_1 = hipblasZtrmvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasStrsv_rank_0(handle,uplo,transA,diag,n,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      !
      hipblasStrsv_rank_0 = hipblasStrsv_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx)
    end function

    function hipblasStrsv_rank_1(handle,uplo,transA,diag,n,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasStrsv_rank_1 = hipblasStrsv_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx)
    end function

    function hipblasDtrsv_rank_0(handle,uplo,transA,diag,n,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      !
      hipblasDtrsv_rank_0 = hipblasDtrsv_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx)
    end function

    function hipblasDtrsv_rank_1(handle,uplo,transA,diag,n,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasDtrsv_rank_1 = hipblasDtrsv_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx)
    end function

    function hipblasCtrsv_rank_0(handle,uplo,transA,diag,n,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasCtrsv_rank_0 = hipblasCtrsv_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx)
    end function

    function hipblasCtrsv_rank_1(handle,uplo,transA,diag,n,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasCtrsv_rank_1 = hipblasCtrsv_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx)
    end function

    function hipblasZtrsv_rank_0(handle,uplo,transA,diag,n,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsv_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasZtrsv_rank_0 = hipblasZtrsv_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx)
    end function

    function hipblasZtrsv_rank_1(handle,uplo,transA,diag,n,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsv_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasZtrsv_rank_1 = hipblasZtrsv_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx)
    end function

    function hipblasCtrsv_v2_rank_0(handle,uplo,transA,diag,n,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsv_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasCtrsv_v2_rank_0 = hipblasCtrsv_v2_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx)
    end function

    function hipblasCtrsv_v2_rank_1(handle,uplo,transA,diag,n,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsv_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasCtrsv_v2_rank_1 = hipblasCtrsv_v2_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx)
    end function

    function hipblasZtrsv_v2_rank_0(handle,uplo,transA,diag,n,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsv_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      !
      hipblasZtrsv_v2_rank_0 = hipblasZtrsv_v2_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx)
    end function

    function hipblasZtrsv_v2_rank_1(handle,uplo,transA,diag,n,AP,lda,x,incx)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsv_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      !
      hipblasZtrsv_v2_rank_1 = hipblasZtrsv_v2_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx)
    end function

    function hipblasStrsvBatched_full_rank(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStrsvBatched_full_rank = hipblasStrsvBatched_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasStrsvBatched_rank_0(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStrsvBatched_rank_0 = hipblasStrsvBatched_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasStrsvBatched_rank_1(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasStrsvBatched_rank_1 = hipblasStrsvBatched_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasDtrsvBatched_full_rank(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtrsvBatched_full_rank = hipblasDtrsvBatched_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasDtrsvBatched_rank_0(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtrsvBatched_rank_0 = hipblasDtrsvBatched_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasDtrsvBatched_rank_1(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasDtrsvBatched_rank_1 = hipblasDtrsvBatched_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtrsvBatched_full_rank(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtrsvBatched_full_rank = hipblasCtrsvBatched_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtrsvBatched_rank_0(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtrsvBatched_rank_0 = hipblasCtrsvBatched_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtrsvBatched_rank_1(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtrsvBatched_rank_1 = hipblasCtrsvBatched_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtrsvBatched_full_rank(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsvBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtrsvBatched_full_rank = hipblasZtrsvBatched_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtrsvBatched_rank_0(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsvBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtrsvBatched_rank_0 = hipblasZtrsvBatched_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtrsvBatched_rank_1(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsvBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtrsvBatched_rank_1 = hipblasZtrsvBatched_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtrsvBatched_v2_full_rank(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsvBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtrsvBatched_v2_full_rank = hipblasCtrsvBatched_v2_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtrsvBatched_v2_rank_0(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsvBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtrsvBatched_v2_rank_0 = hipblasCtrsvBatched_v2_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasCtrsvBatched_v2_rank_1(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsvBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasCtrsvBatched_v2_rank_1 = hipblasCtrsvBatched_v2_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtrsvBatched_v2_full_rank(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsvBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtrsvBatched_v2_full_rank = hipblasZtrsvBatched_v2_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtrsvBatched_v2_rank_0(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsvBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtrsvBatched_v2_rank_0 = hipblasZtrsvBatched_v2_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasZtrsvBatched_v2_rank_1(handle,uplo,transA,diag,n,AP,lda,x,incx,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsvBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int) :: batchCount
      !
      hipblasZtrsvBatched_v2_rank_1 = hipblasZtrsvBatched_v2_(handle,uplo,transA,diag,n,AP,lda,c_loc(x),incx,batchCount)
    end function

    function hipblasStrsvStridedBatched_rank_0(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasStrsvStridedBatched_rank_0 = hipblasStrsvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasStrsvStridedBatched_rank_1(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrsvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasStrsvStridedBatched_rank_1 = hipblasStrsvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDtrsvStridedBatched_rank_0(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDtrsvStridedBatched_rank_0 = hipblasDtrsvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasDtrsvStridedBatched_rank_1(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrsvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasDtrsvStridedBatched_rank_1 = hipblasDtrsvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtrsvStridedBatched_rank_0(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtrsvStridedBatched_rank_0 = hipblasCtrsvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtrsvStridedBatched_rank_1(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtrsvStridedBatched_rank_1 = hipblasCtrsvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtrsvStridedBatched_rank_0(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsvStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtrsvStridedBatched_rank_0 = hipblasZtrsvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtrsvStridedBatched_rank_1(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsvStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtrsvStridedBatched_rank_1 = hipblasZtrsvStridedBatched_(handle,uplo,transA,diag,n,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtrsvStridedBatched_v2_rank_0(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsvStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtrsvStridedBatched_v2_rank_0 = hipblasCtrsvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasCtrsvStridedBatched_v2_rank_1(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrsvStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasCtrsvStridedBatched_v2_rank_1 = hipblasCtrsvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtrsvStridedBatched_v2_rank_0(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsvStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtrsvStridedBatched_v2_rank_0 = hipblasZtrsvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasZtrsvStridedBatched_v2_rank_1(handle,uplo,transA,diag,n,AP,lda,strideA,x,incx,stridex,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrsvStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      integer(c_int) :: batchCount
      !
      hipblasZtrsvStridedBatched_v2_rank_1 = hipblasZtrsvStridedBatched_v2_(handle,uplo,transA,diag,n,AP,lda,strideA,c_loc(x),incx,stridex,batchCount)
    end function

    function hipblasStrmm_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmm_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasStrmm_full_rank = hipblasStrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasStrmm_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float),target :: C
      integer(c_int) :: ldc
      !
      hipblasStrmm_rank_0 = hipblasStrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasStrmm_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasStrmm_rank_1 = hipblasStrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasDtrmm_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmm_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasDtrmm_full_rank = hipblasDtrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasDtrmm_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double),target :: C
      integer(c_int) :: ldc
      !
      hipblasDtrmm_rank_0 = hipblasDtrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasDtrmm_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasDtrmm_rank_1 = hipblasDtrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasCtrmm_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmm_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasCtrmm_full_rank = hipblasCtrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasCtrmm_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      hipblasCtrmm_rank_0 = hipblasCtrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasCtrmm_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasCtrmm_rank_1 = hipblasCtrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasZtrmm_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmm_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasZtrmm_full_rank = hipblasZtrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasZtrmm_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      hipblasZtrmm_rank_0 = hipblasZtrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasZtrmm_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasZtrmm_rank_1 = hipblasZtrmm_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasCtrmm_v2_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmm_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasCtrmm_v2_full_rank = hipblasCtrmm_v2_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasCtrmm_v2_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmm_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      !
      hipblasCtrmm_v2_rank_0 = hipblasCtrmm_v2_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasCtrmm_v2_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmm_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasCtrmm_v2_rank_1 = hipblasCtrmm_v2_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasZtrmm_v2_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmm_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      !
      hipblasZtrmm_v2_full_rank = hipblasZtrmm_v2_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasZtrmm_v2_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmm_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      !
      hipblasZtrmm_v2_rank_0 = hipblasZtrmm_v2_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasZtrmm_v2_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmm_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      !
      hipblasZtrmm_v2_rank_1 = hipblasZtrmm_v2_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc)
    end function

    function hipblasStrmmBatched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasStrmmBatched_full_rank = hipblasStrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasStrmmBatched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasStrmmBatched_rank_0 = hipblasStrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasStrmmBatched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasStrmmBatched_rank_1 = hipblasStrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasDtrmmBatched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasDtrmmBatched_full_rank = hipblasDtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasDtrmmBatched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasDtrmmBatched_rank_0 = hipblasDtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasDtrmmBatched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasDtrmmBatched_rank_1 = hipblasDtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasCtrmmBatched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCtrmmBatched_full_rank = hipblasCtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasCtrmmBatched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCtrmmBatched_rank_0 = hipblasCtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasCtrmmBatched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCtrmmBatched_rank_1 = hipblasCtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasZtrmmBatched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZtrmmBatched_full_rank = hipblasZtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasZtrmmBatched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZtrmmBatched_rank_0 = hipblasZtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasZtrmmBatched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZtrmmBatched_rank_1 = hipblasZtrmmBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasCtrmmBatched_v2_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmmBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCtrmmBatched_v2_full_rank = hipblasCtrmmBatched_v2_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasCtrmmBatched_v2_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmmBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCtrmmBatched_v2_rank_0 = hipblasCtrmmBatched_v2_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasCtrmmBatched_v2_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmmBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCtrmmBatched_v2_rank_1 = hipblasCtrmmBatched_v2_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasZtrmmBatched_v2_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmmBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZtrmmBatched_v2_full_rank = hipblasZtrmmBatched_v2_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasZtrmmBatched_v2_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmmBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZtrmmBatched_v2_rank_0 = hipblasZtrmmBatched_v2_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasZtrmmBatched_v2_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,B,ldb,C,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmmBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZtrmmBatched_v2_rank_1 = hipblasZtrmmBatched_v2_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,c_loc(B),ldb,c_loc(C),ldc,batchCount)
    end function

    function hipblasStrmmStridedBatched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmmStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasStrmmStridedBatched_full_rank = hipblasStrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasStrmmStridedBatched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasStrmmStridedBatched_rank_0 = hipblasStrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasStrmmStridedBatched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrmmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float) :: alpha
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasStrmmStridedBatched_rank_1 = hipblasStrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasDtrmmStridedBatched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmmStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasDtrmmStridedBatched_full_rank = hipblasDtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasDtrmmStridedBatched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasDtrmmStridedBatched_rank_0 = hipblasDtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasDtrmmStridedBatched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrmmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double) :: alpha
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasDtrmmStridedBatched_rank_1 = hipblasDtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCtrmmStridedBatched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmmStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCtrmmStridedBatched_full_rank = hipblasCtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCtrmmStridedBatched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCtrmmStridedBatched_rank_0 = hipblasCtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCtrmmStridedBatched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCtrmmStridedBatched_rank_1 = hipblasCtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZtrmmStridedBatched_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmmStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZtrmmStridedBatched_full_rank = hipblasZtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZtrmmStridedBatched_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZtrmmStridedBatched_rank_0 = hipblasZtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZtrmmStridedBatched_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZtrmmStridedBatched_rank_1 = hipblasZtrmmStridedBatched_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCtrmmStridedBatched_v2_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmmStridedBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCtrmmStridedBatched_v2_full_rank = hipblasCtrmmStridedBatched_v2_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCtrmmStridedBatched_v2_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmmStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCtrmmStridedBatched_v2_rank_0 = hipblasCtrmmStridedBatched_v2_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasCtrmmStridedBatched_v2_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrmmStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex) :: alpha
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCtrmmStridedBatched_v2_rank_1 = hipblasCtrmmStridedBatched_v2_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZtrmmStridedBatched_v2_full_rank(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmmStridedBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex),target,dimension(:,:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZtrmmStridedBatched_v2_full_rank = hipblasZtrmmStridedBatched_v2_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZtrmmStridedBatched_v2_rank_0(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmmStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZtrmmStridedBatched_v2_rank_0 = hipblasZtrmmStridedBatched_v2_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasZtrmmStridedBatched_v2_rank_1(handle,side,uplo,transA,diag,m,n,alpha,A,lda,strideA,B,ldb,strideB,C,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrmmStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_OP_N)) :: transA
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex) :: alpha
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZtrmmStridedBatched_v2_rank_1 = hipblasZtrmmStridedBatched_v2_(handle,side,uplo,transA,diag,m,n,alpha,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,c_loc(C),ldc,strideC,batchCount)
    end function

    function hipblasStrtri_full_rank(handle,uplo,diag,n,AP,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrtri_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: invA
      integer(c_int) :: ldinvA
      !
      hipblasStrtri_full_rank = hipblasStrtri_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA)
    end function

    function hipblasStrtri_rank_0(handle,uplo,diag,n,AP,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrtri_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target :: invA
      integer(c_int) :: ldinvA
      !
      hipblasStrtri_rank_0 = hipblasStrtri_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA)
    end function

    function hipblasStrtri_rank_1(handle,uplo,diag,n,AP,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrtri_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      !
      hipblasStrtri_rank_1 = hipblasStrtri_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA)
    end function

    function hipblasDtrtri_full_rank(handle,uplo,diag,n,AP,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrtri_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: invA
      integer(c_int) :: ldinvA
      !
      hipblasDtrtri_full_rank = hipblasDtrtri_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA)
    end function

    function hipblasDtrtri_rank_0(handle,uplo,diag,n,AP,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrtri_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target :: invA
      integer(c_int) :: ldinvA
      !
      hipblasDtrtri_rank_0 = hipblasDtrtri_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA)
    end function

    function hipblasDtrtri_rank_1(handle,uplo,diag,n,AP,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrtri_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      !
      hipblasDtrtri_rank_1 = hipblasDtrtri_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA)
    end function

    function hipblasCtrtri_full_rank(handle,uplo,diag,n,AP,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtri_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: invA
      integer(c_int) :: ldinvA
      !
      hipblasCtrtri_full_rank = hipblasCtrtri_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA)
    end function

    function hipblasCtrtri_rank_0(handle,uplo,diag,n,AP,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtri_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: invA
      integer(c_int) :: ldinvA
      !
      hipblasCtrtri_rank_0 = hipblasCtrtri_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA)
    end function

    function hipblasCtrtri_rank_1(handle,uplo,diag,n,AP,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtri_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      !
      hipblasCtrtri_rank_1 = hipblasCtrtri_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA)
    end function

    function hipblasZtrtri_full_rank(handle,uplo,diag,n,AP,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtri_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: invA
      integer(c_int) :: ldinvA
      !
      hipblasZtrtri_full_rank = hipblasZtrtri_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA)
    end function

    function hipblasZtrtri_rank_0(handle,uplo,diag,n,AP,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtri_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: invA
      integer(c_int) :: ldinvA
      !
      hipblasZtrtri_rank_0 = hipblasZtrtri_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA)
    end function

    function hipblasZtrtri_rank_1(handle,uplo,diag,n,AP,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtri_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      !
      hipblasZtrtri_rank_1 = hipblasZtrtri_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA)
    end function

    function hipblasCtrtri_v2_full_rank(handle,uplo,diag,n,AP,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtri_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: invA
      integer(c_int) :: ldinvA
      !
      hipblasCtrtri_v2_full_rank = hipblasCtrtri_v2_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA)
    end function

    function hipblasCtrtri_v2_rank_0(handle,uplo,diag,n,AP,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtri_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: invA
      integer(c_int) :: ldinvA
      !
      hipblasCtrtri_v2_rank_0 = hipblasCtrtri_v2_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA)
    end function

    function hipblasCtrtri_v2_rank_1(handle,uplo,diag,n,AP,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtri_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      !
      hipblasCtrtri_v2_rank_1 = hipblasCtrtri_v2_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA)
    end function

    function hipblasZtrtri_v2_full_rank(handle,uplo,diag,n,AP,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtri_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: invA
      integer(c_int) :: ldinvA
      !
      hipblasZtrtri_v2_full_rank = hipblasZtrtri_v2_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA)
    end function

    function hipblasZtrtri_v2_rank_0(handle,uplo,diag,n,AP,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtri_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: invA
      integer(c_int) :: ldinvA
      !
      hipblasZtrtri_v2_rank_0 = hipblasZtrtri_v2_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA)
    end function

    function hipblasZtrtri_v2_rank_1(handle,uplo,diag,n,AP,lda,invA,ldinvA)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtri_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      !
      hipblasZtrtri_v2_rank_1 = hipblasZtrtri_v2_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA)
    end function

    function hipblasStrtriBatched_full_rank(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrtriBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasStrtriBatched_full_rank = hipblasStrtriBatched_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasStrtriBatched_rank_0(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrtriBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasStrtriBatched_rank_0 = hipblasStrtriBatched_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasStrtriBatched_rank_1(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrtriBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasStrtriBatched_rank_1 = hipblasStrtriBatched_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasDtrtriBatched_full_rank(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrtriBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasDtrtriBatched_full_rank = hipblasDtrtriBatched_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasDtrtriBatched_rank_0(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrtriBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasDtrtriBatched_rank_0 = hipblasDtrtriBatched_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasDtrtriBatched_rank_1(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrtriBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasDtrtriBatched_rank_1 = hipblasDtrtriBatched_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasCtrtriBatched_full_rank(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtriBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasCtrtriBatched_full_rank = hipblasCtrtriBatched_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasCtrtriBatched_rank_0(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtriBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasCtrtriBatched_rank_0 = hipblasCtrtriBatched_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasCtrtriBatched_rank_1(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtriBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasCtrtriBatched_rank_1 = hipblasCtrtriBatched_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasZtrtriBatched_full_rank(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtriBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasZtrtriBatched_full_rank = hipblasZtrtriBatched_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasZtrtriBatched_rank_0(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtriBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasZtrtriBatched_rank_0 = hipblasZtrtriBatched_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasZtrtriBatched_rank_1(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtriBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasZtrtriBatched_rank_1 = hipblasZtrtriBatched_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasCtrtriBatched_v2_full_rank(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtriBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasCtrtriBatched_v2_full_rank = hipblasCtrtriBatched_v2_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasCtrtriBatched_v2_rank_0(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtriBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasCtrtriBatched_v2_rank_0 = hipblasCtrtriBatched_v2_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasCtrtriBatched_v2_rank_1(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtriBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasCtrtriBatched_v2_rank_1 = hipblasCtrtriBatched_v2_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasZtrtriBatched_v2_full_rank(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtriBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasZtrtriBatched_v2_full_rank = hipblasZtrtriBatched_v2_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasZtrtriBatched_v2_rank_0(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtriBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasZtrtriBatched_v2_rank_0 = hipblasZtrtriBatched_v2_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasZtrtriBatched_v2_rank_1(handle,uplo,diag,n,AP,lda,invA,ldinvA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtriBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int) :: batchCount
      !
      hipblasZtrtriBatched_v2_rank_1 = hipblasZtrtriBatched_v2_(handle,uplo,diag,n,AP,lda,c_loc(invA),ldinvA,batchCount)
    end function

    function hipblasStrtriStridedBatched_full_rank(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrtriStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:,:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasStrtriStridedBatched_full_rank = hipblasStrtriStridedBatched_(handle,uplo,diag,n,AP,lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasStrtriStridedBatched_rank_0(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrtriStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasStrtriStridedBatched_rank_0 = hipblasStrtriStridedBatched_(handle,uplo,diag,n,AP,lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasStrtriStridedBatched_rank_1(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasStrtriStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasStrtriStridedBatched_rank_1 = hipblasStrtriStridedBatched_(handle,uplo,diag,n,AP,lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasDtrtriStridedBatched_full_rank(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrtriStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:,:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasDtrtriStridedBatched_full_rank = hipblasDtrtriStridedBatched_(handle,uplo,diag,n,AP,lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasDtrtriStridedBatched_rank_0(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrtriStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasDtrtriStridedBatched_rank_0 = hipblasDtrtriStridedBatched_(handle,uplo,diag,n,AP,lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasDtrtriStridedBatched_rank_1(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDtrtriStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasDtrtriStridedBatched_rank_1 = hipblasDtrtriStridedBatched_(handle,uplo,diag,n,AP,lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasCtrtriStridedBatched_full_rank(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtriStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasCtrtriStridedBatched_full_rank = hipblasCtrtriStridedBatched_(handle,uplo,diag,n,AP,lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasCtrtriStridedBatched_rank_0(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtriStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasCtrtriStridedBatched_rank_0 = hipblasCtrtriStridedBatched_(handle,uplo,diag,n,AP,lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasCtrtriStridedBatched_rank_1(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtriStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasCtrtriStridedBatched_rank_1 = hipblasCtrtriStridedBatched_(handle,uplo,diag,n,AP,lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasZtrtriStridedBatched_full_rank(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtriStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasZtrtriStridedBatched_full_rank = hipblasZtrtriStridedBatched_(handle,uplo,diag,n,AP,lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasZtrtriStridedBatched_rank_0(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtriStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasZtrtriStridedBatched_rank_0 = hipblasZtrtriStridedBatched_(handle,uplo,diag,n,AP,lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasZtrtriStridedBatched_rank_1(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtriStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasZtrtriStridedBatched_rank_1 = hipblasZtrtriStridedBatched_(handle,uplo,diag,n,AP,lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasCtrtriStridedBatched_v2_full_rank(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtriStridedBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasCtrtriStridedBatched_v2_full_rank = hipblasCtrtriStridedBatched_v2_(handle,uplo,diag,n,AP,lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasCtrtriStridedBatched_v2_rank_0(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtriStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasCtrtriStridedBatched_v2_rank_0 = hipblasCtrtriStridedBatched_v2_(handle,uplo,diag,n,AP,lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasCtrtriStridedBatched_v2_rank_1(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCtrtriStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasCtrtriStridedBatched_v2_rank_1 = hipblasCtrtriStridedBatched_v2_(handle,uplo,diag,n,AP,lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasZtrtriStridedBatched_v2_full_rank(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtriStridedBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasZtrtriStridedBatched_v2_full_rank = hipblasZtrtriStridedBatched_v2_(handle,uplo,diag,n,AP,lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasZtrtriStridedBatched_v2_rank_0(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtriStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasZtrtriStridedBatched_v2_rank_0 = hipblasZtrtriStridedBatched_v2_(handle,uplo,diag,n,AP,lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasZtrtriStridedBatched_v2_rank_1(handle,uplo,diag,n,AP,lda,strideA,invA,ldinvA,stride_invA,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZtrtriStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_FILL_MODE_UPPER)) :: uplo
      integer(kind(HIPBLAS_DIAG_NON_UNIT)) :: diag
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: invA
      integer(c_int) :: ldinvA
      integer(c_int64_t) :: stride_invA
      integer(c_int) :: batchCount
      !
      hipblasZtrtriStridedBatched_v2_rank_1 = hipblasZtrtriStridedBatched_v2_(handle,uplo,diag,n,AP,lda,strideA,c_loc(invA),ldinvA,stride_invA,batchCount)
    end function

    function hipblasSdgmm_rank_0(handle,side,m,n,AP,lda,x,incx,CP,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdgmm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      !
      hipblasSdgmm_rank_0 = hipblasSdgmm_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc)
    end function

    function hipblasSdgmm_rank_1(handle,side,m,n,AP,lda,x,incx,CP,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdgmm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      !
      hipblasSdgmm_rank_1 = hipblasSdgmm_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc)
    end function

    function hipblasDdgmm_rank_0(handle,side,m,n,AP,lda,x,incx,CP,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdgmm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      !
      hipblasDdgmm_rank_0 = hipblasDdgmm_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc)
    end function

    function hipblasDdgmm_rank_1(handle,side,m,n,AP,lda,x,incx,CP,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdgmm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      !
      hipblasDdgmm_rank_1 = hipblasDdgmm_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc)
    end function

    function hipblasCdgmm_rank_0(handle,side,m,n,AP,lda,x,incx,CP,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      !
      hipblasCdgmm_rank_0 = hipblasCdgmm_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc)
    end function

    function hipblasCdgmm_rank_1(handle,side,m,n,AP,lda,x,incx,CP,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      !
      hipblasCdgmm_rank_1 = hipblasCdgmm_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc)
    end function

    function hipblasZdgmm_rank_0(handle,side,m,n,AP,lda,x,incx,CP,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmm_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      !
      hipblasZdgmm_rank_0 = hipblasZdgmm_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc)
    end function

    function hipblasZdgmm_rank_1(handle,side,m,n,AP,lda,x,incx,CP,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmm_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      !
      hipblasZdgmm_rank_1 = hipblasZdgmm_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc)
    end function

    function hipblasCdgmm_v2_rank_0(handle,side,m,n,AP,lda,x,incx,CP,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmm_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      !
      hipblasCdgmm_v2_rank_0 = hipblasCdgmm_v2_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc)
    end function

    function hipblasCdgmm_v2_rank_1(handle,side,m,n,AP,lda,x,incx,CP,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmm_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      !
      hipblasCdgmm_v2_rank_1 = hipblasCdgmm_v2_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc)
    end function

    function hipblasZdgmm_v2_rank_0(handle,side,m,n,AP,lda,x,incx,CP,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmm_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      !
      hipblasZdgmm_v2_rank_0 = hipblasZdgmm_v2_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc)
    end function

    function hipblasZdgmm_v2_rank_1(handle,side,m,n,AP,lda,x,incx,CP,ldc)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmm_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      !
      hipblasZdgmm_v2_rank_1 = hipblasZdgmm_v2_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc)
    end function

    function hipblasSdgmmBatched_full_rank(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdgmmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasSdgmmBatched_full_rank = hipblasSdgmmBatched_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc,batchCount)
    end function

    function hipblasSdgmmBatched_rank_0(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdgmmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasSdgmmBatched_rank_0 = hipblasSdgmmBatched_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc,batchCount)
    end function

    function hipblasSdgmmBatched_rank_1(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdgmmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasSdgmmBatched_rank_1 = hipblasSdgmmBatched_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc,batchCount)
    end function

    function hipblasDdgmmBatched_full_rank(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdgmmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasDdgmmBatched_full_rank = hipblasDdgmmBatched_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc,batchCount)
    end function

    function hipblasDdgmmBatched_rank_0(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdgmmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasDdgmmBatched_rank_0 = hipblasDdgmmBatched_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc,batchCount)
    end function

    function hipblasDdgmmBatched_rank_1(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdgmmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasDdgmmBatched_rank_1 = hipblasDdgmmBatched_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc,batchCount)
    end function

    function hipblasCdgmmBatched_full_rank(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCdgmmBatched_full_rank = hipblasCdgmmBatched_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc,batchCount)
    end function

    function hipblasCdgmmBatched_rank_0(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCdgmmBatched_rank_0 = hipblasCdgmmBatched_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc,batchCount)
    end function

    function hipblasCdgmmBatched_rank_1(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCdgmmBatched_rank_1 = hipblasCdgmmBatched_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc,batchCount)
    end function

    function hipblasZdgmmBatched_full_rank(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmmBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZdgmmBatched_full_rank = hipblasZdgmmBatched_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc,batchCount)
    end function

    function hipblasZdgmmBatched_rank_0(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmmBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZdgmmBatched_rank_0 = hipblasZdgmmBatched_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc,batchCount)
    end function

    function hipblasZdgmmBatched_rank_1(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmmBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZdgmmBatched_rank_1 = hipblasZdgmmBatched_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc,batchCount)
    end function

    function hipblasCdgmmBatched_v2_full_rank(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmmBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCdgmmBatched_v2_full_rank = hipblasCdgmmBatched_v2_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc,batchCount)
    end function

    function hipblasCdgmmBatched_v2_rank_0(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmmBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCdgmmBatched_v2_rank_0 = hipblasCdgmmBatched_v2_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc,batchCount)
    end function

    function hipblasCdgmmBatched_v2_rank_1(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmmBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasCdgmmBatched_v2_rank_1 = hipblasCdgmmBatched_v2_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc,batchCount)
    end function

    function hipblasZdgmmBatched_v2_full_rank(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmmBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZdgmmBatched_v2_full_rank = hipblasZdgmmBatched_v2_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc,batchCount)
    end function

    function hipblasZdgmmBatched_v2_rank_0(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmmBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZdgmmBatched_v2_rank_0 = hipblasZdgmmBatched_v2_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc,batchCount)
    end function

    function hipblasZdgmmBatched_v2_rank_1(handle,side,m,n,AP,lda,x,incx,CP,ldc,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmmBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int) :: batchCount
      !
      hipblasZdgmmBatched_v2_rank_1 = hipblasZdgmmBatched_v2_(handle,side,m,n,AP,lda,c_loc(x),incx,CP,ldc,batchCount)
    end function

    function hipblasSdgmmStridedBatched_rank_0(handle,side,m,n,AP,lda,strideA,x,incx,stridex,CP,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdgmmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasSdgmmStridedBatched_rank_0 = hipblasSdgmmStridedBatched_(handle,side,m,n,AP,lda,strideA,c_loc(x),incx,stridex,CP,ldc,strideC,batchCount)
    end function

    function hipblasSdgmmStridedBatched_rank_1(handle,side,m,n,AP,lda,strideA,x,incx,stridex,CP,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSdgmmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasSdgmmStridedBatched_rank_1 = hipblasSdgmmStridedBatched_(handle,side,m,n,AP,lda,strideA,c_loc(x),incx,stridex,CP,ldc,strideC,batchCount)
    end function

    function hipblasDdgmmStridedBatched_rank_0(handle,side,m,n,AP,lda,strideA,x,incx,stridex,CP,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdgmmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasDdgmmStridedBatched_rank_0 = hipblasDdgmmStridedBatched_(handle,side,m,n,AP,lda,strideA,c_loc(x),incx,stridex,CP,ldc,strideC,batchCount)
    end function

    function hipblasDdgmmStridedBatched_rank_1(handle,side,m,n,AP,lda,strideA,x,incx,stridex,CP,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDdgmmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasDdgmmStridedBatched_rank_1 = hipblasDdgmmStridedBatched_(handle,side,m,n,AP,lda,strideA,c_loc(x),incx,stridex,CP,ldc,strideC,batchCount)
    end function

    function hipblasCdgmmStridedBatched_rank_0(handle,side,m,n,AP,lda,strideA,x,incx,stridex,CP,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCdgmmStridedBatched_rank_0 = hipblasCdgmmStridedBatched_(handle,side,m,n,AP,lda,strideA,c_loc(x),incx,stridex,CP,ldc,strideC,batchCount)
    end function

    function hipblasCdgmmStridedBatched_rank_1(handle,side,m,n,AP,lda,strideA,x,incx,stridex,CP,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCdgmmStridedBatched_rank_1 = hipblasCdgmmStridedBatched_(handle,side,m,n,AP,lda,strideA,c_loc(x),incx,stridex,CP,ldc,strideC,batchCount)
    end function

    function hipblasZdgmmStridedBatched_rank_0(handle,side,m,n,AP,lda,strideA,x,incx,stridex,CP,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmmStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZdgmmStridedBatched_rank_0 = hipblasZdgmmStridedBatched_(handle,side,m,n,AP,lda,strideA,c_loc(x),incx,stridex,CP,ldc,strideC,batchCount)
    end function

    function hipblasZdgmmStridedBatched_rank_1(handle,side,m,n,AP,lda,strideA,x,incx,stridex,CP,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmmStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZdgmmStridedBatched_rank_1 = hipblasZdgmmStridedBatched_(handle,side,m,n,AP,lda,strideA,c_loc(x),incx,stridex,CP,ldc,strideC,batchCount)
    end function

    function hipblasCdgmmStridedBatched_v2_rank_0(handle,side,m,n,AP,lda,strideA,x,incx,stridex,CP,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmmStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCdgmmStridedBatched_v2_rank_0 = hipblasCdgmmStridedBatched_v2_(handle,side,m,n,AP,lda,strideA,c_loc(x),incx,stridex,CP,ldc,strideC,batchCount)
    end function

    function hipblasCdgmmStridedBatched_v2_rank_1(handle,side,m,n,AP,lda,strideA,x,incx,stridex,CP,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCdgmmStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasCdgmmStridedBatched_v2_rank_1 = hipblasCdgmmStridedBatched_v2_(handle,side,m,n,AP,lda,strideA,c_loc(x),incx,stridex,CP,ldc,strideC,batchCount)
    end function

    function hipblasZdgmmStridedBatched_v2_rank_0(handle,side,m,n,AP,lda,strideA,x,incx,stridex,CP,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmmStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZdgmmStridedBatched_v2_rank_0 = hipblasZdgmmStridedBatched_v2_(handle,side,m,n,AP,lda,strideA,c_loc(x),incx,stridex,CP,ldc,strideC,batchCount)
    end function

    function hipblasZdgmmStridedBatched_v2_rank_1(handle,side,m,n,AP,lda,strideA,x,incx,stridex,CP,ldc,strideC,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZdgmmStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_SIDE_LEFT)) :: side
      integer(c_int) :: m
      integer(c_int) :: n
      type(c_ptr) :: AP
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: x
      integer(c_int) :: incx
      integer(c_int64_t) :: stridex
      type(c_ptr) :: CP
      integer(c_int) :: ldc
      integer(c_int64_t) :: strideC
      integer(c_int) :: batchCount
      !
      hipblasZdgmmStridedBatched_v2_rank_1 = hipblasZdgmmStridedBatched_v2_(handle,side,m,n,AP,lda,strideA,c_loc(x),incx,stridex,CP,ldc,strideC,batchCount)
    end function

    function hipblasSgetrf_full_rank(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasSgetrf_full_rank = hipblasSgetrf_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasSgetrf_rank_0(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasSgetrf_rank_0 = hipblasSgetrf_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasSgetrf_rank_1(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasSgetrf_rank_1 = hipblasSgetrf_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasDgetrf_full_rank(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasDgetrf_full_rank = hipblasDgetrf_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasDgetrf_rank_0(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasDgetrf_rank_0 = hipblasDgetrf_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasDgetrf_rank_1(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasDgetrf_rank_1 = hipblasDgetrf_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasCgetrf_full_rank(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasCgetrf_full_rank = hipblasCgetrf_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasCgetrf_rank_0(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasCgetrf_rank_0 = hipblasCgetrf_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasCgetrf_rank_1(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasCgetrf_rank_1 = hipblasCgetrf_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasZgetrf_full_rank(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasZgetrf_full_rank = hipblasZgetrf_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasZgetrf_rank_0(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasZgetrf_rank_0 = hipblasZgetrf_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasZgetrf_rank_1(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasZgetrf_rank_1 = hipblasZgetrf_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasCgetrf_v2_full_rank(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrf_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasCgetrf_v2_full_rank = hipblasCgetrf_v2_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasCgetrf_v2_rank_0(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrf_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasCgetrf_v2_rank_0 = hipblasCgetrf_v2_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasCgetrf_v2_rank_1(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrf_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasCgetrf_v2_rank_1 = hipblasCgetrf_v2_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasZgetrf_v2_full_rank(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrf_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasZgetrf_v2_full_rank = hipblasZgetrf_v2_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasZgetrf_v2_rank_0(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrf_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasZgetrf_v2_rank_0 = hipblasZgetrf_v2_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasZgetrf_v2_rank_1(handle,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrf_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasZgetrf_v2_rank_1 = hipblasZgetrf_v2_(handle,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasSgetrfBatched_full_rank(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrfBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetrfBatched_full_rank = hipblasSgetrfBatched_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasSgetrfBatched_rank_0(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrfBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetrfBatched_rank_0 = hipblasSgetrfBatched_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasSgetrfBatched_rank_1(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrfBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetrfBatched_rank_1 = hipblasSgetrfBatched_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasDgetrfBatched_full_rank(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrfBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetrfBatched_full_rank = hipblasDgetrfBatched_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasDgetrfBatched_rank_0(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrfBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetrfBatched_rank_0 = hipblasDgetrfBatched_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasDgetrfBatched_rank_1(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrfBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetrfBatched_rank_1 = hipblasDgetrfBatched_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasCgetrfBatched_full_rank(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrfBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrfBatched_full_rank = hipblasCgetrfBatched_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasCgetrfBatched_rank_0(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrfBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrfBatched_rank_0 = hipblasCgetrfBatched_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasCgetrfBatched_rank_1(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrfBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrfBatched_rank_1 = hipblasCgetrfBatched_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasZgetrfBatched_full_rank(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrfBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrfBatched_full_rank = hipblasZgetrfBatched_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasZgetrfBatched_rank_0(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrfBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrfBatched_rank_0 = hipblasZgetrfBatched_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasZgetrfBatched_rank_1(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrfBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrfBatched_rank_1 = hipblasZgetrfBatched_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasCgetrfBatched_v2_full_rank(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrfBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrfBatched_v2_full_rank = hipblasCgetrfBatched_v2_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasCgetrfBatched_v2_rank_0(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrfBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrfBatched_v2_rank_0 = hipblasCgetrfBatched_v2_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasCgetrfBatched_v2_rank_1(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrfBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrfBatched_v2_rank_1 = hipblasCgetrfBatched_v2_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasZgetrfBatched_v2_full_rank(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrfBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrfBatched_v2_full_rank = hipblasZgetrfBatched_v2_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasZgetrfBatched_v2_rank_0(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrfBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrfBatched_v2_rank_0 = hipblasZgetrfBatched_v2_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasZgetrfBatched_v2_rank_1(handle,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrfBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrfBatched_v2_rank_1 = hipblasZgetrfBatched_v2_(handle,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasSgetrfStridedBatched_full_rank(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrfStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetrfStridedBatched_full_rank = hipblasSgetrfStridedBatched_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasSgetrfStridedBatched_rank_0(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrfStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetrfStridedBatched_rank_0 = hipblasSgetrfStridedBatched_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasSgetrfStridedBatched_rank_1(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrfStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetrfStridedBatched_rank_1 = hipblasSgetrfStridedBatched_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasDgetrfStridedBatched_full_rank(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrfStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetrfStridedBatched_full_rank = hipblasDgetrfStridedBatched_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasDgetrfStridedBatched_rank_0(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrfStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetrfStridedBatched_rank_0 = hipblasDgetrfStridedBatched_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasDgetrfStridedBatched_rank_1(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrfStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetrfStridedBatched_rank_1 = hipblasDgetrfStridedBatched_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasCgetrfStridedBatched_full_rank(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrfStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrfStridedBatched_full_rank = hipblasCgetrfStridedBatched_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasCgetrfStridedBatched_rank_0(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrfStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrfStridedBatched_rank_0 = hipblasCgetrfStridedBatched_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasCgetrfStridedBatched_rank_1(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrfStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrfStridedBatched_rank_1 = hipblasCgetrfStridedBatched_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasZgetrfStridedBatched_full_rank(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrfStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrfStridedBatched_full_rank = hipblasZgetrfStridedBatched_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasZgetrfStridedBatched_rank_0(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrfStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrfStridedBatched_rank_0 = hipblasZgetrfStridedBatched_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasZgetrfStridedBatched_rank_1(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrfStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrfStridedBatched_rank_1 = hipblasZgetrfStridedBatched_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasCgetrfStridedBatched_v2_full_rank(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrfStridedBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrfStridedBatched_v2_full_rank = hipblasCgetrfStridedBatched_v2_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasCgetrfStridedBatched_v2_rank_0(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrfStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrfStridedBatched_v2_rank_0 = hipblasCgetrfStridedBatched_v2_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasCgetrfStridedBatched_v2_rank_1(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrfStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrfStridedBatched_v2_rank_1 = hipblasCgetrfStridedBatched_v2_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasZgetrfStridedBatched_v2_full_rank(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrfStridedBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrfStridedBatched_v2_full_rank = hipblasZgetrfStridedBatched_v2_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasZgetrfStridedBatched_v2_rank_0(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrfStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrfStridedBatched_v2_rank_0 = hipblasZgetrfStridedBatched_v2_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasZgetrfStridedBatched_v2_rank_1(handle,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrfStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrfStridedBatched_v2_rank_1 = hipblasZgetrfStridedBatched_v2_(handle,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasSgetrs_full_rank(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrs_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasSgetrs_full_rank = hipblasSgetrs_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasSgetrs_rank_0(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrs_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_float),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasSgetrs_rank_0 = hipblasSgetrs_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasSgetrs_rank_1(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrs_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasSgetrs_rank_1 = hipblasSgetrs_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasDgetrs_full_rank(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrs_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasDgetrs_full_rank = hipblasDgetrs_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasDgetrs_rank_0(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrs_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_double),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasDgetrs_rank_0 = hipblasDgetrs_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasDgetrs_rank_1(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrs_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasDgetrs_rank_1 = hipblasDgetrs_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasCgetrs_full_rank(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrs_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasCgetrs_full_rank = hipblasCgetrs_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasCgetrs_rank_0(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrs_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasCgetrs_rank_0 = hipblasCgetrs_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasCgetrs_rank_1(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrs_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasCgetrs_rank_1 = hipblasCgetrs_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasZgetrs_full_rank(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrs_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasZgetrs_full_rank = hipblasZgetrs_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasZgetrs_rank_0(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrs_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasZgetrs_rank_0 = hipblasZgetrs_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasZgetrs_rank_1(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrs_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasZgetrs_rank_1 = hipblasZgetrs_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasCgetrs_v2_full_rank(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrs_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasCgetrs_v2_full_rank = hipblasCgetrs_v2_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasCgetrs_v2_rank_0(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrs_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasCgetrs_v2_rank_0 = hipblasCgetrs_v2_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasCgetrs_v2_rank_1(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrs_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasCgetrs_v2_rank_1 = hipblasCgetrs_v2_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasZgetrs_v2_full_rank(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrs_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasZgetrs_v2_full_rank = hipblasZgetrs_v2_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasZgetrs_v2_rank_0(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrs_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasZgetrs_v2_rank_0 = hipblasZgetrs_v2_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasZgetrs_v2_rank_1(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrs_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      !
      hipblasZgetrs_v2_rank_1 = hipblasZgetrs_v2_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo)
    end function

    function hipblasSgetrsBatched_full_rank(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrsBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetrsBatched_full_rank = hipblasSgetrsBatched_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasSgetrsBatched_rank_0(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrsBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_float),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetrsBatched_rank_0 = hipblasSgetrsBatched_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasSgetrsBatched_rank_1(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrsBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetrsBatched_rank_1 = hipblasSgetrsBatched_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasDgetrsBatched_full_rank(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrsBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetrsBatched_full_rank = hipblasDgetrsBatched_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasDgetrsBatched_rank_0(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrsBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_double),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetrsBatched_rank_0 = hipblasDgetrsBatched_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasDgetrsBatched_rank_1(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrsBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetrsBatched_rank_1 = hipblasDgetrsBatched_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasCgetrsBatched_full_rank(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrsBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrsBatched_full_rank = hipblasCgetrsBatched_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasCgetrsBatched_rank_0(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrsBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrsBatched_rank_0 = hipblasCgetrsBatched_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasCgetrsBatched_rank_1(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrsBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrsBatched_rank_1 = hipblasCgetrsBatched_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasZgetrsBatched_full_rank(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrsBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrsBatched_full_rank = hipblasZgetrsBatched_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasZgetrsBatched_rank_0(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrsBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrsBatched_rank_0 = hipblasZgetrsBatched_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasZgetrsBatched_rank_1(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrsBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrsBatched_rank_1 = hipblasZgetrsBatched_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasCgetrsBatched_v2_full_rank(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrsBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrsBatched_v2_full_rank = hipblasCgetrsBatched_v2_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasCgetrsBatched_v2_rank_0(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrsBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrsBatched_v2_rank_0 = hipblasCgetrsBatched_v2_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasCgetrsBatched_v2_rank_1(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrsBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrsBatched_v2_rank_1 = hipblasCgetrsBatched_v2_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasZgetrsBatched_v2_full_rank(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrsBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrsBatched_v2_full_rank = hipblasZgetrsBatched_v2_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasZgetrsBatched_v2_rank_0(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrsBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrsBatched_v2_rank_0 = hipblasZgetrsBatched_v2_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasZgetrsBatched_v2_rank_1(handle,trans,n,nrhs,A,lda,ipiv,B,ldb,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrsBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrsBatched_v2_rank_1 = hipblasZgetrsBatched_v2_(handle,trans,n,nrhs,c_loc(A),lda,ipiv,c_loc(B),ldb,myInfo,batchCount)
    end function

    function hipblasSgetrsStridedBatched_full_rank(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrsStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetrsStridedBatched_full_rank = hipblasSgetrsStridedBatched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasSgetrsStridedBatched_rank_0(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrsStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetrsStridedBatched_rank_0 = hipblasSgetrsStridedBatched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasSgetrsStridedBatched_rank_1(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetrsStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetrsStridedBatched_rank_1 = hipblasSgetrsStridedBatched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasDgetrsStridedBatched_full_rank(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrsStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetrsStridedBatched_full_rank = hipblasDgetrsStridedBatched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasDgetrsStridedBatched_rank_0(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrsStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetrsStridedBatched_rank_0 = hipblasDgetrsStridedBatched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasDgetrsStridedBatched_rank_1(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetrsStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetrsStridedBatched_rank_1 = hipblasDgetrsStridedBatched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasCgetrsStridedBatched_full_rank(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrsStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrsStridedBatched_full_rank = hipblasCgetrsStridedBatched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasCgetrsStridedBatched_rank_0(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrsStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrsStridedBatched_rank_0 = hipblasCgetrsStridedBatched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasCgetrsStridedBatched_rank_1(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrsStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrsStridedBatched_rank_1 = hipblasCgetrsStridedBatched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasZgetrsStridedBatched_full_rank(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrsStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrsStridedBatched_full_rank = hipblasZgetrsStridedBatched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasZgetrsStridedBatched_rank_0(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrsStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrsStridedBatched_rank_0 = hipblasZgetrsStridedBatched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasZgetrsStridedBatched_rank_1(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrsStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrsStridedBatched_rank_1 = hipblasZgetrsStridedBatched_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasCgetrsStridedBatched_v2_full_rank(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrsStridedBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrsStridedBatched_v2_full_rank = hipblasCgetrsStridedBatched_v2_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasCgetrsStridedBatched_v2_rank_0(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrsStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrsStridedBatched_v2_rank_0 = hipblasCgetrsStridedBatched_v2_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasCgetrsStridedBatched_v2_rank_1(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetrsStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetrsStridedBatched_v2_rank_1 = hipblasCgetrsStridedBatched_v2_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasZgetrsStridedBatched_v2_full_rank(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrsStridedBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrsStridedBatched_v2_full_rank = hipblasZgetrsStridedBatched_v2_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasZgetrsStridedBatched_v2_rank_0(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrsStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrsStridedBatched_v2_rank_0 = hipblasZgetrsStridedBatched_v2_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasZgetrsStridedBatched_v2_rank_1(handle,trans,n,nrhs,A,lda,strideA,ipiv,strideP,B,ldb,strideB,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetrsStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetrsStridedBatched_v2_rank_1 = hipblasZgetrsStridedBatched_v2_(handle,trans,n,nrhs,c_loc(A),lda,strideA,ipiv,strideP,c_loc(B),ldb,strideB,myInfo,batchCount)
    end function

    function hipblasSgetriBatched_full_rank(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetriBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_float),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetriBatched_full_rank = hipblasSgetriBatched_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasSgetriBatched_rank_0(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetriBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_float),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetriBatched_rank_0 = hipblasSgetriBatched_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasSgetriBatched_rank_1(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgetriBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_float),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgetriBatched_rank_1 = hipblasSgetriBatched_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasDgetriBatched_full_rank(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetriBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_double),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetriBatched_full_rank = hipblasDgetriBatched_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasDgetriBatched_rank_0(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetriBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_double),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetriBatched_rank_0 = hipblasDgetriBatched_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasDgetriBatched_rank_1(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgetriBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      real(c_double),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgetriBatched_rank_1 = hipblasDgetriBatched_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasCgetriBatched_full_rank(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetriBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetriBatched_full_rank = hipblasCgetriBatched_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasCgetriBatched_rank_0(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetriBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetriBatched_rank_0 = hipblasCgetriBatched_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasCgetriBatched_rank_1(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetriBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetriBatched_rank_1 = hipblasCgetriBatched_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasZgetriBatched_full_rank(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetriBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetriBatched_full_rank = hipblasZgetriBatched_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasZgetriBatched_rank_0(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetriBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetriBatched_rank_0 = hipblasZgetriBatched_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasZgetriBatched_rank_1(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetriBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetriBatched_rank_1 = hipblasZgetriBatched_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasCgetriBatched_v2_full_rank(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetriBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_float_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetriBatched_v2_full_rank = hipblasCgetriBatched_v2_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasCgetriBatched_v2_rank_0(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetriBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_float_complex),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetriBatched_v2_rank_0 = hipblasCgetriBatched_v2_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasCgetriBatched_v2_rank_1(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgetriBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_float_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgetriBatched_v2_rank_1 = hipblasCgetriBatched_v2_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasZgetriBatched_v2_full_rank(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetriBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_double_complex),target,dimension(:,:,:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetriBatched_v2_full_rank = hipblasZgetriBatched_v2_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasZgetriBatched_v2_rank_0(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetriBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_double_complex),target :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetriBatched_v2_rank_0 = hipblasZgetriBatched_v2_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasZgetriBatched_v2_rank_1(handle,n,A,lda,ipiv,C,ldc,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgetriBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      complex(c_double_complex),target,dimension(:) :: C
      integer(c_int) :: ldc
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgetriBatched_v2_rank_1 = hipblasZgetriBatched_v2_(handle,n,c_loc(A),lda,ipiv,c_loc(C),ldc,myInfo,batchCount)
    end function

    function hipblasSgels_full_rank(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgels_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      !
      hipblasSgels_full_rank = hipblasSgels_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo)
    end function

    function hipblasSgels_rank_0(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgels_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      !
      hipblasSgels_rank_0 = hipblasSgels_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo)
    end function

    function hipblasSgels_rank_1(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgels_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      !
      hipblasSgels_rank_1 = hipblasSgels_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo)
    end function

    function hipblasDgels_full_rank(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgels_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      !
      hipblasDgels_full_rank = hipblasDgels_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo)
    end function

    function hipblasDgels_rank_0(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgels_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      !
      hipblasDgels_rank_0 = hipblasDgels_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo)
    end function

    function hipblasDgels_rank_1(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgels_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      !
      hipblasDgels_rank_1 = hipblasDgels_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo)
    end function

    function hipblasCgels_full_rank(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgels_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      !
      hipblasCgels_full_rank = hipblasCgels_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo)
    end function

    function hipblasCgels_rank_0(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgels_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      !
      hipblasCgels_rank_0 = hipblasCgels_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo)
    end function

    function hipblasCgels_rank_1(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgels_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      !
      hipblasCgels_rank_1 = hipblasCgels_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo)
    end function

    function hipblasZgels_full_rank(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgels_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      !
      hipblasZgels_full_rank = hipblasZgels_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo)
    end function

    function hipblasZgels_rank_0(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgels_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      !
      hipblasZgels_rank_0 = hipblasZgels_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo)
    end function

    function hipblasZgels_rank_1(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgels_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      !
      hipblasZgels_rank_1 = hipblasZgels_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo)
    end function

    function hipblasCgels_v2_full_rank(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgels_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      !
      hipblasCgels_v2_full_rank = hipblasCgels_v2_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo)
    end function

    function hipblasCgels_v2_rank_0(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgels_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      !
      hipblasCgels_v2_rank_0 = hipblasCgels_v2_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo)
    end function

    function hipblasCgels_v2_rank_1(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgels_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      !
      hipblasCgels_v2_rank_1 = hipblasCgels_v2_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo)
    end function

    function hipblasZgels_v2_full_rank(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgels_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      !
      hipblasZgels_v2_full_rank = hipblasZgels_v2_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo)
    end function

    function hipblasZgels_v2_rank_0(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgels_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      !
      hipblasZgels_v2_rank_0 = hipblasZgels_v2_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo)
    end function

    function hipblasZgels_v2_rank_1(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgels_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      !
      hipblasZgels_v2_rank_1 = hipblasZgels_v2_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo)
    end function

    function hipblasSgelsBatched_full_rank(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgelsBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasSgelsBatched_full_rank = hipblasSgelsBatched_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo,batchCount)
    end function

    function hipblasSgelsBatched_rank_0(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgelsBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target :: A
      integer(c_int) :: lda
      real(c_float),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasSgelsBatched_rank_0 = hipblasSgelsBatched_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo,batchCount)
    end function

    function hipblasSgelsBatched_rank_1(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgelsBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasSgelsBatched_rank_1 = hipblasSgelsBatched_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo,batchCount)
    end function

    function hipblasDgelsBatched_full_rank(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgelsBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasDgelsBatched_full_rank = hipblasDgelsBatched_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo,batchCount)
    end function

    function hipblasDgelsBatched_rank_0(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgelsBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target :: A
      integer(c_int) :: lda
      real(c_double),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasDgelsBatched_rank_0 = hipblasDgelsBatched_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo,batchCount)
    end function

    function hipblasDgelsBatched_rank_1(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgelsBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasDgelsBatched_rank_1 = hipblasDgelsBatched_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo,batchCount)
    end function

    function hipblasCgelsBatched_full_rank(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgelsBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasCgelsBatched_full_rank = hipblasCgelsBatched_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo,batchCount)
    end function

    function hipblasCgelsBatched_rank_0(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgelsBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasCgelsBatched_rank_0 = hipblasCgelsBatched_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo,batchCount)
    end function

    function hipblasCgelsBatched_rank_1(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgelsBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasCgelsBatched_rank_1 = hipblasCgelsBatched_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo,batchCount)
    end function

    function hipblasZgelsBatched_full_rank(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgelsBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasZgelsBatched_full_rank = hipblasZgelsBatched_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo,batchCount)
    end function

    function hipblasZgelsBatched_rank_0(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgelsBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasZgelsBatched_rank_0 = hipblasZgelsBatched_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo,batchCount)
    end function

    function hipblasZgelsBatched_rank_1(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgelsBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasZgelsBatched_rank_1 = hipblasZgelsBatched_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo,batchCount)
    end function

    function hipblasCgelsBatched_v2_full_rank(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgelsBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasCgelsBatched_v2_full_rank = hipblasCgelsBatched_v2_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo,batchCount)
    end function

    function hipblasCgelsBatched_v2_rank_0(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgelsBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasCgelsBatched_v2_rank_0 = hipblasCgelsBatched_v2_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo,batchCount)
    end function

    function hipblasCgelsBatched_v2_rank_1(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgelsBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasCgelsBatched_v2_rank_1 = hipblasCgelsBatched_v2_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo,batchCount)
    end function

    function hipblasZgelsBatched_v2_full_rank(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgelsBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:,:,:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasZgelsBatched_v2_full_rank = hipblasZgelsBatched_v2_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo,batchCount)
    end function

    function hipblasZgelsBatched_v2_rank_0(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgelsBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasZgelsBatched_v2_rank_0 = hipblasZgelsBatched_v2_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo,batchCount)
    end function

    function hipblasZgelsBatched_v2_rank_1(handle,trans,m,n,nrhs,A,lda,B,ldb,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgelsBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasZgelsBatched_v2_rank_1 = hipblasZgelsBatched_v2_(handle,trans,m,n,nrhs,c_loc(A),lda,c_loc(B),ldb,myInfo,deviceInfo,batchCount)
    end function

    function hipblasSgelsStridedBatched_full_rank(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgelsStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasSgelsStridedBatched_full_rank = hipblasSgelsStridedBatched_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,deviceInfo,batchCount)
    end function

    function hipblasSgelsStridedBatched_rank_0(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgelsStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasSgelsStridedBatched_rank_0 = hipblasSgelsStridedBatched_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,deviceInfo,batchCount)
    end function

    function hipblasSgelsStridedBatched_rank_1(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgelsStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_float),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasSgelsStridedBatched_rank_1 = hipblasSgelsStridedBatched_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,deviceInfo,batchCount)
    end function

    function hipblasDgelsStridedBatched_full_rank(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgelsStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasDgelsStridedBatched_full_rank = hipblasDgelsStridedBatched_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,deviceInfo,batchCount)
    end function

    function hipblasDgelsStridedBatched_rank_0(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgelsStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasDgelsStridedBatched_rank_0 = hipblasDgelsStridedBatched_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,deviceInfo,batchCount)
    end function

    function hipblasDgelsStridedBatched_rank_1(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgelsStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      real(c_double),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasDgelsStridedBatched_rank_1 = hipblasDgelsStridedBatched_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,deviceInfo,batchCount)
    end function

    function hipblasCgelsStridedBatched_full_rank(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgelsStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasCgelsStridedBatched_full_rank = hipblasCgelsStridedBatched_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,deviceInfo,batchCount)
    end function

    function hipblasCgelsStridedBatched_rank_0(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgelsStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasCgelsStridedBatched_rank_0 = hipblasCgelsStridedBatched_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,deviceInfo,batchCount)
    end function

    function hipblasCgelsStridedBatched_rank_1(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgelsStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasCgelsStridedBatched_rank_1 = hipblasCgelsStridedBatched_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,deviceInfo,batchCount)
    end function

    function hipblasZgelsStridedBatched_full_rank(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgelsStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasZgelsStridedBatched_full_rank = hipblasZgelsStridedBatched_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,deviceInfo,batchCount)
    end function

    function hipblasZgelsStridedBatched_rank_0(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgelsStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasZgelsStridedBatched_rank_0 = hipblasZgelsStridedBatched_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,deviceInfo,batchCount)
    end function

    function hipblasZgelsStridedBatched_rank_1(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgelsStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasZgelsStridedBatched_rank_1 = hipblasZgelsStridedBatched_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,deviceInfo,batchCount)
    end function

    function hipblasCgelsStridedBatched_v2_full_rank(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgelsStridedBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasCgelsStridedBatched_v2_full_rank = hipblasCgelsStridedBatched_v2_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,deviceInfo,batchCount)
    end function

    function hipblasCgelsStridedBatched_v2_rank_0(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgelsStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasCgelsStridedBatched_v2_rank_0 = hipblasCgelsStridedBatched_v2_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,deviceInfo,batchCount)
    end function

    function hipblasCgelsStridedBatched_v2_rank_1(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgelsStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_float_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasCgelsStridedBatched_v2_rank_1 = hipblasCgelsStridedBatched_v2_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,deviceInfo,batchCount)
    end function

    function hipblasZgelsStridedBatched_v2_full_rank(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgelsStridedBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:,:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasZgelsStridedBatched_v2_full_rank = hipblasZgelsStridedBatched_v2_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,deviceInfo,batchCount)
    end function

    function hipblasZgelsStridedBatched_v2_rank_0(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgelsStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasZgelsStridedBatched_v2_rank_0 = hipblasZgelsStridedBatched_v2_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,deviceInfo,batchCount)
    end function

    function hipblasZgelsStridedBatched_v2_rank_1(handle,trans,m,n,nrhs,A,lda,strideA,B,ldb,strideB,myInfo,deviceInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgelsStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(kind(HIPBLAS_OP_N)) :: trans
      integer(c_int) :: m
      integer(c_int) :: n
      integer(c_int) :: nrhs
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      complex(c_double_complex),target,dimension(:) :: B
      integer(c_int) :: ldb
      integer(c_int64_t) :: strideB
      type(c_ptr) :: myInfo
      type(c_ptr) :: deviceInfo
      integer(c_int) :: batchCount
      !
      hipblasZgelsStridedBatched_v2_rank_1 = hipblasZgelsStridedBatched_v2_(handle,trans,m,n,nrhs,c_loc(A),lda,strideA,c_loc(B),ldb,strideB,myInfo,deviceInfo,batchCount)
    end function

    function hipblasSgeqrf_full_rank(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeqrf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasSgeqrf_full_rank = hipblasSgeqrf_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasSgeqrf_rank_0(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeqrf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasSgeqrf_rank_0 = hipblasSgeqrf_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasSgeqrf_rank_1(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeqrf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasSgeqrf_rank_1 = hipblasSgeqrf_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasDgeqrf_full_rank(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeqrf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasDgeqrf_full_rank = hipblasDgeqrf_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasDgeqrf_rank_0(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeqrf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasDgeqrf_rank_0 = hipblasDgeqrf_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasDgeqrf_rank_1(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeqrf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasDgeqrf_rank_1 = hipblasDgeqrf_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasCgeqrf_full_rank(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasCgeqrf_full_rank = hipblasCgeqrf_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasCgeqrf_rank_0(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasCgeqrf_rank_0 = hipblasCgeqrf_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasCgeqrf_rank_1(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasCgeqrf_rank_1 = hipblasCgeqrf_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasZgeqrf_full_rank(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrf_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasZgeqrf_full_rank = hipblasZgeqrf_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasZgeqrf_rank_0(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrf_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasZgeqrf_rank_0 = hipblasZgeqrf_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasZgeqrf_rank_1(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrf_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasZgeqrf_rank_1 = hipblasZgeqrf_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasCgeqrf_v2_full_rank(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrf_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasCgeqrf_v2_full_rank = hipblasCgeqrf_v2_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasCgeqrf_v2_rank_0(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrf_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasCgeqrf_v2_rank_0 = hipblasCgeqrf_v2_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasCgeqrf_v2_rank_1(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrf_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasCgeqrf_v2_rank_1 = hipblasCgeqrf_v2_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasZgeqrf_v2_full_rank(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrf_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasZgeqrf_v2_full_rank = hipblasZgeqrf_v2_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasZgeqrf_v2_rank_0(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrf_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasZgeqrf_v2_rank_0 = hipblasZgeqrf_v2_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasZgeqrf_v2_rank_1(handle,m,n,A,lda,ipiv,myInfo)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrf_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      !
      hipblasZgeqrf_v2_rank_1 = hipblasZgeqrf_v2_(handle,m,n,c_loc(A),lda,ipiv,myInfo)
    end function

    function hipblasSgeqrfBatched_full_rank(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeqrfBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgeqrfBatched_full_rank = hipblasSgeqrfBatched_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasSgeqrfBatched_rank_0(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeqrfBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgeqrfBatched_rank_0 = hipblasSgeqrfBatched_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasSgeqrfBatched_rank_1(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeqrfBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgeqrfBatched_rank_1 = hipblasSgeqrfBatched_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasDgeqrfBatched_full_rank(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeqrfBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgeqrfBatched_full_rank = hipblasDgeqrfBatched_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasDgeqrfBatched_rank_0(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeqrfBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgeqrfBatched_rank_0 = hipblasDgeqrfBatched_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasDgeqrfBatched_rank_1(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeqrfBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgeqrfBatched_rank_1 = hipblasDgeqrfBatched_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasCgeqrfBatched_full_rank(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrfBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgeqrfBatched_full_rank = hipblasCgeqrfBatched_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasCgeqrfBatched_rank_0(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrfBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgeqrfBatched_rank_0 = hipblasCgeqrfBatched_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasCgeqrfBatched_rank_1(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrfBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgeqrfBatched_rank_1 = hipblasCgeqrfBatched_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasZgeqrfBatched_full_rank(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrfBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgeqrfBatched_full_rank = hipblasZgeqrfBatched_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasZgeqrfBatched_rank_0(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrfBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgeqrfBatched_rank_0 = hipblasZgeqrfBatched_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasZgeqrfBatched_rank_1(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrfBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgeqrfBatched_rank_1 = hipblasZgeqrfBatched_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasCgeqrfBatched_v2_full_rank(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrfBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgeqrfBatched_v2_full_rank = hipblasCgeqrfBatched_v2_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasCgeqrfBatched_v2_rank_0(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrfBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgeqrfBatched_v2_rank_0 = hipblasCgeqrfBatched_v2_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasCgeqrfBatched_v2_rank_1(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrfBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgeqrfBatched_v2_rank_1 = hipblasCgeqrfBatched_v2_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasZgeqrfBatched_v2_full_rank(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrfBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:,:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgeqrfBatched_v2_full_rank = hipblasZgeqrfBatched_v2_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasZgeqrfBatched_v2_rank_0(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrfBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgeqrfBatched_v2_rank_0 = hipblasZgeqrfBatched_v2_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasZgeqrfBatched_v2_rank_1(handle,m,n,A,lda,ipiv,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrfBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      type(c_ptr) :: ipiv
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgeqrfBatched_v2_rank_1 = hipblasZgeqrfBatched_v2_(handle,m,n,c_loc(A),lda,ipiv,myInfo,batchCount)
    end function

    function hipblasSgeqrfStridedBatched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeqrfStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgeqrfStridedBatched_full_rank = hipblasSgeqrfStridedBatched_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasSgeqrfStridedBatched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeqrfStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgeqrfStridedBatched_rank_0 = hipblasSgeqrfStridedBatched_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasSgeqrfStridedBatched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasSgeqrfStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_float),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasSgeqrfStridedBatched_rank_1 = hipblasSgeqrfStridedBatched_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasDgeqrfStridedBatched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeqrfStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgeqrfStridedBatched_full_rank = hipblasDgeqrfStridedBatched_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasDgeqrfStridedBatched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeqrfStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgeqrfStridedBatched_rank_0 = hipblasDgeqrfStridedBatched_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasDgeqrfStridedBatched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasDgeqrfStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      real(c_double),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasDgeqrfStridedBatched_rank_1 = hipblasDgeqrfStridedBatched_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasCgeqrfStridedBatched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrfStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgeqrfStridedBatched_full_rank = hipblasCgeqrfStridedBatched_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasCgeqrfStridedBatched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrfStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgeqrfStridedBatched_rank_0 = hipblasCgeqrfStridedBatched_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasCgeqrfStridedBatched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrfStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgeqrfStridedBatched_rank_1 = hipblasCgeqrfStridedBatched_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasZgeqrfStridedBatched_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrfStridedBatched_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgeqrfStridedBatched_full_rank = hipblasZgeqrfStridedBatched_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasZgeqrfStridedBatched_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrfStridedBatched_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgeqrfStridedBatched_rank_0 = hipblasZgeqrfStridedBatched_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasZgeqrfStridedBatched_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrfStridedBatched_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgeqrfStridedBatched_rank_1 = hipblasZgeqrfStridedBatched_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasCgeqrfStridedBatched_v2_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrfStridedBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgeqrfStridedBatched_v2_full_rank = hipblasCgeqrfStridedBatched_v2_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasCgeqrfStridedBatched_v2_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrfStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgeqrfStridedBatched_v2_rank_0 = hipblasCgeqrfStridedBatched_v2_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasCgeqrfStridedBatched_v2_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasCgeqrfStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_float_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasCgeqrfStridedBatched_v2_rank_1 = hipblasCgeqrfStridedBatched_v2_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasZgeqrfStridedBatched_v2_full_rank(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrfStridedBatched_v2_full_rank
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:,:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgeqrfStridedBatched_v2_full_rank = hipblasZgeqrfStridedBatched_v2_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasZgeqrfStridedBatched_v2_rank_0(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrfStridedBatched_v2_rank_0
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgeqrfStridedBatched_v2_rank_0 = hipblasZgeqrfStridedBatched_v2_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

    function hipblasZgeqrfStridedBatched_v2_rank_1(handle,m,n,A,lda,strideA,ipiv,strideP,myInfo,batchCount)
      use iso_c_binding
      use hipfort_hipblas_enums
      implicit none
      integer(kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasZgeqrfStridedBatched_v2_rank_1
      type(c_ptr) :: handle
      integer(c_int) :: m
      integer(c_int) :: n
      complex(c_double_complex),target,dimension(:) :: A
      integer(c_int) :: lda
      integer(c_int64_t) :: strideA
      type(c_ptr) :: ipiv
      integer(c_int64_t) :: strideP
      type(c_ptr) :: myInfo
      integer(c_int) :: batchCount
      !
      hipblasZgeqrfStridedBatched_v2_rank_1 = hipblasZgeqrfStridedBatched_v2_(handle,m,n,c_loc(A),lda,strideA,ipiv,strideP,myInfo,batchCount)
    end function

#endif
end module hipfort_hipblas
